{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Air Force Cadet Career Problem (afccp) Documentation!","text":"<p>AFCCP is a comprehensive collection of models designed to streamline and automate as much of the cadet-AFSC matching process conducted by the Air Force Personnel Center (AFPC) as possible.</p> <p>This documentation serves to provide clear guidance, technical details, and resources to support both developers and  users in effectively using the afccp module.</p>"},{"location":"#what-you-will-find-here","title":"What You Will Find Here","text":"<ul> <li>Getting Started - Key overviews and installation instructions to get you up and running with afccp.</li> <li>User Guide - Detailed instructions, best practices, and user-friendly guidance to fully leverage afccp features.</li> <li>Developer Guide - Technical documentation, API details, data architecture, and modeling assumptions necessary for developers and analysts.</li> <li>Data - All necessary information in understanding the data and data structure used by afccp.</li> <li>Solutions - Critical details pertaining to the models and algorithms represented by afccp to solve the CadetCareerProblem instance.</li> <li>Visualizations - Insight into the various kinds of data visualizations used to communicate information about a CadetCareerProblem instance.</li> <li>FAQs - Answers to frequently asked questions about afccp, addressing common issues, clarifying functionalities, and providing quick solutions.</li> <li>Help - Contact information and resources to assist users with troubleshooting, technical support, and additional guidance on using Castle Suite effectively.</li> </ul>"},{"location":"#need-help","title":"Need Help?","text":"<p>If you have questions or require support, please contact Capt D. Griffen Laird at  griffenlaird007@gmail.com or  daniel.laird.4@us.af.mil, or refer to the Help section.</p>"},{"location":"developer-guide/","title":"Developer Guide","text":""},{"location":"developer-guide/#overview","title":"Overview","text":"<p>The AFCCP Developer Guide provides comprehensive information and instructions to assist developers in  understanding, maintaining, and enhancing the afccp module. This guide includes essential details  about the system's architecture, code guidelines, modeling assumptions, and more.  Below is a detailed breakdown of the guide's contents:</p>"},{"location":"faq/","title":"Frequently Asked Questions (FAQs)","text":"<p>Welcome to the AFCCP FAQ section. Here, you\u2019ll find answers to common questions regarding  afccp\u2019s functionality, data processing, and documentation.</p>"},{"location":"help/","title":"Help","text":"<p>Welcome to the AFCCP Help page. If you encounter any issues, need clarification,  or require assistance with the afccp module, this guide provides essential support resources.</p>"},{"location":"help/#frequently-asked-questions-faqs","title":"Frequently Asked Questions (FAQs)","text":"<p>Before reaching out for support, check the FAQs section for answers to common issues.</p>"},{"location":"getting-started/developer-checklist/","title":"\ud83d\udee0 AFCCP Developer Onboarding Checklist","text":"<p>Welcome to the afccp development team! This checklist will guide you through all required steps to fully  onboard and set up your development environment.</p>"},{"location":"getting-started/getting-started/","title":"\ud83d\udcc4 Overview","text":"<p>Welcome to the AFCCP Overview page. This guide offers a comprehensive introduction to afccp,  detailing its functionalities and benefits.</p>"},{"location":"getting-started/getting-started/#background-on-afccp","title":"Background on AFCCP","text":"<p>For detailed information on the Air Force Cadet-Career Problem, please reference Capt Laird's master's thesis.  As more papers are published directly using afccp, they will be included here as well.</p> <p>Griffen Laird's Thesis</p>"},{"location":"getting-started/installation/","title":"\ud83d\udee0\ufe0f Installation Instructions for AFCCP","text":"<p>This guide walks you through setting up the Air Force Cadet Career Problem (AFCCP) repository using PyCharm and Anaconda. You\u2019ll first clone the repository using terminal, then choose between two setup options: - Using Terminal - Using PyCharm\u2019s GUI</p>"},{"location":"getting-started/installation/#1-install-required-tools","title":"\ud83d\udce5 1. Install Required Tools","text":""},{"location":"getting-started/installation/#required","title":"\u2705 Required:","text":"<ul> <li>Git</li> <li>Anaconda (Python 3.8+)</li> <li>PyCharm Community or Professional Edition</li> </ul> <p>\u26a0\ufe0f We recommend the Professional Edition if you have access, but the Community Edition works fine too.</p> <p>Personally, I love PyCharm and will always recommend it as the go-to python IDE! If you'd like to get started with  PyCharm, you can follow my PyCharm Instructions.</p>"},{"location":"getting-started/installation/#2-clone-the-afccp-repository","title":"\ud83c\udf00 2. Clone the AFCCP Repository","text":"<p>Use your terminal (Mac/Linux: Terminal, Windows: Anaconda Prompt or Git Bash). First navigate to your desired directory to clone this project. Personally, I have a folder called \"Coding Projects\" where I keep all of my python  projects:</p> <pre><code>cd \"/Users/griffenlaird/Coding Projects\"\n</code></pre> <p>Once you're in the directory you want to clone afccp to, clone it!:</p> <pre><code>git clone https://github.com/dglaird/afccp.git\ncd afccp\n</code></pre> <p>When you clone the repo, you should see some output that looks like this:</p> <pre>\n<pre><code>$ git clone https://github.com/dglaird/afccp.git\nCloning into 'afccp'...\nremote: Enumerating objects: 108, done.\nremote: Counting objects: 100% (108/108), done.\nremote: Compressing objects: 100% (82/82), done.\nReceiving objects: 100% (108/108), 120.34 KiB | 2.35 MiB/s, done.\n</code></pre>\n</pre>"},{"location":"getting-started/installation/#3-set-up-the-python-environment","title":"\u2699\ufe0f 3. Set Up the Python Environment","text":"<p>You have two options:</p>"},{"location":"getting-started/installation/#option-a-using-terminal-recommended-for-reproducibility","title":"\ud83e\uddea Option A: Using Terminal (Recommended for reproducibility)","text":""},{"location":"getting-started/installation/#1-create-a-new-environment","title":"1. Create a new environment:","text":"<pre><code>conda create -n afccp python=3.8 -y\n</code></pre>"},{"location":"getting-started/installation/#2-activate-the-environment","title":"2. Activate the environment:","text":"<pre><code>conda activate afccp\n</code></pre>"},{"location":"getting-started/installation/#3-install-all-dependencies","title":"3. Install all dependencies:","text":"<pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"getting-started/installation/#4-launch-pycharm-and-select-this-environment-when-opening-the-project","title":"4. Launch PyCharm, and select this environment when opening the project:","text":"<p>File &gt; Settings &gt; Project: afccp &gt; Python Interpreter &gt; Add &gt; Conda Environment &gt; Existing environment</p>"},{"location":"getting-started/installation/#option-b-using-pycharm-gui","title":"\ud83d\udcbb Option B: Using PyCharm (GUI)","text":""},{"location":"getting-started/installation/#1-open-pycharm-and-select","title":"1. Open PyCharm and select:","text":"<ul> <li><code>Open Project</code> \u2192 navigate to and select the cloned <code>afccp/</code> directory.</li> </ul>"},{"location":"getting-started/installation/#2-go-to","title":"2. Go to:","text":"<ul> <li><code>PyCharm &gt; Preferences</code> (Mac) or <code>File &gt; Settings</code> (Windows)</li> </ul>"},{"location":"getting-started/installation/#3-navigate-to","title":"3. Navigate to:","text":"<ul> <li><code>Project: afccp &gt; Python Interpreter</code></li> </ul>"},{"location":"getting-started/installation/#4-click-the-gear-icon-add-interpreter-conda-environment","title":"4. Click the \u2699\ufe0f gear icon \u2192 <code>Add Interpreter</code> \u2192 <code>Conda Environment</code>.","text":""},{"location":"getting-started/installation/#5-choose","title":"5. Choose:","text":"<ul> <li><code>New environment</code> (or Existing if you\u2019ve already created one)</li> <li>Python version: 3.8</li> </ul>"},{"location":"getting-started/installation/#6-once-created-click-ok-and-pycharm-will-create-and-set-up-the-interpreter","title":"6. Once created, click OK, and PyCharm will create and set up the interpreter.","text":""},{"location":"getting-started/installation/#7-now-install-the-dependencies","title":"7. Now install the dependencies:","text":"<ul> <li>Open the built-in PyCharm Terminal</li> <li> <p>Run:</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> </ul>"},{"location":"getting-started/installation/#4-run-an-example","title":"\ud83d\udee0 4. Run an Example","text":"<p>Personally, I love PyCharm and will always recommend using it and so I will again refer you to my  PyCharm Instructions to run all of this through that IDE. Ok, perhaps you're using the terminal and want to test the repo to make sure it works. You can run my example script \"example.py\" that is currently sitting in the root directory.</p> <pre><code>python example.py\n</code></pre> <p>The code inside this script is quite simple, but demonstrates a bit of the scope of afccp. The python code is:</p> <pre><code># Load the main afccp object\nfrom afccp import CadetCareerProblem\n\n# Generate a random instance of data with 20 cadets, 5 AFSCs, and 4 AFSC preferences\ninstance = CadetCareerProblem(N=20, M=5, P=4, printing=True)\ninstance.fix_generated_data(printing=False)  # Fix the data to appropriately align assumptions\n\n# Formulate and solve the \"Hospital/Residents\" problem, then export all the data back to the instances folder \ninstance.classic_hr()\ninstance.export_data()\n</code></pre> <p>This script will generate a small test example containing all the necessary input files to run a cadet-AFSC problem instance. It will solve that randomly generated instance using the Hospital/Residents algorithm and will export  all the data back to csvs. If you've followed the instructions thus far and have correctly initialized the repo, you should see an output that looks something like this:</p> <pre>\n<pre><code>$ python example.py\nImporting 'afccp' module...\nFolder 'instances' not in current working directory. Creating it now...\nFolder 'solvers' not in current working directory. Creating it now...\nFolder 'support' not in current working directory. Creating it now...\nSupport sub-folder 'data' not in current working directory. Creating it now...\nSupport sub-folder 'value parameters defaults' not in current working directory. Creating it now...\nPyomo module found.\nSDV module found.\nSklearn Manifold module found.\nPython PPTX module found.\nGenerating 'Random_1' instance...\nInstance 'Random_1' initialized.\n0 Making 8 cadets ineligible for 'R1' by altering their qualification to 'I2'. \n2 Making 4 cadets ineligible for 'R3' by altering their qualification to 'I2'. \n3 Making 4 cadets ineligible for 'R4' by altering their qualification to 'I2'. \n4 Making 4 cadets ineligible for 'R5' by altering their qualification to 'I2'. \nUpdating cadet preference matrices from the preference dictionaries. ie. 1, 2, 4, 6, 7 -&gt; 1, 2, 3, 4, 5 (preference lists need to omit gaps)\nConverting AFSC preferences (a_pref_matrix) into percentiles (afsc_utility on AFSCs Utility.csv)...\nUpdating cadet columns (Cadets.csv...c_utilities, c_preferences) from the preference matrix (c_pref_matrix)...\nSanity checking the instance parameters...\nDone, 0 issues found.\nModeling this as an H/R problem and solving with DAA...\nNew Solution Evaluated.\nMeasured exact VFT objective value: 0.7909.\nGlobal Utility Score: 0.7364. 0 / 0 AFSCs fixed. 0 / 0 AFSCs reserved. 0 / 0 alternate list scenarios respected.\nBlocking pairs: 1. Unmatched cadets: 1.\nMatched cadets: 19/20. N^Match: 20. Ineligible cadets: 0.\nExporting datasets ['Cadets', 'AFSCs', 'Preferences', 'Goal Programming', 'Value Parameters', 'Solutions', 'Additional', 'Base Solutions', 'Course Solutions']\n</code></pre>\n</pre> <p>If successful, you should see a new \"Random_1\" data folder inside your constructed \"instances\" folder. The instances folder is located in the root directory:</p> <pre><code>afccp/                 # Root directory\n\u251c\u2500\u2500 instances/         # Problem data folder (generated from afccp)\n\u251c\u2500\u2500\u2500\u2500\u2500 Random_1/       # Specific problem instance (newly generated data)\n</code></pre> <p>For more information on the instance data structure used by afccp, please refer to the Data module.</p>"},{"location":"getting-started/installation/#5-install-pyomo-solvers","title":"5. Install Pyomo Solvers","text":"<p>One very important step is the setup of the optimization solvers used by Pyomo.</p> <ul> <li>The <code>solvers/</code> folder will be automatically created the first time you import the <code>afccp</code> module.</li> <li>You can manually place solver executables in this folder (e.g., <code>baron</code>, <code>bonmin</code>, <code>couenne</code>, <code>cbc</code>, etc.).</li> </ul>"},{"location":"getting-started/installation/#recommended-method-for-solver-setup","title":"\ud83d\udd27 Recommended Method for Solver Setup:","text":"<ol> <li>Go to the AMPL download portal.</li> <li> <p>Under COIN-OR solvers, choose the appropriate compressed \"coin\" package for your operating system.</p> <ul> <li>This page has undergone changes, and so I have no guarantee what it'll look like in the future. </li> <li>As of right now (June 2025), you can scroll down to the \"Individual Modules\" section, and select the version of the COIN-OR solver collection that fits your operating system (MacOS or Windows):     <p> </p></li> </ul> </li> <li> <p>Download and extract the ZIP file.</p> </li> <li>Locate the solver executables inside (e.g., <code>cbc.exe</code> on Windows or <code>cbc</code> on Unix-based systems).</li> <li>Drag those solver executables into the <code>solvers/</code> folder in your working directory (the same directory as your <code>afccp/</code> project).</li> </ol> <p>\u2705 Once placed, <code>afccp</code> will detect and use the solvers when solving Pyomo models.</p> <p>\ud83d\udd12 Note: Make sure the solver files have execution permissions (e.g., <code>chmod +x cbc</code>) on Mac/Linux.</p>"},{"location":"getting-started/installation/#solver-test","title":"\ud83e\uddea Solver Test","text":"<p>The main solver used for the majority of the afccp models is the CBC solver. Let's make sure it is working with Pyomo in your <code>afccp</code> environment.</p>"},{"location":"getting-started/installation/#test-script","title":"\ud83d\udccb Test Script","text":"<p>Copy the following code into a file called <code>test_solver.py</code> in your project root:</p> <pre><code>from pyomo.environ import *\n\n# Define a simple model\nmodel = ConcreteModel()\n\n# Variables\nmodel.x = Var(within=NonNegativeReals)\nmodel.y = Var(within=NonNegativeReals)\n\n# Objective: Maximize 3x + 4y\nmodel.obj = Objective(expr=3 * model.x + 4 * model.y, sense=maximize)\n\n# Constraint: x + 2y &lt;= 8\nmodel.constraint = Constraint(expr=model.x + 2 * model.y &lt;= 8)\n\n# Solve with CBC\nsolver = SolverFactory(\"cbc\")\nresult = solver.solve(model, tee=True)\n\n# Print results\nprint(f\"x = {model.x():.2f}\")\nprint(f\"y = {model.y():.2f}\")\nprint(f\"Objective = {model.obj():.2f}\")\n</code></pre>"},{"location":"getting-started/installation/#run-the-script","title":"\u25b6\ufe0f Run the Script","text":"<p>In your terminal (with your virtual environment activated):</p> <pre><code>python test_solver.py\n</code></pre>"},{"location":"getting-started/installation/#expected-output","title":"\u2705 Expected Output","text":"<p>If CBC is correctly configured, you should see output similar to:</p> <pre><code>Welcome to the CBC MILP Solver\n...\n\nx = 8.00\ny = 0.00\nObjective = 24.00\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"\u26a0\ufe0f Troubleshooting","text":"<p>If you see an error like:</p> <pre><code>ApplicationError: No executable found for solver 'cbc'\n</code></pre> <p>That means Pyomo cannot find the CBC executable. Here are your options:</p>"},{"location":"getting-started/installation/#option-1-verify-the-solver-location","title":"\u2705 Option 1: Verify the solver location","text":"<p>Make sure that:</p> <ul> <li>You've downloaded CBC from the AMPL coin-or page</li> <li>You extracted the ZIP file and found the <code>cbc</code> (or <code>cbc.exe</code> on Windows) executable</li> <li>You moved that file into your project's <code>solvers/</code> folder (this folder is created after first importing <code>afccp</code>)</li> <li>On Mac/Linux, the file is executable: <pre><code>chmod +x solvers/cbc\n</code></pre></li> </ul>"},{"location":"getting-started/installation/#option-2-provide-the-full-path-to-the-cbc-executable","title":"\u2705 Option 2: Provide the full path to the CBC executable","text":"<p>If Pyomo still can\u2019t detect it, specify the full path to the solver manually:</p> <pre><code>from pyomo.environ import *\n\nsolver = SolverFactory(\"cbc\", executable=\"solvers/cbc\")  # or \"solvers/cbc.exe\" on Windows\n</code></pre> <p>This bypasses the PATH lookup and tells Pyomo exactly where to find CBC.</p> <p>\ud83e\uddea You can also test this directly in the Python console to verify that it resolves:</p> <pre><code>from pyomo.environ import *\nSolverFactory(\"cbc\", executable=\"solvers/cbc\").available()\n</code></pre> <p>It should return <code>True</code> if CBC is accessible and working.</p> <p>Once CBC is properly located and executable, your test model should run without errors.</p>"},{"location":"getting-started/installation/#6-project-structure","title":"\ud83d\udcc1 6. Project Structure","text":"<pre><code>afccp/\n\u251c\u2500\u2500 afccp/                # Core source code\n\u251c\u2500\u2500 docs/                 # MkDocs documentation\n\u251c\u2500\u2500 instances/            # Input instance data\n\u251c\u2500\u2500 support/              # Data shared across instances (Private- ask AFPC/DSY)\n\u251c\u2500\u2500 files/                # Data shared across instances (Publically available)\n\u251c\u2500\u2500 solvers/              # Solver .exe files for use by Pyomo\n\u251c\u2500\u2500 requirements.txt      # Python dependencies\n\u251c\u2500\u2500 mkdocs.yml            # MkDocs config file\n\u2514\u2500\u2500 README.md             # Project overview\n</code></pre>"},{"location":"getting-started/installation/#7-view-the-documentation-locally","title":"\ud83d\udcda 7. View the Documentation Locally","text":"<p>If you want to view the full documentation site locally:</p> <pre><code>mkdocs serve\n</code></pre> <p>Then visit http://127.0.0.1:8000 in your browser.</p>"},{"location":"getting-started/installation/#8-optional-rebuild-reference-pages","title":"\ud83d\ude80 8. (Optional) Rebuild Reference Pages","text":"<p>To generate API reference pages:</p> <pre><code>python afccp/gen_ref_pages.py\n</code></pre> <p>Be sure to run this from the project root directory, where <code>mkdocs.yml</code> is located.</p>"},{"location":"getting-started/installation/#9-run-unit-tests-if-available","title":"\ud83e\uddea 9. Run Unit Tests (if available)","text":"<p>If the repo includes tests:</p> <pre><code>pytest tests/\n</code></pre>"},{"location":"getting-started/installation/#more-info","title":"\ud83e\udde0 More Info","text":"<ul> <li>Author: Griffen Laird</li> </ul> <p>Happy modeling! \u2708\ufe0f</p>"},{"location":"getting-started/jupyter-instructions/","title":"\ud83e\uddea Jupyter Notebook Setup for AFCCP","text":"<p>This tutorial walks you through setting up the afccp environment to work with Jupyter Notebooks,  using Anaconda or Miniconda to manage dependencies.</p>"},{"location":"getting-started/jupyter-instructions/#1-install-anaconda-or-miniconda","title":"\ud83d\udce6 1. Install Anaconda (or Miniconda)","text":"<p>Before anything else, install a Python environment manager:</p> <ul> <li> <p>Anaconda (recommended):   https://www.anaconda.com/products/distribution (Includes Python, Jupyter, and many scientific packages out-of-the-box)</p> </li> <li> <p>Miniconda (lightweight version):   https://docs.conda.io/en/latest/miniconda.html</p> </li> </ul> <p>After installation, you should be able to run <code>conda</code> from your terminal or Anaconda Prompt.</p>"},{"location":"getting-started/jupyter-instructions/#2-install-jupyter-and-configure-the-kernel","title":"\ud83e\uddea 2. Install Jupyter and Configure the Kernel","text":"<p>If you've followed the main Installation Guide, you should already have a  working <code>afccp</code> virtual environment which will have the <code>notebook</code> and <code>ipykernel</code> packages. But, you can always directly install them here. Regardless, you'll need to make the <code>afccp</code> environment available as a kernel:</p> <pre><code>pip install notebook ipykernel\npython -m ipykernel install --user --name afccp --display-name \"Python (afccp)\"\n</code></pre> <p>This will let you choose Python (afccp) as a kernel option inside Jupyter.</p>"},{"location":"getting-started/jupyter-instructions/#3-launch-jupyter-notebook","title":"\ud83d\ude80 3. Launch Jupyter Notebook","text":"<p>With the environment still activated, launch Jupyter:</p> <pre><code>jupyter notebook\n</code></pre> <p>This will open a browser window where you can create and run notebooks. Select \"Python (afccp)\" as your kernel.</p>"},{"location":"getting-started/jupyter-instructions/#4-verify-afccp-imports","title":"\u2705 4. Verify afccp Imports","text":"<p>Create a new notebook and run this code to test your setup:</p> <pre><code>from afccp import CadetCareerProblem\nprint(\"AFCCP module loaded successfully!\")\n</code></pre>"},{"location":"getting-started/jupyter-instructions/#bonus-recommended-notebook-extensions-optional","title":"\ud83d\udca1 Bonus: Recommended Notebook Extensions (Optional)","text":"<p>If you'd like a better notebook experience, install:</p> <pre><code>pip install jupyterlab jupyter_contrib_nbextensions\njupyter contrib nbextension install --user\n</code></pre> <p>These add features like collapsible cells, codefolding, and table of contents sidebars.</p>"},{"location":"getting-started/jupyter-instructions/#youre-all-set","title":"\ud83e\udde0 You're All Set!","text":"<p>You now have a fully configured AFCCP development environment running inside Jupyter. Use it to: - Explore AFCCP models interactively - Visualize value functions and assignments - Run analyses and share notebooks with others</p> <p>You may now return to Tutorial 1 to resume the introduction.</p>"},{"location":"getting-started/pycharm-instructions/","title":"\ud83e\udde0 PyCharm Setup Guide for AFCCP","text":"<p>This guide walks you through setting up PyCharm for use with the Air Force Cadet Career Problem (AFCCP) project. It covers: - Opening the project - Setting up the Python interpreter - Creating a run configuration - Using the built-in terminal</p>"},{"location":"getting-started/pycharm-instructions/#1-install-pycharm","title":"\ud83e\uddf0 1. Install PyCharm","text":"<p>If you haven't already:</p> <ul> <li>Download from https://www.jetbrains.com/pycharm/download</li> <li>Install either the Community (free) or Professional edition</li> </ul>"},{"location":"getting-started/pycharm-instructions/#2-open-the-project-folder","title":"\ud83d\udcc2 2. Open the Project Folder","text":"<ol> <li>Open PyCharm.</li> <li>Click \"Open\" on the welcome screen.</li> <li>Navigate to the directory where you cloned the <code>afccp</code> repository (e.g., <code>~/Documents/Projects/afccp</code>) and click Open.</li> </ol> <p>\ud83d\udcdd If you haven\u2019t cloned the repository yet, do this from terminal first: <pre><code>git clone https://github.com/dglaird/afccp.git\ncd afccp\n</code></pre></p>"},{"location":"getting-started/pycharm-instructions/#3-configure-the-python-interpreter-conda-or-virtualenv","title":"\ud83d\udc0d 3. Configure the Python Interpreter (Conda or VirtualEnv)","text":"<ol> <li>Go to File &gt; Settings &gt; Project: afccp &gt; Python Interpreter</li> <li>Click the \u2699\ufe0f icon (top-right) and choose Add...</li> <li>In the dialog:</li> <li>Select Conda Environment</li> <li>Choose:<ul> <li>Existing environment if you've already created one (e.g., via terminal):    <pre><code>conda create -n afccp python=3.8 -y\nconda activate afccp\n</code></pre></li> <li>New environment if you want PyCharm to create it</li> </ul> </li> <li>Set Python version to 3.8</li> <li>Click OK to save and apply the interpreter</li> </ol> <p>\u2705 Once set, PyCharm will index your environment and show packages in the interpreter panel.</p>"},{"location":"getting-started/pycharm-instructions/#4-install-project-dependencies","title":"\ud83d\udce6 4. Install Project Dependencies","text":"<p>Once your interpreter is set:</p> <ol> <li>Open the Terminal tab at the bottom of PyCharm</li> <li>Run:</li> </ol> <pre><code>pip install -r requirements.txt\n</code></pre> <p>This installs all packages required for AFCCP, including <code>pyomo</code>, <code>pandas</code>, <code>mkdocs</code>, and more.</p>"},{"location":"getting-started/pycharm-instructions/#5-create-a-run-configuration","title":"\u25b6\ufe0f 5. Create a Run Configuration","text":"<p>To quickly run the model script from inside PyCharm:</p> <ol> <li>Go to Run &gt; Edit Configurations...</li> <li>Click the \u2795 to add a new configuration</li> <li>Choose Python</li> <li>Set:</li> <li>Name: <code>Run AFCCP</code></li> <li>Script path: <code>afccp/example.py</code> (use the file chooser)</li> <li>Python Interpreter: select the environment you just configured</li> <li>Click Apply and OK</li> </ol> <p>Now you can run the model with the \u25b6\ufe0f button in the top-right corner.</p>"},{"location":"getting-started/pycharm-instructions/#6-optional-add-test-configurations","title":"\ud83e\uddea 6. (Optional) Add Test Configurations","text":"<p>If you have test files in <code>tests/</code>, create another Run Configuration:</p> <ol> <li>Add a new pytest configuration</li> <li>Point it to the <code>tests/</code> directory</li> <li>Give it a name like <code>Run Tests</code></li> </ol>"},{"location":"getting-started/pycharm-instructions/#7-recommended-pycharm-settings","title":"\ud83d\udcc1 7. Recommended PyCharm Settings","text":""},{"location":"getting-started/pycharm-instructions/#editor-settings","title":"Editor Settings","text":"<ul> <li>Enable soft wrap for Markdown and <code>.py</code> files: <code>Preferences &gt; Editor &gt; General &gt; Soft Wraps</code></li> </ul>"},{"location":"getting-started/pycharm-instructions/#markdown-preview","title":"Markdown Preview","text":"<ul> <li><code>Preferences &gt; Languages &amp; Frameworks &gt; Markdown &gt; Preview</code>   Choose \"Preview with HTML and CSS\"</li> </ul>"},{"location":"getting-started/pycharm-instructions/#auto-save-on-run","title":"Auto-save on Run","text":"<ul> <li><code>Preferences &gt; Appearance &amp; Behavior &gt; System Settings &gt; Save files on frame deactivation</code></li> </ul>"},{"location":"getting-started/pycharm-instructions/#youre-ready-to-develop","title":"\ud83e\udde0 You're Ready to Develop!","text":"<p>You now have a fully working setup in PyCharm: - Code highlighting and linting - Conda environment - One-click model execution - Markdown editing with preview - Git integration</p> <p>Happy modeling!</p>"},{"location":"reference/","title":"Index","text":""},{"location":"reference/#afccp","title":"<code>afccp</code>","text":"<p>This is the main afccp module!!</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>afccp</li> <li>data<ul> <li>adjustments</li> <li>generation<ul> <li>basic</li> <li>realistic</li> </ul> </li> <li>preferences</li> <li>processing</li> <li>support</li> <li>values</li> </ul> </li> <li>gen_ref_pages</li> <li>globals</li> <li>main/CadetCareerProblem \u2013 Overview</li> <li>main/CadetCareerProblem \u2013 Generated Data Corrections</li> <li>main/CadetCareerProblem \u2013 Main Data Corrections</li> <li>main/CadetCareerProblem \u2013 Other Adjustments</li> <li>main/CadetCareerProblem \u2013 Value Parameter Specifications</li> <li>main/CadetCareerProblem \u2013 Solution Generation &amp; Algorithms</li> <li>main/CadetCareerProblem \u2013 Optimization Models &amp; Meta-Heuristics</li> <li>main/CadetCareerProblem \u2013 Solution Handling</li> <li>main/CadetCareerProblem \u2013 Export Data</li> <li>main/CadetCareerProblem \u2013 Data Visualizations</li> <li>main/CadetCareerProblem \u2013 Results Visualizations</li> <li>research<ul> <li>ots_cadet_additions</li> <li>rotc_rated</li> <li>testing</li> </ul> </li> <li>solutions<ul> <li>algorithms</li> <li>handling</li> <li>optimization</li> <li>sensitivity</li> </ul> </li> <li>visualizations<ul> <li>bubbles</li> <li>charts</li> <li>slides</li> </ul> </li> </ul>"},{"location":"reference/data/","title":"Overview","text":""},{"location":"reference/data/#data","title":"<code>data</code>","text":"<p>Test</p>"},{"location":"reference/gen_ref_pages/","title":"Gen ref pages","text":""},{"location":"reference/gen_ref_pages/#gen_ref_pages","title":"<code>gen_ref_pages</code>","text":"<p>Generate the code reference pages and structured navigation for AFCCP.</p>"},{"location":"reference/globals/","title":"Globals","text":""},{"location":"reference/globals/#globals","title":"<code>globals</code>","text":""},{"location":"reference/globals/#globals.import_data","title":"<code>import_data(filepath, sheet_name=None, specify_engine=True)</code>","text":"<p>This function is to alleviate issues with importing pandas dataframes since some versions can just import .xlsx files normally but some have to add \", engine= 'openpyxl'\". Pandas versions &gt; 1.2.1 must specify openpyxl as the engine</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <p>excel file path</p> required <code>sheet_name</code> <p>name of the sheet to import</p> <code>None</code> <code>specify_engine</code> <p>issues with pandas \"engine=\"</p> <code>True</code> <p>Returns:</p> Type Description <p>pandas dataframe</p> Source code in <code>afccp/globals.py</code> <pre><code>def import_data(filepath, sheet_name=None, specify_engine=True):\n    \"\"\"\n    This function is to alleviate issues with importing pandas dataframes since some versions can just\n    import .xlsx files normally but some have to add \", engine= 'openpyxl'\". Pandas versions &gt; 1.2.1 must\n    specify openpyxl as the engine\n    :param filepath: excel file path\n    :param sheet_name: name of the sheet to import\n    :param specify_engine: issues with pandas \"engine=\"\n    :return: pandas dataframe\n    \"\"\"\n\n    if specify_engine:\n        if sheet_name is None:\n            df = pd.read_excel(filepath, engine='openpyxl')\n        else:\n            df = pd.read_excel(filepath, sheet_name=sheet_name, engine='openpyxl')\n    else:\n        if sheet_name is None:\n            df = pd.read_excel(filepath)\n        else:\n            df = pd.read_excel(filepath, sheet_name=sheet_name)\n\n    return df\n</code></pre>"},{"location":"reference/globals/#globals.import_csv_data","title":"<code>import_csv_data(filepath)</code>","text":"<p>My own import statement in case I change the way I import data later</p> Source code in <code>afccp/globals.py</code> <pre><code>def import_csv_data(filepath):\n    \"\"\"\n    My own import statement in case I change the way I import data later\n    \"\"\"\n    return pd.read_csv(filepath)  #, encoding='latin-1')\n</code></pre>"},{"location":"reference/research/","title":"Research","text":""},{"location":"reference/research/#research","title":"<code>research</code>","text":""},{"location":"reference/solutions/","title":"Overview","text":""},{"location":"reference/solutions/#solutions","title":"<code>solutions</code>","text":""},{"location":"reference/visualizations/","title":"Overview","text":""},{"location":"reference/visualizations/#visualizations","title":"<code>visualizations</code>","text":""},{"location":"reference/data/adjustments/","title":"Adjustments","text":""},{"location":"reference/data/adjustments/#data.adjustments","title":"<code>data.adjustments</code>","text":""},{"location":"reference/data/adjustments/#data.adjustments--data-adjustments-module-for-afccp","title":"Data Adjustments Module for AFCCP","text":"<p>This module contains utility functions that perform critical adjustments, validations, and transformations on the <code>parameters</code> and <code>vp_dict</code> dictionaries that define each problem instance in the AFCCP model.</p> <p>The functions here serve as post-processing or pre-processing steps to ensure internal consistency, prepare data for model input, or apply specific business rules (such as OTS must-matches or degree tier qualification logic). They are commonly called after loading data or before solving a model.</p>"},{"location":"reference/data/adjustments/#data.adjustments--functions","title":"Functions:","text":"<ul> <li> <p><code>parameter_sanity_check(parameters)</code>   Performs validation checks on parameters and value parameters to ensure modeling assumptions are satisfied.</p> </li> <li> <p><code>parameter_sets_additions(parameters)</code>   Updates derived parameter sets (like <code>I^OTS</code>, <code>I^USAF</code>, <code>J^Rated</code>) based on core problem inputs.</p> </li> <li> <p><code>more_parameter_additions(parameters)</code>   Adds further derived variables or flags used throughout the AFCCP model such as first-choice indicators.</p> </li> <li> <p><code>base_training_parameter_additions(parameters)</code>   Adds data structures needed to support Base Training assignments for cadets.</p> </li> <li> <p><code>set_ots_must_matches(parameters)</code>   Selects a subset of OTS cadets as \"must-match\" based on their merit and OTS accession targets.</p> </li> <li> <p><code>gather_degree_tier_qual_matrix(cadets_df, parameters)</code>   Determines the qualification matrix for AFSC eligibility based on degree tier requirements.</p> </li> <li> <p><code>convert_instance_to_from_scrubbed(instance, new_letter=None, translation_dict=None, data_name='Unknown')</code>   Converts instance AFSC names to \"scrubbed\" placeholders or restores them back to their original names for   anonymized modeling and solution reproducibility.</p> </li> </ul>"},{"location":"reference/data/adjustments/#data.adjustments.parameter_sanity_check","title":"<code>parameter_sanity_check(instance)</code>","text":"<p>Perform a Full Sanity Check on Problem Instance Parameters.</p> <p>This function performs a comprehensive audit of the problem instance's input data and value parameters to verify that all structures, matrices, and definitions are logically consistent and feasible. This includes checks on cadet eligibility, AFSC quotas, objective constraints, preference list coherence, utility monotonicity, and tiered qualification logic.</p> <p>The goal is to prevent downstream issues during optimization by catching data errors or logical mismatches in advance. All checks are printed with contextual explanations and will highlight both errors and warnings when inconsistencies are found.</p>"},{"location":"reference/data/adjustments/#data.adjustments.parameter_sanity_check--parameters","title":"Parameters:","text":"<ul> <li> <p>instance: <code>CadetCareerProblem</code> class instance     An instantiated problem containing:</p> <ul> <li><code>parameters</code>: dictionaries and matrices representing cadets, AFSCs, preferences, and utility definitions.</li> <li><code>value_parameters</code>: constraints, objective targets, and value function metadata.</li> </ul> </li> </ul>"},{"location":"reference/data/adjustments/#data.adjustments.parameter_sanity_check--returns","title":"Returns:","text":"<ul> <li>None: This function prints all identified issues to the console but does not return any values.   It may raise a <code>ValueError</code> if <code>value_parameters</code> are not initialized.</li> </ul>"},{"location":"reference/data/adjustments/#data.adjustments.parameter_sanity_check--examples","title":"Examples:","text":"<pre><code>from afccp.data.adjustments import parameter_sanity_check\nparameter_sanity_check(instance)\n</code></pre> <p>This prints a series of diagnostics like:</p> <ul> <li>\"ISSUE: AFSC '15A' quota constraint invalid: 12 (min) &gt; 10 (eligible)\"</li> <li>\"WARNING: Cadet 41 has no preferences and is therefore eligible for nothing.\"</li> <li>\"ISSUE: Value function breakpoints for AFSC '17X' objective 'Tier 2' are misaligned.\"</li> </ul> Source code in <code>afccp/data/adjustments.py</code> <pre><code>def parameter_sanity_check(instance):\n    \"\"\"\n    Perform a Full Sanity Check on Problem Instance Parameters.\n\n    This function performs a comprehensive audit of the problem instance's input data and value parameters to verify that all\n    structures, matrices, and definitions are logically consistent and feasible. This includes checks on cadet eligibility,\n    AFSC quotas, objective constraints, preference list coherence, utility monotonicity, and tiered qualification logic.\n\n    The goal is to prevent downstream issues during optimization by catching data errors or logical mismatches in advance.\n    All checks are printed with contextual explanations and will highlight both errors and warnings when inconsistencies are found.\n\n    Parameters:\n    --------\n    - instance: `CadetCareerProblem` class instance\n        An instantiated problem containing:\n\n        - `parameters`: dictionaries and matrices representing cadets, AFSCs, preferences, and utility definitions.\n        - `value_parameters`: constraints, objective targets, and value function metadata.\n\n    Returns:\n    --------\n    - None: This function prints all identified issues to the console but does not return any values.\n      It may raise a `ValueError` if `value_parameters` are not initialized.\n\n    Examples:\n    --------\n    ```python\n    from afccp.data.adjustments import parameter_sanity_check\n    parameter_sanity_check(instance)\n    ```\n\n    This prints a series of diagnostics like:\n\n    - \"ISSUE: AFSC '15A' quota constraint invalid: 12 (min) &gt; 10 (eligible)\"\n    - \"WARNING: Cadet 41 has no preferences and is therefore eligible for nothing.\"\n    - \"ISSUE: Value function breakpoints for AFSC '17X' objective 'Tier 2' are misaligned.\"\n    \"\"\"\n\n    # Shorthand\n    p, vp = instance.parameters, instance.value_parameters\n\n    if vp is None:\n        raise ValueError(\"Cannot sanity check parameters without specifying which value_parameters to use.\")\n\n    # Initialization\n    print(\"Sanity checking the instance parameters...\")\n    issue = 0\n\n    # Check constraint type matrix (I discontinued \"3\"s and \"4\"s in favor of just doing \"1\"s and \"2\"s\n    if 3 in vp['constraint_type'] or 4 in vp['constraint_type']:\n        issue += 1\n        print(issue, \"ISSUE: 'constraint_type' matrix contains 3s and/or 4s instead of 1s and 2s. I discontinued the\"\n                     \"use of the former in favor of the latter so please adjust it.\")\n\n    # Loop through each AFSC to check various elements\n    for j, afsc in enumerate(p[\"afscs\"][:p[\"M\"]]):\n\n        if p[\"num_eligible\"][j] &lt; p[\"quota_min\"][j]:\n            issue += 1\n            print(issue, \"ISSUE: AFSC '\" + afsc + \"' quota constraint invalid. \" + str(p[\"quota_min\"][j]) +\n                  \" (min) &gt; \" + str(p[\"num_eligible\"][j]) + \" (number of eligible cadets).\")\n        elif p[\"num_eligible\"][j] == p[\"quota_min\"][j]:\n            issue += 1\n            print(issue, \"WARNING: AFSC '\" + afsc +\n                  \"' has a lower quota that is the same as its number of eligible cadets (\" +\n                  str(p[\"quota_min\"][j]) + \"). All eligible cadets for this AFSC will be assigned to it.\")\n\n        if p[\"quota_min\"][j] &gt; p[\"quota_max\"][j]:\n            issue += 1\n            print(issue, \"ISSUE: AFSC '\" + afsc + \"' quota constraint invalid. \" + str(p[\"quota_min\"][j]) +\n                  \" (min) &gt; \" + str(p[\"quota_max\"][j]) + \" (max).\")\n\n        quota_k = np.where(vp[\"objectives\"] == \"Combined Quota\")[0][0]\n        if p[\"quota_d\"][j] != vp[\"objective_target\"][j, quota_k]:\n            issue += 1\n            print(issue, \"ISSUE: AFSC '\" + afsc + \"' quota desired target of \" + str(p[\"quota_d\"][j]) +\n                  \" from AFSCs Fixed does not match its objective target (\" + str(vp[\"objective_target\"][j, quota_k]) +\n                  \") in the value parameters.\")\n\n        if p[\"quota_d\"][j] &lt; p[\"quota_min\"][j] or p[\"quota_d\"][j] &gt; p[\"quota_max\"][j]:\n            issue += 1\n            print(issue, \"ISSUE: AFSC '\" + afsc + \"' quota desired target of \" + str(p[\"quota_d\"][j]) +\n                  \" is outside the specified range on the number of cadets (\" + str(p[\"quota_min\"][j]) + \", \" +\n                  str(p[\"quota_max\"][j]) + \").\")\n\n        # If we have the AFSC preference lists, we validate certain features\n        if 'a_pref_matrix' in p:\n\n            cfm_list = np.where(p['a_pref_matrix'][:, j])[0]  # Cadets on the AFSC preference list\n\n            # Cadets that are both on the CFM preference list and are eligible for the AFSC (qual matrix)\n            both_lists = np.intersect1d(cfm_list, p['I^E'][j])  # SHOULD contain the same cadets\n            num_cfm, num_qual = len(cfm_list), len(p['I^E'][j])  # SHOULD be the same number of cadets\n\n            # If the numbers aren't equal\n            if len(both_lists) != num_qual:\n                issue += 1\n                cfm_not_qual = [cadet for cadet in cfm_list if cadet not in p['I^E'][j]]\n                qual_not_cfm = [cadet for cadet in p['I^E'][j] if cadet not in cfm_list]\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' CFM preference list ('a_pref_matrix') does not match the qual\"\n                                                      \"matrix. \\nThere are \" + str(num_cfm) +\n                      \" cadets that are on the preference list (non-zero ranks) but there are \"\n                      + str(num_qual) + \" 'eligible' cadets (qual matrix). There are \" + str(len(both_lists)) +\n                      \" cadets in both sets. \\nCFM list but not qual cadets:\", cfm_not_qual,\n                      \"\\nQual but not CFM list cadets:\", qual_not_cfm)\n\n            # Make sure that all eligibility pairs line up\n            if 'c_pref_matrix' in p:\n\n                for i, cadet in enumerate(p['cadets']):\n\n                    on_afsc_list = p['a_pref_matrix'][i, j] &gt; 0\n                    on_cadet_list = p['c_pref_matrix'][i, j] &gt; 0\n\n                    if on_cadet_list and not on_afsc_list:\n                        issue += 1\n                        print(issue, \"ISSUE: AFSC '\" + afsc + \"' is on cadet '\" + str(cadet) + \"' (index=\" +\n                              str(i) + \")'s preference list (c_pref_matrix) but the cadet is not on their preference \"\n                                       \"list (a_pref_matrix).\")\n                    elif on_afsc_list and not on_cadet_list:\n                        issue += 1\n                        print(issue, \"ISSUE: Cadet '\" + str(cadet) + \"' (index=\" + str(i) + \") is on AFSC '\" + afsc +\n                              \"'s preference list (a_pref_matrix) but the AFSC is not on their preference list (c_pref_matrix).\")\n\n        # Validate AFOCD tier objectives\n        for objective in [\"Mandatory\", \"Desired\", \"Permitted\", \"Tier 1\", \"Tier 2\", \"Tier 3\", \"Tier 4\"]:\n\n            # Make sure this is a valid objective for this problem instance\n            if objective not in vp[\"objectives\"]:\n                continue  # goes to the next objective\n\n            # Get index\n            k = np.where(vp[\"objectives\"] == objective)[0][0]\n\n            # Check if the AFSC is constraining this objective\n            if k not in vp[\"K^C\"][j]:\n                continue\n\n            # Make sure there are cadets that are in this degree tier\n            if len(p[\"I^D\"][objective][j]) == 0:\n                issue += 1\n                if \"Tier\" in objective:\n                    print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                          \"' is empty. No cadets have degrees that fit in this tier for this class year.\")\n                else:\n                    print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                          \"'-Tier is empty. No cadets have degrees that fit in this tier for this class year.\")\n\n            # Make sure objective has valid target\n            if vp[\"objective_target\"][j, k] == 0:\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                      \"'-Tier target cannot be 0 when it has a nonzero weight.\")\n\n        # Validate AFOCD Tier objectives\n        levels = []\n        for t, objective in enumerate([\"Tier 1\", \"Tier 2\", \"Tier 3\", \"Tier 4\"]):\n\n            # Make sure this is a valid objective for this problem instance\n            if objective not in vp[\"objectives\"]:\n                continue  # goes to the next objective\n\n            # Get index\n            k = np.where(vp[\"objectives\"] == objective)[0][0]\n\n            # Make sure that this is a valid tier for this AFSC\n            if k not in vp['K^A'][j]:\n                continue  # goes to the next objective\n\n            level = \"I\" + str(t + 1)\n            requirement_dict = {'t_mandatory': 'M', 't_desired': 'D', 't_permitted': 'P'}\n            for r_level in requirement_dict:\n                if p[r_level][j, t]:\n                    level = requirement_dict[r_level] + str(t + 1)\n            levels.append(level)\n\n            # Make sure this requirement/qualification level is present with the cadets\n            if level not in p['qual'][:, j]:\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                      \"' expected cadet qualification level is '\" + level + \"' but this is not in the qual matrix.\")\n\n        unique_levels = np.unique(p['qual'][:, j])\n        for level in unique_levels:\n            if level not in levels and 'E' not in level and 'I' not in level:\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' qualification level '\" + level +\n                      \"' found within the cadet qual matrix but this is not defined within the value\"\n                      \" parameters.\" )\n\n        # Make sure all constrained objectives have appropriate constraints\n        for k in vp[\"K^C\"][j]:\n            objective = vp[\"objectives\"][k]\n\n            # Check constraint type to see if something doesn't check out\n            if vp[\"constraint_type\"][j, k] == 1:\n\n                # If the minimum is zero, we know this is an \"at MOST\" constraint (0 to 0.3, for example)\n                if vp['objective_min'][j, k] == 0:\n                    issue += 1\n                    print(issue, \"WARNING: AFSC '\" + afsc + \"' objective '\" + objective +\n                          \"' has an 'at most' constraint of '\" + vp['objective_value_min'][j, k] +\n                          \"'. The constraint_type is 1, indicating an approximate constraint but this is not recommended. \"\n                          \"Instead, use the constraint_type '2' to indicate an exact constraint since this is the easiest\"\n                          \" way to meet an 'at most' constraint.\")\n\n            # Make sure constrained objectives have valid constraint types\n            if vp['constraint_type'][j, k] not in [1, 2]:\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                      \"' is in set of constrained objectives: vp['K^C'][j] but has a constraint_type of '\" +\n                      str(vp['constraint_type'][j, k]) + \"'. This is not a valid active constraint.\",\n                      \"Please update the set of value parameters using 'instance.update_value_parameters()'.\")\n\n            # Check valid 'objective_value_min' constraint range\n            try:\n                lb = float(vp[\"objective_value_min\"][j, k].split(\",\")[0])\n                ub = float(vp[\"objective_value_min\"][j, k].split(\",\")[1])\n                assert lb &lt;= ub\n            except:\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                      \"' constraint range (objective_value_min) '\" + vp[\"objective_value_min\"][j, k] +\n                      \"' is invalid. This constraint is currently activated.\")\n\n        # Make sure value functions are valid\n        for k in vp[\"K^A\"][j]:\n            objective = vp[\"objectives\"][k]\n            vf_string_start = vp[\"value_functions\"][j, k].split(\"|\")[0]\n\n            # VF String validation\n            if vf_string_start not in [\"Min Increasing\", \"Min Decreasing\", \"Balance\", \"Quota_Direct\",\n                                       \"Quota_Normal\"]:\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective + \"' value function string '\" +\n                      vp[\"value_functions\"][j, k] + \"' is invalid.\")\n\n            # Validate number of breakpoints\n            if vp[\"r\"][j, k] == 0:\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                      \"' does not have any value function breakpoints. 'a':\", vp[\"a\"][j][k])\n                continue\n\n            # Value function should have same number of x and y coordinates\n            if len(vp[\"a\"][j][k]) != len(vp[\"f^hat\"][j][k]):\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                      \"' value function breakpoint coordinates do not align. 'a' has length of \" + len(vp[\"a\"][j][k]) +\n                      \" while 'f^hat' has length of \" + len(vp[\"f^hat\"][j][k]) + \".\")\n                continue\n\n            # Ensure that the breakpoint \"x\" coordinates are always getting bigger\n            current_x = -1\n            valid_x_bps = True\n            for l in vp[\"L\"][j][k]:\n                if vp[\"a\"][j][k][l] &lt; current_x:\n                    valid_x_bps = False\n                    break\n                else:\n                    current_x = vp[\"a\"][j][k][l]\n\n            if not valid_x_bps:\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                      \"' value function x coordinates do not continuously increase along x-axis. 'a':\", vp[\"a\"][j][k],\n                      \"'vf_string':\", vp[\"value_functions\"][j, k])\n\n        # Check all the objectives to see if the user missed something\n        for k, objective in enumerate(vp['objectives']):\n\n            if vp['constraint_type'][j, k] in [1, 2] and k not in vp['K^C'][j]:\n                issue += 1\n                print(issue, \"WARNING: AFSC '\" + afsc + \"' objective '\" + objective +\n                      \"' has a constraint_type of '\" + str(vp['constraint_type'][j, k]) +\n                      \"' but is not in set of constrained objectives: vp['K^C'][j]. This is a mistake so\",\n                      \"please update the set of value parameters using 'instance.update_value_parameters()'.\")\n\n    # Loop through each cadet to check preferences and utility values\n    invalid_utility, invalid_cadet_utility = 0, 0\n    invalid_utility_cadets, invalid_cadet_utility_cadets = [], []\n    for i in p['I']:\n        if 'c_preferences' in p and 'c_pref_matrix' in p:\n            for choice in range(p['P']):\n                afsc = p['c_preferences'][i, choice]\n                if afsc in p['afscs']:\n                    j = np.where(p['afscs'] == afsc)[0][0]\n                    if p['c_pref_matrix'][i, j] != choice + 1:\n                        issue += 1\n                        print(issue, \"ISSUE: Cadet\", p['cadets'][i], \"has AFSC '\" + afsc + \"' in position '\"\n                              + str(choice + 1) + \"' in the Cadets.csv file, but it is ranked '\" +\n                              str(p['c_pref_matrix'][i, j]) + \"' from the Cadets Preferences.csv file.\")\n                        break  # Don't need to check the rest of the cadet's preferences\n\n            # If this cadet does not have any preferences, we skip them (must be an OTS candidate)\n            if len(p['cadet_preferences'][i]) == 0:\n                issue += 1\n                print(issue, f\"WARNING: Cadet {i} has no preferences and is therefore eligible for nothing.\")\n                continue\n\n            # Make sure \"utility\" array is monotonically decreasing and the \"cadet_utility\" array is strictly decreasing\n            arr_1 = p['utility'][i, p['cadet_preferences'][i]]\n            arr_2 = p['cadet_utility'][i, p['cadet_preferences'][i]]\n            if not all(arr_1[idx] &gt;= arr_1[idx + 1] for idx in range(len(arr_1) - 1)):\n                invalid_utility += 1\n                invalid_utility_cadets.append(i)\n            if not all(arr_2[idx] &gt; arr_2[idx + 1] for idx in range(len(arr_2) - 1)):\n                invalid_cadet_utility += 1\n                invalid_cadet_utility_cadets.append(i)\n\n    # Report issues with decreasing cadet utility values\n    if invalid_utility &gt; 0:\n        issue += 1\n        print(issue, \"ISSUE: The cadet-reported utility matrix 'utility', located in 'Cadets Utility.csv'\\nand in the \"\n                     \"'Util' columns of 'Cadets.csv', does not incorporate monotonically\\ndecreasing utility values for \"\n                     \"\" + str(invalid_utility) + \" cadets. Please adjust.\")\n        if invalid_utility &lt; 100:\n            print('These are the cadets at indices', invalid_utility_cadets)\n    if invalid_cadet_utility &gt; 0 and 'last_afsc' not in p:  # There IS indifference with the new method of utilities\n        issue += 1\n        print(issue, \"ISSUE: The constructed cadet utility matrix 'cadet_utility', located in 'Cadets Utility (Final).\"\n                     \"csv',\\ndoes not incorporate strictly decreasing utility values for \"\n                     \"\" + str(invalid_cadet_utility) + \" cadets. Please adjust.\")\n        if invalid_cadet_utility &lt; 40:\n            print('These are the cadets at indices', invalid_cadet_utility_cadets)\n\n    # Loop through each objective to see if there are any null values in the objective target array\n    for k, objective in enumerate(vp[\"objectives\"]):\n        num_null = pd.isnull(vp[\"objective_target\"][:, k]).sum()\n        if num_null &gt; 0:\n            issue += 1\n            print(issue, \"ISSUE: Objective '\" + objective + \"' contains \" +\n                  str(num_null) + \" null target values ('objective_target').\")\n\n    # USSF OM Constraint rules\n    if instance.mdl_p['USSF OM'] is True and \"USSF\" not in p['afscs_acc_grp']:\n        issue += 1\n        print(issue, \"ISSUE: Space Force OM constraint specified in controls (USSF OM = True) but no USSF\"\n                     \" AFSCS found in the instance.\")\n\n    # At least one rated preference for rated eligible\n    for soc in p['SOCs']:\n        if soc in p['Rated Cadets']:\n            for i in p['Rated Cadets'][soc]:\n                if len(p['Rated Choices'][soc][i]) == 0:\n                    issue += 1\n                    print(issue,\n                          \"ISSUE: Cadet '\" + str(p['cadets'][i]) + \"' is on \" + soc.upper() +\n                          \"'s Rated list (\" + soc.upper() + \" Rated OM.csv) but is not eligible for any Rated AFSCs. \"\n                                                            \"You need to remove their row from the csv.\")\n\n    # Make sure all cadets eligible for at least one rated AFSC are in their SOC's rated OM list\n    for soc in p['SOCs']:\n        if 'J^Rated' in p:  # Make sure we have rated AFSCs\n\n            # Loop through each cadet from this SOC\n            for i in p[soc + '_cadets']:\n\n                # Check if they're eligible for at least one rated AFSC\n                if np.sum(p['eligible'][i][p['J^Rated']]) &gt;= 1:\n\n                    # If they're eligible for a Rated AFSC but aren't in the \"Rated OM.csv\" file, that's a problem\n                    if i not in p['Rated Cadets'][soc]:\n                        rated_afscs_eligible = p['afscs'][np.intersect1d(p['J^Rated'], p['J^E'][i])]\n                        issue += 1\n                        print(issue, \"ISSUE: Cadet '\" + str(p['cadets'][i]) + \"' is not on \" + soc.upper() +\n                              \"'s Rated list (\" + soc.upper() + \" Rated OM.csv), but is on the preference lists for\",\n                              rated_afscs_eligible, \"Please add a row in 'Rated OM.csv' for this cadet reflecting their \"\n                                                    \"OM.\")\n\n    # Validate that the \"totals\" for minimums/maximums work\n    if np.sum(p['pgl']) &gt; p['N']:\n        issue += 1\n        print(issue, \"ISSUE: Total sum of PGL targets is\", int(np.sum(p['pgl'])),\n              \" while 'N' is \" + str(p['N']) + \". This is infeasible since we don't have enough cadets.\")\n    if np.sum(p['quota_min']) &gt; p['N']:\n        issue += 1\n        print(issue, \"ISSUE: Total sum of minimum constrained capacities (quota_min) is\", int(np.sum(p['quota_min'])),\n              \" while 'N' is \" + str(p['N']) + \". This is infeasible since we don't have enough cadets.\")\n    if (np.sum(p['quota_max']) &lt; p['N']) and 'ots' not in p['SOCs']:  # OTS candidates can go unmatched\n        issue += 1\n        print(issue, \"ISSUE: Maximum constrained capacities (quota_max) is\", int(np.sum(p['quota_max'])),\n              \" while 'N' is \" + str(p['N']) + \". This is infeasible; we don't have enough positions for cadets to fill.\")\n\n    # Print statement\n    print('Done,', issue, \"issues found.\")\n</code></pre>"},{"location":"reference/data/adjustments/#data.adjustments.parameter_sets_additions","title":"<code>parameter_sets_additions(parameters)</code>","text":"<p>Add Indexed Sets and Subsets to the Problem Instance Parameters.</p> <p>This function enhances the problem instance by creating indexed sets and subsets for both cadets and AFSCs, demographic filters, eligibility matrices, preference-related metadata, and readiness for optimization. It also validates eligibility constraints and appends additional calculated data fields.</p>"},{"location":"reference/data/adjustments/#data.adjustments.parameter_sets_additions--parameters","title":"Parameters","text":"<p>parameters : dict     The fixed model input parameters for a cadet-AFSC assignment instance, including eligibility matrices,     cadet/AFSC attributes, utility matrices, and demographics.</p>"},{"location":"reference/data/adjustments/#data.adjustments.parameter_sets_additions--returns","title":"Returns","text":"<p>Updated parameter dictionary with:</p> <ul> <li>Indexed cadet and AFSC sets: <code>I</code>, <code>J</code>, <code>J^E</code>, <code>I^E</code></li> <li>Eligibility and preference counts: <code>num_eligible</code>, <code>Choice Count</code></li> <li>Demographic and qualification subsets: <code>I^D</code>, <code>I^USAFA</code>, <code>I^Male</code>, <code>I^Minority</code>, etc.</li> <li>Assignment constraints: <code>J^Fixed</code>, <code>J^Reserved</code></li> <li>Cadet and AFSC preference mappings</li> <li>Updated utility matrix with unmatched column</li> </ul>"},{"location":"reference/data/adjustments/#data.adjustments.parameter_sets_additions--examples","title":"Examples","text":"<pre><code>from afccp.data.adjustments import parameter_sets_additions\nparams = parameter_sets_additions(params)\n</code></pre>"},{"location":"reference/data/adjustments/#data.adjustments.parameter_sets_additions--notes","title":"Notes","text":"<ul> <li>Automatically detects and processes USAFA/ROTC cadet splits based on <code>usafa</code> and <code>soc</code> columns.</li> <li>Adds extra handling for cadets that are fixed to AFSCs via preassignments in <code>assigned</code>.</li> <li>Includes support for rated cadets, STEM AFSCs, race/ethnicity filters, and eligibility-based breakouts.</li> </ul>"},{"location":"reference/data/adjustments/#data.adjustments.parameter_sets_additions--see-also","title":"See Also","text":"<ul> <li><code>more_parameter_additions</code>:   Adds enhanced logic for cadet/AFSC matching, preference flattening, and diversity tracking.</li> <li><code>base_training_parameter_additions</code>:   Adds base and training assignment structures to the parameters.</li> </ul> Source code in <code>afccp/data/adjustments.py</code> <pre><code>def parameter_sets_additions(parameters):\n    \"\"\"\n    Add Indexed Sets and Subsets to the Problem Instance Parameters.\n\n    This function enhances the problem instance by creating indexed sets and subsets for both cadets and AFSCs,\n    demographic filters, eligibility matrices, preference-related metadata, and readiness for optimization.\n    It also validates eligibility constraints and appends additional calculated data fields.\n\n    Parameters\n    ----------\n    parameters : dict\n        The fixed model input parameters for a cadet-AFSC assignment instance, including eligibility matrices,\n        cadet/AFSC attributes, utility matrices, and demographics.\n\n    Returns\n    -------\n    Updated parameter dictionary with:\n\n    - Indexed cadet and AFSC sets: ``I``, ``J``, ``J^E``, ``I^E``\n    - Eligibility and preference counts: ``num_eligible``, ``Choice Count``\n    - Demographic and qualification subsets: ``I^D``, ``I^USAFA``, ``I^Male``, ``I^Minority``, etc.\n    - Assignment constraints: ``J^Fixed``, ``J^Reserved``\n    - Cadet and AFSC preference mappings\n    - Updated utility matrix with unmatched column\n\n    Examples\n    --------\n    ```python\n    from afccp.data.adjustments import parameter_sets_additions\n    params = parameter_sets_additions(params)\n    ```\n\n    Notes\n    -----\n    - Automatically detects and processes USAFA/ROTC cadet splits based on `usafa` and `soc` columns.\n    - Adds extra handling for cadets that are fixed to AFSCs via preassignments in `assigned`.\n    - Includes support for rated cadets, STEM AFSCs, race/ethnicity filters, and eligibility-based breakouts.\n\n    See Also\n    --------\n    - [`more_parameter_additions`](../../../afccp/reference/data/adjustments/#data.adjustments.more_parameter_additions):\n      Adds enhanced logic for cadet/AFSC matching, preference flattening, and diversity tracking.\n    - [`base_training_parameter_additions`](../../../afccp/reference/data/adjustments/#data.adjustments.base_training_parameter_additions):\n      Adds base and training assignment structures to the parameters.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Cadet Indexed Sets\n    p['I'] = np.arange(p['N'])\n    p['J'] = np.arange(p['M'])\n    p['J^E'] = [np.where(p['eligible'][i, :])[0] for i in p['I']]  # set of AFSCs that cadet i is eligible for\n\n    # AFSC Indexed Sets\n    p['I^E'] = [np.where(p['eligible'][:, j])[0] for j in p['J']]  # set of cadets that are eligible for AFSC j\n\n    # Number of eligible cadets for each AFSC\n    p[\"num_eligible\"] = np.array([len(p['I^E'][j]) for j in p['J']])\n\n    # More cadet preference sets if we have the \"cadet preference columns\"\n    if \"c_preferences\" in p:\n        p[\"I^Choice\"] = {choice: [np.where(\n            p[\"c_preferences\"][:, choice] == afsc)[0] for afsc in p[\"afscs\"][:p[\"M\"]]] for choice in range(p[\"P\"])}\n        p[\"Choice Count\"] = {choice: np.array(\n            [len(p[\"I^Choice\"][choice][j]) for j in p[\"J\"]]) for choice in range(p[\"P\"])}\n\n    # Add demographic sets if they're included\n    p['I^D'] = {}\n    if 'usafa' in p:\n        usafa = np.where(p['usafa'] == 1)[0]  # set of usafa cadets\n        p['usafa_proportion'] = np.mean(p['usafa'])\n        p['I^D']['USAFA Proportion'] = [np.intersect1d(p['I^E'][j], usafa) for j in p['J']]\n    if 'mandatory' in p:  # Qual Type = \"Old\"\n        p['I^D']['Mandatory'] = [np.where(p['mandatory'][:, j])[0] for j in p['J']]\n        p['I^D']['Desired'] = [np.where(p['desired'][:, j])[0] for j in p['J']]\n        p['I^D']['Permitted'] = [np.where(p['permitted'][:, j])[0] for j in p['J']]\n    if \"tier 1\" in p:  # Qual Type = \"Tiers\"\n        for t in ['1', '2', '3', '4']:\n            p['I^D']['Tier ' + t] = [np.where(p['tier ' + t][:, j])[0] for j in p['J']]\n\n        # Get arrays of unique degree tier values\n        p['Deg Tier Values'] = {j: np.unique(p['qual'][:, j]) for j in p['J']}\n\n    if 'male' in p:\n        male = np.where(p['male'] == 1)[0]  # set of male cadets\n        p['male_proportion'] = np.mean(p['male'])\n        p['I^D']['Male'] = [np.intersect1d(p['I^E'][j], male) for j in p['J']]\n    if 'minority' in p:\n        minority = np.where(p['minority'] == 1)[0]  # set of minority cadets\n        p['minority_proportion'] = np.mean(p['minority'])\n        p['I^D']['Minority'] = [np.intersect1d(p['I^E'][j], minority) for j in p['J']]\n\n    # Add an extra column to the utility matrix for cadets who are unmatched (if it hasn't already been added)\n    zeros_vector = np.array([[0] for _ in range(p[\"N\"])])\n    if np.shape(p['utility']) == (p['N'], p['M']):\n        p[\"utility\"] = np.hstack((p[\"utility\"], zeros_vector))\n\n    # Merit\n    if 'merit' in p:\n        p['sum_merit'] = p['merit'].sum()  # should be close to N/2\n\n    # USAFA/ROTC/OTS cadets\n    if 'SOCs' not in p:  # If it's just a \"USAFA\" column, we assume it's only USAFA/ROTC\n        p['rotc'] = (p['usafa'] == 0) * 1\n        p['usafa_cadets'] = np.where(p['usafa'])[0]\n        p['rotc_cadets'] = np.where(p['rotc'])[0]\n        p['usafa_eligible_count'] = np.array([len(np.intersect1d(p['I^E'][j], p['usafa_cadets'])) for j in p['J']])\n        p['rotc_eligible_count'] = np.array([len(np.intersect1d(p['I^E'][j], p['rotc_cadets'])) for j in p['J']])\n        p['SOCs'] = ['usafa', 'rotc']\n    else:\n        for soc in p['SOCs']:\n            p[soc] = (p['soc'] == soc.upper()) * 1\n            p[f'{soc}_cadets'] = np.where(p[soc])[0]\n            p[f'{soc}_eligible_count'] = np.array([len(np.intersect1d(p['I^E'][j], p[f'{soc}_cadets'])) for j in p['J']])\n\n    # Initialize empty dictionaries of matched/reserved cadets\n    p[\"J^Fixed\"] = {}\n    p[\"J^Reserved\"] = {}\n\n    # If we have the \"Assigned\" column in Cadets.csv, we can check to see if anyone is \"fixed\" in this solution\n    if \"assigned\" in p:\n\n        for i, afsc in enumerate(p[\"assigned\"]):\n            j = np.where(p[\"afscs\"] == afsc)[0]  # AFSC index\n\n            # Check if the cadet is actually assigned an AFSC already (it's not blank)\n            if len(j) != 0:\n                j = int(j[0])  # Actual index\n\n                # Check if the cadet is assigned to an AFSC they're not eligible for\n                if j not in p[\"J^E\"][i]:\n                    cadet = str(p['cadets'][i])\n                    raise ValueError(\"Cadet \" + cadet + \" assigned to '\" +\n                                     afsc + \"' but is not eligible for it. Adjust the qualification matrix!\")\n                else:\n                    p[\"J^Fixed\"][i] = j\n\n    # Cadet preference/rated cadet set additions\n    p = more_parameter_additions(p)\n\n    # Base/Training set additions\n    if \"bases\" in p:\n        p = base_training_parameter_additions(p)\n\n    return p\n</code></pre>"},{"location":"reference/data/adjustments/#data.adjustments.more_parameter_additions","title":"<code>more_parameter_additions(parameters)</code>","text":"<p>Add Additional Subsets and Parameter Structures to the Problem Instance.</p> <p>This function enhances the problem instance by appending numerous structured subsets and derived attributes based on cadet preferences, eligibility, accession groupings, demographics, and more. It enriches the input parameter dictionary in preparation for detailed analysis and optimization.</p>"},{"location":"reference/data/adjustments/#data.adjustments.more_parameter_additions--parameters","title":"Parameters","text":"<p>parameters : dict     The initial problem instance dictionary, containing data on cadets, AFSCs, eligibility, utility matrices, etc.</p>"},{"location":"reference/data/adjustments/#data.adjustments.more_parameter_additions--returns","title":"Returns","text":"<p>dict The updated problem instance with additional fields, subsets, and derived variables including:</p> <ul> <li>Cadet and AFSC preferences</li> <li>Accessions group (Rated, USSF, NRL) AFSC indices</li> <li>Rated-specific cadet groupings and OM mapping</li> <li>Simpson index for race/ethnicity</li> <li>Groupings by SOC (e.g., ROTC, USAFA), gender, and STEM designation</li> <li>Subsets like <code>I^Must_Match</code>, <code>J^Bottom 2 Choices</code>, etc.</li> </ul>"},{"location":"reference/data/adjustments/#data.adjustments.more_parameter_additions--examples","title":"Examples","text":"<pre><code>parameters = more_parameter_additions(parameters)\n</code></pre>"},{"location":"reference/data/adjustments/#data.adjustments.more_parameter_additions--notes","title":"Notes","text":"<p>The function performs a large number of conditional operations and appends dozens of new keys to <code>parameters</code>. These are used downstream in optimization and statistical evaluation of AFSC assignment plans.</p>"},{"location":"reference/data/adjustments/#data.adjustments.more_parameter_additions--see-also","title":"See Also","text":"<ul> <li><code>parameter_sets_additions</code>:   Related utility that adds indexed parameter sets post-preference generation.</li> </ul> Source code in <code>afccp/data/adjustments.py</code> <pre><code>def more_parameter_additions(parameters):\n    \"\"\"\n    Add Additional Subsets and Parameter Structures to the Problem Instance.\n\n    This function enhances the problem instance by appending numerous structured subsets and derived attributes\n    based on cadet preferences, eligibility, accession groupings, demographics, and more. It enriches the input\n    parameter dictionary in preparation for detailed analysis and optimization.\n\n    Parameters\n    ----------\n    parameters : dict\n        The initial problem instance dictionary, containing data on cadets, AFSCs, eligibility, utility matrices, etc.\n\n    Returns\n    -------\n    dict\n    The updated problem instance with additional fields, subsets, and derived variables including:\n\n    - Cadet and AFSC preferences\n    - Accessions group (Rated, USSF, NRL) AFSC indices\n    - Rated-specific cadet groupings and OM mapping\n    - Simpson index for race/ethnicity\n    - Groupings by SOC (e.g., ROTC, USAFA), gender, and STEM designation\n    - Subsets like `I^Must_Match`, `J^Bottom 2 Choices`, etc.\n\n    Examples\n    --------\n    ```python\n    parameters = more_parameter_additions(parameters)\n    ```\n\n    Notes\n    -----\n    The function performs a large number of conditional operations and appends dozens of new keys to `parameters`.\n    These are used downstream in optimization and statistical evaluation of AFSC assignment plans.\n\n    See Also\n    --------\n    - [`parameter_sets_additions`](../../../afccp/reference/data/adjustments/#data.adjustments.parameter_sets_additions):\n      Related utility that adds indexed parameter sets post-preference generation.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Create Cadet preferences\n    if 'c_pref_matrix' in p:\n        p['cadet_preferences'] = {}\n        p['num_cadet_choices'] = np.zeros(p['N'])\n        for i in p['I']:\n\n            # Sort the cadet preferences\n            cadet_sorted_preferences = np.argsort(p['c_pref_matrix'][i, :])\n            p['cadet_preferences'][i] = []\n\n            # Loop through each AFSC in order of preference and add it to the cadet's list\n            for j in cadet_sorted_preferences:\n\n                # Only add AFSCs that the cadet is eligible for and expressed a preference for\n                if 'last_afsc' not in p:\n                    if j in p['J^E'][i] and p['c_pref_matrix'][i, j] != 0:\n                        p['cadet_preferences'][i].append(j)\n\n                # Only add AFSCs that the cadet expressed a preference for\n                else:\n                    if p['c_pref_matrix'][i, j] != 0:\n                        p['cadet_preferences'][i].append(j)\n\n            p['cadet_preferences'][i] = np.array(p['cadet_preferences'][i])  # Convert to numpy array\n            p['num_cadet_choices'][i] = len(p['cadet_preferences'][i])\n\n    # Create AFSC preferences\n    if 'a_pref_matrix' in p:\n        p['afsc_preferences'] = {}\n        for j in p['J']:\n\n            # Sort the AFSC preferences\n            afsc_sorted_preferences = np.argsort(p['a_pref_matrix'][:, j])\n            p['afsc_preferences'][j] = []\n\n            # Loop through each cadet in order of preference and add them to the AFSC's list\n            for i in afsc_sorted_preferences:\n\n                # Only add cadets that are eligible for this AFSC and expressed a preference for it\n                if i in p['I^E'][j] and p['a_pref_matrix'][i, j] != 0:\n                    p['afsc_preferences'][j].append(i)\n\n            p['afsc_preferences'][j] = np.array(p['afsc_preferences'][j])  # Convert to numpy array\n\n    # Determine AFSCs by Accessions Group\n    p['afscs_acc_grp'] = {}\n    if 'acc_grp' in p:\n        for acc_grp in ['Rated', 'USSF', 'NRL']:\n            p['J^' + acc_grp] = np.where(p['acc_grp'] == acc_grp)[0]\n            p['afscs_acc_grp'][acc_grp] = p['afscs'][p['J^' + acc_grp]]\n    else:  # Previously, we've only assigned NRL cadets so we assume that's what we're dealing with here\n        p['acc_grp'] = np.array(['NRL' for _ in p['J']])\n        p['afscs_acc_grp']['NRL'] = p['afscs']\n        p['J^NRL'] = p['J']\n\n    # If we have the \"Accessions Group\" column in Cadets.csv, we can check to see if anyone is fixed to a group here\n    if 'acc_grp_constraint' in p:\n\n        # Loop through each Accession group and get the cadets that are constrained to be in this \"group\"\n        for acc_grp in p['afscs_acc_grp']:  # This should really only ever apply to USSF, but we're generalizing it\n\n            # Constrained cadets for each Accession group (don't confuse with I^*acc_grp* in the \"solutions\" dictionary!)\n            p['I^' + acc_grp] = np.where(p['acc_grp_constraint'] == acc_grp)[0]\n\n    # PGL Totals per SOC for USSF\n    if 'USSF' in p['afscs_acc_grp']:\n        p['ussf_usafa_pgl'] = np.sum(p['usafa_quota'][j] for j in p['J^USSF'])\n        p['ussf_rotc_pgl'] = np.sum(p['rotc_quota'][j] for j in p['J^USSF'])\n\n    # We already have \"J^USSF\" defined above; now we want one for USAF (NRL + Rated)\n    if 'USSF' in p['afscs_acc_grp']:\n        p['J^USAF'] = np.array([j for j in p['J'] if j not in p['J^USSF']])\n\n    # Determine eligible Rated cadets for both SOCs (cadets that are considered by the board)\n    cadets_dict = {soc: f'{soc[0]}r_om_cadets' for soc in p['SOCs']}\n    p[\"Rated Cadets\"] = {}\n    p[\"Rated Cadet Index Dict\"] = {}\n    p['Rated Choices'] = {}  # Dictionary of Rated cadet choices (only Rated AFSCs) by SOC\n    p['Num Rated Choices'] = {}  # Number of Rated cadet choices by SOC\n    for soc in cadets_dict:\n\n        # If we already have the array of cadets from the dataset\n        if cadets_dict[soc] in p:\n            p[\"Rated Cadets\"][soc] = p[cadets_dict[soc]]\n            p[\"Rated Cadet Index Dict\"][soc] = {i: idx for idx, i in enumerate(p[\"Rated Cadets\"][soc])}\n\n        # If we don't have this dataset, we check to see if we have Rated AFSCs\n        elif 'Rated' in p['afscs_acc_grp']:\n\n            # Add Rated cadets in order to each SOC list\n            p[\"Rated Cadets\"][soc] = []\n            for i in p[soc + '_cadets']:\n                for j in p['J^Rated']:\n                    if j in p['J^E'][i]:\n                        p[\"Rated Cadets\"][soc].append(i)\n                        break\n\n            # Convert to numpy array and get translation dictionary\n            p[\"Rated Cadets\"][soc] = np.array(p[\"Rated Cadets\"][soc])\n            p[\"Rated Cadet Index Dict\"][soc] = {i: idx for idx, i in enumerate(p[\"Rated Cadets\"][soc])}\n\n        # Get Rated preferences (where we strip out all NRL/USSF choices\n        if soc in p['Rated Cadets'] and 'cadet_preferences' in p:\n            p['Rated Choices'][soc] = {}\n            p['Num Rated Choices'][soc] = {i: 0 for i in p[\"Rated Cadets\"][soc]}\n            for i in p[\"Rated Cadets\"][soc]:\n                rated_order = []\n                for j in p['cadet_preferences'][i]:\n                    if j in p['J^Rated']:\n                        rated_order.append(j)\n                        p['Num Rated Choices'][soc][i] += 1\n                p['Rated Choices'][soc][i] = np.array(rated_order)\n\n    # If we haven't already created the \"cadet_utility\" matrix, we do that here (only one time)\n    if 'cadet_utility' not in p:\n\n        # Build out cadet_utility using cadet preferences\n        p['cadet_utility'] = np.around(copy.deepcopy(p['utility']), 4)\n\n    # set of AFSCs that cadet i has placed a preference for and is also eligible for\n    non_zero_utils_j = [np.where(p['cadet_utility'][i, :] &gt; 0)[0] for i in p['I']]\n    p[\"J^P\"] = [np.intersect1d(p['J^E'][i], non_zero_utils_j[i]) for i in p['I']]\n\n    # set of cadets that have placed a preference for AFSC j and are eligible for AFSC j\n    non_zero_utils_i = [np.where(p['cadet_utility'][:, j] &gt; 0)[0] for j in p['J']]\n    p[\"I^P\"] = [np.intersect1d(p['I^E'][j], non_zero_utils_i[j]) for j in p['J']]\n\n    # Race categories\n    if 'race' in p:\n        p['race_categories'] = np.unique(p['race'])\n        for race in p['race_categories']:\n            p['I^' + race] = np.where(p['race'] == race)[0]\n\n        # Calculate simpson index for overall class as a baseline\n        p['baseline_simpson_index'] = round(1 - np.sum([(len(\n            p['I^' + race]) * (len(p['I^' + race]) - 1)) / (p['N'] * (p['N'] - 1)) for race in p['race_categories']]), 2)\n\n    # Ethnicity categories\n    if 'ethnicity' in p:\n        p['ethnicity_categories'] = np.unique(p['ethnicity'])\n        for eth in p['ethnicity_categories']:\n            p['I^' + eth] = np.where(p['ethnicity'] == eth)[0]\n\n        # Calculate simpson index for overall class as a baseline\n        p['baseline_simpson_index_eth'] = round(1 - np.sum([(len(\n            p['I^' + eth]) * (len(p['I^' + eth]) - 1)) / (p['N'] * (p['N'] - 1)) for eth in\n                                                        p['ethnicity_categories']]), 2)\n\n    # SOC and Gender cadets standardized like above\n    if 'SOCs' in p:\n        for soc in p['SOCs']:\n            p[f'I^{soc.upper()}'] = np.where(p[soc])[0]\n    if 'male' in p:\n        p['I^Male'] = np.where(p['male'])[0]\n        p['I^Female'] = np.where(p['male'] == 0)[0]\n\n    # STEM cadets\n    if 'stem' in p:\n        p['I^STEM'] = np.where(p['stem'])[0]\n\n        if 'afscs_stem' in p:\n            p['J^STEM'] = np.where(p['afscs_stem'] == 'Yes')[0]\n            p['J^Not STEM'] = np.where(p['afscs_stem'] == 'No')[0]\n            p['J^Hybrid'] = np.where(p['afscs_stem'] == 'Hybrid')[0]\n\n    # Selected AFSCs\n    if 'c_selected_matrix' in p:\n        p['J^Selected'] = {}  # The cadet selected the AFSC as a preference\n        p['J^Selected-E'] = {}  # The cadet selected the AFSC as a preference and is eligible for it\n        for i in p['I']:\n            p['J^Selected'][i] = np.where(p['c_selected_matrix'][i])[0]\n            p['J^Selected-E'][i] = np.intersect1d(p['J^E'][i], p['J^Selected'][i])\n\n    # Incorporate \"Must Match\" information for OTS\n    if 'must_match' in p:\n        p['I^Must_Match'] = np.where(p['must_match'] == 1)[0]\n\n    # Last/Second to Last AFSCs\n    if 'last_afsc' in p and 'second_to_last_afscs' in p:\n        p['J^Bottom 2 Choices'] = {}\n        p['J^Last Choice'] = {}\n\n        # Loop through each cadet\n        for i in p['I']:\n\n            # Get a list of AFSC indices of the bottom 2 choices (but not last choice)\n            if type(p['second_to_last_afscs'][i]) == str:\n                afsc_list = p['second_to_last_afscs'][i].split(',')\n            else:\n                afsc_list = [\"\"]\n\n            p['J^Bottom 2 Choices'][i] = []\n            for afsc in afsc_list:\n                afsc = afsc.strip()\n                if afsc in p['afscs']:\n                    j = np.where(p['afscs'] == afsc)[0][0]\n                    p['J^Bottom 2 Choices'][i].append(j)\n            p['J^Bottom 2 Choices'][i] = np.array(p['J^Bottom 2 Choices'][i])\n\n            # Get the last AFSC choice index\n            p['J^Last Choice'][i] = p['M']  # Unmatched AFSC (*)\n            if p['last_afsc'][i] in p['afscs']:\n                p['J^Last Choice'][i] = np.where(p['afscs'] == p['last_afsc'][i])[0][0]\n\n    return p\n</code></pre>"},{"location":"reference/data/adjustments/#data.adjustments.base_training_parameter_additions","title":"<code>base_training_parameter_additions(parameters)</code>","text":"<p>Add Base and Training Parameters to the Problem Instance.</p> <p>This function extends the parameter dictionary with the data structures required to support base assignments and training course scheduling within the CASTLE Base/Training optimization model. Each cadet is categorized into preference-based \"states\" depending on their AFSC priorities and base/course interest.</p> <p>The function also calculates cadet-course availability, utility of wait times, and assignment eligibility across bases and courses. This enables simultaneous modeling of AFSC matches, base assignments, and training timelines.</p>"},{"location":"reference/data/adjustments/#data.adjustments.base_training_parameter_additions--parameters","title":"Parameters","text":"<p>parameters : dict     The problem instance parameters, including cadet preferences, AFSC eligibility, utility scores, training     thresholds, and configuration flags for base/course logic.</p>"},{"location":"reference/data/adjustments/#data.adjustments.base_training_parameter_additions--returns","title":"Returns","text":"<p>dict Updated parameter dictionary with additional sets and matrices such as:</p> <ul> <li><code>D</code>, <code>Cadet Objectives</code>, <code>J^State</code>, <code>w^A</code>, <code>w^B</code>, <code>w^C</code>, <code>u^S</code>: cadet state structures.</li> <li><code>B^A</code>, <code>B^E</code>, <code>B^State</code>: base assignment eligibility mappings.</li> <li><code>C^E</code>, <code>I^A</code>, <code>course_days_cadet</code>, <code>course_utility</code>: training availability and utility values.</li> <li><code>lo^B</code>, <code>hi^B</code>, <code>lo^C</code>, <code>hi^C</code>: quantity constraints on base/course assignments.</li> </ul>"},{"location":"reference/data/adjustments/#data.adjustments.base_training_parameter_additions--examples","title":"Examples","text":"<pre><code>from afccp.data.adjustments import base_training_parameter_additions\nparameters = base_training_parameter_additions(parameters)\n</code></pre>"},{"location":"reference/data/adjustments/#data.adjustments.base_training_parameter_additions--notes","title":"Notes","text":"<ul> <li>Cadet states are built using <code>base_threshold</code> and <code>training_threshold</code>, which split cadet preferences into   AFSCs only, AFSC + base, and AFSC + base + course states.</li> <li>Utility from training courses is based on cadet preferences (<code>Early</code>, <code>Late</code>, <code>None</code>) and normalized start dates.</li> <li>Course utility is scaled from 0 to 1, with utility decreasing/increasing with wait time as appropriate.</li> <li>This logic assumes all relevant arrays like <code>training_start</code>, <code>course_start</code>, <code>afsc_assign_base</code>, etc., exist and   are preloaded in the parameter dictionary.</li> </ul>"},{"location":"reference/data/adjustments/#data.adjustments.base_training_parameter_additions--see-also","title":"See Also","text":"<ul> <li><code>parameter_sets_additions</code>:   Adds foundational indexed sets and preference structures used prior to base/training expansion.</li> </ul> Source code in <code>afccp/data/adjustments.py</code> <pre><code>def base_training_parameter_additions(parameters):\n    \"\"\"\n    Add Base and Training Parameters to the Problem Instance.\n\n    This function extends the parameter dictionary with the data structures required to support base assignments and\n    training course scheduling within the CASTLE Base/Training optimization model. Each cadet is categorized into\n    preference-based \"states\" depending on their AFSC priorities and base/course interest.\n\n    The function also calculates cadet-course availability, utility of wait times, and assignment eligibility across bases\n    and courses. This enables simultaneous modeling of AFSC matches, base assignments, and training timelines.\n\n    Parameters\n    ----------\n    parameters : dict\n        The problem instance parameters, including cadet preferences, AFSC eligibility, utility scores, training\n        thresholds, and configuration flags for base/course logic.\n\n    Returns\n    -------\n    dict\n    Updated parameter dictionary with additional sets and matrices such as:\n\n    - `D`, `Cadet Objectives`, `J^State`, `w^A`, `w^B`, `w^C`, `u^S`: cadet state structures.\n    - `B^A`, `B^E`, `B^State`: base assignment eligibility mappings.\n    - `C^E`, `I^A`, `course_days_cadet`, `course_utility`: training availability and utility values.\n    - `lo^B`, `hi^B`, `lo^C`, `hi^C`: quantity constraints on base/course assignments.\n\n    Examples\n    --------\n    ```python\n    from afccp.data.adjustments import base_training_parameter_additions\n    parameters = base_training_parameter_additions(parameters)\n    ```\n\n    Notes\n    -----\n    - Cadet states are built using `base_threshold` and `training_threshold`, which split cadet preferences into\n      AFSCs only, AFSC + base, and AFSC + base + course states.\n    - Utility from training courses is based on cadet preferences (`Early`, `Late`, `None`) and normalized start dates.\n    - Course utility is scaled from 0 to 1, with utility decreasing/increasing with wait time as appropriate.\n    - This logic assumes all relevant arrays like `training_start`, `course_start`, `afsc_assign_base`, etc., exist and\n      are preloaded in the parameter dictionary.\n\n    See Also\n    --------\n    - [`parameter_sets_additions`](../../../afccp/reference/data/adjustments/#data.adjustments.parameter_sets_additions):\n      Adds foundational indexed sets and preference structures used prior to base/training expansion.\n    \"\"\"\n\n    # Helpful function to extract the datetime object from a specific string containing date information\n    def parse_date(date_str):\n        for fmt in ('%m/%d/%y', '%Y-%m-%d'):\n            try:\n                return datetime.strptime(date_str, fmt).date()\n            except ValueError:\n                pass\n        return None  # Return None if no format matches\n\n    # Shorthand\n    p = parameters\n\n    # Sets of bases and courses\n    p['B'] = np.arange(p['S'])\n    p['C'] = {j: np.arange(p['T'][j]) for j in p['J']}\n\n    # Set of AFSCs that assign cadets to bases\n    p['J^B'] = np.where(p['afsc_assign_base'])[0]\n\n    # Set of bases that AFSC j may assign cadets to\n    p['B^A'] = {j: np.where(p['base_max'][:, j] &gt; 0)[0] for j in p['J']}\n\n    # Set of bases that cadet i may be assigned to (based on the union of all eligible bases from AFSCs in J^E_i)\n    p['B^E'] = {i: reduce(np.union1d, (p['B^A'][j] for j in np.intersect1d(p['J^E'][i], p['J^B']))) for i in p['I']}\n\n    # Sets/Parameters for AFSC outcome states for each cadet\n    p['D'] = {}  # Set of all AFSC outcome states that cadet i has designated\n    p['Cadet Objectives'] = {}  # Set of cadet objectives included for each cadet and each state\n    p['J^State'] = {}  # Set of AFSCs that, if assigned, would put cadet i into state d\n    p['w^A'] = {}  # the weight that cadet i places on AFSCs in state d\n    p['w^B'] = {}  # the weight that cadet i places on bases in state d\n    p['w^C'] = {}  # the weight that cadet i places on courses in state d\n    p['u^S'] = {}  # the maximum utility that cadet i receives from state d (based on best AFSC)\n    p['B^State'] = {}  # Set of bases that cadet i can be assigned to in state d (According to J^State_id)\n\n    # Determine the \"states\" for each cadet based on the differences of AFSC outcomes\n    for i in p['I']:\n\n        # Base/Training Thresholds (Shorthand)\n        bt, tt = p['base_threshold'][i], p['training_threshold'][i]\n\n        # Determine \"primary\" set of AFSCs and states based on thresholds\n        if bt &lt; tt:\n            afscs = {1: p['cadet_preferences'][i][:bt],\n                      2: p['cadet_preferences'][i][bt: tt],\n                      3: p['cadet_preferences'][i][tt:]}\n            included = {1: ['afsc'], 2: ['afsc', 'base'], 3: ['afsc', 'base', 'course']}\n        elif tt &lt; bt:\n            afscs = {1: p['cadet_preferences'][i][:tt],\n                      2: p['cadet_preferences'][i][tt: bt],\n                      3: p['cadet_preferences'][i][bt:]}\n            included = {1: ['afsc'], 2: ['afsc', 'course'], 3: ['afsc', 'base', 'course']}\n        else:  # They're equal!\n            afscs = {1: p['cadet_preferences'][i][:bt],\n                      2: p['cadet_preferences'][i][bt:]}\n            included = {1: ['afsc'], 2: ['afsc', 'base', 'course']}\n\n        # Sets/Parameters for AFSC outcome states for each cadet\n        p['D'][i] = []  # Set of all AFSC outcome states that cadet i has designated\n        p['Cadet Objectives'][i] = {}  # Set of cadet objectives included for each cadet and each state\n        p['J^State'][i] = {}  # Set of AFSCs that, if assigned, would put cadet i into state d\n        p['w^A'][i] = {}  # the weight that cadet i places on AFSCs in state d\n        p['w^B'][i] = {}  # the weight that cadet i places on bases in state d\n        p['w^C'][i] = {}  # the weight that cadet i places on courses in state d\n        p['u^S'][i] = {}  # the maximum utility that cadet i receives from state d (based on best AFSC)\n        p['B^State'][i] = {}  # Set of bases that cadet i can be assigned to in state d (According to J^State_id)\n\n        # Loop through each \"primary\" state to get \"final\" states (Split up states based on base assignment AFSCs)\n        d = 1\n        for state in included:\n\n            # Empty state!\n            if len(afscs[state]) == 0:\n                continue\n\n            # Split up the AFSCs into two groups if they assign cadets to bases or not\n            sets = {'Assigned': np.intersect1d(p['J^B'], afscs[state]),\n                    'Not Assigned': np.array([j for j in afscs[state] if j not in p['J^B']])}\n\n            # Loop through both sets and create a new state if the set contains AFSCs\n            for set_name, afscs_in_set in sets.items():\n                if len(afscs_in_set) != 0:\n\n                    # Add information to this state\n                    p['D'][i].append(d)\n                    p['Cadet Objectives'][i][d] = included[state]\n                    p['J^State'][i][d] = afscs_in_set\n                    p['u^S'][i][d] = p['cadet_utility'][i, afscs[state][0]]  # Utility of the top preferred AFSC\n\n                    # Weights and set of bases are differentiated by if this is a set containing J^B AFSCs or not\n                    if set_name == \"Assigned\":\n\n                        # Re-scale weights based on the objectives included in this state\n                        p['w^A'][i][d] = p['weight_afsc'][i] / sum(p['weight_' + obj][i] for obj in included[state])\n                        p['w^C'][i][d] = p['weight_course'][i] / sum(p['weight_' + obj][i] for obj in included[state]) \\\n                                         * ('course' in included[state])\n                        p['w^B'][i][d] = p['weight_base'][i] / sum(p['weight_' + obj][i] for obj in included[state]) \\\n                                         * ('base' in included[state])\n\n                        # Union of bases that this cadet could be assigned to in this state according to J^State_id\n                        p['B^State'][i][d] = reduce(np.union1d, (p['B^A'][j] for j in p['J^State'][i][d]))\n\n                    else:\n\n                        # Re-scale weights based on the objectives included in this state\n                        p['w^A'][i][d] = p['weight_afsc'][i] / \\\n                                         sum(p['weight_' + obj][i] for obj in included[state] if obj != \"base\")\n                        p['w^C'][i][d] = ('course' in included[state]) * p['weight_course'][i] / \\\n                                         sum(p['weight_' + obj][i] for obj in included[state] if obj != \"base\")\n                        p['w^B'][i][d] = 0\n                        p['B^State'][i][d] = np.array([])  # Empty array (no bases)\n\n                    # Next state\n                    d += 1\n\n        # Print statement for specific cadet\n        if i == 10 and False:  # Meant for debugging and sanity checking this logic!\n            print('Cadet', i)\n            for d in p['D'][i]:\n                print('\\n\\n')\n                print('State', d)\n                print('Objectives', p['Cadet Objectives'][i][d])\n                print('J^State', p['afscs'][p['J^State'][i][d]])\n                if len(p['B^State'][i][d]) &gt; 0:\n                    print('B^State', p['bases'][p['B^State'][i][d]])\n                else:\n                    print('B^State', [])\n                print('Weight (AFSC)', round(p['w^A'][i][d], 3))\n                print('Weight (Base)', round(p['w^B'][i][d], 3))\n                print('Weight (Course)', round(p['w^C'][i][d], 3))\n                print('Utility (State)', round(p['u^S'][i][d], 3))\n\n    # Adjust AFSC, base, course weights to give slight bump to ensure all are considered in each applicable state\n    max_afsc_weight = max([p['w^A'][i][d] for i in p['I'] for d in p['D'][i] if p['w^A'][i][d] != 1])\n    max_afsc_weight += (1 - max_afsc_weight) / 2\n    for i in p['I']:\n        for d in p['D'][i]:\n\n            # Take some weight from AFSCs\n            p['w^A'][i][d] = p['w^A'][i][d] * max_afsc_weight\n\n            # Redistribute the weight to Base/Courses depending on existence of J^B AFSCs\n            if len(p['B^State'][i][d]) &gt; 0:\n                p['w^B'][i][d] = p['w^B'][i][d] * max_afsc_weight + (1 - max_afsc_weight) / 2\n                p['w^C'][i][d] = p['w^C'][i][d] * max_afsc_weight + (1 - max_afsc_weight) / 2\n            else:\n                p['w^C'][i][d] = p['w^C'][i][d] * max_afsc_weight + (1 - max_afsc_weight)\n\n    # Sets pertaining to courses for each AFSC\n    p['C^E'] = {}  # Set of courses that cadet i is available to take with AFSC j\n    p['I^A'] = {}  # Set of cadets that are available to take course c with AFSC j\n\n    # Calculate course utility for each cadet, AFSC, course tuple\n    p['course_days_cadet'] = {}\n    p['course_utility'] = {}\n    for i in p['I']:\n\n        # Initialize information for this cadet\n        p['course_days_cadet'][i] = {}\n        p['course_utility'][i] = {}\n        p['C^E'][i] = {}\n\n        # Loop through each AFSC and course to determine days between cadet start and course start\n        for j in p['J^E'][i]:\n            p['course_days_cadet'][i][j] = {}\n            for c in p['C'][j]:\n\n                # Convert str format to datetime format if necessary\n                if type(p['course_start'][j][c]) == str:\n                    course_start = parse_date(p['course_start'][j][c])\n                    cadet_start = parse_date(p['training_start'][i])\n                else:\n                    course_start = p['course_start'][j][c]\n                    cadet_start = p['training_start'][i]\n\n                # Calculate days between\n                days_between = (course_start - cadet_start).days\n                if days_between &gt;= 0:  # If the cadet is available to take the course before it starts\n                    p['course_days_cadet'][i][j][c] = days_between\n\n            # Get subset of courses that this cadet can take for this AFSC\n            p['C^E'][i][j] = np.array([c for c in p['course_days_cadet'][i][j]])\n\n        # Get course wait times and determine min and max\n        course_waits = [p['course_days_cadet'][i][j][c] for j in p['J^E'][i] for c in p['C^E'][i][j]]\n        max_wait, min_wait = max(course_waits), min(course_waits)\n\n        # Loop through each AFSC and course again to calculate utility (normalize the wait times)\n        for j in p['J^E'][i]:\n            p['course_utility'][i][j] = {}\n            for c in p['C^E'][i][j]:\n                if p['training_preferences'][i] == 'Early':\n                    p['course_utility'][i][j][c] = 1 - (p['course_days_cadet'][i][j][c] - min_wait) / \\\n                                                   (max_wait - min_wait)\n                elif p['training_preferences'][i] == 'Late':\n                    p['course_utility'][i][j][c] = (p['course_days_cadet'][i][j][c] - min_wait) / \\\n                                                   (max_wait - min_wait)\n                else:  # No preference\n                    p['course_utility'][i][j][c] = 0\n\n                if i == 0 and False:  # Meant for debugging and sanity checking this logic!\n                    print(i, j, c, \"Dates\", course_start, cadet_start, \"DAYS\", p['course_days_cadet'][i][j][c],\n                          \"Utility\", p['course_utility'][i][j][c])\n\n    # Determine set of cadets that are available to take course c with AFSC j\n    for j in p['J']:\n        p['I^A'][j] = {}\n        for c in p['C'][j]:\n            p['I^A'][j][c] = np.array([i for i in p['I^E'][j] if c in p['C^E'][i][j]])\n\n    # Get minimum and maximum quantities for bases\n    p['lo^B'], p['hi^B'] = {}, {}\n    for j in p['J^B']:\n        p['lo^B'][j], p['hi^B'][j] = {}, {}\n        for b in p['B^A'][j]:\n            p['lo^B'][j][b], p['hi^B'][j][b] = p['base_min'][b, j], p['base_max'][b, j]\n\n    # Get minimum and maximum quantities for courses\n    p['lo^C'], p['hi^C'] = p['course_min'], p['course_max']\n\n    return p\n</code></pre>"},{"location":"reference/data/adjustments/#data.adjustments.set_ots_must_matches","title":"<code>set_ots_must_matches(parameters)</code>","text":"<p>Identify OTS Candidates Who Must Be Matched in the Assignment.</p> <p>This function determines which Officer Training School (OTS) cadets must be assigned (i.e., matched) by identifying the top candidates based on their Order of Merit (OM) scores. It updates the <code>must_match</code> array to indicate mandatory match requirements, and adds a new set <code>I^Must_Match</code> containing the indices of cadets who must be assigned a slot.</p> <p>If OTS is not a participating source of commissioning (SOC) in the instance, the function exits early with no modifications.</p>"},{"location":"reference/data/adjustments/#data.adjustments.set_ots_must_matches--parameters","title":"Parameters:","text":"<ul> <li>parameters (dict): Dictionary of model parameters, including cadet index sets (<code>I</code>, <code>I^OTS</code>), merit scores,   and SOC definitions.</li> </ul>"},{"location":"reference/data/adjustments/#data.adjustments.set_ots_must_matches--returns","title":"Returns:","text":"<ul> <li> <p>dict: The updated parameters dictionary with the following changes:</p> <ul> <li><code>must_match</code>: N-length array with <code>1</code> for must-match cadets, <code>0</code> for others, and <code>NaN</code> for non-OTS cadets.</li> <li><code>I^Must_Match</code>: Set of cadet indices in <code>I^OTS</code> who are in the top ~99.5% of the OM distribution.</li> </ul> </li> </ul>"},{"location":"reference/data/adjustments/#data.adjustments.set_ots_must_matches--examples","title":"Examples:","text":"<pre><code>parameters = set_ots_must_matches(parameters)\n</code></pre> Source code in <code>afccp/data/adjustments.py</code> <pre><code>def set_ots_must_matches(parameters):\n    \"\"\"\n    Identify OTS Candidates Who Must Be Matched in the Assignment.\n\n    This function determines which Officer Training School (OTS) cadets must be assigned (i.e., matched) by\n    identifying the top candidates based on their Order of Merit (OM) scores. It updates the `must_match`\n    array to indicate mandatory match requirements, and adds a new set `I^Must_Match` containing the indices\n    of cadets who must be assigned a slot.\n\n    If OTS is not a participating source of commissioning (SOC) in the instance, the function exits early\n    with no modifications.\n\n    Parameters:\n    --------\n    - parameters (dict): Dictionary of model parameters, including cadet index sets (`I`, `I^OTS`), merit scores,\n      and SOC definitions.\n\n    Returns:\n    --------\n    - dict: The updated parameters dictionary with the following changes:\n\n        - `must_match`: N-length array with `1` for must-match cadets, `0` for others, and `NaN` for non-OTS cadets.\n        - `I^Must_Match`: Set of cadet indices in `I^OTS` who are in the top ~99.5% of the OM distribution.\n\n    Examples:\n    --------\n    ```python\n    parameters = set_ots_must_matches(parameters)\n    ```\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Clear \"must matches\"\n    p['must_match'] = np.array([np.nan for _ in p['I']])\n    p['must_match'][p['I^OTS']] = 0\n\n    # No OTS adjustments to be made\n    if 'ots' not in p['SOCs']:\n        print('OTS not included in this instance!! Nothing to do here.')\n        return p\n\n    # Sort OTS candidates by OM and take the top {ots_accessions} people\n    sorted_by_merit = np.argsort(p['merit'])[::-1]\n    ots_sorted = np.array([i for i in sorted_by_merit if i in p['I^OTS']])\n    p['I^Must_Match'] = ots_sorted[:int(p['ots_accessions'] * 0.995)]\n    p['must_match'][p['I^Must_Match']] = 1\n    return p\n</code></pre>"},{"location":"reference/data/adjustments/#data.adjustments.gather_degree_tier_qual_matrix","title":"<code>gather_degree_tier_qual_matrix(cadets_df, parameters)</code>","text":"<p>Construct or Validate Degree Tier Qualification Matrix for Cadets.</p> <p>This function analyzes the provided <code>cadets_df</code> and <code>parameters</code> to determine if a valid degree qualification matrix (<code>qual</code>) exists. If not, or if the format differs from the expected \"Tiers\" structure, a new one is generated using CIP codes. It then computes a series of derived binary matrices (e.g., <code>eligible</code>, <code>mandatory</code>, <code>tier 1</code>, etc.) that describe cadet eligibility for each AFSC based on degree requirements.</p> <p>The degree tier qualification matrix is a critical part of the AFSC assignment model, influencing eligibility filtering, tier-based objective constraints, and value function evaluations.</p>"},{"location":"reference/data/adjustments/#data.adjustments.gather_degree_tier_qual_matrix--parameters","title":"Parameters:","text":"<ul> <li>cadets_df (pd.DataFrame): The dataframe containing cadet qualification data. Must contain   columns like <code>qual_AFSC</code> or CIP fields if generating the qualification matrix.</li> <li>parameters (dict): Instance parameter dictionary (<code>p</code>) that includes AFSCs, CIP codes,   qualification type, and degree tier expectations. This dictionary will be modified in place.</li> </ul>"},{"location":"reference/data/adjustments/#data.adjustments.gather_degree_tier_qual_matrix--returns","title":"Returns:","text":"<ul> <li> <p>dict: Updated <code>parameters</code> dictionary with the following keys (if applicable):</p> <ul> <li><code>\"qual\"</code>: The constructed or validated NxM string matrix of qualification levels.</li> <li><code>\"eligible\"</code> / <code>\"ineligible\"</code>: Binary matrices indicating AFSC eligibility.</li> <li><code>\"mandatory\"</code> / <code>\"desired\"</code> / <code>\"permitted\"</code>: Binary matrices based on tier requirements.</li> <li><code>\"tier 1\"</code> to <code>\"tier 4\"</code>: Tier-specific binary matrices.</li> <li><code>\"exception\"</code>: Binary matrix marking cadets eligible through exception rules.</li> <li><code>\"t_count\"</code>: Array of number of degree tiers per AFSC.</li> <li><code>\"t_proportion\"</code>: Matrix with expected proportions for each tier per AFSC.</li> <li><code>\"t_eq\"</code> / <code>\"t_geq\"</code> / <code>\"t_leq\"</code>: Binary matrices specifying how tier requirements should be interpreted.</li> </ul> </li> </ul>"},{"location":"reference/data/adjustments/#data.adjustments.gather_degree_tier_qual_matrix--examples","title":"Examples:","text":"<pre><code>p = gather_degree_tier_qual_matrix(cadets_df, p)\n</code></pre>"},{"location":"reference/data/adjustments/#data.adjustments.gather_degree_tier_qual_matrix--see-also","title":"See Also:","text":"<ul> <li><code>cip_to_qual_tiers</code>:   Generates tier-based qualification matrix from CIP codes.</li> </ul> Source code in <code>afccp/data/adjustments.py</code> <pre><code>def gather_degree_tier_qual_matrix(cadets_df, parameters):\n    \"\"\"\n    Construct or Validate Degree Tier Qualification Matrix for Cadets.\n\n    This function analyzes the provided `cadets_df` and `parameters` to determine if a valid degree\n    qualification matrix (`qual`) exists. If not, or if the format differs from the expected\n    \"Tiers\" structure, a new one is generated using CIP codes. It then computes a series of derived\n    binary matrices (e.g., `eligible`, `mandatory`, `tier 1`, etc.) that describe cadet eligibility\n    for each AFSC based on degree requirements.\n\n    The degree tier qualification matrix is a critical part of the AFSC assignment model, influencing\n    eligibility filtering, tier-based objective constraints, and value function evaluations.\n\n    Parameters:\n    --------\n    - cadets_df (pd.DataFrame): The dataframe containing cadet qualification data. Must contain\n      columns like `qual_AFSC` or CIP fields if generating the qualification matrix.\n    - parameters (dict): Instance parameter dictionary (`p`) that includes AFSCs, CIP codes,\n      qualification type, and degree tier expectations. This dictionary will be modified in place.\n\n    Returns:\n    --------\n    - dict: Updated `parameters` dictionary with the following keys (if applicable):\n\n        - `\"qual\"`: The constructed or validated NxM string matrix of qualification levels.\n        - `\"eligible\"` / `\"ineligible\"`: Binary matrices indicating AFSC eligibility.\n        - `\"mandatory\"` / `\"desired\"` / `\"permitted\"`: Binary matrices based on tier requirements.\n        - `\"tier 1\"` to `\"tier 4\"`: Tier-specific binary matrices.\n        - `\"exception\"`: Binary matrix marking cadets eligible through exception rules.\n        - `\"t_count\"`: Array of number of degree tiers per AFSC.\n        - `\"t_proportion\"`: Matrix with expected proportions for each tier per AFSC.\n        - `\"t_eq\"` / `\"t_geq\"` / `\"t_leq\"`: Binary matrices specifying how tier requirements should be interpreted.\n\n    Examples:\n    --------\n    ```python\n    p = gather_degree_tier_qual_matrix(cadets_df, p)\n    ```\n\n    See Also:\n    --------\n    - [`cip_to_qual_tiers`](../../../afccp/reference/data/support/#data.support.cip_to_qual_tiers):\n      Generates tier-based qualification matrix from CIP codes.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Determine if there is already a qualification matrix in the Cadets dataframe, and what \"type\" it is\n    afsc_1, afsc_M = p[\"afscs\"][0], p[\"afscs\"][p[\"M\"] - 1]\n    current_qual_type = \"None\"  # If there is no qualification matrix, we'll have to generate it\n    if cadets_df is not None:\n        if \"qual_\" + afsc_1 in cadets_df:\n            qual = np.array(cadets_df.loc[:, \"qual_\" + afsc_1: \"qual_\" + afsc_M]).astype(str)\n            test_qual = str(qual[0, 0])  # Variable to determine if we need to alter the qualification matrix\n\n            # Determine the type of qual matrix we *currently* have\n            if len(test_qual) == 1:\n                if test_qual in [\"1\", \"0\"]:\n                    current_qual_type = \"Binary\"\n                else:\n                    current_qual_type = \"Relaxed\"\n            else:\n                current_qual_type = \"Tiers\"\n\n    # If the current qualification matrix matches the one we want, then we don't need to do anything\n    generate_qual_matrix = False\n    if p[\"Qual Type\"] != current_qual_type:\n\n        # We don't have a qual matrix at all (We will generate the \"Tiers\" qual matrix!)\n        if current_qual_type == \"None\":\n            generate_qual_matrix = True\n\n        # We have a qual matrix and have specified that we want to keep it the way it is (Don't need to generate it)\n        elif p[\"Qual Type\"] == \"Consistent\":\n            p[\"Qual Type\"] = current_qual_type\n\n        # We have a qual matrix, but want to generate the \"Tiers\" qual matrix\n        elif p[\"Qual Type\"] == \"Tiers\":\n            generate_qual_matrix = True\n\n        else:\n            generate_qual_matrix = True\n            print(\"WARNING. The degree_qual_type parameter '\" + p[\"Qual Type\"] +\n                  \" specified but current qual matrix is of type '\" + current_qual_type +\n                  \"'. We no longer generate that kind of qual matrix. We will generate a 'Tiers' qual matrix.\")\n\n    # If we're going to generate a qual matrix, it'll be a \"Tiers\" matrix\n    if generate_qual_matrix:\n        p[\"Qual Type\"] = \"Tiers\"\n\n        if \"cip1\" in p:\n            if \"cip2\" in p:\n                qual = afccp.data.support.cip_to_qual_tiers(\n                    p[\"afscs\"][:p[\"M\"]], p['cip1'], cip2=p['cip2'])\n            else:\n                qual = afccp.data.support.cip_to_qual_tiers(\n                    p[\"afscs\"][:p[\"M\"]], p['cip1'])\n        else:\n            raise ValueError(\"Error. Need to update the degree tier qualification matrix to include tiers \"\n                             \"('M1' instead of 'M' for example) but don't have CIP codes. Please incorporate this.\")\n\n    # Determine the binary matrices for cadets based on their degree tiers and/or eligibility\n    if p[\"Qual Type\"] == \"Tiers\":\n\n        # NxM matrices with various features\n        p[\"ineligible\"] = (np.core.defchararray.find(qual, \"I\") != -1) * 1\n        p[\"eligible\"] = (p[\"ineligible\"] == 0) * 1\n        for t in [1, 2, 3, 4]:\n            p[\"tier \" + str(t)] = (np.core.defchararray.find(qual, str(t)) != -1) * 1\n        p[\"mandatory\"] = (np.core.defchararray.find(qual, \"M\") != -1) * 1\n        p[\"desired\"] = (np.core.defchararray.find(qual, \"D\") != -1) * 1\n        p[\"permitted\"] = (np.core.defchararray.find(qual, \"P\") != -1) * 1\n\n        # NEW: Exception to degree qualification based on CFM ranks\n        p[\"exception\"] = (np.core.defchararray.find(qual, \"E\") != -1) * 1\n\n        # Error Handling\n        if \"Deg Tiers\" not in p:\n            raise ValueError(\"Error. Degree qualification matrix is 'Tiers' category ('M1' instead of 'M' for example)\"\n                             \" and 'Deg Tier X' columns not found in 'AFSCs' dataframe. Please correct this issue.\")\n\n    elif p[\"Qual Type\"] == \"Relaxed\":\n        p['ineligible'] = (qual == 'I') * 1\n        p['eligible'] = (p['ineligible'] == 0) * 1\n        p['mandatory'] = (qual == 'M') * 1\n        p['desired'] = (qual == 'D') * 1\n        p['permitted'] = (qual == 'P') * 1\n\n        # NEW: Exception to degree qualification based on CFM ranks\n        p['exception'] = (qual == 'E') * 1\n\n    else:  # 'Binary'\n        p['ineligible'] = (qual == 0) * 1\n        p['eligible'] = qual\n\n    # Force string type!\n    p['Deg Tiers'][pd.isnull(p[\"Deg Tiers\"])] = ''\n    p['Deg Tiers'] = p['Deg Tiers'].astype(str)\n\n    # Load in Degree Tier information for each AFSC\n    if p[\"Qual Type\"] == \"Tiers\":\n\n        # Initialize information for AFSC degree tiers\n        p[\"t_count\"] = np.zeros(p['M']).astype(int)\n        p[\"t_proportion\"] = np.zeros([p['M'], 4])\n        p[\"t_leq\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"&lt;\") != -1) * 1\n        p[\"t_geq\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"&gt;\") != -1) * 1\n        p[\"t_eq\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"=\") != -1) * 1\n        p[\"t_mandatory\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"M\") != -1) * 1\n        p[\"t_desired\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"D\") != -1) * 1\n        p[\"t_permitted\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"P\") != -1) * 1\n\n        # Loop through each AFSC\n        for j, afsc in enumerate(p[\"afscs\"][:p['M']]):\n\n            # Loop through each potential degree tier\n            for t in range(4):\n                val = p[\"Deg Tiers\"][j, t]\n\n                # Empty degree tier\n                if val in [\"nan\", \"\"] or pd.isnull(val):\n                    t -= 1\n                    break\n\n                # Degree Tier Proportion\n                p[\"t_proportion\"][j, t] = val.split(\" \")[2]\n\n            # Num tiers\n            p[\"t_count\"][j] = t + 1\n\n    # Save qual matrix and return the instance p\n    p[\"qual\"] = qual\n    return p\n</code></pre>"},{"location":"reference/data/adjustments/#data.adjustments.convert_instance_to_from_scrubbed","title":"<code>convert_instance_to_from_scrubbed(instance, new_letter=None, translation_dict=None, data_name='Unknown')</code>","text":"<p>Convert Between Original and Scrubbed AFSC Names Based on PGL Sorting.</p> <p>This function transforms a problem instance by reordering or restoring AFSC names based on their PGL targets. It is used to anonymize (scrub) AFSCs for publication or experimentation by replacing real AFSC identifiers with generic labels (e.g., \"X1\", \"X2\", ...) while preserving order. If a translation dictionary is provided, it performs the inverse operation\u2014restoring original AFSC names from their scrubbed versions.</p> <p>The function updates all relevant AFSC-indexed matrices, arrays, and value parameters in the instance. It also modifies the solution dictionary (<code>instance.solutions</code>) and preference matrices to maintain consistency.</p>"},{"location":"reference/data/adjustments/#data.adjustments.convert_instance_to_from_scrubbed--parameters","title":"Parameters:","text":"<ul> <li>instance (<code>CadetCareerProblem</code>): The full problem instance containing parameter and solution data.</li> <li>new_letter (str, optional): A single letter (e.g., <code>\"X\"</code>) to use as the prefix for scrubbed AFSC names.   If provided, performs a forward conversion (real \u2192 scrubbed).</li> <li>translation_dict (dict, optional): A mapping from real to scrubbed AFSC names. If provided and   <code>new_letter</code> is None, performs a reverse conversion (scrubbed \u2192 real).</li> <li>data_name (str, optional): A custom label to attach to the instance's <code>data_name</code> attribute.</li> </ul>"},{"location":"reference/data/adjustments/#data.adjustments.convert_instance_to_from_scrubbed--returns","title":"Returns:","text":"<ul> <li>tuple:<ul> <li><code>instance</code> (<code>CadetCareerProblem</code>): The updated instance with renamed AFSCs and adjusted internal data.</li> <li><code>translation_dict</code> (dict): The mapping used for conversion (real \u2192 scrubbed).</li> </ul> </li> </ul>"},{"location":"reference/data/adjustments/#data.adjustments.convert_instance_to_from_scrubbed--examples","title":"Examples:","text":"<pre><code># Forward conversion (scrubbing AFSC names)\nnew_instance, afsc_mapping = convert_instance_to_from_scrubbed(instance, new_letter=\"X\")\n\n# Reverse conversion (restoring AFSC names)\noriginal_instance, _ = convert_instance_to_from_scrubbed(new_instance, translation_dict=afsc_mapping)\n</code></pre> Source code in <code>afccp/data/adjustments.py</code> <pre><code>def convert_instance_to_from_scrubbed(instance, new_letter=None, translation_dict=None, data_name='Unknown'):\n    \"\"\"\n    Convert Between Original and Scrubbed AFSC Names Based on PGL Sorting.\n\n    This function transforms a problem instance by reordering or restoring AFSC names based on their PGL targets.\n    It is used to anonymize (scrub) AFSCs for publication or experimentation by replacing real AFSC identifiers\n    with generic labels (e.g., \"X1\", \"X2\", ...) while preserving order. If a translation dictionary is provided,\n    it performs the inverse operation\u2014restoring original AFSC names from their scrubbed versions.\n\n    The function updates all relevant AFSC-indexed matrices, arrays, and value parameters in the instance.\n    It also modifies the solution dictionary (`instance.solutions`) and preference matrices to maintain consistency.\n\n    Parameters:\n    --------\n    - instance (`CadetCareerProblem`): The full problem instance containing parameter and solution data.\n    - new_letter (str, optional): A single letter (e.g., `\"X\"`) to use as the prefix for scrubbed AFSC names.\n      If provided, performs a *forward* conversion (real \u2192 scrubbed).\n    - translation_dict (dict, optional): A mapping from real to scrubbed AFSC names. If provided and\n      `new_letter` is None, performs a *reverse* conversion (scrubbed \u2192 real).\n    - data_name (str, optional): A custom label to attach to the instance's `data_name` attribute.\n\n    Returns:\n    --------\n    - tuple:\n        - `instance` (`CadetCareerProblem`): The updated instance with renamed AFSCs and adjusted internal data.\n        - `translation_dict` (dict): The mapping used for conversion (real \u2192 scrubbed).\n\n    Examples:\n    --------\n    ```python\n    # Forward conversion (scrubbing AFSC names)\n    new_instance, afsc_mapping = convert_instance_to_from_scrubbed(instance, new_letter=\"X\")\n\n    # Reverse conversion (restoring AFSC names)\n    original_instance, _ = convert_instance_to_from_scrubbed(new_instance, translation_dict=afsc_mapping)\n    ```\n    \"\"\"\n\n    # Load parameters\n    p = copy.deepcopy(instance.parameters)\n\n    # Initialize AFSC information\n    current_afscs_unsorted = p[\"afscs\"][:p[\"M\"]]\n    new_p = copy.deepcopy(p)\n\n    # We're going from original to scrubbed\n    if new_letter is not None:\n        data_name = new_letter\n\n        # Sort current list of AFSCs by PGL\n        t_indices = np.argsort(p[\"pgl\"])[::-1]  # Indices that word sort the list -&gt; used a lot below!\n        current_afscs = copy.deepcopy(current_afscs_unsorted[t_indices])\n\n        # Construct new list of AFSCS\n        new_p['afscs'] = np.array([' ' * 10 for _ in p['J']])\n        for j, afsc in enumerate(current_afscs):\n            new_p['afscs'][j] = new_letter + str(j + 1)\n\n            # Adjust new AFSC by adding \"_U\" or \"_R\" extension if necessary\n            for ext in [\"_R\", \"_U\"]:\n                if ext in afsc:\n                    new_p['afscs'][j] += ext\n                    break\n\n        # Translate AFSCs to the new list\n        translation_dict = {}\n        for afsc in current_afscs_unsorted:\n            j = np.where(current_afscs == afsc)[0][0]\n            translation_dict[afsc] = new_p['afscs'][j]  # Save this AFSC to the translation dictionary\n        new_p[\"afscs\"] = np.hstack((new_p[\"afscs\"], \"*\"))  # Add \"unmatched\" AFSC\n\n    # We're going from scrubbed to original\n    else:\n\n        # Translate AFSCs (Really weird sorting going on...sorry)\n        new_p[\"afscs\"] = np.array(list(translation_dict.keys()))\n        new_p[\"afscs\"] = np.hstack((new_p[\"afscs\"], \"*\"))  # Add \"unmatched\" AFSC\n        flipped_translation_dict = {translation_dict[afsc]: afsc for afsc in translation_dict}\n        real_order_scrubbed_afscs = np.array(list(flipped_translation_dict.keys()))\n        scrubbed_order_indices = np.array(\n            [np.where(real_order_scrubbed_afscs==afsc)[0][0] for afsc in current_afscs_unsorted])\n        scrubbed_order_real_afscs = new_p['afscs'][scrubbed_order_indices]\n        current_afscs = real_order_scrubbed_afscs\n\n        # Get sorted indices\n        t_indices = np.array([np.where(scrubbed_order_real_afscs==afsc)[0][0] for afsc in new_p[\"afscs\"][:p[\"M\"]]])\n\n    # Loop through each key in the parameter dictionary to translate it\n    for key in p:\n\n        # If it's a one dimensional array of length M, we translate it accordingly\n        if np.shape(p[key]) == (p[\"M\"], ) and \"^\" not in key:  # Sets/Subsets will be adjusted later\n            new_p[key] = p[key][t_indices]\n\n        # If it's a two-dimensional array of shape Mx4, we translate it accordingly\n        elif np.shape(p[key]) == (p[\"M\"], 4):\n            new_p[key] = p[key][t_indices, :]\n\n        # If it's a two-dimensional array of shape (NxM), we translate it accordingly\n        elif np.shape(p[key]) == (p[\"N\"], p[\"M\"]) and key not in ['c_preferences', 'c_utilities']:\n            new_p[key] = p[key][:, t_indices]\n\n        # If it's a two-dimensional array of shape (NxM+1), we translate it accordingly (leave unmatched AFSC alone)\n        elif np.shape(p[key]) == (p[\"N\"], p[\"M\"] + 1):\n            new_p[key] = copy.deepcopy(p[key])\n            new_p[key][:, :p['M']] = p[key][:, t_indices]\n\n    # Get assigned AFSC vector\n    for i, real_afsc in enumerate(p[\"assigned\"]):\n        if real_afsc in current_afscs:\n            j = np.where(current_afscs == real_afsc)[0][0]\n            new_p[\"assigned\"][i] = new_p[\"afscs\"][j]\n\n    # Set additions, and add to the instance\n    instance.parameters = parameter_sets_additions(new_p)\n\n    # Translate value parameters\n    if instance.vp_dict is not None:\n        new_vp_dict = {}\n        for vp_name in instance.vp_dict:\n            vp = copy.deepcopy(instance.vp_dict[vp_name])\n            new_vp = copy.deepcopy(vp)\n\n            for key in vp:\n\n                # If it's a one dimensional array of length M, we translate it accordingly\n                if np.shape(vp[key]) == (p[\"M\"],):\n                    new_vp[key] = vp[key][t_indices]\n\n                # If it's a two-dimensional array of shape (NxM), we translate it accordingly\n                elif np.shape(vp[key]) == (p[\"N\"], p[\"M\"]):\n                    new_vp[key] = vp[key][:, t_indices]\n\n                # If it's a two-dimensional array of shape (MxO), we translate it accordingly\n                elif np.shape(vp[key]) == (vp[\"M\"], vp[\"O\"]) and key not in [\"a\", \"f^hat\"]:\n                    new_vp[key] = vp[key][t_indices, :]\n\n            for j, old_j in enumerate(t_indices):\n                for k in vp[\"K\"]:\n                    for key in [\"a\", \"f^hat\"]:\n                        new_vp[key][j][k] = vp[key][old_j][k]\n\n            # Set value parameters to dict\n            new_vp_dict[vp_name] = new_vp\n\n        # Set it to the instance\n        instance.vp_dict = new_vp_dict\n\n        # Loop through each set of value parameters again\n        for vp_name in instance.vp_dict:\n\n            # Set additions\n            instance.vp_dict[vp_name] = \\\n                afccp.data.values.value_parameters_sets_additions(instance.parameters, instance.vp_dict[vp_name])\n\n    else:\n        instance.vp_dict = None\n\n    # Translate solutions\n    if instance.solutions is not None:\n        new_solutions_dict = {}\n\n        # Loop through each solution\n        for solution_name in instance.solutions:\n            real_solution = copy.deepcopy(instance.solutions[solution_name])\n            new_solutions_dict[solution_name] = copy.deepcopy(real_solution)\n\n            # Loop through each assigned AFSC for the cadets\n            for i, j in enumerate(real_solution['j_array']):\n                if j != p[\"M\"]:\n                    real_afsc = p[\"afscs\"][j]\n                    j = np.where(current_afscs == real_afsc)[0][0]\n                    new_solutions_dict[solution_name]['j_array'][i] = j\n\n        # Save solutions dictionary\n        instance.solutions = new_solutions_dict\n\n    else:\n        instance.solutions = None\n\n    # Convert \"c_preferences\" array\n    if \"c_preferences\" in p:\n        for i in p[\"I\"]:\n            for pref in range(p[\"P\"]):\n                real_afsc = p[\"c_preferences\"][i, pref]\n                if real_afsc in current_afscs:\n                    j = np.where(current_afscs == real_afsc)[0][0]\n                    new_p[\"c_preferences\"][i, pref] = new_p[\"afscs\"][j]\n\n    # Instance Attributes\n    instance.data_name, instance.data_version = data_name, \"Default\"\n    instance.import_paths, instance.export_paths = None, None\n\n    return instance, translation_dict\n</code></pre>"},{"location":"reference/data/generation/","title":"Generation","text":""},{"location":"reference/data/generation/#data.generation","title":"<code>data.generation</code>","text":""},{"location":"reference/data/generation/#data.generation.generate_random_instance","title":"<code>generate_random_instance(N=1600, M=32, P=6, S=6, generate_only_nrl=False, generate_extra=False)</code>","text":"<p>This procedure takes in the specified parameters (defined below) and then simulates new random \"fixed\" cadet/AFSC input parameters. These parameters are then returned and can be used to solve the VFT model.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>number of cadets</p> <code>1600</code> <code>M</code> <p>number of AFSCs</p> <code>32</code> <code>P</code> <p>number of preferences allowed</p> <code>6</code> <code>S</code> <p>number of Bases</p> <code>6</code> <code>generate_only_nrl</code> <p>Only generate NRL AFSCs (default to False)</p> <code>False</code> <code>generate_extra</code> <p>Whether to generate extra components (bases/IST). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>model fixed parameters</p> Source code in <code>afccp/data/generation/basic.py</code> <pre><code>def generate_random_instance(N=1600, M=32, P=6, S=6, generate_only_nrl=False, generate_extra=False):\n    \"\"\"\n    This procedure takes in the specified parameters (defined below) and then simulates new random \"fixed\" cadet/AFSC\n    input parameters. These parameters are then returned and can be used to solve the VFT model.\n    :param N: number of cadets\n    :param M: number of AFSCs\n    :param P: number of preferences allowed\n    :param S: number of Bases\n    :param generate_only_nrl: Only generate NRL AFSCs (default to False)\n    :param generate_extra: Whether to generate extra components (bases/IST). Defaults to False.\n    :return: model fixed parameters\n    \"\"\"\n\n    # Initialize parameter dictionary\n    # noinspection PyDictCreation\n    p = {'N': N, 'P': P, 'M': M, 'num_util': P, 'cadets': np.arange(N),\n         'usafa': np.random.choice([0, 1], size=N, p=[2 / 3, 1 / 3]), 'merit': np.random.rand(N)}\n\n    # Generate various features of the cadets\n    p['merit_all'] = p['merit']\n    p['assigned'] = np.array(['' for _ in range(N)])\n    p['soc'] = np.array(['USAFA' for _ in range(p['N'])])\n    p['soc'][np.where(p['usafa'] == 0)[0]] = 'ROTC'\n\n    # Calculate quotas for each AFSC\n    p['pgl'], p['usafa_quota'], p['rotc_quota'] = np.zeros(M), np.zeros(M), np.zeros(M)\n    p['quota_min'], p['quota_max'] = np.zeros(M), np.zeros(M)\n    p['quota_e'], p['quota_d'] = np.zeros(M), np.zeros(M)\n    for j in range(M):\n\n        # Get PGL target\n        p['pgl'][j] = max(10, np.random.normal(1000 / M, 100))\n\n    # Scale PGL and force integer values and minimum of 1\n    p['pgl'] = np.around((p['pgl'] / np.sum(p['pgl'])) * N * 0.8)\n    indices = np.where(p['pgl'] == 0)[0]\n    p['pgl'][indices] = 1\n\n    # Sort PGL by size\n    p['pgl'] = np.sort(p['pgl'])[::-1]\n\n    # USAFA/ROTC Quotas\n    p['usafa_quota'] = np.around(np.random.rand(M) * 0.3 + 0.1 * p['pgl'])\n    p['rotc_quota'] = p['pgl'] - p['usafa_quota']\n\n    # Min/Max\n    p['quota_min'], p['quota_max'] = p['pgl'], np.around(p['pgl'] * (1 + np.random.rand(M) * 0.9))\n\n    # Target is a random integer between the minimum and maximum targets\n    target = np.around(p['quota_min'] + np.random.rand(M) * (p['quota_max'] - p['quota_min']))\n    p['quota_e'], p['quota_d'] = target, target\n\n    # Generate AFSCs\n    p['afscs'] = np.array(['R' + str(j + 1) for j in range(M)])\n\n    # Determine what \"accessions group\" each AFSC is in\n    if generate_only_nrl:\n        p['acc_grp'] = np.array([\"NRL\" for _ in range(M)])\n    else:\n\n        # If there are 3 or more AFSCs, we want all three accessions groups represented\n        if M &gt;= 3:\n            invalid = True\n            while invalid:\n\n                # If we have 6 or fewer, limit USSF to just one AFSC\n                if M &lt;= 6:\n                    p['acc_grp'] = ['USSF']\n                    for _ in range(M - 1):\n                        p['acc_grp'].append(np.random.choice(['NRL', 'Rated']))\n                else:\n                    p['acc_grp'] = [np.random.choice(['NRL', 'Rated', 'USSF']) for _ in range(M)]\n\n                # Make sure we have at least one AFSC from each accession's group\n                invalid = False  # \"Innocent until proven guilty\"\n                for grp in ['NRL', 'Rated', 'USSF']:\n                    if grp not in p['acc_grp']:\n                        invalid = True\n                        break\n\n                # If we have 4 or more AFSCs, make sure we have at least two Rated\n                if M &gt;= 4:\n                    if p['acc_grp'].count('Rated') &lt; 2:\n                        invalid = True\n            p['acc_grp'] = np.array(p['acc_grp'])  # Convert to numpy array\n\n        # If we only have one or two AFSCs, they'll all be NRL\n        else:\n            p['acc_grp'] = np.array([\"NRL\" for _ in range(M)])\n\n    # Add an \"*\" to the list of AFSCs to be considered the \"Unmatched AFSC\"\n    p[\"afscs\"] = np.hstack((p[\"afscs\"], \"*\"))\n\n    # Add degree tier qualifications to the set of parameters\n    def generate_degree_tier_qualifications():\n        \"\"\"\n        I made this nested function, so I could have a designated section to generate degree qualifications and such\n        \"\"\"\n\n        # Determine degree tiers and qualification information\n        p['qual'] = np.array([['P1' for _ in range(M)] for _ in range(N)])\n        p['Deg Tiers'] = np.array([[' ' * 10 for _ in range(4)] for _ in range(M)])\n        for j in range(M):\n\n            if p['acc_grp'][j] == 'Rated':  # All Degrees eligible for Rated\n                p['qual'][:, j] = np.array(['P1' for _ in range(N)])\n                p['Deg Tiers'][j, :] = ['P = 1', 'I = 0', '', '']\n\n                # Pick 20% of the cadets at random to be ineligible for this Rated AFSC\n                indices = random.sample(list(np.arange(N)), k=int(0.2 * N))\n                p['qual'][indices, j] = 'I2'\n            else:\n                # Determine what tiers to use on this AFSC\n                if N &lt; 100:\n                    random_number = np.random.rand()\n                    if random_number &lt; 0.2:\n                        tiers = ['M1', 'I2']\n                        p['Deg Tiers'][j, :] = ['M = 1', 'I = 0', '', '']\n                    elif 0.2 &lt; random_number &lt; 0.4:\n                        tiers = ['D1', 'P2']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['D &gt; ' + str(target_num), 'P &lt; ' + str(1 - target_num), '', '']\n                    elif 0.4 &lt; random_number &lt; 0.6:\n                        tiers = ['P1']\n                        p['Deg Tiers'][j, :] = ['P = 1', '', '', '']\n                    else:\n                        tiers = ['M1', 'P2']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num), 'P &lt; ' + str(1 - target_num), '', '']\n                else:\n                    random_number = np.random.rand()\n                    if random_number &lt; 0.1:\n                        tiers = ['M1', 'I2']\n                        p['Deg Tiers'][j, :] = ['M = 1', 'I = 0', '', '']\n                    elif 0.1 &lt; random_number &lt; 0.2:\n                        tiers = ['D1', 'P2']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['D &gt; ' + str(target_num), 'P &lt; ' + str(1 - target_num), '', '']\n                    elif 0.2 &lt; random_number &lt; 0.3:\n                        tiers = ['P1']\n                        p['Deg Tiers'][j, :] = ['P = 1', '', '', '']\n                    elif 0.3 &lt; random_number &lt; 0.4:\n                        tiers = ['M1', 'P2']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num), 'P &lt; ' + str(1 - target_num), '', '']\n                    elif 0.4 &lt; random_number &lt; 0.5:\n                        tiers = ['M1', 'D2', 'P3']\n                        target_num_1 = round(np.random.rand() * 0.7, 2)\n                        target_num_2 = round(np.random.rand() * (1 - target_num_1) * 0.8, 2)\n                        target_num_3 = round(1 - target_num_1 - target_num_2, 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num_1), 'D &gt; ' + str(target_num_2),\n                                                'P &lt; ' + str(target_num_3), '']\n                    elif 0.5 &lt; random_number &lt; 0.6:\n                        tiers = ['D1', 'D2', 'P3']\n                        target_num_1 = round(np.random.rand() * 0.7, 2)\n                        target_num_2 = round(np.random.rand() * (1 - target_num_1) * 0.8, 2)\n                        target_num_3 = round(1 - target_num_1 - target_num_2, 2)\n                        p['Deg Tiers'][j, :] = ['D &gt; ' + str(target_num_1), 'D &gt; ' + str(target_num_2),\n                                                'P &lt; ' + str(target_num_3), '']\n                    elif 0.6 &lt; random_number &lt; 0.7:\n                        tiers = ['M1', 'D2', 'I3']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num), 'D &lt; ' + str(1 - target_num), 'I = 0', '']\n                    elif 0.7 &lt; random_number &lt; 0.8:\n                        tiers = ['M1', 'P2', 'I3']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num), 'P &lt; ' + str(1 - target_num), 'I = 0', '']\n                    else:\n                        tiers = ['M1', 'D2', 'P3', 'I4']\n                        target_num_1 = round(np.random.rand() * 0.7, 2)\n                        target_num_2 = round(np.random.rand() * (1 - target_num_1) * 0.8, 2)\n                        target_num_3 = round(1 - target_num_1 - target_num_2, 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num_1), 'D &gt; ' + str(target_num_2),\n                                                'P &lt; ' + str(target_num_3), 'I = 0']\n\n                # Generate the tiers for the cadets\n                c_tiers = np.random.randint(0, len(tiers), N)\n                p['qual'][:, j] = np.array([tiers[c_tiers[i]] for i in range(N)])\n\n        # NxM qual matrices with various features\n        p[\"ineligible\"] = (np.core.defchararray.find(p['qual'], \"I\") != -1) * 1\n        p[\"eligible\"] = (p[\"ineligible\"] == 0) * 1\n        for t in [1, 2, 3, 4]:\n            p[\"tier \" + str(t)] = (np.core.defchararray.find(p['qual'], str(t)) != -1) * 1\n        p[\"mandatory\"] = (np.core.defchararray.find(p['qual'], \"M\") != -1) * 1\n        p[\"desired\"] = (np.core.defchararray.find(p['qual'], \"D\") != -1) * 1\n        p[\"permitted\"] = (np.core.defchararray.find(p['qual'], \"P\") != -1) * 1\n\n        # NEW: Exception to degree qualification based on CFM ranks\n        p[\"exception\"] = (np.core.defchararray.find(p['qual'], \"E\") != -1) * 1\n\n        # Initialize information for AFSC degree tiers\n        p[\"t_count\"] = np.zeros(p['M']).astype(int)\n        p[\"t_proportion\"] = np.zeros([p['M'], 4])\n        p[\"t_leq\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"&lt;\") != -1) * 1\n        p[\"t_geq\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"&gt;\") != -1) * 1\n        p[\"t_eq\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"=\") != -1) * 1\n        p[\"t_mandatory\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"M\") != -1) * 1\n        p[\"t_desired\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"D\") != -1) * 1\n        p[\"t_permitted\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"P\") != -1) * 1\n\n        # Loop through each AFSC\n        for j, afsc in enumerate(p[\"afscs\"][:p['M']]):\n\n            # Loop through each potential degree tier\n            for t in range(4):\n                val = p[\"Deg Tiers\"][j, t]\n\n                # Empty degree tier\n                if 'M' not in val and 'D' not in val and 'P' not in val and 'I' not in val:\n                # if val in [\"nan\", \"\", ''] or pd.isnull(val):\n                    t -= 1\n                    break\n\n                # Degree Tier Proportion\n                p[\"t_proportion\"][j, t] = val.split(\" \")[2]\n\n            # Num tiers\n            p[\"t_count\"][j] = t + 1\n\n        return p   # Return updated parameters\n    p = generate_degree_tier_qualifications()\n\n    # Cadet preferences\n    utility = np.random.rand(N, M)  # random utility matrix\n    max_util = np.max(utility, axis=1)\n    p['utility'] = np.around(utility / np.array([[max_util[i]] for i in range(N)]), 2)\n    p['c_preferences'], p['c_utilities'] = afccp.data.preferences.get_utility_preferences(p)\n    p['c_preferences'] = p['c_preferences'][:, :P]\n    p['c_utilities'] = p['c_utilities'][:, :P]\n\n    # Get cadet preferences\n    p[\"c_pref_matrix\"] = np.zeros([p[\"N\"], p[\"M\"]]).astype(int)\n    for i in range(p['N']):\n\n        # Sort the utilities to get the preference list\n        utilities = p[\"utility\"][i, :p[\"M\"]]\n        sorted_indices = np.argsort(utilities)[::-1]\n        preferences = np.argsort(\n            sorted_indices) + 1  # Add 1 to change from python index (at 0) to rank (start at 1)\n        p[\"c_pref_matrix\"][i, :] = preferences\n\n    # If we want to generate extra components to match with, we do so here\n    if generate_extra:\n        p['S'] = S\n        p = generate_extra_components(p)\n\n    # Update set of parameters\n    p = afccp.data.adjustments.parameter_sets_additions(p)\n\n    return p  # Return updated parameters\n</code></pre>"},{"location":"reference/data/generation/#data.generation.generate_random_value_parameters","title":"<code>generate_random_value_parameters(parameters, num_breakpoints=24)</code>","text":"<p>Generate Random Value Parameters for a Cadet-AFSC Assignment Problem.</p> <p>This function constructs a randomized set of value-focused thinking (VFT) parameters for a given cadet-AFSC matching instance. These include AFSC weights, cadet weights, value function definitions, and constraint structures across defined objectives. It supports a mix of manually assigned logic and randomized components and can be used to simulate plausible input conditions for testing the assignment algorithm.</p>"},{"location":"reference/data/generation/#data.generation.generate_random_value_parameters--parameters","title":"Parameters","text":"<p>parameters : dict     The problem instance parameters, including cadet/AFSC info, merit scores, eligibility, quotas, and utilities. num_breakpoints : int, optional     Number of breakpoints to use in piecewise linear value functions, by default 24.</p>"},{"location":"reference/data/generation/#data.generation.generate_random_value_parameters--returns","title":"Returns","text":"<p>dict     A dictionary <code>vp</code> containing generated value parameters, including objectives, weights, constraints,     value functions, and breakpoints.</p>"},{"location":"reference/data/generation/#data.generation.generate_random_value_parameters--examples","title":"Examples","text":"<pre><code>vp = generate_random_value_parameters(parameters, num_breakpoints=16)\n</code></pre>"},{"location":"reference/data/generation/#data.generation.generate_random_value_parameters--see-also","title":"See Also","text":"<ul> <li><code>generate_afocd_value_parameters</code>:   Adds tiered AFOCD objectives and fills in default VFT structure for a given instance.</li> <li><code>create_segment_dict_from_string</code>:   Parses string definitions into nonlinear segment dictionaries for value functions.</li> <li><code>value_function_builder</code>:   Linearizes nonlinear value functions using a fixed number of breakpoints.</li> <li><code>cadet_weight_function</code>:   Creates weights across cadets based on merit scores and function type.</li> <li><code>afsc_weight_function</code>:   Creates weights across AFSCs based on projected gains/losses and selected function type.</li> </ul> Source code in <code>afccp/data/generation/basic.py</code> <pre><code>def generate_random_value_parameters(parameters, num_breakpoints=24):\n    \"\"\"\n    Generate Random Value Parameters for a Cadet-AFSC Assignment Problem.\n\n    This function constructs a randomized set of value-focused thinking (VFT) parameters for a given cadet-AFSC\n    matching instance. These include AFSC weights, cadet weights, value function definitions, and constraint structures\n    across defined objectives. It supports a mix of manually assigned logic and randomized components and can be\n    used to simulate plausible input conditions for testing the assignment algorithm.\n\n    Parameters\n    ----------\n    parameters : dict\n        The problem instance parameters, including cadet/AFSC info, merit scores, eligibility, quotas, and utilities.\n    num_breakpoints : int, optional\n        Number of breakpoints to use in piecewise linear value functions, by default 24.\n\n    Returns\n    -------\n    dict\n        A dictionary `vp` containing generated value parameters, including objectives, weights, constraints,\n        value functions, and breakpoints.\n\n    Examples\n    --------\n    ```python\n    vp = generate_random_value_parameters(parameters, num_breakpoints=16)\n    ```\n\n    See Also\n    --------\n    - [`generate_afocd_value_parameters`](../../../afccp/reference/data/values/#data.values.generate_afocd_value_parameters):\n      Adds tiered AFOCD objectives and fills in default VFT structure for a given instance.\n    - [`create_segment_dict_from_string`](../../../afccp/reference/data/values/#data.values.create_segment_dict_from_string):\n      Parses string definitions into nonlinear segment dictionaries for value functions.\n    - [`value_function_builder`](../../../afccp/reference/data/values/#data.values.value_function_builder):\n      Linearizes nonlinear value functions using a fixed number of breakpoints.\n    - [`cadet_weight_function`](../../../afccp/reference/data/values/#data.values.cadet_weight_function):\n      Creates weights across cadets based on merit scores and function type.\n    - [`afsc_weight_function`](../../../afccp/reference/data/values/#data.values.afsc_weight_function):\n      Creates weights across AFSCs based on projected gains/losses and selected function type.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Objective to parameters lookup dictionary (if the parameter is in \"p\", we include the objective)\n    objective_lookups = {'Norm Score': 'a_pref_matrix', 'Merit': 'merit', 'USAFA Proportion': 'usafa',\n                         'Combined Quota': 'quota_d', 'USAFA Quota': 'usafa_quota', 'ROTC Quota': 'rotc_quota',\n                         'Utility': 'utility', 'Mandatory': 'mandatory',\n                         'Desired': 'desired', 'Permitted': 'permitted'}\n    for t in [\"1\", \"2\", \"3\", \"4\"]:  # Add in AFOCD Degree tiers\n        objective_lookups[\"Tier \" + t] = \"tier \" + t\n\n    # Add the AFSC objectives that are included in this instance (check corresponding parameters using dict above)\n    objectives = np.array([objective for objective in objective_lookups if objective_lookups[objective] in p])\n\n    # Initialize set of value parameters\n    vp = {'objectives': objectives, 'cadets_overall_weight': np.random.rand(), 'O': len(objectives),\n          'K': np.arange(len(objectives)), 'num_breakpoints': num_breakpoints, 'cadets_overall_value_min': 0,\n          'afscs_overall_value_min': 0}\n    vp['afscs_overall_weight'] = 1- vp['cadets_overall_weight']\n\n    # Generate AFSC and cadet weights\n    weight_functions = ['Linear', 'Direct', 'Curve_1', 'Curve_2', 'Equal']\n    vp['cadet_weight_function'] = np.random.choice(weight_functions)\n    vp['afsc_weight_function'] = np.random.choice(weight_functions)\n    vp['cadet_weight'] = afccp.data.values.cadet_weight_function(p['merit_all'], func= vp['cadet_weight_function'])\n    vp['afsc_weight'] = afccp.data.values.afsc_weight_function(p['pgl'], func = vp['afsc_weight_function'])\n\n    # Stuff that doesn't matter here\n    vp['cadet_value_min'], vp['afsc_value_min'] = np.zeros(p['N']), np.zeros(p['N'])\n    vp['USAFA-Constrained AFSCs'], vp['Cadets Top 3 Constraint'] = '', ''\n    vp['USSF OM'] = False\n\n    # Initialize arrays\n    vp['objective_weight'], vp['objective_target'] = np.zeros([p['M'], vp['O']]), np.zeros([p['M'], vp['O']])\n    vp['constraint_type'] = np.zeros([p['M'], vp['O']])\n    vp['objective_value_min'] = np.array([[' ' * 20 for _ in vp['K']] for _ in p['J']])\n    vp['value_functions'] = np.array([[' ' * 200 for _ in vp['K']] for _ in p['J']])\n\n    # Initialize breakpoints\n    vp['a'] = [[[] for _ in vp['K']] for _ in p[\"J\"]]\n    vp['f^hat'] = [[[] for _ in vp['K']] for _ in p[\"J\"]]\n\n    # Initialize objective set\n    vp['K^A'] = {}\n\n    # Get AFOCD Tier objectives\n    vp = afccp.data.values.generate_afocd_value_parameters(p, vp)\n    vp['constraint_type'] = np.zeros([p['M'], vp['O']])  # Turn off all the constraints again\n\n    # Loop through all AFSCs\n    for j in p['J']:\n\n        # Loop through all AFSC objectives\n        for k, objective in enumerate(vp['objectives']):\n\n            maximum, minimum, actual = None, None, None\n            if objective == 'Norm Score':\n                vp['objective_weight'][j, k] = (np.random.rand() * 0.2 + 0.3) * 100  # Scale up to 100\n                vp['value_functions'][j, k] = 'Min Increasing|0.3'\n                vp['objective_target'][j, k] = 1\n\n            if objective == 'Merit':\n                vp['objective_weight'][j, k] = (np.random.rand() * 0.4 + 0.05) * 100\n                vp['value_functions'][j, k] = 'Min Increasing|-0.3'\n                vp['objective_target'][j, k] = p['sum_merit'] / p['N']\n                actual = np.mean(p['merit'][p['I^E'][j]])\n\n            elif objective == 'USAFA Proportion':\n                vp['objective_weight'][j, k] = (np.random.rand() * 0.3 + 0.05) * 100\n                vp['value_functions'][j, k] = 'Balance|0.15, 0.15, 0.1, 0.08, 0.08, 0.1, 0.6'\n                vp['objective_target'][j, k] = p['usafa_proportion']\n                actual = len(p['I^D'][objective][j]) / len(p['I^E'][j])\n\n            elif objective == 'Combined Quota':\n                vp['objective_weight'][j, k] = (np.random.rand() * 0.8 + 0.2) * 100\n                vp['value_functions'][j, k] = 'Quota_Normal|0.2, 0.25, 0.2'\n                vp['objective_target'][j, k] = p['quota_d'][j]\n\n                # Get bounds and turn on this constraint\n                minimum, maximum = p['quota_min'][j], p['quota_max'][j]\n                vp['objective_value_min'][j, k] = str(int(minimum)) + \", \" + str(int(maximum))\n                vp['constraint_type'][j, k] = 2\n\n            elif objective == 'USAFA Quota':\n                vp['objective_weight'][j, k] = 0\n                vp['value_functions'][j, k] = 'Min Increasing|0.3'\n                vp['objective_target'][j, k] = p['usafa_quota'][j]\n\n                # Bounds on this constraint (but leave it off)\n                vp['objective_value_min'][j, k] = str(int(p['usafa_quota'][j])) + \", \" + \\\n                                                  str(int(p['quota_max'][j]))\n\n            elif objective == 'ROTC Quota':\n                vp['objective_weight'][j, k] = 0\n                vp['value_functions'][j, k] = 'Min Increasing|0.3'\n                vp['objective_target'][j, k] = p['rotc_quota'][j]\n\n                # Bounds on this constraint (but leave it off)\n                vp['objective_value_min'][j, k] = str(int(p['rotc_quota'][j])) + \", \" + \\\n                                                  str(int(p['quota_max'][j]))\n\n            # If we care about this objective, we load in its value function breakpoints\n            if vp['objective_weight'][j, k] != 0:\n\n                # Create the non-linear piecewise exponential segment dictionary\n                segment_dict = afccp.data.values.create_segment_dict_from_string(\n                    vp['value_functions'][j, k], vp['objective_target'][j, k],\n                    minimum=minimum, maximum=maximum, actual=actual)\n\n                # Linearize the non-linear function using the specified number of breakpoints\n                vp['a'][j][k], vp['f^hat'][j][k] = afccp.data.values.value_function_builder(\n                    segment_dict, num_breakpoints=num_breakpoints)\n\n        # Scale the objective weights for this AFSC, so they sum to 1\n        vp['objective_weight'][j] = vp['objective_weight'][j] / sum(vp['objective_weight'][j])\n        vp['K^A'][j] = np.where(vp['objective_weight'][j] != 0)[0]\n\n    return vp\n</code></pre>"},{"location":"reference/data/generation/#data.generation.generate_extra_components","title":"<code>generate_extra_components(parameters)</code>","text":"<p>If we generate extra components (such as bases and IST) for the CadetCareerProblem instance</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <p>instance parameters</p> required <p>Returns:</p> Type Description <p>updated parameters</p> Source code in <code>afccp/data/generation/basic.py</code> <pre><code>def generate_extra_components(parameters):\n    \"\"\"\n    If we generate extra components (such as bases and IST) for the CadetCareerProblem instance\n    :param parameters: instance parameters\n    :return: updated parameters\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Get list of ordered letters (based on Excel column names)\n    alphabet = list(string.ascii_uppercase)\n    excel_columns = copy.deepcopy(alphabet)\n    for letter in alphabet:\n        for letter_2 in alphabet:\n            excel_columns.append(letter + letter_2)\n\n    # Determine which AFSCs we assign bases for\n    p['afsc_assign_base'] = np.zeros(p['M']).astype(int)\n    for j in range(p['M']):\n        if p['acc_grp'][j] != \"Rated\" and np.random.rand() &gt; 0.3:\n            p['afsc_assign_base'][j] = 1\n\n    # Name the bases according to the Excel columns (just a method of generating unique ordered letters)\n    p['bases'] = np.array([\"Base \" + excel_columns[b] for b in range(p['S'])])\n\n    # Get capacities for each AFSC at each base\n    p['base_min'] = np.zeros((p['S'], p['M'])).astype(int)\n    p['base_max'] = np.zeros((p['S'], p['M'])).astype(int)\n    afscs_with_base_assignments = np.where(p['afsc_assign_base'])[0]\n    for j in afscs_with_base_assignments:\n        total_max = p['pgl'][j] * 1.5\n        base_max = np.array([np.random.rand() for _ in range(p['S'])])\n        base_max = (base_max / np.sum(base_max)) * total_max\n        p['base_max'][:, j] = base_max.astype(int)\n        p['base_min'][:, j] = (base_max * 0.4).astype(int)\n\n    # Generate random cadet preferences for bases\n    bases = copy.deepcopy(p['bases'])\n    p['base_preferences'] = {}\n    p['b_pref_matrix'] = np.zeros((p['N'], p['S'])).astype(int)\n    p['base_utility'] = np.zeros((p['N'], p['S']))\n    for i in range(p['N']):\n        random.shuffle(bases)\n        num_base_pref = np.random.choice(np.arange(2, p['S'] + 1))\n        p['base_preferences'][i] = np.array([np.where(p['bases'] == base)[0][0] for base in bases[:num_base_pref]])\n\n        # Convert to base preference matrix\n        p['b_pref_matrix'][i, p['base_preferences'][i]] = np.arange(1, len(p['base_preferences'][i]) + 1)\n\n        utilities = np.around(np.random.rand(num_base_pref), 2)\n        p['base_utility'][i, p['base_preferences'][i]] = np.sort(utilities)[::-1]\n        p['base_utility'][i, p['base_preferences'][i][0]] = 1.0  # First choice is always utility of 1!\n\n    # Get the baseline starting date (January 1st of the year we're classifying)\n    next_year = datetime.datetime.now().year + 1\n    p['baseline_date'] = datetime.date(next_year, 1, 1)\n\n    # Generate training preferences for each cadet\n    p['training_preferences'] = np.array(\n        [random.choices(['Early', 'Late'], weights=[0.9, 0.1])[0] for _ in range(p['N'])])\n\n    # Generate base/training \"thresholds\" for when these preferences kick in (based on preferences for AFSCs)\n    p['training_threshold'] = np.array([np.random.choice(np.arange(p['M'] + 1)) for _ in range(p['N'])])\n    p['base_threshold'] = np.array([np.random.choice(np.arange(p['M'] + 1)) for _ in range(p['N'])])\n\n    # Generate weights for AFSCs, bases, and courses\n    p['weight_afsc'], p['weight_base'], p['weight_course'] = np.zeros(p['N']), np.zeros(p['N']), np.zeros(p['N'])\n    for i in range(p['N']):\n\n        # Force some percentage of cadets to make their threshold the last possible AFSC (this means these don't matter)\n        if np.random.rand() &gt; 0.8:\n            p['base_threshold'][i] = p['M']\n        if np.random.rand() &gt; 0.7:\n            p['training_threshold'][i] = p['M']\n\n        # Generate weights for bases, training (courses), and AFSCs\n        if p['base_threshold'][i] == p['M']:\n            w_b = 0\n        else:\n            w_b = np.random.triangular(0, 50, 100)\n        if p['training_threshold'][i] == p['M']:\n            w_c = 0\n        else:\n            w_c = np.random.triangular(0, 20, 100)\n        w_a = np.random.triangular(0, 90, 100)\n\n        # Scale weights so that they sum to one and load into arrays\n        p['weight_afsc'][i] = w_a / (w_a + w_b + w_c)\n        p['weight_base'][i] = w_b / (w_a + w_b + w_c)\n        p['weight_course'][i] = w_c / (w_a + w_b + w_c)\n\n    # Generate training start dates for each cadet\n    p['training_start'] = []\n    for i in range(p['N']):\n\n        # If this cadet is a USAFA cadet\n        if p['usafa'][i]:\n\n            # Make it May 28th of this year\n            p['training_start'].append(datetime.date(next_year, 5, 28))\n\n        # If it's an ROTC cadet, we sample from two different distributions (on-time and late grads)\n        else:\n\n            # 80% should be in spring\n            if np.random.rand() &lt; 0.8:\n                dt = datetime.date(next_year, 4, 15) + datetime.timedelta(int(np.random.triangular(0, 30, 60)))\n                p['training_start'].append(dt)\n\n            # 20% should be after\n            else:\n                dt = datetime.date(next_year, 6, 1) + datetime.timedelta(int(np.random.triangular(0, 30*5, 30*6)))\n                p['training_start'].append(dt)\n    p['training_start'] = np.array(p['training_start'])\n\n    # Generate training courses for each AFSC\n    p['courses'], p['course_start'], p['course_min'], p['course_max'] = {}, {}, {}, {}\n    p['course_count'] = np.zeros(p['M'])\n    for j in range(p['M']):\n\n        # Determine total number of training slots to divide up\n        total_max = p['pgl'][j] * 1.5\n\n        # Determine number of courses to generate\n        if total_max &lt;= 3:\n            T = 1\n        elif total_max &lt;= 10:\n            T = np.random.choice([1, 2])\n        elif total_max &lt; 25:\n            T = np.random.choice([2, 3])\n        elif total_max &lt; 100:\n            T = np.random.choice([3, 4, 5])\n        else:\n            T = np.random.choice([4, 5, 6, 7, 8, 9])\n\n        # Course minimums and maximums\n        random_nums = np.random.rand(T)\n        p['course_max'][j] = np.around(total_max * (random_nums / np.sum(random_nums))).astype(int)\n        p['course_min'][j] = np.zeros(T).astype(int)\n\n        # Generate course specific information\n        p['courses'][j], p['course_start'][j] = [], []\n        current_date = p['baseline_date'] + datetime.timedelta(int(np.random.triangular(30*5, 30*9, 30*11)))\n        for _ in range(T):\n\n            # Course names (random strings of letters)\n            num_letters = random.choice(np.arange(4, 10))\n            p['courses'][j].append(''.join(random.choices(alphabet, k=num_letters)))\n\n            # Course start date\n            p['course_start'][j].append(current_date)\n\n            # Get next course start date\n            current_date += datetime.timedelta(int(np.random.triangular(30, 30*4, 30*6)))\n\n        # Convert to numpy arrays\n        for param in ['courses', 'course_start', 'course_max', 'course_min']:\n            p[param][j] = np.array(p[param][j])\n\n    # Number of training courses per AFSC\n    p['T'] = np.array([len(p['courses'][j]) for j in range(p['M'])])\n\n    # Return updated parameters\n    return p\n</code></pre>"},{"location":"reference/data/generation/#data.generation.generate_concave_curve","title":"<code>generate_concave_curve(num_points, max_x)</code>","text":"<p>Generates x and y coordinates for a concave function.</p> <p>Args:     num_points (int): Number of points to generate.     max_x (float): Maximum value along the x-axis.</p> <p>Returns:     tuple: (x_values, y_values) as numpy arrays.</p> Source code in <code>afccp/data/generation/basic.py</code> <pre><code>def generate_concave_curve(num_points, max_x):\n    \"\"\"\n    Generates x and y coordinates for a concave function.\n\n    Args:\n        num_points (int): Number of points to generate.\n        max_x (float): Maximum value along the x-axis.\n\n    Returns:\n        tuple: (x_values, y_values) as numpy arrays.\n    \"\"\"\n    x_values = np.linspace(0, max_x, num_points)\n    y_values = 1 - np.exp(-x_values / (max_x / 6))  # Adjust curvature\n    return x_values, y_values\n</code></pre>"},{"location":"reference/data/generation/#data.generation.generate_realistic_castle_value_curves","title":"<code>generate_realistic_castle_value_curves(parameters, num_breakpoints: int = 10)</code>","text":"<p>Generate Concave Value Curves for CASTLE AFSCs.</p> <p>Creates piecewise linear approximations of realistic concave value functions for each CASTLE-level AFSC. These curves are used to evaluate the marginal utility of inventory across AFSCs, enabling smooth optimization and modeling in the CASTLE simulation.</p> <p>Parameters:     parameters (dict): Problem instance parameters containing CASTLE AFSC groups and PGL values.     num_breakpoints (int, optional): Number of breakpoints to use in the piecewise value curve.         Defaults to 10.</p> <p>Returns:     dict: A dictionary <code>q</code> containing the following keys for each CASTLE AFSC:         - <code>'a'</code>: Array of x-values (inventory levels).         - <code>'f^hat'</code>: Array of corresponding y-values (utility).         - <code>'r'</code>: Number of breakpoints.         - <code>'L'</code>: Index array of breakpoints.</p> <p>Example:     <pre><code>q = generate_realistic_castle_value_curves(parameters, num_breakpoints=12)\nx_vals = q['a']['21A']       # x-values for AFSC 21A\ny_vals = q['f^hat']['21A']   # corresponding utility values\n</code></pre></p> <p>See Also:     - <code>generate_concave_curve</code>:       Generates a concave (diminishing returns) curve with specified number of points and max range.</p> Source code in <code>afccp/data/generation/basic.py</code> <pre><code>def generate_realistic_castle_value_curves(parameters, num_breakpoints: int = 10):\n    \"\"\"\n    Generate Concave Value Curves for CASTLE AFSCs.\n\n    Creates piecewise linear approximations of realistic concave value functions for each CASTLE-level AFSC.\n    These curves are used to evaluate the marginal utility of inventory across AFSCs, enabling smooth\n    optimization and modeling in the CASTLE simulation.\n\n    Parameters:\n        parameters (dict): Problem instance parameters containing CASTLE AFSC groups and PGL values.\n        num_breakpoints (int, optional): Number of breakpoints to use in the piecewise value curve.\n            Defaults to 10.\n\n    Returns:\n        dict: A dictionary `q` containing the following keys for each CASTLE AFSC:\n            - `'a'`: Array of x-values (inventory levels).\n            - `'f^hat'`: Array of corresponding y-values (utility).\n            - `'r'`: Number of breakpoints.\n            - `'L'`: Index array of breakpoints.\n\n    Example:\n        ```python\n        q = generate_realistic_castle_value_curves(parameters, num_breakpoints=12)\n        x_vals = q['a']['21A']       # x-values for AFSC 21A\n        y_vals = q['f^hat']['21A']   # corresponding utility values\n        ```\n\n    See Also:\n        - [`generate_concave_curve`](../../../afccp/reference/data/generation/#data.generation.generate_concave_curve):\n          Generates a concave (diminishing returns) curve with specified number of points and max range.\n    \"\"\"\n    # Shorthand\n    p = parameters\n\n    # Define \"q\" dictionary for value function components\n    q = {'a': {}, 'f^hat': {}, 'r': {}, 'L': {}}\n    for afsc in p['castle_afscs']:\n        # Sum up the PGL targets for all \"AFPC\" AFSCs grouped for this \"CASTLE\" AFSC\n        pgl = np.sum(p['pgl'][p['J^CASTLE'][afsc]])\n\n        # Generate x and y coordinates for concave shape\n        x, y = generate_concave_curve(num_points=num_breakpoints, max_x=pgl * 2)\n\n        # Save breakpoint information to q dictionary\n        q['a'][afsc], q['f^hat'][afsc] = x, y\n        q['r'][afsc], q['L'][afsc] = len(x), np.arange(len(x))\n\n    return q\n</code></pre>"},{"location":"reference/data/generation/#data.generation.train_ctgan","title":"<code>train_ctgan(epochs=1000, printing=True, name='CTGAN_Full')</code>","text":"<p>Train CTGAN to produce realistic data based on the current \"ctgan_data\" file in the support sub-folder. This function then saves the \".pkl\" file back to the support sub-folder</p> Source code in <code>afccp/data/generation/realistic.py</code> <pre><code>def train_ctgan(epochs=1000, printing=True, name='CTGAN_Full'):\n    \"\"\"\n    Train CTGAN to produce realistic data based on the current \"ctgan_data\" file in the support sub-folder. This\n    function then saves the \".pkl\" file back to the support sub-folder\n    \"\"\"\n\n    # Import data\n    data = afccp.globals.import_csv_data(afccp.globals.paths['support'] + 'data/ctgan_data.csv')\n    data = data[[col for col in data.columns if col not in ['YEAR']]]\n    metadata = SingleTableMetadata()  # SDV requires this now\n    metadata.detect_from_dataframe(data=data)  # get the metadata from dataframe\n\n    # Create the synthesizer model\n    model = CTGANSynthesizer(metadata, epochs=epochs, verbose=True)\n\n    # List of constraints for CTGAN\n    constraints = []\n\n    # Get list of columns that must be between 0 and 1\n    zero_to_one_columns = [\"Merit\"]\n    for col in data.columns:\n        if \"_Cadet\" in col or \"_AFSC\" in col:\n            zero_to_one_columns.append(col)\n\n    # Create the \"zero to one\" constraints and add them to our list of constraints\n    for col in zero_to_one_columns:\n        zero_to_one_constraint = {\"constraint_class\": \"ScalarRange\",\n                                  \"constraint_parameters\": {\n                                      'column_name': col,\n                                      'low_value': 0,\n                                      'high_value': 1,\n                                      'strict_boundaries': False\n                                  }}\n        constraints.append(zero_to_one_constraint)\n\n    # Add the constraints to the model\n    model.add_constraints(constraints)\n\n    # Train the model\n    if printing:\n        print(\"Training the model...\")\n    model.fit(data)\n\n    # Save the model\n    filepath = afccp.globals.paths[\"support\"] + name + '.pkl'\n    model.save(filepath)\n    if printing:\n        print(\"Model saved to\", filepath)\n</code></pre>"},{"location":"reference/data/generation/#data.generation.generate_ctgan_instance","title":"<code>generate_ctgan_instance(N=1600, name='CTGAN_Full', pilot_condition=False, degree_qual_type='Consistent')</code>","text":"<p>This procedure takes in the specified number of cadets and then generates a representative problem instance using CTGAN that has been trained from a real class year of cadets</p> <p>Parameters:</p> Name Type Description Default <code>pilot_condition</code> <p>If we want to sample cadets according to pilot preferences (make this more representative)</p> <code>False</code> <code>name</code> <p>Name of the CTGAN model to import</p> <code>'CTGAN_Full'</code> <code>N</code> <p>number of cadets</p> <code>1600</code> <p>Returns:</p> Type Description <p>model fixed parameters</p> Source code in <code>afccp/data/generation/realistic.py</code> <pre><code>def generate_ctgan_instance(N=1600, name='CTGAN_Full', pilot_condition=False, degree_qual_type='Consistent'):\n    \"\"\"\n    This procedure takes in the specified number of cadets and then generates a representative problem\n    instance using CTGAN that has been trained from a real class year of cadets\n    :param pilot_condition: If we want to sample cadets according to pilot preferences\n    (make this more representative)\n    :param name: Name of the CTGAN model to import\n    :param N: number of cadets\n    :return: model fixed parameters\n    \"\"\"\n\n    # Load in the model\n    filepath = afccp.globals.paths[\"support\"] + name + '.pkl'\n    model = CTGANSynthesizer.load(filepath)\n\n    # Split up the number of ROTC/USAFA cadets\n    N_usafa = round(np.random.triangular(0.25, 0.33, 0.4) * N)\n    N_rotc = N - N_usafa\n\n    # Pilot is by far the #1 desired career field, let's make sure this is represented here\n    N_usafa_pilots = round(np.random.triangular(0.3, 0.4, 0.43) * N_usafa)\n    N_usafa_generic = N_usafa - N_usafa_pilots\n    N_rotc_pilots = round(np.random.triangular(0.25, 0.3, 0.33) * N_rotc)\n    N_rotc_generic = N_rotc - N_rotc_pilots\n\n    # Condition the data generated to produce the right composition of pilot first choice preferences\n    usafa_pilot_first_choice = Condition(num_rows = N_usafa_pilots, column_values={'SOC': 'USAFA', '11XX_Cadet': 1})\n    usafa_generic_cadets = Condition(num_rows=N_usafa_generic, column_values={'SOC': 'USAFA'})\n    rotc_pilot_first_choice = Condition(num_rows=N_rotc_pilots, column_values={'SOC': 'ROTC', '11XX_Cadet': 1})\n    rotc_generic_cadets = Condition(num_rows=N_rotc_generic, column_values={'SOC': 'ROTC'})\n\n    # Sample data  (Sampling from conditions may take too long!)\n    if pilot_condition:\n        data = model.sample_from_conditions(conditions=[usafa_pilot_first_choice, usafa_generic_cadets,\n                                                        rotc_pilot_first_choice, rotc_generic_cadets])\n    else:\n        data = model.sample(N)\n\n    # Load in AFSCs data\n    filepath = afccp.globals.paths[\"support\"] + 'data/afscs_data.csv'\n    afscs_data = afccp.globals.import_csv_data(filepath)\n\n    # Get list of AFSCs\n    afscs = np.array(afscs_data['AFSC'])\n\n    # Initialize parameter dictionary\n    p = {'afscs': afscs, 'N': N, 'P': len(afscs), 'M': len(afscs), 'merit': np.array(data['Merit']),\n         'cadets': np.arange(N), 'usafa': np.array(data['SOC'] == 'USAFA') * 1,\n         'cip1': np.array(data['CIP1']), 'cip2': np.array(data['CIP2']), 'num_util': 10,  # 10 utilities taken\n         'rotc': np.array(data['SOC'] == 'ROTC'), 'I': np.arange(N), 'J': np.arange(len(afscs))}\n\n    # Clean up degree columns (remove the leading \"c\" I put there if it's there)\n    for i in p['I']:\n        if p['cip1'][i][0] == 'c':\n            p['cip1'][i] = p['cip1'][i][1:]\n        if p['cip2'][i][0] == 'c':\n            p['cip2'][i] = p['cip2'][i][1:]\n\n    # Fix percentiles for USAFA and ROTC\n    re_scaled_om = p['merit']\n    for soc in ['usafa', 'rotc']:\n        indices = np.where(p[soc])[0]  # Indices of these SOC-specific cadets\n        percentiles = p['merit'][indices]  # The percentiles of these cadets\n        N = len(percentiles)  # Number of cadets from this SOC\n        sorted_indices = np.argsort(percentiles)[::-1]  # Sort these percentiles (descending)\n        new_percentiles = (np.arange(N)) / (N - 1)  # New percentiles we want to replace these with\n        magic_indices = np.argsort(sorted_indices)  # Indices that let us put the new percentiles in right place\n        new_percentiles = new_percentiles[magic_indices]  # Put the new percentiles back in the right place\n        np.put(re_scaled_om, indices, new_percentiles)  # Put these new percentiles in combined SOC OM spot\n\n    # Replace merit\n    p['merit'] = re_scaled_om\n\n    # Add AFSC features to parameters\n    p['acc_grp'] = np.array(afscs_data['Accessions Group'])\n    p['Deg Tiers'] = np.array(afscs_data.loc[:, 'Deg Tier 1': 'Deg Tier 4'])\n    p['Deg Tiers'][pd.isnull(p[\"Deg Tiers\"])] = ''  # TODO\n\n    # Determine AFSCs by Accessions Group\n    p['afscs_acc_grp'] = {}\n    if 'acc_grp' in p:\n        for acc_grp in ['Rated', 'USSF', 'NRL']:\n            p['J^' + acc_grp] = np.where(p['acc_grp'] == acc_grp)[0]\n            p['afscs_acc_grp'][acc_grp] = p['afscs'][p['J^' + acc_grp]]\n\n    # Useful data elements to help us generate PGL targets\n    usafa_prop, rotc_prop, pgl_prop = np.array(afscs_data['USAFA Proportion']), \\\n                                      np.array(afscs_data['ROTC Proportion']), \\\n                                      np.array(afscs_data['PGL Proportion'])\n\n    # Total targets needed to distribute\n    total_targets = int(p['N'] * min(0.95, np.random.normal(0.93, 0.08)))\n\n    # PGL targets\n    p['pgl'] = np.zeros(p['M']).astype(int)\n    p['usafa_quota'] = np.zeros(p['M']).astype(int)\n    p['rotc_quota'] = np.zeros(p['M']).astype(int)\n    for j in p['J']:\n\n        # Create the PGL target by sampling from the PGL proportion triangular distribution\n        p_min = max(0, 0.8 * pgl_prop[j])\n        p_max = 1.2 * pgl_prop[j]\n        prop = np.random.triangular(p_min, pgl_prop[j], p_max)\n        p['pgl'][j] = int(max(1, prop * total_targets))\n\n        # Get the ROTC proportion of this PGL target to allocate\n        if rotc_prop[j] in [1, 0]:\n            prop = rotc_prop[j]\n        else:\n            rotc_p_min = max(0, 0.8 * rotc_prop[j])\n            rotc_p_max = min(1, 1.2 * rotc_prop[j])\n            prop = np.random.triangular(rotc_p_min, rotc_prop[j], rotc_p_max)\n\n        # Create the SOC-specific targets\n        p['rotc_quota'][j] = int(prop * p['pgl'][j])\n        p['usafa_quota'][j] = p['pgl'][j] - p['rotc_quota'][j]\n\n    # Initialize the other pieces of information here\n    for param in ['quota_e', 'quota_d', 'quota_min', 'quota_max']:\n        p[param] = p['pgl']\n\n    # Break up USSF and 11XX AFSC by SOC\n    for afsc in ['USSF', '11XX']:\n        for col in ['Cadet', 'AFSC']:\n            for soc in ['USAFA', 'ROTC']:\n                data[f'{afsc}_{soc[0]}_{col}'] = 0\n                data.loc[data['SOC'] == soc, f'{afsc}_{soc[0]}_{col}'] = data.loc[data['SOC'] == soc, f'{afsc}_{col}']\n\n    c_pref_cols = [f'{afsc}_Cadet' for afsc in afscs]\n    util_original = np.around(np.array(data[c_pref_cols]), 2)\n\n    # Initialize cadet preference information\n    p['c_utilities'] = np.zeros((p['N'], 10))\n    p['c_preferences'] = np.array([[' ' * 6 for _ in range(p['M'])] for _ in range(p['N'])])\n    p['cadet_preferences'] = {}\n    p['c_pref_matrix'] = np.zeros((p['N'], p['M'])).astype(int)\n    p['utility'] = np.zeros((p['N'], p['M']))\n\n    # Loop through each cadet to tweak their preferences\n    for i in p['cadets']:\n\n        # Manually fix 62EXE preferencing from eligible cadets\n        ee_j = np.where(afscs == '62EXE')[0][0]\n        if '1410' in data.loc[i, 'CIP1'] or '1447' in data.loc[i, 'CIP1']:\n            if np.random.rand() &gt; 0.6:\n                util_original[i, ee_j] = np.around(max(util_original[i, ee_j], min(1, np.random.normal(0.8, 0.18))),\n                                                   2)\n\n        # Fix rated/USSF volunteer situation\n        for acc_grp in ['Rated', 'USSF']:\n            if data.loc[i, f'{acc_grp} Vol']:\n                if np.max(util_original[i, p[f'J^{acc_grp}']]) &lt; 0.6:\n                    util_original[i, p[f'J^{acc_grp}']] = 0\n                    data.loc[i, f'{acc_grp} Vol'] = False\n            else:  # Not a volunteer\n\n                # We have a higher preference for these kinds of AFSCs\n                if np.max(util_original[i, p[f'J^{acc_grp}']]) &gt;= 0.6:\n                    data.loc[i, f'{acc_grp} Vol'] = True  # Make them a volunteer now\n\n        # Was this the last choice AFSC? Remove from our lists\n        ordered_list = np.argsort(util_original[i])[::-1]\n        last_choice = data.loc[i, 'Last Choice']\n        if last_choice in afscs:\n            j = np.where(afscs == last_choice)[0][0]\n            ordered_list = ordered_list[ordered_list != j]\n\n        # Add the \"2nd least desired AFSC\" to list\n        second_last_choice = data.loc[i, '2nd-Last Choice']\n        bottom = []\n        if second_last_choice in afscs and afsc != last_choice:  # Check if valid and not in bottom choices\n            j = np.where(afscs == second_last_choice)[0][0]  # Get index of AFSC\n            ordered_list = ordered_list[ordered_list != j]  # Remove index from preferences\n            bottom.append(second_last_choice)  # Add it to the list of bottom choices\n\n        # If it's a valid AFSC that isn't already in the bottom choices\n        third_last_choice = data.loc[i, '3rd-Last Choice']  # Add the \"3rd least desired AFSC\" to list\n        if third_last_choice in afscs and afsc not in [last_choice, second_last_choice]:\n            j = np.where(afscs == third_last_choice)[0][0]  # Get index of AFSC\n            ordered_list = ordered_list[\n                ordered_list != j]  # Reordered_list = np.argsort(util_original[i])[::-1]move index from preferences\n            bottom.append(third_last_choice)  # Add it to the list of bottom choices\n\n        # If we have an AFSC in the bottom choices, but NOT the LAST choice, move one to the last choice\n        if len(bottom) &gt; 0 and pd.isnull(last_choice):\n            afsc = bottom.pop(0)\n            data.loc[i, 'Last Choice'] = afsc\n        data.loc[i, 'Second Least Desired AFSCs'] = ', '.join(bottom)  # Put it in the dataframe\n\n        # Save cadet preference information\n        num_pref = 10 if np.random.rand() &gt; 0.1 else int(np.random.triangular(11, 15, 26))\n        p['c_utilities'][i] = util_original[i, ordered_list[:10]]\n        p['cadet_preferences'][i] = ordered_list[:num_pref]\n        p['c_preferences'][i, :num_pref] = afscs[p['cadet_preferences'][i]]\n        p['c_pref_matrix'][i, p['cadet_preferences'][i]] = np.arange(1, len(p['cadet_preferences'][i]) + 1)\n        p['utility'][i, p['cadet_preferences'][i][:10]] = p['c_utilities'][i]\n\n    # Get qual matrix information\n    p['Qual Type'] = degree_qual_type\n    p = afccp.data.adjustments.gather_degree_tier_qual_matrix(cadets_df=None, parameters=p)\n\n    # Get the qual matrix to know what people are eligible for\n    ineligible = (np.core.defchararray.find(p['qual'], \"I\") != -1) * 1\n    eligible = (ineligible == 0) * 1\n    I_E = [np.where(eligible[:, j])[0] for j in p['J']]  # set of cadets that are eligible for AFSC j\n\n    # Modify AFSC utilities based on eligibility\n    a_pref_cols = [f'{afsc}_AFSC' for afsc in afscs]\n    p['afsc_utility'] = np.around(np.array(data[a_pref_cols]), 2)\n    for acc_grp in ['Rated', 'USSF']:\n        for j in p['J^' + acc_grp]:\n            volunteer_col = np.array(data['Rated Vol'])\n            volunteers = np.where(volunteer_col)[0]\n            not_volunteers = np.where(volunteer_col == False)[0]\n            ranked = np.where(p['afsc_utility'][:, j] &gt; 0)[0]\n            unranked = np.where(p['afsc_utility'][:, j] == 0)[0]\n\n            # Fill in utility values with OM for rated folks who don't have an AFSC score\n            volunteer_unranked = np.intersect1d(volunteers, unranked)\n            p['afsc_utility'][volunteer_unranked, j] = p['merit'][volunteer_unranked]\n\n            # If the cadet didn't actually volunteer, they should have utility of 0\n            non_volunteer_ranked = np.intersect1d(not_volunteers, ranked)\n            p['afsc_utility'][non_volunteer_ranked, j] = 0\n\n    # Remove cadets from this AFSC's preferences if the cadet is not eligible\n    for j in p['J^NRL']:\n\n        # Get appropriate sets of cadets\n        eligible_cadets = I_E[j]\n        ineligible_cadets = np.where(ineligible[:, j])[0]\n        ranked_cadets = np.where(p['afsc_utility'][:, j] &gt; 0)[0]\n        unranked_cadets = np.where(p['afsc_utility'][:, j] == 0)[0]\n\n        # Fill in utility values with OM for eligible folks who don't have an AFSC score\n        eligible_unranked = np.intersect1d(eligible_cadets, unranked_cadets)\n        p['afsc_utility'][eligible_unranked, j] = p['merit'][eligible_unranked]\n\n        # If the cadet isn't actually eligible, they should have utility of 0\n        ineligible_ranked = np.intersect1d(ineligible_cadets, ranked_cadets)\n        p['afsc_utility'][ineligible_ranked, j] = 0\n\n    # Collect AFSC preference information\n    p['afsc_preferences'] = {}\n    p['a_pref_matrix'] = np.zeros((p['N'], p['M'])).astype(int)\n    for j in p['J']:\n\n        # Sort the utilities to get the preference list\n        utilities = p[\"afsc_utility\"][:, j]\n        ineligible_indices = np.where(utilities == 0)[0]\n        sorted_indices = np.argsort(utilities)[::-1][:p['N'] - len(ineligible_indices)]\n        p['afsc_preferences'][j] = sorted_indices\n\n        # Since 'afsc_preferences' is an array of AFSC indices, we can do this\n        p['a_pref_matrix'][p['afsc_preferences'][j], j] = np.arange(1, len(p['afsc_preferences'][j]) + 1)\n\n    # Needed information for rated OM matrices\n    dataset_dict = {'rotc': 'rr_om_matrix', 'usafa': 'ur_om_matrix'}\n    cadets_dict = {'rotc': 'rr_om_cadets', 'usafa': 'ur_om_cadets'}\n    p[\"Rated Cadets\"] = {}\n\n    # Create rated OM matrices for each SOC\n    for soc in ['usafa', 'rotc']:\n\n        # Rated AFSCs for this SOC\n        if soc == 'rotc':\n            rated_J_soc = np.array([j for j in p['J^Rated'] if '_U' not in p['afscs'][j]])\n        else:  # usafa\n            rated_J_soc = np.array([j for j in p['J^Rated'] if '_R' not in p['afscs'][j]])\n\n        # Cadets from this SOC\n        soc_cadets = np.where(p[soc])[0]\n\n        # Determine which cadets are eligible for at least one rated AFSC\n        p[\"Rated Cadets\"][soc] = np.array([i for i in soc_cadets if np.sum(p['c_pref_matrix'][i, rated_J_soc]) &gt; 0])\n        p[cadets_dict[soc]] = p[\"Rated Cadets\"][soc]\n\n        # Initialize OM dataset\n        p[dataset_dict[soc]] = np.zeros([len(p[\"Rated Cadets\"][soc]), len(rated_J_soc)])\n\n        # Create OM dataset\n        for col, j in enumerate(rated_J_soc):\n\n            # Get the maximum rank someone had\n            max_rank = np.max(p['a_pref_matrix'][p[\"Rated Cadets\"][soc], j])\n\n            # Loop through each cadet to convert rank to percentile\n            for row, i in enumerate(p[\"Rated Cadets\"][soc]):\n                rank = p['a_pref_matrix'][i, j]\n                if rank == 0:\n                    p[dataset_dict[soc]][row, col] = 0\n                else:\n                    p[dataset_dict[soc]][row, col] = (max_rank - rank + 1) / max_rank\n\n    # Return parameters\n    return p\n</code></pre>"},{"location":"reference/data/generation/#data.generation.safe_round","title":"<code>safe_round(data, decimals=0, axis=-1)</code>","text":"<p>Round <code>data</code> to <code>decimals</code> decimals along <code>axis</code>, preserving the sum of each slice (to <code>decimals</code>), using a \"difference\" style strategy.</p> Source code in <code>afccp/data/generation/realistic.py</code> <pre><code>def safe_round(data, decimals=0, axis=-1):\n    \"\"\"\n    Round `data` to `decimals` decimals along `axis`, preserving the sum of each\n    slice (to `decimals`), using a \"difference\" style strategy.\n    \"\"\"\n    data_type = type(data)\n    constructor = {}\n\n    # 1) Scale by 10^decimals\n    scale = 10.0 ** decimals\n    scaled = data * scale\n\n    # 2) Naively round each element to the nearest integer\n    rounded = np.rint(scaled)\n\n    # 3) Compute how many integer \"units\" the sum *should* have in each slice\n    sum_rounded = np.sum(rounded, axis=axis, keepdims=True)\n    sum_desired = np.rint(np.sum(scaled, axis=axis, keepdims=True))\n    difference = sum_desired - sum_rounded\n\n    n = data.shape[axis]\n    leftover_div = np.floor_divide(difference, n)\n    leftover_mod = difference - leftover_div * n\n    rounded += leftover_div\n\n    # 5) Select elements to tweak\n    difference = scaled - rounded\n    leftover_sign = np.sign(leftover_mod)\n    difference_sign = np.sign(difference)\n    candidate_mask = (difference_sign == leftover_sign) &amp; (difference_sign != 0)\n    sort_key = np.where(candidate_mask, -np.abs(difference), np.inf)\n    sorted_idx = np.argsort(sort_key, axis=axis, kind='stable')\n\n    ranks = np.empty_like(sorted_idx)\n    shape_for_r = [1] * data.ndim\n    shape_for_r[axis] = n\n    r_array = np.arange(n, dtype=sorted_idx.dtype).reshape(shape_for_r)\n    np.put_along_axis(ranks, sorted_idx, r_array, axis=axis)\n\n    leftover_mod_int = np.abs(leftover_mod).astype(int)\n    choose_mask = ranks &lt; leftover_mod_int\n    rounded += leftover_sign * choose_mask\n\n    result = rounded / scale\n\n    if data_type is np.ndarray:\n        return result\n\n    return data_type(result.squeeze(), **constructor)\n</code></pre>"},{"location":"reference/data/preferences/","title":"Preferences","text":""},{"location":"reference/data/preferences/#data.preferences","title":"<code>data.preferences</code>","text":"<p>This module contains functions for constructing and modifying cadet and AFSC preference structures within the Air Force Cadet Career Problem (AFCCP) model.</p> <p>These utilities operate on the model's parameter dictionary to: - Build preference matrices (<code>c_pref_matrix</code>, <code>a_pref_matrix</code>) from raw preference lists - Convert preferences into normalized utilities and percentiles - Apply eligibility filters to AFSC preferences - Update final utility matrices for use in optimization</p> <p>Functions in this module are essential for: - Ensuring consistency between input data (Cadets.csv, AFSCs.csv) and the model structure - Supporting preference-based evaluation and assignment logic - Performing key preprocessing steps used during instance initialization or data generation</p>"},{"location":"reference/data/preferences/#data.preferences.convert_utility_matrices_preferences","title":"<code>convert_utility_matrices_preferences(parameters, cadets_as_well=False)</code>","text":"<p>Converts utility matrices into ordinal preference matrices.</p> <p>This function transforms the continuous utility values provided in the cadet and AFSC utility matrices into discrete preference rankings (ordinal preferences). These rankings are stored in <code>a_pref_matrix</code> and optionally <code>c_pref_matrix</code> within the <code>parameters</code> dictionary.</p>"},{"location":"reference/data/preferences/#data.preferences.convert_utility_matrices_preferences--parameters","title":"Parameters","text":"<p>parameters : dict     Dictionary of model parameters, including <code>afsc_utility</code> and optionally <code>cadet_utility</code>.</p> <p>cadets_as_well : bool, optional     If <code>True</code>, the cadet utility matrix (<code>cadet_utility</code>) is also converted into a cadet     preference matrix (<code>c_pref_matrix</code>). Defaults to <code>False</code>.</p>"},{"location":"reference/data/preferences/#data.preferences.convert_utility_matrices_preferences--returns","title":"Returns","text":"<p>dict     Updated <code>parameters</code> dictionary with added <code>a_pref_matrix</code> and optionally <code>c_pref_matrix</code>.</p> Source code in <code>afccp/data/preferences.py</code> <pre><code>def convert_utility_matrices_preferences(parameters, cadets_as_well=False):\n    \"\"\"\n    Converts utility matrices into ordinal preference matrices.\n\n    This function transforms the continuous utility values provided in the cadet and AFSC utility\n    matrices into discrete preference rankings (ordinal preferences). These rankings are stored in\n    `a_pref_matrix` and optionally `c_pref_matrix` within the `parameters` dictionary.\n\n    Parameters\n    ----------\n    parameters : dict\n        Dictionary of model parameters, including `afsc_utility` and optionally `cadet_utility`.\n\n    cadets_as_well : bool, optional\n        If `True`, the cadet utility matrix (`cadet_utility`) is also converted into a cadet\n        preference matrix (`c_pref_matrix`). Defaults to `False`.\n\n    Returns\n    -------\n    dict\n        Updated `parameters` dictionary with added `a_pref_matrix` and optionally `c_pref_matrix`.\n    \"\"\"\n    p = parameters\n\n    # Loop through each AFSC to get their preferences\n    if 'afsc_utility' in p:\n        p[\"a_pref_matrix\"] = np.zeros([p[\"N\"], p[\"M\"]]).astype(int)\n        for j in p[\"J\"]:\n\n            # Sort the utilities to get the preference list\n            utilities = p[\"afsc_utility\"][:, j]\n            sorted_indices = np.argsort(utilities)[::-1]\n            preferences = np.argsort(sorted_indices)\n            p[\"a_pref_matrix\"][:, j] = preferences\n\n    # Loop through each cadet to get their preferences\n    if cadets_as_well:\n        p[\"c_pref_matrix\"] = np.zeros([p[\"N\"], p[\"M\"]]).astype(int)\n        for i in p[\"I\"]:\n\n            # Sort the utilities to get the preference list\n            utilities = p[\"cadet_utility\"][i, :p[\"M\"]]\n            sorted_indices = np.argsort(utilities)[::-1]\n            preferences = np.argsort(\n                sorted_indices) + 1  # Add 1 to change from python index (at 0) to rank (start at 1)\n            p[\"c_pref_matrix\"][i, :] = preferences\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.generate_fake_afsc_preferences","title":"<code>generate_fake_afsc_preferences(parameters, value_parameters=None, fix_cadet_eligibility=False)</code>","text":"<p>Generate synthetic AFSC utility and preference matrices.</p> <p>This function constructs artificial utility scores and corresponding preference rankings for Air Force Specialty Codes (AFSCs) using merit, AFOCD tiers, and other known cadet attributes. It supports both weighted approaches using a provided set of value parameters or a default fixed weighting strategy. Preferences are automatically adjusted to ensure cadets and AFSCs only rank eligible options.</p>"},{"location":"reference/data/preferences/#data.preferences.generate_fake_afsc_preferences--parameters","title":"Parameters","text":"<p>parameters : dict     Dictionary containing fixed model parameters (cadet/AFSC eligibility, merit scores, utility matrices, etc.).</p> <p>value_parameters : dict, optional     Value parameter dictionary containing weights and objectives to guide AFSC utility generation. If None,     a default set of weights is used.</p> <p>fix_cadet_eligibility : bool, default=False     If True, overrides cadet preferences to match eligibility criteria and recomputes rankings.</p>"},{"location":"reference/data/preferences/#data.preferences.generate_fake_afsc_preferences--returns","title":"Returns","text":"<p>parameters : dict     Updated parameter dictionary containing generated utility matrices and preference rankings:</p> <pre><code>- `afsc_utility`: N x M matrix of cadet utility scores for each AFSC.\n- `a_pref_matrix`: AFSCs' preference rankings of cadets.\n- `c_pref_matrix`: Cadets' preference rankings of AFSCs.\n- `afsc_preferences`: Dict mapping each AFSC to its sorted list of cadet indices.\n- `cadet_preferences`: Dict mapping each cadet to their sorted list of AFSC indices.\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.generate_fake_afsc_preferences--examples","title":"Examples","text":"<pre><code>parameters = generate_fake_afsc_preferences(parameters)\nparameters = generate_fake_afsc_preferences(parameters, value_parameters=vp, fix_cadet_eligibility=True)\n</code></pre> Source code in <code>afccp/data/preferences.py</code> <pre><code>def generate_fake_afsc_preferences(parameters, value_parameters=None, fix_cadet_eligibility=False):\n    \"\"\"\n    Generate synthetic AFSC utility and preference matrices.\n\n    This function constructs artificial utility scores and corresponding preference rankings for Air Force Specialty\n    Codes (AFSCs) using merit, AFOCD tiers, and other known cadet attributes. It supports both weighted approaches\n    using a provided set of value parameters or a default fixed weighting strategy. Preferences are automatically\n    adjusted to ensure cadets and AFSCs only rank eligible options.\n\n    Parameters\n    ----------\n    parameters : dict\n        Dictionary containing fixed model parameters (cadet/AFSC eligibility, merit scores, utility matrices, etc.).\n\n    value_parameters : dict, optional\n        Value parameter dictionary containing weights and objectives to guide AFSC utility generation. If None,\n        a default set of weights is used.\n\n    fix_cadet_eligibility : bool, default=False\n        If True, overrides cadet preferences to match eligibility criteria and recomputes rankings.\n\n    Returns\n    -------\n    parameters : dict\n        Updated parameter dictionary containing generated utility matrices and preference rankings:\n\n        - `afsc_utility`: N x M matrix of cadet utility scores for each AFSC.\n        - `a_pref_matrix`: AFSCs' preference rankings of cadets.\n        - `c_pref_matrix`: Cadets' preference rankings of AFSCs.\n        - `afsc_preferences`: Dict mapping each AFSC to its sorted list of cadet indices.\n        - `cadet_preferences`: Dict mapping each cadet to their sorted list of AFSC indices.\n\n    Examples\n    --------\n    ```python\n    parameters = generate_fake_afsc_preferences(parameters)\n    parameters = generate_fake_afsc_preferences(parameters, value_parameters=vp, fix_cadet_eligibility=True)\n    ```\n    \"\"\"\n    # Shorthand\n    p, vp = parameters, value_parameters\n\n    # Create AFSC Utility Matrix\n    p[\"afsc_utility\"] = np.zeros([p[\"N\"], p[\"M\"]])\n    if vp is None:\n\n        # If we don't have a set of value_parameters, we just make some assumptions\n        weights = {\"Merit\": 80, \"Tier 1\": 100, \"Tier 2\": 50, \"Tier 3\": 30, \"Tier 4\": 0, \"Utility\": 60}\n        for objective in weights:\n            if objective.lower() in p:\n\n                if objective == \"Merit\":\n                    merit = np.tile(p['merit'], [p[\"M\"], 1]).T\n                    p[\"afsc_utility\"] += merit * weights[objective]\n                else:\n                    p[\"afsc_utility\"] += p[objective.lower()][:, :p[\"M\"]] * weights[objective]\n    else:\n\n        # If we do have a set of value_parameters, we incorporate them\n        for objective in ['Merit', 'Tier 1', 'Tier 2', 'Tier 3', 'Tier 4', 'Utility']:\n            if objective in vp['objectives']:\n\n                k = np.where(vp['objectives'] == objective)[0][0]\n                if objective == \"Merit\":\n                    merit = np.tile(p['merit'], [p[\"M\"], 1]).T\n                    p[\"afsc_utility\"] += merit * vp['objective_weight'][:, k].T\n                else:\n                    p[\"afsc_utility\"] += p[objective.lower()][:, :p[\"M\"]] * vp['objective_weight'][:, k].T\n    p[\"afsc_utility\"] *= p[\"eligible\"]  # They have to be eligible!\n\n    if fix_cadet_eligibility:  # We just start over from scratch with cadet preferences\n        p['c_pref_matrix'] = np.zeros([p[\"N\"], p[\"M\"]]).astype(int)\n        p['cadet_preferences'] = {}\n\n        # Add a column to the eligible matrix for the unmatched AFSC (just to get the below multiplication to work)\n        eligible = copy.deepcopy(p['eligible'])\n        eligible = np.hstack((eligible, np.array([[0] for _ in range(p[\"N\"])])))\n        p['cadet_utility'] *= eligible  # They have to be eligible!\n        for i in p[\"I\"]:\n\n            # Sort the utilities to get the preference list\n            utilities = p[\"cadet_utility\"][i, :p[\"M\"]]\n            ineligible_indices = np.where(eligible[i, :p[\"M\"]] == 0)[0]\n            sorted_indices = np.argsort(utilities)[::-1][:p['M'] - len(ineligible_indices)]\n            p['cadet_preferences'][i] = sorted_indices\n\n            # Since 'cadet_preferences' is an array of AFSC indices, we can do this\n            p['c_pref_matrix'][i, p['cadet_preferences'][i]] = np.arange(1, len(p['cadet_preferences'][i]) + 1)\n\n    # Create AFSC Preferences\n    p[\"a_pref_matrix\"] = np.zeros([p[\"N\"], p[\"M\"]]).astype(int)\n    p['afsc_preferences'] = {}\n    for j in p[\"J\"]:\n\n        # Loop through each cadet one more time to fix them on the AFSC list\n        for i in p['I']:\n            if p['c_pref_matrix'][i, j] == 0:\n                p['afsc_utility'][i, j] = 0\n\n        # Sort the utilities to get the preference list\n        utilities = p[\"afsc_utility\"][:, j]\n        ineligible_indices = np.where(utilities == 0)[0]\n        sorted_indices = np.argsort(utilities)[::-1][:p['N'] - len(ineligible_indices)]\n        p['afsc_preferences'][j] = sorted_indices\n\n        # Since 'afsc_preferences' is an array of AFSC indices, we can do this\n        p['a_pref_matrix'][p['afsc_preferences'][j], j] = np.arange(1, len(p['afsc_preferences'][j]) + 1)\n\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.generate_rated_data","title":"<code>generate_rated_data(parameters)</code>","text":"<p>Generate Simulated Rated Interest and Order of Merit (OM) Data.</p> <p>This function generates ROTC-rated interest levels and USAFA/ROTC-rated Order of Merit (OM) scores for cadets eligible for rated AFSCs (e.g., Pilot, CSO, ABM, RPA). These scores are essential for modeling preferences and eligibility in rated board algorithms.</p>"},{"location":"reference/data/preferences/#data.preferences.generate_rated_data--parameters","title":"Parameters","text":"<p>parameters : dict     The main parameter dictionary for the cadet-AFSC assignment problem. It must contain:</p> <pre><code>- `Rated Cadets`: Dictionary of rated cadets by commissioning source (`usafa`, `rotc`)\n- `afscs_acc_grp`: AFSCs categorized into assignment groups (must include 'Rated')\n- `SOCs`: List of commissioning source identifiers (e.g., `('usafa', 'Rated')`)\n- `afsc_preferences`: AFSCs\u2019 ranked preferences over cadets\n- `I^E`: Cadet eligibility sets\n- `afscs`: Full list of AFSCs\n- `Rated Cadet Index Dict`: Lookup dict to convert cadet ID to matrix row index for each SOC\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.generate_rated_data--returns","title":"Returns","text":"<p>dict Updated parameter dictionary including:</p> <ul> <li><code>rr_interest_matrix</code>: ROTC cadets' self-assessed interest in rated AFSCs</li> <li><code>xr_om_matrix</code>, <code>ur_om_matrix</code>, etc.: Rated OM matrices for each SOC (generated if missing)</li> </ul>"},{"location":"reference/data/preferences/#data.preferences.generate_rated_data--examples","title":"Examples","text":"<pre><code>parameters = generate_rated_data(parameters)\n</code></pre> <p>This generates the following additions:</p> <ul> <li><code>parameters['rr_interest_matrix']</code> \u2192 random values like ['High', 'Med', 'Low', 'None']</li> <li><code>parameters['ur_om_matrix']</code> \u2192 OM percentiles for USAFA-rated cadets and AFSCs</li> </ul> Source code in <code>afccp/data/preferences.py</code> <pre><code>def generate_rated_data(parameters):\n    \"\"\"\n    Generate Simulated Rated Interest and Order of Merit (OM) Data.\n\n    This function generates ROTC-rated interest levels and USAFA/ROTC-rated Order of Merit (OM) scores for cadets\n    eligible for rated AFSCs (e.g., Pilot, CSO, ABM, RPA). These scores are essential for modeling preferences and\n    eligibility in rated board algorithms.\n\n    Parameters\n    ----------\n    parameters : dict\n        The main parameter dictionary for the cadet-AFSC assignment problem. It must contain:\n\n        - `Rated Cadets`: Dictionary of rated cadets by commissioning source (`usafa`, `rotc`)\n        - `afscs_acc_grp`: AFSCs categorized into assignment groups (must include 'Rated')\n        - `SOCs`: List of commissioning source identifiers (e.g., `('usafa', 'Rated')`)\n        - `afsc_preferences`: AFSCs\u2019 ranked preferences over cadets\n        - `I^E`: Cadet eligibility sets\n        - `afscs`: Full list of AFSCs\n        - `Rated Cadet Index Dict`: Lookup dict to convert cadet ID to matrix row index for each SOC\n\n    Returns\n    -------\n    dict\n    Updated parameter dictionary including:\n\n    - `rr_interest_matrix`: ROTC cadets' self-assessed interest in rated AFSCs\n    - `xr_om_matrix`, `ur_om_matrix`, etc.: Rated OM matrices for each SOC (generated if missing)\n\n    Examples\n    --------\n    ```python\n    parameters = generate_rated_data(parameters)\n    ```\n\n    This generates the following additions:\n\n    - `parameters['rr_interest_matrix']` \u2192 random values like ['High', 'Med', 'Low', 'None']\n    - `parameters['ur_om_matrix']` \u2192 OM percentiles for USAFA-rated cadets and AFSCs\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n    if 'usafa' not in p['Rated Cadets']:\n        return p  # No Rated AFSCs to add\n\n    # ROTC Rated Interest Matrix (Only generate random data if we don't already have it)\n    if 'rr_interest_matrix' not in p:\n        p['rr_interest_matrix'] = np.array(\n            [[np.random.choice(['High', 'Med', 'Low', 'None']) for _ in\n              p['afscs_acc_grp']['Rated']] for _ in range(len(p['Rated Cadets']['rotc']))])\n\n    # Loop through each SOC to generate OM data (based on AFSC preferences) if we don't already have it\n    dataset_dict = {soc: f'{soc[0]}r_om_matrix' for soc in p['SOCs']}\n    for soc in dataset_dict:\n        dataset = dataset_dict[soc]  # SOC specific dataset name for Rated OM data\n\n        # Collect useful information on the Rated cadets (for this SOC) and the Rated AFSCs\n        rated_cadets, rated_afscs = p['Rated Cadets'][soc], p['afscs_acc_grp']['Rated']\n        num_rated_cadets, num_rated_afscs = len(rated_cadets), len(rated_afscs)\n        if dataset not in p:  # Only generate data if we don't already have it\n\n            # Loop through each Rated AFSC to construct their OM data\n            p[dataset] = np.zeros([num_rated_cadets, num_rated_afscs])\n            for afsc_index, afsc in enumerate(p['afscs_acc_grp']['Rated']):\n                j = np.where(p['afscs'] == afsc)[0][0]\n\n                # Percentiles sorted from top (1) to bottom (0)\n                rated_afsc_eligible_cadets = np.intersect1d(p['I^E'][j], rated_cadets)\n                percentiles = \\\n                    ((np.arange(len(rated_afsc_eligible_cadets)) + 1) / (len(rated_afsc_eligible_cadets)))[::-1]\n\n                # Loop through each cadet in order of preference and give them the highest percentile based on SOC\n                count = 0\n                for i in p['afsc_preferences'][j]:\n                    if i in rated_afsc_eligible_cadets:\n                        cadet_index = p['Rated Cadet Index Dict'][soc][i]\n                        p[dataset][cadet_index, afsc_index] = percentiles[count]\n                        count += 1\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.construct_rated_preferences_from_om_by_soc","title":"<code>construct_rated_preferences_from_om_by_soc(parameters)</code>","text":"<p>Construct AFSC Preferences for Rated Candidates Using OM Matrices.</p> <p>This function consolidates the Ordered Merit (OM) matrices from multiple Sources of Commissioning (SOCs) (e.g., USAFA and ROTC) and creates a unified AFSC preference list for Rated AFSCs. It normalizes OM rankings across SOCs, combines them into a single composite preference score, and updates both the <code>afsc_preferences</code> list and the <code>a_pref_matrix</code> for use in assignment modeling.</p>"},{"location":"reference/data/preferences/#data.preferences.construct_rated_preferences_from_om_by_soc--parameters","title":"Parameters:","text":"<p>parameters (dict): Dictionary containing the model instance parameters, including:</p> <ul> <li><code>rr_om_matrix</code>, <code>ur_om_matrix</code>: Ordered merit matrices from ROTC and USAFA.</li> <li><code>or_om_matrix</code>: Potentially Ordered merit matrices from OTS.</li> <li><code>afsc_preferences</code>: Dictionary to update with new AFSC \u2192 cadet preference lists.</li> <li><code>a_pref_matrix</code>: Matrix representing cadet rankings from the AFSCs' perspective.</li> <li><code>SOCs</code>, <code>afscs_acc_grp</code>, and cadet lists for each SOC.</li> </ul>"},{"location":"reference/data/preferences/#data.preferences.construct_rated_preferences_from_om_by_soc--returns","title":"Returns:","text":"<p>dict: Updated <code>parameters</code> dictionary with modified <code>afsc_preferences</code> and <code>a_pref_matrix</code> reflecting normalized OM-based preference rankings for Rated AFSCs.</p>"},{"location":"reference/data/preferences/#data.preferences.construct_rated_preferences_from_om_by_soc--example","title":"Example:","text":"<pre><code>parameters = construct_rated_preferences_from_om_by_soc(parameters)\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.construct_rated_preferences_from_om_by_soc--see-also","title":"See Also:","text":"<p><code>determine_soc_rated_afscs</code>:     Identifies which AFSCs are rated within a given SOC.</p> Source code in <code>afccp/data/preferences.py</code> <pre><code>def construct_rated_preferences_from_om_by_soc(parameters):\n    \"\"\"\n    Construct AFSC Preferences for Rated Candidates Using OM Matrices.\n\n    This function consolidates the Ordered Merit (OM) matrices from multiple Sources of Commissioning (SOCs)\n    (e.g., USAFA and ROTC) and creates a unified AFSC preference list for Rated AFSCs. It normalizes OM rankings\n    across SOCs, combines them into a single composite preference score, and updates both the `afsc_preferences`\n    list and the `a_pref_matrix` for use in assignment modeling.\n\n    Parameters:\n    --------\n    parameters (dict): Dictionary containing the model instance parameters, including:\n\n    - `rr_om_matrix`, `ur_om_matrix`: Ordered merit matrices from ROTC and USAFA.\n    - `or_om_matrix`: **Potentially** Ordered merit matrices from OTS.\n    - `afsc_preferences`: Dictionary to update with new AFSC \u2192 cadet preference lists.\n    - `a_pref_matrix`: Matrix representing cadet rankings from the AFSCs' perspective.\n    - `SOCs`, `afscs_acc_grp`, and cadet lists for each SOC.\n\n    Returns:\n    --------\n    dict: Updated `parameters` dictionary with modified `afsc_preferences` and `a_pref_matrix` reflecting\n    normalized OM-based preference rankings for Rated AFSCs.\n\n    Example:\n    --------\n    ```python\n    parameters = construct_rated_preferences_from_om_by_soc(parameters)\n    ```\n\n    See Also:\n    --------\n    [`determine_soc_rated_afscs`](../../../afccp/reference/data/preferences/#data.preferences.determine_soc_rated_afscs):\n        Identifies which AFSCs are rated within a given SOC.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Loop through all the parameters we need and make sure we have everything\n    for key in ['rr_om_matrix', 'ur_om_matrix', 'afsc_preferences', 'a_pref_matrix']:\n        if key not in p:\n            raise ValueError(\"Error. Parameter '\" + key + \"' not in the parameter dictionary. Please make sure you have\"\n                                                          \"AFSC preferences and Rated preferences from both sources \"\n                                                          \"of commissioning.\")\n\n    # Need to construct a \"combined Rated OM\" matrix with ALL cadets which also contains 0 if the cadet is ineligible\n    all_rated_afscs = p['afscs_acc_grp'][\"Rated\"]\n    dataset_dict = {soc: f'{soc[0]}r_om_matrix' for soc in p['SOCs']}\n    cadets_dict = {soc: f'{soc[0]}r_om_cadets' for soc in p['SOCs']}\n    combined_rated_om = {afsc: np.zeros(p['N']) for afsc in all_rated_afscs}\n\n    # Loop through all sources of commissioning\n    rated_cadets, rated_cadet_index_dict = {}, {}\n    for soc in p['SOCs']:\n\n        # Rated AFSCs for this SOC\n        rated_afscs = determine_soc_rated_afscs(soc, all_rated_afscs)\n\n        # Rated cadets for this SOC\n        rated_cadets[soc] = p[cadets_dict[soc]]\n\n        # Loop through SOC-specific rated AFSCs\n        for afsc_index, afsc in enumerate(rated_afscs):\n\n            # Need to re-normalize OM to make it fair across SOCs\n            nonzero_indices_in_soc_dataset = np.where(p[dataset_dict[soc]][:, afsc_index] != 0)[0]\n            num_eligible = len(nonzero_indices_in_soc_dataset)\n            sorted_eligible_indices = np.argsort(p[dataset_dict[soc]][:, afsc_index])[::-1][:num_eligible]\n            ordered_cadets = rated_cadets[soc][sorted_eligible_indices]\n            combined_rated_om[afsc][ordered_cadets] = np.arange(1, num_eligible + 1)[::-1] / (num_eligible + 1)\n\n    # Sort the OM to convert it into a 1-N\n    for afsc in all_rated_afscs:\n        j = np.where(p['afscs'] == afsc)[0][0]\n\n        # Get AFSC preferences (list of cadet indices in order)\n        ineligibles = np.where(combined_rated_om[afsc] == 0)[0]\n        num_ineligible = len(ineligibles)  # Ineligibles are going to be at the bottom of the list (and we remove them)\n        p['afsc_preferences'][j] = np.argsort(combined_rated_om[afsc])[::-1][:p['N'] - num_ineligible]\n\n        # Reset this AFSC's \"preference matrix\" column\n        p['a_pref_matrix'][:, j] = np.zeros(p['N'])\n\n        # Since 'afsc_preferences' is an array of cadet indices, we can do this\n        p['a_pref_matrix'][p['afsc_preferences'][j], j] = np.arange(1, len(p['afsc_preferences'][j]) + 1)\n\n    return p  # Return updated parameters\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.fill_remaining_preferences","title":"<code>fill_remaining_preferences(parameters)</code>","text":"<p>Fill in Remaining Cadet Preferences to Complete the Preference Matrix.</p> <p>This function ensures that each cadet has a complete preference list across all AFSCs. It fills in any unranked AFSCs (excluding bottom 2 and last choice) with incrementing ranks, followed by bottom 2 preferences, and finally the explicitly marked last choice if applicable.</p>"},{"location":"reference/data/preferences/#data.preferences.fill_remaining_preferences--parameters","title":"Parameters:","text":"<p>parameters (dict): The problem instance parameters, containing:     - <code>cadet_preferences</code>: Dictionary of AFSC preference orderings per cadet.     - <code>c_pref_matrix</code>: Matrix of cadet preferences over AFSCs.     - <code>J^Bottom 2 Choices</code>: Dictionary of each cadet's bottom two AFSCs.     - <code>J^Last Choice</code>: Dictionary of each cadet's last AFSC choice.     - <code>I</code>, <code>J</code>, <code>M</code>: Indexed sets of cadets, AFSCs, and unmatched AFSC index.</p>"},{"location":"reference/data/preferences/#data.preferences.fill_remaining_preferences--returns","title":"Returns:","text":"<p>dict: Updated parameters dictionary with a fully filled <code>c_pref_matrix</code>.</p>"},{"location":"reference/data/preferences/#data.preferences.fill_remaining_preferences--example","title":"Example:","text":"<pre><code>parameters = fill_remaining_preferences(parameters)\n</code></pre> Source code in <code>afccp/data/preferences.py</code> <pre><code>def fill_remaining_preferences(parameters):\n    \"\"\"\n    Fill in Remaining Cadet Preferences to Complete the Preference Matrix.\n\n    This function ensures that each cadet has a complete preference list across all AFSCs. It fills in any\n    unranked AFSCs (excluding bottom 2 and last choice) with incrementing ranks, followed by bottom 2 preferences,\n    and finally the explicitly marked last choice if applicable.\n\n    Parameters:\n    --------\n    parameters (dict): The problem instance parameters, containing:\n        - `cadet_preferences`: Dictionary of AFSC preference orderings per cadet.\n        - `c_pref_matrix`: Matrix of cadet preferences over AFSCs.\n        - `J^Bottom 2 Choices`: Dictionary of each cadet's bottom two AFSCs.\n        - `J^Last Choice`: Dictionary of each cadet's last AFSC choice.\n        - `I`, `J`, `M`: Indexed sets of cadets, AFSCs, and unmatched AFSC index.\n\n    Returns:\n    --------\n    dict: Updated parameters dictionary with a fully filled `c_pref_matrix`.\n\n    Example:\n    --------\n    ```python\n    parameters = fill_remaining_preferences(parameters)\n    ```\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Loop through all cadets\n    for i in p['I']:\n\n        # Loop through all \"indifferent\" AFSCs that they are eligible for\n        pref_num = len(p['cadet_preferences'][i]) + 1\n        for j in p['J']:\n\n            # The AFSC is not in the cadet's preferences and it's not in the bottom choices\n            if j not in p['cadet_preferences'][i] and \\\n                    j not in p['J^Bottom 2 Choices'][i] and j != p['J^Last Choice'][i]:\n                p['c_pref_matrix'][i, j] = pref_num\n                pref_num += 1\n\n        # Loop through bottom 2 choices\n        for j in p['J^Bottom 2 Choices'][i]:\n            p['c_pref_matrix'][i, j] = pref_num\n            pref_num += 1\n\n        # Set last choice preference if applicable\n        if p['J^Last Choice'][i] != p['M']:\n            p['c_pref_matrix'][i, p['J^Last Choice'][i]] = pref_num\n\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.remove_ineligible_cadet_choices","title":"<code>remove_ineligible_cadet_choices(parameters, printing=False)</code>","text":"<p>Clean Ineligible Cadet-AFSC Preference Pairings.</p> <p>This function audits and cleans the cadet-AFSC preference matrices by removing any inconsistent or ineligible pairings based on the qualification matrix. It ensures that both <code>c_pref_matrix</code> (cadet preferences) and <code>a_pref_matrix</code> (AFSC preferences) reflect only valid, eligible pairings. It also updates the qualification matrix to reflect enforced ineligibility for problematic pairs.</p>"},{"location":"reference/data/preferences/#data.preferences.remove_ineligible_cadet_choices--parameters","title":"Parameters:","text":"<p>parameters (dict): Dictionary of the problem instance parameters.</p> <p>printing (bool, optional): If True, logs every change made. Default is False.</p>"},{"location":"reference/data/preferences/#data.preferences.remove_ineligible_cadet_choices--returns","title":"Returns:","text":"<p>dict: Updated parameters dictionary with cleaned preference matrices and enforced eligibility alignment.</p>"},{"location":"reference/data/preferences/#data.preferences.remove_ineligible_cadet_choices--example","title":"Example:","text":"<pre><code>parameters = remove_ineligible_cadet_choices(parameters, printing=True)\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.remove_ineligible_cadet_choices--see-also","title":"See Also:","text":"<ul> <li><code>fill_remaining_preferences</code>:   Fills in arbitrary preferences for cadets, excluding bottom-ranked AFSCs.</li> <li><code>parameter_sets_additions</code>:   Rebuilds indexed sets after modifying eligibility or preference matrices.</li> </ul> Source code in <code>afccp/data/preferences.py</code> <pre><code>def remove_ineligible_cadet_choices(parameters, printing=False):\n    \"\"\"\n    Clean Ineligible Cadet-AFSC Preference Pairings.\n\n    This function audits and cleans the cadet-AFSC preference matrices by removing any inconsistent or ineligible pairings\n    based on the qualification matrix. It ensures that both `c_pref_matrix` (cadet preferences) and `a_pref_matrix`\n    (AFSC preferences) reflect only valid, eligible pairings. It also updates the qualification matrix to reflect enforced\n    ineligibility for problematic pairs.\n\n    Parameters:\n    --------\n    parameters (dict): Dictionary of the problem instance parameters.\n\n    printing (bool, optional): If True, logs every change made. Default is False.\n\n    Returns:\n    --------\n    dict: Updated parameters dictionary with cleaned preference matrices and enforced eligibility alignment.\n\n    Example:\n    --------\n    ```python\n    parameters = remove_ineligible_cadet_choices(parameters, printing=True)\n    ```\n\n    See Also:\n    --------\n    - [`fill_remaining_preferences`](../../../afccp/reference/data/preferences/#data.preferences.fill_remaining_preferences):\n      Fills in arbitrary preferences for cadets, excluding bottom-ranked AFSCs.\n    - [`parameter_sets_additions`](../../../afccp/reference/data/adjustments/#data.adjustments.parameter_sets_additions):\n      Rebuilds indexed sets after modifying eligibility or preference matrices.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # This is my final correction for preferences to make it all match up\n    num_removals = 0\n    lines = []\n    for i in p['I']:\n        for j in p['J']:\n            afsc = p['afscs'][j]  # AFSC name\n\n            # Cadet not eligible based on degree qualification matrix\n            if i not in p['I^E'][j]:\n\n                # AFSC is currently in the cadet's preference list\n                if p['c_pref_matrix'][i, j] != 0:\n                    p['c_pref_matrix'][i, j] = 0\n                    num_removals += 1\n                    lines.append('Edit ' + str(num_removals) + ': Cadet ' + str(i) + ' not eligible for ' + afsc +\n                                 ' based on degree qualification matrix but the AFSC was in the cadet preference list. '\n                                 'c_pref_matrix position (' + str(i) + \", \" + str(j) + ') set to 0.')\n\n                # Cadet is currently in the AFSC's preference list\n                if p['a_pref_matrix'][i, j] != 0:\n                    p['a_pref_matrix'][i, j] = 0\n                    num_removals += 1\n                    lines.append('Edit ' + str(num_removals) + ': Cadet ' + str(i) + ' not eligible for ' + afsc +\n                                 ' based on degree qualification matrix but the cadet was in the AFSC preference list. '\n                                 'a_pref_matrix position (' + str(i) + \", \" + str(j) + ') set to 0.')\n\n            # Cadet is currently eligible based on degree qualification matrix\n            else:\n\n                # If there's already an ineligible tier in this AFSC, we use it in case we need to adjust qual matrix\n                if \"I = 0\" in p['Deg Tiers'][j]:\n                    val = \"I\" + str(p['t_count'][j])\n                else:\n                    val = \"I\" + str(p['t_count'][j] + 1)\n\n                # The cadet is not in the AFSC's preference list\n                if p['a_pref_matrix'][i, j] == 0:\n\n                    # The AFSC is in the cadet's preference list\n                    if p['c_pref_matrix'][i, j] != 0:\n                        p['c_pref_matrix'][i, j] = 0\n                        num_removals += 1\n                        lines.append('Edit ' + str(num_removals) + ': Cadet ' + str(i) + ' eligible for ' + afsc +\n                                     ' based on degree qualification matrix but the cadet was not in the AFSC preference list. '\n                                     'c_pref_matrix position (' + str(i) + \", \" + str(j) +\n                                     ') set to 0 and qual position adjusted to ' + val + \".\")\n\n                    # The AFSC is not in the cadet's preference list\n                    else:\n                        num_removals += 1\n                        lines.append('Edit ' + str(num_removals) + ': Cadet ' + str(i) + ' eligible for ' + afsc +\n                                     ' based on degree qualification matrix but the cadet/afsc pairing was in neither '\n                                     'matrix (a_pref_matrix or c_pref_matrix). Both a_pref_matrix and c_pref_matrix '\n                                     'position (' + str(i) + \", \" + str(j) + ') were already 0 so only qual position was '\n                                                                             'adjusted to ' + val + \".\")\n\n                    # Force ineligibility in the qual matrix as well\n                    p['qual'][i, j] = val\n                    p['eligible'][i, j] = 0\n                    p['ineligible'][i, j] = 0\n\n                # The AFSC is not in the cadet's preference list\n                if p['c_pref_matrix'][i, j] == 0:\n\n                    # The cadet is in the AFSC's preference list\n                    if p['a_pref_matrix'][i, j] != 0:\n                        p['a_pref_matrix'][i, j] = 0\n                        num_removals += 1\n                        lines.append('Edit ' + str(num_removals) + ': Cadet ' + str(i) + ' eligible for ' + afsc +\n                                     ' based on degree qualification matrix but the AFSC was not in the cadet preference list. '\n                                     'a_pref_matrix position (' + str(i) + \", \" + str(j) +\n                                     ') set to 0 and qual position adjusted to ' + val + \".\")\n\n                    # The cadet is not in the AFSC's preference list\n                    else:\n                        num_removals += 1\n                        lines.append('Edit ' + str(num_removals) + ': Cadet ' + str(i) + ' eligible for ' + afsc +\n                                     ' based on degree qualification matrix but the cadet/afsc pairing was in neither '\n                                     'matrix (a_pref_matrix or c_pref_matrix). Both a_pref_matrix and c_pref_matrix '\n                                     'position (' + str(i) + \", \" + str(\n                                         j) + ') were already 0 so only qual position was '\n                                              'adjusted to ' + val + \".\")\n\n                    # Force ineligibility in the qual matrix as well\n                    p['qual'][i, j] = val\n                    p['eligible'][i, j] = 0\n                    p['ineligible'][i, j] = 0\n\n    # Print statement\n    if printing:\n        for line in lines:\n            print(line)\n        print(num_removals, \"total adjustments.\")\n    return p  # Return parameters\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.update_preference_matrices","title":"<code>update_preference_matrices(parameters)</code>","text":"<p>Reconstructs cadet and AFSC preference matrices based on index-based preference lists.</p> <p>This function updates the <code>c_pref_matrix</code> (cadet preference matrix) and <code>a_pref_matrix</code> (AFSC preference matrix) using the indexed preference lists provided in <code>cadet_preferences</code> and <code>afsc_preferences</code>, respectively. Cadets and AFSCs with empty preferences are skipped.</p>"},{"location":"reference/data/preferences/#data.preferences.update_preference_matrices--parameters","title":"Parameters","text":"<p>parameters : dict A parameter dictionary containing:</p> <ul> <li><code>N</code> : int, total number of cadets</li> <li><code>M</code> : int, total number of AFSCs</li> <li><code>I</code> : list of cadet indices</li> <li><code>J</code> : list of AFSC indices</li> <li><code>cadet_preferences</code> : dictionary of lists; each list contains AFSC indices ranked by each cadet</li> <li><code>afsc_preferences</code> : dictionary of lists; each list contains cadet indices ranked by each AFSC</li> </ul>"},{"location":"reference/data/preferences/#data.preferences.update_preference_matrices--returns","title":"Returns","text":"<p>dict Updated parameter dictionary with:</p> <ul> <li><code>c_pref_matrix</code> : ndarray, shape (N, M)     Preference matrix where entry (i, j) indicates cadet i's rank of AFSC j (0 if not ranked)</li> <li><code>a_pref_matrix</code> : ndarray, shape (N, M)     Preference matrix where entry (i, j) indicates AFSC j's rank of cadet i (0 if not ranked)</li> </ul>"},{"location":"reference/data/preferences/#data.preferences.update_preference_matrices--examples","title":"Examples","text":"<pre><code>from afccp.data.preferences import update_preference_matrices\nparameters = update_preference_matrices(parameters)\n</code></pre> Source code in <code>afccp/data/preferences.py</code> <pre><code>def update_preference_matrices(parameters):\n    \"\"\"\n    Reconstructs cadet and AFSC preference matrices based on index-based preference lists.\n\n    This function updates the `c_pref_matrix` (cadet preference matrix) and `a_pref_matrix`\n    (AFSC preference matrix) using the indexed preference lists provided in\n    `cadet_preferences` and `afsc_preferences`, respectively. Cadets and AFSCs with empty\n    preferences are skipped.\n\n    Parameters\n    ----------\n    parameters : dict\n    A parameter dictionary containing:\n\n    - `N` : int, total number of cadets\n    - `M` : int, total number of AFSCs\n    - `I` : list of cadet indices\n    - `J` : list of AFSC indices\n    - `cadet_preferences` : dictionary of lists; each list contains AFSC indices ranked by each cadet\n    - `afsc_preferences` : dictionary of lists; each list contains cadet indices ranked by each AFSC\n\n    Returns\n    -------\n    dict\n    Updated parameter dictionary with:\n\n    - `c_pref_matrix` : ndarray, shape (N, M)\n        Preference matrix where entry (i, j) indicates cadet i's rank of AFSC j (0 if not ranked)\n    - `a_pref_matrix` : ndarray, shape (N, M)\n        Preference matrix where entry (i, j) indicates AFSC j's rank of cadet i (0 if not ranked)\n\n    Examples\n    --------\n    ```python\n    from afccp.data.preferences import update_preference_matrices\n    parameters = update_preference_matrices(parameters)\n    ```\n    \"\"\"\n    # Shorthand\n    p = parameters\n\n    # Update the cadet preference matrix (c_pref_matrix)\n    if 'cadet_preferences' in p:\n\n        # Since 'cadet_preferences' is an array of AFSC indices, we can do this\n        p['c_pref_matrix'] = np.zeros([p['N'], p['M']]).astype(int)\n        for i in p['I']:\n\n            # If this cadet does not have any preferences, we skip them (must be an OTS candidate)\n            if len(p['cadet_preferences'][i]) == 0:\n                continue\n            p['c_pref_matrix'][i, p['cadet_preferences'][i]] = np.arange(1, len(p['cadet_preferences'][i]) + 1)\n\n    # Update the AFSC preference matrix (a_pref_matrix)\n    if 'afsc_preferences' in p:\n\n        # Since 'afsc_preferences' is an array of cadet indices, we can do this\n        p['a_pref_matrix'] = np.zeros([p['N'], p['M']]).astype(int)\n        for j in p['J']:\n            p['a_pref_matrix'][p['afsc_preferences'][j], j] = np.arange(1, len(p['afsc_preferences'][j]) + 1)\n\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.update_first_choice_cadet_utility_to_one","title":"<code>update_first_choice_cadet_utility_to_one(parameters, printing=True)</code>","text":"<p>Fix First-Choice Cadet Utility to One.</p> <p>Updates the utility matrix so that each cadet's top-ranked AFSC is assigned a utility value of 1.0, indicating maximum preference. This only applies to cadets who have valid preference lists.</p>"},{"location":"reference/data/preferences/#data.preferences.update_first_choice_cadet_utility_to_one--parameters","title":"Parameters","text":"<p>parameters : dict A parameter dictionary containing:</p> <ul> <li><code>I</code> : list of int   Cadet indices.</li> <li><code>cadet_preferences</code> : dict of lists   Each cadet's list of AFSC indices in ranked order of preference.</li> <li><code>utility</code> : ndarray of shape (N, M)   Matrix of cadet utility values where entry (i, j) is cadet i's utility for AFSC j.</li> </ul> <p>printing : bool, optional If True, prints the number of cadets updated and their indices. Default is True.</p>"},{"location":"reference/data/preferences/#data.preferences.update_first_choice_cadet_utility_to_one--returns","title":"Returns","text":"<p>ndarray: Updated utility matrix with each cadet's first choice AFSC set to a utility of 1.</p>"},{"location":"reference/data/preferences/#data.preferences.update_first_choice_cadet_utility_to_one--examples","title":"Examples","text":"<pre><code>updated_utility = update_first_choice_cadet_utility_to_one(parameters)\n</code></pre> Source code in <code>afccp/data/preferences.py</code> <pre><code>def update_first_choice_cadet_utility_to_one(parameters, printing=True):\n    \"\"\"\n    Fix First-Choice Cadet Utility to One.\n\n    Updates the utility matrix so that each cadet's top-ranked AFSC is assigned a utility value of 1.0,\n    indicating maximum preference. This only applies to cadets who have valid preference lists.\n\n    Parameters\n    ----------\n    parameters : dict\n    A parameter dictionary containing:\n\n    - `I` : list of int\n      Cadet indices.\n    - `cadet_preferences` : dict of lists\n      Each cadet's list of AFSC indices in ranked order of preference.\n    - `utility` : ndarray of shape (N, M)\n      Matrix of cadet utility values where entry (i, j) is cadet i's utility for AFSC j.\n\n    printing : bool, optional\n    If True, prints the number of cadets updated and their indices. Default is True.\n\n    Returns\n    -------\n    ndarray:\n    Updated utility matrix with each cadet's first choice AFSC set to a utility of 1.\n\n    Examples\n    --------\n    ```python\n    updated_utility = update_first_choice_cadet_utility_to_one(parameters)\n    ```\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Loop through each cadet and make their first choice AFSC have a utility of 1\n    fixed_cadets = []\n    for i in p['I']:\n\n        # If this cadet does not have any preferences, we skip them (must be an OTS candidate)\n        if len(p['cadet_preferences'][i]) == 0:\n            continue\n\n        # Fix the first choice\n        if p['utility'][i, p['cadet_preferences'][i][0]] != 1:\n            p['utility'][i, p['cadet_preferences'][i][0]] = 1\n            fixed_cadets.append(i)\n\n    if printing:\n        print_str = f'Fixed {len(fixed_cadets)} first choice cadet utility values to 100%.\\nCadets: {fixed_cadets}'\n        print(print_str)\n\n    return p['utility']\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.convert_afsc_preferences_to_percentiles","title":"<code>convert_afsc_preferences_to_percentiles(parameters)</code>","text":"<p>Convert AFSC Preferences to Percentile-Based Utilities.</p> <p>This method transforms each AFSC's preference list into a normalized percentile utility score for each cadet. Higher-ranked cadets receive higher percentile scores (closer to 1), while lower-ranked cadets receive lower scores (closer to 0). These scores are stored in a new matrix called <code>afsc_utility</code>.</p>"},{"location":"reference/data/preferences/#data.preferences.convert_afsc_preferences_to_percentiles--parameters","title":"Parameters","text":"<p>parameters: dict A parameter dictionary containing:</p> <ul> <li><code>N</code> : int   Total number of cadets</li> <li><code>M</code> : int   Total number of AFSCs</li> <li><code>J</code> : list of AFSC indices</li> <li><code>afsc_preferences</code> : dict   Dictionary where each key is an AFSC index and each value is a list of cadet indices ranked by that AFSC</li> </ul>"},{"location":"reference/data/preferences/#data.preferences.convert_afsc_preferences_to_percentiles--returns","title":"Returns","text":"<p>parameters : dict Updated parameter dictionary with:</p> <ul> <li><code>afsc_utility</code>: ndarray of shape (N, M)   Matrix of normalized percentile utility values for each cadet-AFSC pair. A value of 1.0 indicates   top preference, and values decrease with lower preference.</li> </ul>"},{"location":"reference/data/preferences/#data.preferences.convert_afsc_preferences_to_percentiles--examples","title":"Examples","text":"<pre><code># Define AFSC preferences\nparameters = {\n    'N': 3,\n    'M': 2,\n    'J': [0, 1],\n    'afsc_preferences': {\n        0: [2, 1, 0],\n        1: [1, 0]\n    }\n}\n\n# Convert preferences to percentiles\nupdated = convert_afsc_preferences_to_percentiles(parameters)\n\n# View result\nprint(updated['afsc_utility'])\n# Output:\n# array([[0.333, 0.5],\n#        [0.666, 1.0],\n#        [1.0,   0.0]])\n</code></pre> Source code in <code>afccp/data/preferences.py</code> <pre><code>def convert_afsc_preferences_to_percentiles(parameters):\n    \"\"\"\n    Convert AFSC Preferences to Percentile-Based Utilities.\n\n    This method transforms each AFSC's preference list into a normalized percentile utility score\n    for each cadet. Higher-ranked cadets receive higher percentile scores (closer to 1), while lower-ranked\n    cadets receive lower scores (closer to 0). These scores are stored in a new matrix called `afsc_utility`.\n\n    Parameters\n    ----------\n    parameters: dict\n    A parameter dictionary containing:\n\n    - `N` : int\n      Total number of cadets\n    - `M` : int\n      Total number of AFSCs\n    - `J` : list of AFSC indices\n    - `afsc_preferences` : dict\n      Dictionary where each key is an AFSC index and each value is a list of cadet indices ranked by that AFSC\n\n    Returns\n    -------\n    parameters : dict\n    Updated parameter dictionary with:\n\n    - `afsc_utility`: ndarray of shape (N, M)\n      Matrix of normalized percentile utility values for each cadet-AFSC pair. A value of 1.0 indicates\n      top preference, and values decrease with lower preference.\n\n    Examples\n    --------\n    ```python\n    # Define AFSC preferences\n    parameters = {\n        'N': 3,\n        'M': 2,\n        'J': [0, 1],\n        'afsc_preferences': {\n            0: [2, 1, 0],\n            1: [1, 0]\n        }\n    }\n\n    # Convert preferences to percentiles\n    updated = convert_afsc_preferences_to_percentiles(parameters)\n\n    # View result\n    print(updated['afsc_utility'])\n    # Output:\n    # array([[0.333, 0.5],\n    #        [0.666, 1.0],\n    #        [1.0,   0.0]])\n    ```\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Get normalized percentiles (Average of 0.5)\n    p[\"afsc_utility\"] = np.zeros([p['N'], p['M']])\n    for j in p['J']:\n        p['afsc_utility'][p['afsc_preferences'][j], j] = \\\n            np.arange(1, len(p['afsc_preferences'][j]) + 1)[::-1] / len(p['afsc_preferences'][j])\n\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.update_cadet_columns_from_matrices","title":"<code>update_cadet_columns_from_matrices(parameters)</code>","text":"<p>Convert cadet preference matrix to preference columns of AFSC names and calculate utility columns.</p> <p>This function takes the cadet preference matrix (NxM) where cadet \"ranks\" are specified and converts it to preference columns (NxP) of AFSC names, where P is the number of AFSC preferences for each cadet. It uses this preference information alongside the utility dataframe (NxP) to extract the utility columns (NxP) as well.</p> <p>Args: parameters (dict): A dictionary containing the following elements:</p> <ul> <li>\"c_pref_matrix\" (numpy.ndarray): Cadet preference matrix (NxM) with cadet ranks.</li> <li>\"P\" (int): Number of AFSC preferences for each cadet.</li> <li>\"N\" (int): Total number of cadets.</li> <li>\"I\" (list): List of cadet indices.</li> <li>\"M\" (int): Total number of AFSCs.</li> <li>\"afscs\" (numpy.ndarray): Array of AFSC names.</li> <li>\"num_util\" (int): Number of utility values to extract.</li> <li>\"utility\" (numpy.ndarray): Utility dataframe (NxM) containing utility values for cadets and AFSCs.</li> </ul> <p>Returns: tuple: A tuple containing two elements:</p> <ul> <li>preferences (numpy.ndarray): Cadet preference columns (NxP) with AFSC names.</li> <li>utilities_array (numpy.ndarray): Utility columns (NxP) for each cadet and AFSC preference.</li> </ul> Source code in <code>afccp/data/preferences.py</code> <pre><code>def update_cadet_columns_from_matrices(parameters):\n    \"\"\"\n    Convert cadet preference matrix to preference columns of AFSC names and calculate utility columns.\n\n    This function takes the cadet preference matrix (NxM) where cadet \"ranks\" are specified and converts it to\n    preference columns (NxP) of AFSC names, where P is the number of AFSC preferences for each cadet. It uses\n    this preference information alongside the utility dataframe (NxP) to extract the utility columns (NxP) as well.\n\n    Args:\n    parameters (dict): A dictionary containing the following elements:\n\n    - \"c_pref_matrix\" (numpy.ndarray): Cadet preference matrix (NxM) with cadet ranks.\n    - \"P\" (int): Number of AFSC preferences for each cadet.\n    - \"N\" (int): Total number of cadets.\n    - \"I\" (list): List of cadet indices.\n    - \"M\" (int): Total number of AFSCs.\n    - \"afscs\" (numpy.ndarray): Array of AFSC names.\n    - \"num_util\" (int): Number of utility values to extract.\n    - \"utility\" (numpy.ndarray): Utility dataframe (NxM) containing utility values for cadets and AFSCs.\n\n    Returns:\n    tuple: A tuple containing two elements:\n\n    - preferences (numpy.ndarray): Cadet preference columns (NxP) with AFSC names.\n    - utilities_array (numpy.ndarray): Utility columns (NxP) for each cadet and AFSC preference.\n\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Initialize data\n    preference_matrix = copy.deepcopy(p[\"c_pref_matrix\"])\n    preferences = np.array([[\" \" * 10 for _ in range(p['P'])] for _ in range(p['N'])])\n    utilities_array = np.zeros([p['N'], p['P']])\n    for i in p['I']:\n\n        # Eliminate AFSCs that weren't in the cadet's preference list (Change the choice to a large #)\n        zero_indices = np.where(preference_matrix[i, :] == 0)[0]\n        preference_matrix[i, zero_indices] = 100\n\n        # Get the ordered list of AFSCs\n        indices = np.argsort(preference_matrix[i, :])  # [::-1]  #.nonzero()[0]\n        ordered_afscs = p[\"afscs\"][indices][:p[\"M\"] - len(zero_indices)][:p[\"P\"]]\n        ordered_utilities = p[\"utility\"][i, indices][:p[\"M\"] - len(zero_indices)][:p[\"num_util\"]]\n\n        # Put the utilities and preferences in the correct spots\n        np.put(utilities_array[i, :], np.arange(len(ordered_utilities)), ordered_utilities)\n        np.put(preferences[i, :], np.arange(len(ordered_afscs)), ordered_afscs)\n\n    return preferences, utilities_array\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.update_cadet_utility_matrices","title":"<code>update_cadet_utility_matrices(parameters)</code>","text":"<p>Update Cadet Utility Matrices from Reported Utilities.</p> <p>This method reads each cadet's self-reported utility values (from <code>c_utilities</code>) and updates the <code>utility</code> matrix accordingly. It also creates the normalized <code>cadet_utility</code> matrix based on ordinal preferences or a utility-based formula, depending on whether <code>last_afsc</code> is present in the parameters.</p>"},{"location":"reference/data/preferences/#data.preferences.update_cadet_utility_matrices--parameters","title":"Parameters","text":"<p>parameters : dict A parameter dictionary containing:</p> <ul> <li><code>N</code> : int, total number of cadets</li> <li><code>M</code> : int, total number of AFSCs</li> <li><code>I</code> : list of cadet indices</li> <li><code>cadet_preferences</code> : dict of lists; each list contains AFSC indices ranked by cadet</li> <li><code>c_utilities</code> : ndarray, shape (N, P); cadet-reported utilities aligned with their preferences</li> <li><code>num_util</code> : int; number of utility values reported per cadet</li> <li><code>last_afsc</code> (optional) : str; used to determine which utility processing function to apply</li> </ul>"},{"location":"reference/data/preferences/#data.preferences.update_cadet_utility_matrices--returns","title":"Returns","text":"<p>parameters : dict Updated parameter dictionary with:</p> <ul> <li><code>utility</code> : ndarray, shape (N, M+1)     Utility matrix with cadet-reported values; last column represents unmatched utility</li> <li><code>cadet_utility</code> : ndarray     Normalized utility matrix calculated from rankings or weighted formula</li> </ul>"},{"location":"reference/data/preferences/#data.preferences.update_cadet_utility_matrices--raises","title":"Raises","text":"<p>ValueError     If required fields (<code>cadet_preferences</code>, <code>c_utilities</code>) are missing from the parameter dictionary.</p>"},{"location":"reference/data/preferences/#data.preferences.update_cadet_utility_matrices--examples","title":"Examples","text":"<pre><code>parameters = update_cadet_utility_matrices(parameters)\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.update_cadet_utility_matrices--see-also","title":"See Also","text":"<ul> <li><code>create_final_cadet_utility_matrix_from_new_formula</code></li> <li><code>create_new_cadet_utility_matrix</code></li> </ul> Source code in <code>afccp/data/preferences.py</code> <pre><code>def update_cadet_utility_matrices(parameters):\n    \"\"\"\n    Update Cadet Utility Matrices from Reported Utilities.\n\n    This method reads each cadet's self-reported utility values (from `c_utilities`) and updates the `utility` matrix accordingly.\n    It also creates the normalized `cadet_utility` matrix based on ordinal preferences or a utility-based formula,\n    depending on whether `last_afsc` is present in the parameters.\n\n    Parameters\n    ----------\n    parameters : dict\n    A parameter dictionary containing:\n\n    - `N` : int, total number of cadets\n    - `M` : int, total number of AFSCs\n    - `I` : list of cadet indices\n    - `cadet_preferences` : dict of lists; each list contains AFSC indices ranked by cadet\n    - `c_utilities` : ndarray, shape (N, P); cadet-reported utilities aligned with their preferences\n    - `num_util` : int; number of utility values reported per cadet\n    - `last_afsc` (optional) : str; used to determine which utility processing function to apply\n\n    Returns\n    -------\n    parameters : dict\n    Updated parameter dictionary with:\n\n    - `utility` : ndarray, shape (N, M+1)\n        Utility matrix with cadet-reported values; last column represents unmatched utility\n    - `cadet_utility` : ndarray\n        Normalized utility matrix calculated from rankings or weighted formula\n\n    Raises\n    ------\n    ValueError\n        If required fields (`cadet_preferences`, `c_utilities`) are missing from the parameter dictionary.\n\n    Examples\n    --------\n    ```python\n    parameters = update_cadet_utility_matrices(parameters)\n    ```\n\n    See Also\n    --------\n    - [`create_final_cadet_utility_matrix_from_new_formula`](../../../../afccp/reference/data/preferences/#data.preferences.create_final_cadet_utility_matrix_from_new_formula)\n    - [`create_new_cadet_utility_matrix`](../../../../afccp/reference/data/preferences/#data.preferences.create_new_cadet_utility_matrix)\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Simple error checking\n    required_parameters = ['cadet_preferences', 'c_utilities']\n    for param in required_parameters:\n        if param not in p:\n            raise ValueError(\"Error. Parameter '\" + param + \"' not in instance parameters. It is required.\")\n\n    # Initialize matrix (reported cadet utility)\n    p['utility'] = np.zeros((p['N'], p['M'] + 1))  # Additional column for unmatched cadets\n\n    # Loop through each cadet\n    for i in p['I']:\n\n        # If this cadet does not have any preferences, we skip them (must be an OTS candidate)\n        if len(p['cadet_preferences'][i]) == 0:\n            continue\n\n        # List of ordered AFSC indices (by cadet preference) up to the number of utilities\n        afsc_indices = p['cadet_preferences'][i][:p['num_util']]\n\n        # Fill in the reported utilities\n        p['utility'][i, afsc_indices] = p['c_utilities'][i, :len(afsc_indices)]\n\n    # Create the \"cadet_utility\" matrix by re-calculating utility based on ordinal rankings\n    if 'last_afsc' in p:\n        p = create_final_cadet_utility_matrix_from_new_formula(p)\n    else:\n        p = create_new_cadet_utility_matrix(p)\n\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.modify_rated_cadet_lists_based_on_eligibility","title":"<code>modify_rated_cadet_lists_based_on_eligibility(parameters, printing=True)</code>","text":"<p>Remove Ineligible Rated Cadets from Rated Lists and Matrices.</p> <p>This method ensures that cadets in each Source of Commissioning (SOC)'s rated list are only included if they have at least one rated AFSC preference. Cadets without any rated preferences are removed from the rated cadet list for that SOC as well as the corresponding rated order-of-merit matrix (e.g., 'rr_om_matrix' for ROTC).</p>"},{"location":"reference/data/preferences/#data.preferences.modify_rated_cadet_lists_based_on_eligibility--parameters","title":"Parameters","text":"<p>parameters : dict A dictionary of model parameters including:</p> <ul> <li><code>SOCs</code> : list of str     List of Source of Commissioning identifiers (e.g., ['ROTC', 'USAFA', 'OTS'])</li> <li><code>Rated Cadets</code> : dict     Dictionary mapping SOC names to arrays of rated cadet indices</li> <li><code>Rated Choices</code> : dict     Dictionary mapping SOC names to dicts of cadet-rated-AFSC preferences</li> <li><code>rr_om_matrix</code>, <code>ur_om_matrix</code>, etc. : ndarray     Matrices used in rated order-of-merit calculations by SOC</li> </ul> <p>printing : bool, optional     If True (default), prints a summary of the cadets removed and the matrices updated.</p>"},{"location":"reference/data/preferences/#data.preferences.modify_rated_cadet_lists_based_on_eligibility--returns","title":"Returns","text":"<p>dict The updated parameter dictionary with:</p> <ul> <li>Rated cadet lists pruned of cadets lacking rated preferences</li> <li>Rated order-of-merit matrices updated to exclude removed cadets</li> </ul>"},{"location":"reference/data/preferences/#data.preferences.modify_rated_cadet_lists_based_on_eligibility--examples","title":"Examples","text":"<pre><code>parameters = modify_rated_cadet_lists_based_on_eligibility(parameters, printing=True)\n</code></pre> Source code in <code>afccp/data/preferences.py</code> <pre><code>def modify_rated_cadet_lists_based_on_eligibility(parameters, printing=True):\n    \"\"\"\n    Remove Ineligible Rated Cadets from Rated Lists and Matrices.\n\n    This method ensures that cadets in each Source of Commissioning (SOC)'s rated list are only included if they have at least\n    one rated AFSC preference. Cadets without any rated preferences are removed from the rated cadet list for that SOC as well as\n    the corresponding rated order-of-merit matrix (e.g., 'rr_om_matrix' for ROTC).\n\n    Parameters\n    ----------\n    parameters : dict\n    A dictionary of model parameters including:\n\n    - `SOCs` : list of str\n        List of Source of Commissioning identifiers (e.g., ['ROTC', 'USAFA', 'OTS'])\n    - `Rated Cadets` : dict\n        Dictionary mapping SOC names to arrays of rated cadet indices\n    - `Rated Choices` : dict\n        Dictionary mapping SOC names to dicts of cadet-rated-AFSC preferences\n    - `rr_om_matrix`, `ur_om_matrix`, etc. : ndarray\n        Matrices used in rated order-of-merit calculations by SOC\n\n    printing : bool, optional\n        If True (default), prints a summary of the cadets removed and the matrices updated.\n\n    Returns\n    -------\n    dict\n    The updated parameter dictionary with:\n\n    - Rated cadet lists pruned of cadets lacking rated preferences\n    - Rated order-of-merit matrices updated to exclude removed cadets\n\n    Examples\n    --------\n    ```python\n    parameters = modify_rated_cadet_lists_based_on_eligibility(parameters, printing=True)\n    ```\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # At least one rated preference for rated eligible\n    for soc in p['SOCs']:\n        cadets_to_remove = []\n        cadet_indices_in_matrix = []\n        if soc in p['Rated Cadets']:\n            for idx, i in enumerate(p['Rated Cadets'][soc]):\n                if len(p['Rated Choices'][soc][i]) == 0:\n                    cadets_to_remove.append(i)\n                    cadet_indices_in_matrix.append(idx)\n\n        # Remove cadets from set of rated cadets for this SOC\n        cadets_to_remove = np.array(cadets_to_remove)\n        p['Rated Cadets'][soc] = p['Rated Cadets'][soc][~np.isin(p['Rated Cadets'][soc], cadets_to_remove)]\n\n        # Remove the cadet rows by position in the matrix\n        cadet_indices_in_matrix = np.array(cadet_indices_in_matrix)\n        if len(cadet_indices_in_matrix) &gt; 0:\n            parameter = f'{soc[0]}r_om_matrix'\n            p[parameter] = np.delete(p[parameter], cadet_indices_in_matrix, axis=0)\n\n            # Print results\n            if printing:\n                print_str = f\"We removed {len(cadets_to_remove)} cadets from {soc.upper()}'s rated cadet list.\\n\" \\\n                            f\"These were cadets {cadets_to_remove}.\\nWe removed them from {parameter} as well.\"\n                print(print_str)\n\n    # Return modified parameters\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.determine_soc_rated_afscs","title":"<code>determine_soc_rated_afscs(soc, all_rated_afscs)</code>","text":"<p>Filter Rated AFSCs Based on Source of Commissioning (SOC).</p> <p>This function selects only the AFSCs relevant to the given SOC (e.g., USAFA, ROTC, OTS) by excluding AFSCs that are tagged for other SOCs using suffixes like <code>_U</code>, <code>_R</code>, or <code>_O</code>.</p>"},{"location":"reference/data/preferences/#data.preferences.determine_soc_rated_afscs--parameters","title":"Parameters:","text":"<p>soc (str): The name of the source of commissioning (e.g., \"usafa\", \"rotc\"). all_rated_afscs (List[str]): A list of all rated AFSC strings.</p>"},{"location":"reference/data/preferences/#data.preferences.determine_soc_rated_afscs--returns","title":"Returns:","text":"<p>List[str]: Filtered list of AFSCs associated with the provided SOC.</p>"},{"location":"reference/data/preferences/#data.preferences.determine_soc_rated_afscs--example","title":"Example:","text":"<pre><code>determine_soc_rated_afscs(\"usafa\", [\"11XX_U\", \"11XX_R\", \"11XX_O\", \"12XX\", \"13B\", \"18X\"])\n# Returns: [\"11XX_U\", \"12XX\", \"13B\", \"18X\"]\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.determine_soc_rated_afscs--notes","title":"Notes:","text":"<p>The filtering logic assumes that the AFSC string may contain a SOC-specific suffix. - <code>_U</code> for USAFA - <code>_R</code> for ROTC - <code>_O</code> for OTS</p> Source code in <code>afccp/data/preferences.py</code> <pre><code>def determine_soc_rated_afscs(soc, all_rated_afscs):\n    \"\"\"\n    Filter Rated AFSCs Based on Source of Commissioning (SOC).\n\n    This function selects only the AFSCs relevant to the given SOC (e.g., USAFA, ROTC, OTS)\n    by excluding AFSCs that are tagged for other SOCs using suffixes like `_U`, `_R`, or `_O`.\n\n    Parameters:\n    --------\n    soc (str): The name of the source of commissioning (e.g., \"usafa\", \"rotc\").\n    all_rated_afscs (List[str]): A list of all rated AFSC strings.\n\n    Returns:\n    --------\n    List[str]: Filtered list of AFSCs associated with the provided SOC.\n\n    Example:\n    --------\n    ```python\n    determine_soc_rated_afscs(\"usafa\", [\"11XX_U\", \"11XX_R\", \"11XX_O\", \"12XX\", \"13B\", \"18X\"])\n    # Returns: [\"11XX_U\", \"12XX\", \"13B\", \"18X\"]\n    ```\n\n    Notes:\n    --------\n    The filtering logic assumes that the AFSC string may contain a SOC-specific suffix.\n    - `_U` for USAFA\n    - `_R` for ROTC\n    - `_O` for OTS\n    \"\"\"\n\n    # Rated AFSCs for this SOC\n    other_letters = [l for l in ['_U', '_R', '_O'] if l != f'_{soc[0].upper()}']\n    rated_afscs = []\n    for afsc in all_rated_afscs:\n        include = True\n        for l in other_letters:\n            if l in afsc:\n                include = False\n                break\n        if include:\n            rated_afscs.append(afsc)\n\n    return rated_afscs\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.create_new_cadet_utility_matrix","title":"<code>create_new_cadet_utility_matrix(parameters)</code>","text":"<p>Create New Cadet Utility Matrix from Rankings and Original Utilities.</p> <p>This function constructs a new \"cadet_utility\" matrix by blending each cadet's ordinal preferences (normalized rankings) with their original reported utility scores. The result is a weighted composite utility score for each cadet\u2013AFSC pair.</p> <p>The final matrix is stored in <code>cadet_utility</code> and is used in the optimization models.</p>"},{"location":"reference/data/preferences/#data.preferences.create_new_cadet_utility_matrix--parameters","title":"Parameters","text":"<p>parameters : dict Parameter dictionary containing:</p> <ul> <li><code>N</code> : int, number of cadets</li> <li><code>M</code> : int, number of AFSCs</li> <li><code>I</code> : list of cadet indices</li> <li><code>utility</code> : ndarray, cadet-reported utility matrix</li> <li><code>cadet_preferences</code> : dict, cadet-to-AFSC preference lists</li> <li><code>num_cadet_choices</code> : dict, number of ranked AFSCs per cadet</li> </ul>"},{"location":"reference/data/preferences/#data.preferences.create_new_cadet_utility_matrix--returns","title":"Returns","text":"<p>dict : Updated parameter dictionary with:</p> <ul> <li><code>cadet_utility</code> : ndarray, shape (N, M+1)     Blended utility matrix using normalized rankings and reported utilities.     Last column is reserved for unmatched cadets.</li> </ul>"},{"location":"reference/data/preferences/#data.preferences.create_new_cadet_utility_matrix--examples","title":"Examples","text":"<p><pre><code>parameters = {\n    'N': 2,\n    'M': 3,\n    'I': [0, 1],\n    'utility': np.array([[1.0, 0.8, 0.6, 0.0], [0.5, 1.0, 0.0, 0.0]]),\n    'cadet_preferences': {0: [0, 1, 2], 1: [1, 0]},\n    'num_cadet_choices': {0: 3, 1: 2}\n}\nupdated = create_new_cadet_utility_matrix(parameters)\nupdated['cadet_utility']\n</code></pre> Output: <pre><code>array([[1.  , 0.8 , 0.6 , 0.  ],\n       [1.  , 0.75, 0.  , 0.  ]])\n</code></pre></p>"},{"location":"reference/data/preferences/#data.preferences.create_new_cadet_utility_matrix--see-also","title":"See Also","text":"<ul> <li><code>update_cadet_utility_matrices</code></li> </ul> Source code in <code>afccp/data/preferences.py</code> <pre><code>def create_new_cadet_utility_matrix(parameters):\n    \"\"\"\n    Create New Cadet Utility Matrix from Rankings and Original Utilities.\n\n    This function constructs a new \"cadet_utility\" matrix by blending each cadet's ordinal preferences\n    (normalized rankings) with their original reported utility scores. The result is a weighted composite\n    utility score for each cadet\u2013AFSC pair.\n\n    The final matrix is stored in `cadet_utility` and is used in the optimization models.\n\n    Parameters\n    ----------\n    parameters : dict\n    Parameter dictionary containing:\n\n    - `N` : int, number of cadets\n    - `M` : int, number of AFSCs\n    - `I` : list of cadet indices\n    - `utility` : ndarray, cadet-reported utility matrix\n    - `cadet_preferences` : dict, cadet-to-AFSC preference lists\n    - `num_cadet_choices` : dict, number of ranked AFSCs per cadet\n\n    Returns\n    -------\n    dict :\n    Updated parameter dictionary with:\n\n    - `cadet_utility` : ndarray, shape (N, M+1)\n        Blended utility matrix using normalized rankings and reported utilities.\n        Last column is reserved for unmatched cadets.\n\n    Examples\n    --------\n    ```python\n    parameters = {\n        'N': 2,\n        'M': 3,\n        'I': [0, 1],\n        'utility': np.array([[1.0, 0.8, 0.6, 0.0], [0.5, 1.0, 0.0, 0.0]]),\n        'cadet_preferences': {0: [0, 1, 2], 1: [1, 0]},\n        'num_cadet_choices': {0: 3, 1: 2}\n    }\n    updated = create_new_cadet_utility_matrix(parameters)\n    updated['cadet_utility']\n    ```\n    Output:\n    ```\n    array([[1.  , 0.8 , 0.6 , 0.  ],\n           [1.  , 0.75, 0.  , 0.  ]])\n    ```\n\n    See Also\n    --------\n    - [`update_cadet_utility_matrices`](../../../afccp/reference/data/preferences/#data.preferences.update_cadet_utility_matrices)\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Initialize matrix\n    p['cadet_utility'] = np.zeros([p['N'], p['M'] + 1])  # Additional column for unmatched cadets\n\n    # Loop through each cadet\n    for i in p['I']:\n\n        # 1, 2, 3, 4, ..., N  (Pure rankings)\n        rankings = np.arange(p['num_cadet_choices'][i]) + 1\n\n        # 1, 0.8, 0.6, 0.4, ..., 1 / N  (Scale rankings to range from 1 to 0)\n        normalized_rankings = 1 - (rankings / np.max(rankings)) + (1 / np.max(rankings))\n\n        # 1, 0.75, 0, 0, etc. (From utility matrix)\n        original_utilities = p['utility'][i, p['cadet_preferences'][i]]\n\n        # \"New\" Utilities based on a weighted sum of normalized rankings and original utilities\n        new_utilities = np.around(0.5 * normalized_rankings + 0.5 * original_utilities, 4)\n\n        # Put these new utilities back into the utility matrix in the appropriate spots\n        p['cadet_utility'][i, p['cadet_preferences'][i]] = new_utilities\n\n    # Return parameters\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.create_final_cadet_utility_matrix_from_new_formula","title":"<code>create_final_cadet_utility_matrix_from_new_formula(parameters)</code>","text":"<p>Create Final Cadet Utility Matrix Using Eligibility-Aware Scoring Formula.</p> <p>This function constructs a final <code>cadet_utility</code> matrix by integrating ordinal rankings, cadet-reported utilities, and least desired AFSC criteria. It uses a custom scoring formula that reflects cadet preferences, their eligibility, and how the AFSC ranks among their choices.</p> <p>The output matrix is used in the optimization models.</p>"},{"location":"reference/data/preferences/#data.preferences.create_final_cadet_utility_matrix_from_new_formula--parameters","title":"Parameters","text":"<p>parameters : dict A dictionary containing cadet\u2013AFSC preference and eligibility information:</p> <ul> <li><code>N</code> : int, number of cadets</li> <li><code>M</code> : int, number of AFSCs</li> <li><code>I</code> : list of cadet indices</li> <li><code>cadet_preferences</code> : dict, AFSC preference list per cadet</li> <li><code>utility</code> : ndarray, shape (N, M+1), cadet-reported utility values</li> <li><code>J^Selected</code> : dict, selected AFSCs for each cadet</li> <li><code>J^Bottom 2 Choices</code> : dict, bottom two AFSC preferences per cadet</li> <li><code>J^Last Choice</code> : dict, last-choice AFSC for each cadet</li> </ul>"},{"location":"reference/data/preferences/#data.preferences.create_final_cadet_utility_matrix_from_new_formula--returns","title":"Returns","text":"<p>parameters : dict Updated parameter dictionary with:</p> <ul> <li><code>cadet_utility</code> : ndarray, shape (N, M+1)     Weighted utility matrix accounting for ordinal preferences, eligibility, and cadet-reported utilities.</li> </ul>"},{"location":"reference/data/preferences/#data.preferences.create_final_cadet_utility_matrix_from_new_formula--examples","title":"Examples","text":"<pre><code>p = {\n    'N': 2,\n    'M': 3,\n    'I': [0, 1],\n    'utility': np.array([[0.8, 1.0, 0.6, 0.0], [0.5, 0.0, 0.9, 0.0]]),\n    'cadet_preferences': {0: [0, 1, 2], 1: [2, 0]},\n    'J^Selected': {0: [0, 1], 1: [0, 2]},\n    'J^Bottom 2 Choices': {0: [1, 2], 1: [0, 2]},\n    'J^Last Choice': {0: 2, 1: 2}\n}\np = create_final_cadet_utility_matrix_from_new_formula(p)\nprint(p['cadet_utility'])\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.create_final_cadet_utility_matrix_from_new_formula--see-also","title":"See Also","text":"<ul> <li><code>create_new_cadet_utility_matrix</code></li> </ul> Source code in <code>afccp/data/preferences.py</code> <pre><code>def create_final_cadet_utility_matrix_from_new_formula(parameters):\n    \"\"\"\n    Create Final Cadet Utility Matrix Using Eligibility-Aware Scoring Formula.\n\n    This function constructs a final `cadet_utility` matrix by integrating ordinal rankings, cadet-reported utilities,\n    and least desired AFSC criteria. It uses a custom scoring formula that reflects cadet preferences, their\n    eligibility, and how the AFSC ranks among their choices.\n\n    The output matrix is used in the optimization models.\n\n    Parameters\n    ----------\n    parameters : dict\n    A dictionary containing cadet\u2013AFSC preference and eligibility information:\n\n    - `N` : int, number of cadets\n    - `M` : int, number of AFSCs\n    - `I` : list of cadet indices\n    - `cadet_preferences` : dict, AFSC preference list per cadet\n    - `utility` : ndarray, shape (N, M+1), cadet-reported utility values\n    - `J^Selected` : dict, selected AFSCs for each cadet\n    - `J^Bottom 2 Choices` : dict, bottom two AFSC preferences per cadet\n    - `J^Last Choice` : dict, last-choice AFSC for each cadet\n\n    Returns\n    -------\n    parameters : dict\n    Updated parameter dictionary with:\n\n    - `cadet_utility` : ndarray, shape (N, M+1)\n        Weighted utility matrix accounting for ordinal preferences, eligibility, and cadet-reported utilities.\n\n    Examples\n    --------\n    ```python\n    p = {\n        'N': 2,\n        'M': 3,\n        'I': [0, 1],\n        'utility': np.array([[0.8, 1.0, 0.6, 0.0], [0.5, 0.0, 0.9, 0.0]]),\n        'cadet_preferences': {0: [0, 1, 2], 1: [2, 0]},\n        'J^Selected': {0: [0, 1], 1: [0, 2]},\n        'J^Bottom 2 Choices': {0: [1, 2], 1: [0, 2]},\n        'J^Last Choice': {0: 2, 1: 2}\n    }\n    p = create_final_cadet_utility_matrix_from_new_formula(p)\n    print(p['cadet_utility'])\n    ```\n\n    See Also\n    --------\n    - [`create_new_cadet_utility_matrix`](../../../afccp/reference/data/preferences/#data.preferences.create_new_cadet_utility_matrix)\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Initialize matrix (0.1 for everyone by default as indifference)\n    p['cadet_utility'] = np.ones([p['N'], p['M'] + 1]) * 0.1  # Additional column for unmatched cadets\n\n    # Loop through each cadet\n    for i in p['I']:\n\n        # AFSCs the cadet is eligible for and selected (ordered appropriately)\n        intersection = np.intersect1d(p['J^Selected'][i], p['cadet_preferences'][i])\n        intersection = np.array([j for j in p['cadet_preferences'][i] if j in intersection])\n        num_selected = len(intersection)\n\n        # Skip this cadet if they don't have any eligible choices\n        if num_selected == 0:\n            continue\n\n        # 1, 2, 3, 4, ..., N  (Pure rankings)\n        rankings = np.arange(num_selected) + 1\n\n        # 1, 0.8, 0.6, 0.4, ..., 1 / N  (Scale rankings to range from 1 to 0)\n        normalized_rankings = 1 - (rankings / np.max(rankings)) + (1 / np.max(rankings))\n\n        # Create dictionary of normalized ordinal rankings\n        norm_ord_rankings_dict = {j: normalized_rankings[index] for index, j in enumerate(intersection)}\n\n        # Loop through all AFSCs that the cadet is eligible for\n        for j in p['cadet_preferences'][i]:\n\n            # A: AFSC is NOT the LAST choice\n            a = (j != p['J^Last Choice'][i]) * 1\n\n            # B: AFSC is NOT in the bottom 3 choices\n            b = ((j not in p['J^Bottom 2 Choices'][i]) and (j != p['J^Last Choice'][i])) * 1\n\n            # C: AFSC was selected as a preference\n            c = (j in p['J^Selected'][i]) * 1\n\n            # D: AFSC was selected as a preference and has a utility assigned\n            d = (p['utility'][i, j] &gt; 0) * 1\n\n            # X: Normalized ordinal ranking of the AFSC\n            x = norm_ord_rankings_dict[j] if j in norm_ord_rankings_dict else 0\n\n            # Y: Utility value the cadet assigned to the AFSC\n            y = p['utility'][i, j]\n\n            # Execute the formula and load it into the cadet utility matrix\n            p['cadet_utility'][i, j] = 0.05*a + 0.05*b + 0.9*(0.3*c*x + 0.7*d*y)\n\n    # Return parameters\n    return p\n</code></pre>"},{"location":"reference/data/processing/","title":"Processing","text":""},{"location":"reference/data/processing/#data.processing","title":"<code>data.processing</code>","text":""},{"location":"reference/data/processing/#data.processing--data-processing-module","title":"Data Processing Module","text":"<p>This module handles all input/output operations for the AFCCP modeling pipeline.</p> <p>It supports importing problem instance data (AFSCs, cadets, preferences, value functions, etc.) and exporting solutions and diagnostics to CSV and Excel formats for analysis. It also initializes the directory structure for versioned data instances.</p>"},{"location":"reference/data/processing/#data.processing--key-capabilities","title":"Key Capabilities","text":"<ul> <li>Organizes input/output folders and paths for a data instance</li> <li>Imports cleaned data required for AFCCP optimization</li> <li>Exports results and supporting data for evaluation and visualization</li> </ul>"},{"location":"reference/data/processing/#data.processing--primary-functions","title":"Primary Functions","text":"<ul> <li> <p>Initialization</p> <ul> <li><code>initialize_file_information</code>: Sets up import/export folder paths for a given data name and version</li> </ul> </li> <li> <p>Import Functions</p> <ul> <li><code>import_afscs_data</code>: Loads AFSCs and related structural data</li> <li><code>import_cadets_data</code>: Loads cadet records and attributes</li> <li><code>import_afsc_cadet_matrices_data</code>: Loads cadet preference matrices and qualification matrices</li> <li><code>import_value_parameters_data</code>: Loads objective weights and breakpoints for value functions</li> <li><code>import_solutions_data</code>: Imports previously solved cadet-to-AFSC assignments</li> <li><code>import_additional_data</code>: Loads auxiliary data like base assignments and course info</li> </ul> </li> <li> <p>Export Functions</p> <ul> <li><code>export_afscs_data</code>: Saves AFSC-related data to CSV</li> <li><code>export_cadets_data</code>: Saves cadet-related data to CSV</li> <li><code>export_afsc_cadet_matrices_data</code>: Saves preference and qualification matrices to CSV</li> <li><code>export_value_parameters_data</code>: Saves value function breakpoints and weights to CSV</li> <li><code>export_solutions_data</code>: Saves one or more solutions in compact CSV format</li> <li><code>export_additional_data</code>: Saves supporting data (base preferences, utility matrices, courses)</li> <li><code>export_solution_results_excel</code>: Writes detailed solution metrics and diagnostics to an Excel workbook</li> </ul> </li> </ul>"},{"location":"reference/data/processing/#data.processing--notes","title":"Notes","text":"<p>All functions assume access to an <code>Instance</code> object that contains parameters, value structures, solution data, and export path information. The module is used during both the data preparation and results analysis stages of the AFCCP workflow.</p>"},{"location":"reference/data/processing/#data.processing.initialize_file_information","title":"<code>initialize_file_information(data_name: str, data_version: str)</code>","text":"<p>Initialize filepaths for an AFCCP data instance.</p> <p>This function constructs and returns import/export file path dictionaries for a given AFCCP data instance identified by <code>data_name</code> and <code>data_version</code>. It ensures the required directory structure exists under <code>instances/</code> and dynamically builds file paths for reading and writing instance-specific data and results.</p> <p>It is primarily used to manage file I/O consistently across different data experiments or scenario versions within the AFCCP modeling system.</p>"},{"location":"reference/data/processing/#data.processing.initialize_file_information--parameters","title":"Parameters","text":"<ul> <li> <p>data_name : str   The name of the data instance (e.g., <code>\"2025\"</code>, <code>\"Baseline\"</code>, <code>\"TestRun01\"</code>). This defines the   subdirectory under <code>instances/</code> where the data is stored.</p> </li> <li> <p>data_version : str   The version label for the run (e.g., <code>\"Default\"</code>, <code>\"V1\"</code>). Used to separate multiple experimental   runs under the same data instance name, enabling controlled versioning of model input and output files.</p> </li> </ul>"},{"location":"reference/data/processing/#data.processing.initialize_file_information--returns","title":"Returns","text":"<ul> <li>Tuple[Dict[str, str], Dict[str, str]]   A tuple of two dictionaries:<ul> <li><code>import_paths</code>: maps each input data type (e.g., <code>\"Cadets\"</code>, <code>\"AFSCs\"</code>) to its CSV file path.</li> <li><code>export_paths</code>: maps each output destination (e.g., <code>\"Solutions\"</code>, <code>\"Results Charts\"</code>) to its folder or file path.</li> </ul> </li> </ul>"},{"location":"reference/data/processing/#data.processing.initialize_file_information--directory-behavior","title":"Directory Behavior","text":"<ul> <li>Creates base folder <code>instances/&lt;data_name&gt;/</code> if it doesn't exist.</li> <li>Creates version-specific folders for <code>\"Model Input\"</code> and <code>\"Analysis &amp; Results\"</code>:<ul> <li>e.g., <code>\"4. Model Input (V1)\"</code>, <code>\"5. Analysis &amp; Results (V1)\"</code></li> </ul> </li> <li>Also creates subfolders under <code>\"Analysis &amp; Results\"</code> such as:<ul> <li><code>\"Data Charts\"</code>, <code>\"Results Charts\"</code>, <code>\"Cadet Board\"</code>, <code>\"Value Functions\"</code></li> </ul> </li> <li>If version-specific input files are not found, it defaults to shared or base files when appropriate.</li> </ul>"},{"location":"reference/data/processing/#data.processing.initialize_file_information--examples","title":"Examples","text":"<pre><code>from afccp.data.processing import initialize_file_information\n\nimport_paths, export_paths = initialize_file_information(\"2025\", \"V1\")\nafsc_path = import_paths[\"AFSCs\"]\nsolution_folder = export_paths[\"Analysis &amp; Results\"]\n</code></pre> Source code in <code>afccp/data/processing.py</code> <pre><code>def initialize_file_information(data_name: str, data_version: str):\n    \"\"\"\n    Initialize filepaths for an AFCCP data instance.\n\n    This function constructs and returns import/export file path dictionaries for a given AFCCP\n    data instance identified by `data_name` and `data_version`. It ensures the required directory\n    structure exists under `instances/` and dynamically builds file paths for reading and writing\n    instance-specific data and results.\n\n    It is primarily used to manage file I/O consistently across different data experiments or\n    scenario versions within the AFCCP modeling system.\n\n    Parameters\n    ----------\n    - data_name : str\n      The name of the data instance (e.g., `\"2025\"`, `\"Baseline\"`, `\"TestRun01\"`). This defines the\n      subdirectory under `instances/` where the data is stored.\n\n    - data_version : str\n      The version label for the run (e.g., `\"Default\"`, `\"V1\"`). Used to separate multiple experimental\n      runs under the same data instance name, enabling controlled versioning of model input and output files.\n\n    Returns\n    -------\n    - Tuple[Dict[str, str], Dict[str, str]]\n      A tuple of two dictionaries:\n        - `import_paths`: maps each input data type (e.g., `\"Cadets\"`, `\"AFSCs\"`) to its CSV file path.\n        - `export_paths`: maps each output destination (e.g., `\"Solutions\"`, `\"Results Charts\"`) to its folder or file path.\n\n    Directory Behavior\n    ------------------\n    - Creates base folder `instances/&lt;data_name&gt;/` if it doesn't exist.\n    - Creates version-specific folders for `\"Model Input\"` and `\"Analysis &amp; Results\"`:\n        - e.g., `\"4. Model Input (V1)\"`, `\"5. Analysis &amp; Results (V1)\"`\n    - Also creates subfolders under `\"Analysis &amp; Results\"` such as:\n        - `\"Data Charts\"`, `\"Results Charts\"`, `\"Cadet Board\"`, `\"Value Functions\"`\n    - If version-specific input files are not found, it defaults to shared or base files when appropriate.\n\n    Examples\n    --------\n    ```python\n    from afccp.data.processing import initialize_file_information\n\n    import_paths, export_paths = initialize_file_information(\"2025\", \"V1\")\n    afsc_path = import_paths[\"AFSCs\"]\n    solution_folder = export_paths[\"Analysis &amp; Results\"]\n    ```\n    \"\"\"\n\n    # If we don't already have the instance folder, we make it now\n    instance_path = \"instances/\" + data_name + \"/\"\n    if data_name not in afccp.globals.instances_available:\n        os.mkdir(instance_path)\n    instance_folder = np.array(os.listdir(instance_path))\n\n    # Valid files/folders\n    sub_folders = [\"Original &amp; Supplemental\", \"Combined Data\", \"CFMs\", \"Model Input\", \"Analysis &amp; Results\"]\n    sub_folder_files = {\"Model Input\": [\"Cadets\", \"Cadets Preferences\", \"Cadets Utility\", \"Cadets Utility Constraints\",\n                                        \"Cadets Utility (Final)\", \"AFSCs\", \"AFSCs Preferences\", \"AFSCs Utility\",\n                                        \"Value Parameters\", \"Goal Programming\", \"ROTC Rated Interest\",\n                                        \"ROTC Rated OM\", \"USAFA Rated OM\", \"OTS Rated OM\",\n                                        \"Bases\", \"Bases Preferences\",\n                                        \"Bases Utility\", \"Courses\", \"Cadets Selected\", \"AFSCs Buckets\",\n                                        'Castle Input'],\n                        \"Analysis &amp; Results\": [\"Solutions\", \"Base Solutions\", \"Course Solutions\"]}\n\n    # Loop through each sub-folder in the above list and determine the filepaths for the various files\n    import_filepaths = {}\n    export_filepaths = {}\n    for i, sub_folder in enumerate(sub_folders):\n\n        # Sub-Folder with the number: \"4. Model Input\" for example\n        numbered_sub_folder = str(i + 1) + \". \" + sub_folder\n\n        # All the sub-folders that have this numbered sub-folder\n        if len(instance_folder) != 0:\n            indices = np.flatnonzero(np.core.defchararray.find(instance_folder, numbered_sub_folder) != -1)\n            sub_folder_individuals = instance_folder[indices]\n        else:\n            sub_folder_individuals = []\n\n        # If this is the \"default version\", we already know what the sub-folder has to be\n        if data_version == \"Default\":\n            import_sub_folder = numbered_sub_folder\n            export_sub_folder = numbered_sub_folder\n\n            # If we don't currently have this sub-folder, we make it (New instance file)\n            if numbered_sub_folder not in sub_folder_individuals:\n                os.mkdir(instance_path + numbered_sub_folder + \"/\")\n\n        # If the data version was specified, we have to check if it has the specific folder or not\n        else:\n\n            # If the version folder is not there, we import from the default but will export to the data version folder\n            version_indices = np.flatnonzero(np.core.defchararray.find(sub_folder_individuals, data_version) != -1)\n            if len(version_indices) == 0:\n                import_sub_folder = numbered_sub_folder\n                export_sub_folder = numbered_sub_folder + \" (\" + data_version + \")\"\n\n                # We will only ever export specific version data to these sub-folders\n                if sub_folder in [\"Model Input\", \"Analysis &amp; Results\"]:\n                    os.mkdir(instance_path + export_sub_folder + \"/\")\n\n            # We already have the version folder\n            else:\n                import_sub_folder = sub_folder_individuals[version_indices[0]]\n                export_sub_folder = sub_folder_individuals[version_indices[0]]\n\n        # If this is one of the sub-folders we can import/export to/from\n        if sub_folder in sub_folder_files:\n\n            # Get sub folder paths\n            import_sub_folder_path = instance_path + import_sub_folder + \"/\"\n            export_sub_folder_path = instance_path + export_sub_folder + \"/\"\n\n            # Add generic file-paths for this sub-folder\n            export_filepaths[sub_folder] = export_sub_folder_path\n            import_filepaths[sub_folder] = import_sub_folder_path\n\n            # Loop through each file listed above in the \"sub_folder_files\" for this sub-folder\n            sub_folder_files_available = os.listdir(import_sub_folder_path)\n            for file in sub_folder_files[sub_folder]:\n\n                # Create the name of the file\n                if data_version == \"Default\":\n                    filename = data_name + \" \" + file + \".csv\"\n                else:\n                    filename = data_name + \" \" + file + \" (\" + data_version + \").csv\"\n\n                # Get the path that we would export this file to\n                export_filepaths[file] = export_sub_folder_path + filename\n\n                # If we already have this file in the \"import path\", we add it to that filepath dictionary\n                if filename in sub_folder_files_available:\n                    import_filepaths[file] = import_sub_folder_path + filename\n                elif data_version != \"Default\" and data_name + \" \" + file + \".csv\" in sub_folder_files_available:\n                    import_filepaths[file] = import_sub_folder_path + data_name + \" \" + file + \".csv\"\n\n    # If we don't have one of the Analysis &amp; Results \"sub-sub folders\", we make it\n    for sub_sub_folder in [\"Data Charts\", \"Results Charts\", \"Cadet Board\", 'Value Functions']:\n        if sub_sub_folder not in os.listdir(export_filepaths[\"Analysis &amp; Results\"]):\n            os.mkdir(export_filepaths[\"Analysis &amp; Results\"] + sub_sub_folder + \"/\")\n\n    # Return the information\n    return import_filepaths, export_filepaths\n</code></pre>"},{"location":"reference/data/processing/#data.processing.import_afscs_data","title":"<code>import_afscs_data(import_filepaths: dict, parameters: dict) -&gt; dict</code>","text":"<p>Imports AFSC-level model input data from CSV and populates the instance parameter dictionary.</p> <p>This function reads the <code>\"AFSCs\"</code> input file (provided via <code>import_filepaths</code>) and updates the supplied <code>parameters</code> dictionary with structured information for each Air Force Specialty Code (AFSC). These inputs are essential for AFCCP modeling and include AFSC quotas, groupings, tiered degree requirements, and other structural attributes.</p> <p>The function handles type conversion, fills missing entries, and appends a special unmatched AFSC (\"*\") for use in optimization logic.</p>"},{"location":"reference/data/processing/#data.processing.import_afscs_data--parameters","title":"Parameters","text":"<ul> <li> <p>import_filepaths : dict   A dictionary of import paths keyed by label (e.g., <code>\"AFSCs\"</code>). Must contain the key <code>\"AFSCs\"</code> pointing to   the location of the AFSCs input CSV file.</p> </li> <li> <p>parameters : dict   A dictionary of instance-wide input parameters. This will be updated in-place with the AFSC-specific   parameter values.</p> </li> </ul>"},{"location":"reference/data/processing/#data.processing.import_afscs_data--returns","title":"Returns","text":"<ul> <li> <p>dict The updated <code>parameters</code> dictionary, now containing keys such as:</p> </li> <li> <p><code>\"afscs\"</code>: List of AFSC names (plus an unmatched AFSC \"*\")</p> </li> <li><code>\"acc_grp\"</code>: Accession group categories</li> <li><code>\"afscs_stem\"</code>: STEM-designation indicator for each AFSC</li> <li><code>\"quota_d\"</code>, <code>\"quota_e\"</code>, <code>\"quota_min\"</code>, <code>\"quota_max\"</code>: Target and constraint bounds</li> <li><code>\"pgl\"</code>: Projected graduation levels for each AFSC</li> <li><code>\"Deg Tiers\"</code>: Tiered degree qualification matrix (if present)</li> </ul>"},{"location":"reference/data/processing/#data.processing.import_afscs_data--notes","title":"Notes","text":"<ul> <li>All values are loaded as NumPy arrays to facilitate vectorized modeling.</li> <li>The unmatched AFSC <code>\"*\"</code> is appended to <code>\"afscs\"</code> for modeling unmatched cadets.</li> <li>NaN entries and string \"nan\" values in the CSV are sanitized to empty strings before processing.</li> <li>Degree tiers are only added if the <code>\"Deg Tier 1\"</code> column is present in the CSV. ```</li> </ul>"},{"location":"reference/data/processing/#data.processing.import_afscs_data--see-also","title":"See Also","text":"<ul> <li><code>initialize_file_information</code></li> <li><code>import_csv_data</code></li> </ul> Source code in <code>afccp/data/processing.py</code> <pre><code>def import_afscs_data(import_filepaths: dict, parameters: dict) -&gt; dict:\n    \"\"\"\n    Imports AFSC-level model input data from CSV and populates the instance parameter dictionary.\n\n    This function reads the `\"AFSCs\"` input file (provided via `import_filepaths`) and updates the supplied\n    `parameters` dictionary with structured information for each Air Force Specialty Code (AFSC). These inputs\n    are essential for AFCCP modeling and include AFSC quotas, groupings, tiered degree requirements, and other\n    structural attributes.\n\n    The function handles type conversion, fills missing entries, and appends a special unmatched AFSC (\"*\") for\n    use in optimization logic.\n\n    Parameters\n    ----------\n    - import_filepaths : dict\n      A dictionary of import paths keyed by label (e.g., `\"AFSCs\"`). Must contain the key `\"AFSCs\"` pointing to\n      the location of the AFSCs input CSV file.\n\n    - parameters : dict\n      A dictionary of instance-wide input parameters. This will be updated in-place with the AFSC-specific\n      parameter values.\n\n    Returns\n    -------\n    - dict\n    The updated `parameters` dictionary, now containing keys such as:\n\n    - `\"afscs\"`: List of AFSC names (plus an unmatched AFSC \"*\")\n    - `\"acc_grp\"`: Accession group categories\n    - `\"afscs_stem\"`: STEM-designation indicator for each AFSC\n    - `\"quota_d\"`, `\"quota_e\"`, `\"quota_min\"`, `\"quota_max\"`: Target and constraint bounds\n    - `\"pgl\"`: Projected graduation levels for each AFSC\n    - `\"Deg Tiers\"`: Tiered degree qualification matrix (if present)\n\n    Notes\n    -----\n    - All values are loaded as NumPy arrays to facilitate vectorized modeling.\n    - The unmatched AFSC `\"*\"` is appended to `\"afscs\"` for modeling unmatched cadets.\n    - NaN entries and string \"nan\" values in the CSV are sanitized to empty strings before processing.\n    - Degree tiers are only added if the `\"Deg Tier 1\"` column is present in the CSV.\n    ```\n\n    See Also\n    --------\n    - [`initialize_file_information`](../../../afccp/reference/data/processing/#data.processing.initialize_file_information)\n    - [`import_csv_data`](../../../afccp/reference/globals/#globals.import_csv_data)\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Import 'AFSCs' dataframe\n    afscs_df = afccp.globals.import_csv_data(import_filepaths[\"AFSCs\"])\n\n    # Remove \"nans\"\n    afscs_df = afscs_df.replace('nan', '')\n    afscs_df = afscs_df.fillna('')\n\n    # Initialize dictionary translating 'AFSCs' df columns to their parameter counterparts\n    afsc_columns_to_parameters = {\"AFSC\": \"afscs\", \"Accessions Group\": \"acc_grp\", \"STEM\": 'afscs_stem',\n                                  \"USAFA Target\": \"usafa_quota\",\n                                  \"ROTC Target\": \"rotc_quota\",\n                                  \"OTS Target\": \"ots_quota\",\n                                  \"PGL Target\": \"pgl\", \"Estimated\": \"quota_e\",\n                                  \"Desired\": \"quota_d\", \"Min\": \"quota_min\", \"Max\": \"quota_max\",\n                                  'Max (Bubbles)': 'max_bubbles',\n                                  \"Assign Base\": 'afsc_assign_base', 'Num Courses': 'T'}\n\n    # Loop through each column in the 'AFSCs' dataframe to put it into the p dictionary\n    for col in afscs_df.columns:\n\n        # If the column is an instance parameter, we load it in as a numpy array\n        if col in afsc_columns_to_parameters:\n            p_name = afsc_columns_to_parameters[col]\n            p[p_name] = np.array(afscs_df.loc[:, col])\n\n    # Number of AFSCs\n    p[\"M\"] = len(p[\"afscs\"])\n\n    # Add an \"*\" to the list of AFSCs to be considered the \"Unmatched AFSC\"\n    p[\"afscs\"] = np.hstack((p[\"afscs\"], \"*\"))\n\n    # Get the degree tier information from the AFSCs\n    if \"Deg Tier 1\" in afscs_df:\n        p[\"Deg Tiers\"] = np.array(afscs_df.loc[:, \"Deg Tier 1\": \"Deg Tier 4\"]).astype(str)\n\n    # Return parameters dictionary\n    return p\n</code></pre>"},{"location":"reference/data/processing/#data.processing.import_cadets_data","title":"<code>import_cadets_data(import_filepaths, parameters)</code>","text":"<p>Imports Cadet-level model input data from CSV and populates the instance parameter dictionary.</p> <p>This function reads the <code>\"Cadets\"</code> CSV file specified in <code>import_filepaths</code> and extracts relevant demographic, qualification, preference, training, and weighting information for each cadet. It populates the provided <code>parameters</code> dictionary with this structured data, including derived quantities like total cadet count, preference matrix dimensions, and accession source types (SOCs).</p>"},{"location":"reference/data/processing/#data.processing.import_cadets_data--parameters","title":"Parameters","text":"<ul> <li> <p>import_filepaths : dict   Dictionary of import paths keyed by label. Must contain the key <code>\"Cadets\"</code> pointing to the cadet input CSV path.</p> </li> <li> <p>parameters : dict   Dictionary of instance-level parameters. This dictionary will be updated in-place with cadet-related entries.</p> </li> </ul>"},{"location":"reference/data/processing/#data.processing.import_cadets_data--returns","title":"Returns","text":"<p>dict The updated <code>parameters</code> dictionary, now containing cadet-specific fields such as:</p> <ul> <li><code>\"cadets\"</code>, <code>\"merit\"</code>, <code>\"assigned\"</code>, <code>\"asc1\"</code>/<code>\"asc2\"</code>, <code>\"cip1\"</code>/<code>\"cip2\"</code> (basic identifiers)</li> <li><code>\"usafa\"</code>, <code>\"soc\"</code>, <code>\"minority\"</code>, <code>\"race\"</code>, <code>\"ethnicity\"</code> (demographic data)</li> <li><code>\"must_match\"</code> (AFSCs that must be assigned)</li> <li><code>\"c_preferences\"</code>: Preference matrix (N x P) where N = cadets, P = preference slots</li> <li><code>\"c_utilities\"</code>: Utility matrix (N x U), where U = min(P, 10)</li> <li><code>\"SOCs\"</code>: List of accession sources present in this instance (e.g., <code>[\"usafa\", \"rotc\"]</code>)</li> <li><code>\"training_start\"</code>, <code>\"training_preferences\"</code>, <code>\"training_threshold\"</code> (training pipeline values)</li> <li><code>\"weight_afsc\"</code>, <code>\"weight_base\"</code>, <code>\"weight_course\"</code> (objective weights)</li> </ul>"},{"location":"reference/data/processing/#data.processing.import_cadets_data--notes","title":"Notes","text":"<ul> <li>NaN or string 'nan' entries in the CSV are automatically sanitized.</li> <li>Extra care is taken to remove BOM characters (e.g., <code>\"\u00ef\u00bb\u00bf\"</code>) in CSV headers.</li> <li>Preferences are detected using any column starting with <code>\"Pref_\"</code>, and corresponding utilities from <code>\"Util_1\"</code> onward.</li> <li>SOCs must be one of <code>\"USAFA\"</code>, <code>\"ROTC\"</code>, or <code>\"OTS\"</code>; any other value will raise an error.</li> <li>This function calls <code>gather_degree_tier_qual_matrix()</code> to supplement qualification mappings.</li> </ul>"},{"location":"reference/data/processing/#data.processing.import_cadets_data--see-also","title":"See Also","text":"<ul> <li><code>initialize_file_information</code></li> <li><code>gather_degree_tier_qual_matrix</code></li> </ul> Source code in <code>afccp/data/processing.py</code> <pre><code>def import_cadets_data(import_filepaths, parameters):\n    \"\"\"\n    Imports Cadet-level model input data from CSV and populates the instance parameter dictionary.\n\n    This function reads the `\"Cadets\"` CSV file specified in `import_filepaths` and extracts relevant demographic,\n    qualification, preference, training, and weighting information for each cadet. It populates the provided\n    `parameters` dictionary with this structured data, including derived quantities like total cadet count,\n    preference matrix dimensions, and accession source types (SOCs).\n\n    Parameters\n    ----------\n    - import_filepaths : dict\n      Dictionary of import paths keyed by label. Must contain the key `\"Cadets\"` pointing to the cadet input CSV path.\n\n    - parameters : dict\n      Dictionary of instance-level parameters. This dictionary will be updated in-place with cadet-related entries.\n\n    Returns\n    -------\n    dict\n    The updated `parameters` dictionary, now containing cadet-specific fields such as:\n\n    - `\"cadets\"`, `\"merit\"`, `\"assigned\"`, `\"asc1\"`/`\"asc2\"`, `\"cip1\"`/`\"cip2\"` (basic identifiers)\n    - `\"usafa\"`, `\"soc\"`, `\"minority\"`, `\"race\"`, `\"ethnicity\"` (demographic data)\n    - `\"must_match\"` (AFSCs that must be assigned)\n    - `\"c_preferences\"`: Preference matrix (N x P) where N = cadets, P = preference slots\n    - `\"c_utilities\"`: Utility matrix (N x U), where U = min(P, 10)\n    - `\"SOCs\"`: List of accession sources present in this instance (e.g., `[\"usafa\", \"rotc\"]`)\n    - `\"training_start\"`, `\"training_preferences\"`, `\"training_threshold\"` (training pipeline values)\n    - `\"weight_afsc\"`, `\"weight_base\"`, `\"weight_course\"` (objective weights)\n\n    Notes\n    -----\n    - NaN or string 'nan' entries in the CSV are automatically sanitized.\n    - Extra care is taken to remove BOM characters (e.g., `\"\u00ef\u00bb\u00bf\"`) in CSV headers.\n    - Preferences are detected using any column starting with `\"Pref_\"`, and corresponding utilities from `\"Util_1\"` onward.\n    - SOCs must be one of `\"USAFA\"`, `\"ROTC\"`, or `\"OTS\"`; any other value will raise an error.\n    - This function calls `gather_degree_tier_qual_matrix()` to supplement qualification mappings.\n\n    See Also\n    --------\n    - [`initialize_file_information`](../../../afccp/reference/data/processing/#data.processing.initialize_file_information)\n    - [`gather_degree_tier_qual_matrix`](../../../afccp/reference/data/adjustments/#data.adjustments.gather_degree_tier_qual_matrix)\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Import 'Cadets' dataframe\n    cadets_df = afccp.globals.import_csv_data(import_filepaths[\"Cadets\"])\n\n    # Initialize dictionary translating 'AFSCs' df columns to their parameter counterparts\n    cadet_columns_to_parameters = {\"Cadet\": \"cadets\", 'Male': 'male', 'Minority': 'minority', 'Race': 'race',\n                                   \"Ethnicity\": \"ethnicity\", 'USAFA': 'usafa', 'SOC': 'soc',\n                                   \"Must Match\": \"must_match\",\n                                   'ASC1': 'asc1', 'ASC2': 'asc2',\n                                   'CIP1': 'cip1', 'CIP2': 'cip2', 'Merit': 'merit', 'Real Merit': 'merit_all',\n                                   \"Assigned\": \"assigned\", \"STEM\": \"stem\", \"Accessions Group\": \"acc_grp_constraint\",\n                                   \"SF OM\": \"sf_om\", 'Start Date': 'training_start', 'Start Pref': 'training_preferences',\n                                   'Base Threshold': 'base_threshold', 'Course Threshold': 'training_threshold',\n                                   'AFSC Weight': 'weight_afsc', 'Base Weight': 'weight_base',\n                                   'Course Weight': 'weight_course', 'Least Desired AFSC': 'last_afsc',\n                                   'Second Least Desired AFSCs': 'second_to_last_afscs'}\n\n    # Loop through each column in the 'Cadets' dataframe to put it into the p dictionary\n    for col in cadets_df.columns:\n\n        # Weird characters showing up\n        if \"\u00ef\u00bb\u00bf\" in col:\n            col_name = col.replace(\"\u00ef\u00bb\u00bf\", \"\")\n        else:\n            col_name = col\n\n        # If the column is an instance parameter, we load it in as a numpy array\n        if col_name in cadet_columns_to_parameters:\n            p_name = cadet_columns_to_parameters[col_name]\n            p[p_name] = np.array(cadets_df.loc[:, col])\n\n    # Number of Cadets\n    p[\"N\"] = len(p[\"cadets\"])\n\n    # Get qual matrix information\n    p = afccp.data.adjustments.gather_degree_tier_qual_matrix(cadets_df, p)\n\n    # Number of cadet preference choices available and number of utilities available\n    p[\"P\"] = len([col for col in cadets_df.columns if 'Pref_' in col])\n    p[\"num_util\"] = min(10, p[\"P\"])\n    if p[\"P\"] != 0:\n\n        # Get the preferences and utilities columns from the cadets dataframe\n        p[\"c_preferences\"] = np.array(cadets_df.loc[:, \"Pref_1\": \"Pref_\" + str(p['P'])])\n        p[\"c_utilities\"] = np.array(cadets_df.loc[:, \"Util_1\": \"Util_\" + str(p[\"num_util\"])])\n\n    # Determine which SOCs are in this instance\n    if 'soc' in p:\n        unique_socs = np.unique(p['soc'])  # Get unique list of SOCs\n\n        # This just gets the SOCs in the right order\n        soc_options = ['USAFA', 'ROTC', 'OTS']\n        p['SOCs'] = np.array([soc.lower() for soc in soc_options if soc in unique_socs])\n\n        for soc in unique_socs:\n            if soc not in soc_options:\n                raise ValueError(f'SOC {soc} not recognized as valid SOC option! At least one cadet has it.')\n\n    # Return parameters dictionary\n    return p\n</code></pre>"},{"location":"reference/data/processing/#data.processing.import_afsc_cadet_matrices_data","title":"<code>import_afsc_cadet_matrices_data(import_filepaths, parameters)</code>","text":"<p>Imports optional AFSC-cadet interaction matrices and updates the instance parameter dictionary accordingly.</p> <p>This function augments the core cadet and AFSC input data by importing preference matrices, utility matrices, and supplemental rated-selection files (if available). The imported data enables more advanced modeling of cadet-AFSC interactions including two-sided preferences and selection boards.</p>"},{"location":"reference/data/processing/#data.processing.import_afsc_cadet_matrices_data--parameters","title":"Parameters","text":"<ul> <li> <p>import_filepaths : dict     Dictionary of filepaths keyed by dataset name. Recognized keys include:</p> <ul> <li><code>\"Cadets Utility\"</code></li> <li><code>\"Cadets Preferences\"</code></li> <li><code>\"AFSCs Utility\"</code></li> <li><code>\"AFSCs Preferences\"</code></li> <li><code>\"Cadets Utility (Final)\"</code></li> <li><code>\"Cadets Selected\"</code></li> <li><code>\"AFSCs Buckets\"</code></li> <li><code>\"ROTC Rated Interest\"</code>, <code>\"ROTC Rated OM\"</code>, <code>\"USAFA Rated OM\"</code>, <code>\"OTS Rated OM\"</code></li> </ul> </li> <li> <p>parameters : dict     Dictionary of model instance parameters. Must contain:</p> <ul> <li><code>\"afscs\"</code>: array of AFSC names</li> <li><code>\"N\"</code>: number of cadets</li> <li><code>\"M\"</code>: number of AFSCs</li> <li><code>\"num_util\"</code>: number of utility entries per cadet</li> <li><code>\"P\"</code>: number of preferences</li> </ul> </li> </ul>"},{"location":"reference/data/processing/#data.processing.import_afsc_cadet_matrices_data--returns","title":"Returns","text":"<p>dict Updated parameter dictionary with new keys (if data was provided), including:</p> <ul> <li><code>\"utility\"</code>: cadet utility matrix (N x M)</li> <li><code>\"c_pref_matrix\"</code>: cadet preference rankings (N x M, integer-valued, 1 = top choice)</li> <li><code>\"afsc_utility\"</code>: AFSC utility matrix (M x M)</li> <li><code>\"a_pref_matrix\"</code>: AFSC preference rankings (M x M)</li> <li><code>\"cadet_utility\"</code>: final cadet utility matrix (N x M)</li> <li><code>\"c_selected_matrix\"</code>: matrix of cadets selected by AFSCs (N x M)</li> <li><code>\"a_bucket_matrix\"</code>: bucketing of AFSCs for visualization or selection (M x M)</li> <li><code>\"rr_interest_matrix\"</code>, <code>\"rr_om_matrix\"</code>, <code>\"rr_om_cadets\"</code>: ROTC board data</li> <li><code>\"ur_om_matrix\"</code>, <code>\"ur_om_cadets\"</code>: USAFA board data</li> <li><code>\"or_om_matrix\"</code>, <code>\"or_om_cadets\"</code>: OTS board data</li> <li><code>\"usafa_cadets\"</code>: indices of USAFA cadets in the instance</li> </ul>"},{"location":"reference/data/processing/#data.processing.import_afsc_cadet_matrices_data--raises","title":"Raises","text":"<p>ValueError   If neither <code>\"Cadets Utility\"</code> nor <code>\"c_utilities\"</code> are provided in the inputs, since cadet utility data is required.</p>"},{"location":"reference/data/processing/#data.processing.import_afsc_cadet_matrices_data--notes","title":"Notes","text":"<ul> <li>This function assumes the <code>\"Cadets\"</code> and <code>\"AFSCs\"</code> CSVs have already been processed.</li> <li>If raw preferences/utilities are not explicitly imported, they are reconstructed from <code>c_preferences</code> and <code>c_utilities</code>.</li> <li>Preference ranks use integers where <code>1</code> is most preferred (not <code>0</code>).</li> <li>Utility matrices are aligned by the order of <code>p[\"afscs\"]</code> and not by the file column order alone.</li> <li>AFSC utility and preference data are optional but support two-sided matching or board processes.</li> <li>Rated OM/Interest files enable specialty-specific board logic for each SOC.</li> </ul> Source code in <code>afccp/data/processing.py</code> <pre><code>def import_afsc_cadet_matrices_data(import_filepaths, parameters):\n    \"\"\"\n    Imports optional AFSC-cadet interaction matrices and updates the instance parameter dictionary accordingly.\n\n    This function augments the core cadet and AFSC input data by importing preference matrices, utility matrices,\n    and supplemental rated-selection files (if available). The imported data enables more advanced modeling of\n    cadet-AFSC interactions including two-sided preferences and selection boards.\n\n    Parameters\n    ----------\n    - import_filepaths : dict\n        Dictionary of filepaths keyed by dataset name. Recognized keys include:\n\n        - `\"Cadets Utility\"`\n        - `\"Cadets Preferences\"`\n        - `\"AFSCs Utility\"`\n        - `\"AFSCs Preferences\"`\n        - `\"Cadets Utility (Final)\"`\n        - `\"Cadets Selected\"`\n        - `\"AFSCs Buckets\"`\n        - `\"ROTC Rated Interest\"`, `\"ROTC Rated OM\"`, `\"USAFA Rated OM\"`, `\"OTS Rated OM\"`\n\n    - parameters : dict\n        Dictionary of model instance parameters. Must contain:\n\n        - `\"afscs\"`: array of AFSC names\n        - `\"N\"`: number of cadets\n        - `\"M\"`: number of AFSCs\n        - `\"num_util\"`: number of utility entries per cadet\n        - `\"P\"`: number of preferences\n\n    Returns\n    -------\n    dict\n    Updated parameter dictionary with new keys (if data was provided), including:\n\n    - `\"utility\"`: cadet utility matrix (N x M)\n    - `\"c_pref_matrix\"`: cadet preference rankings (N x M, integer-valued, 1 = top choice)\n    - `\"afsc_utility\"`: AFSC utility matrix (M x M)\n    - `\"a_pref_matrix\"`: AFSC preference rankings (M x M)\n    - `\"cadet_utility\"`: final cadet utility matrix (N x M)\n    - `\"c_selected_matrix\"`: matrix of cadets selected by AFSCs (N x M)\n    - `\"a_bucket_matrix\"`: bucketing of AFSCs for visualization or selection (M x M)\n    - `\"rr_interest_matrix\"`, `\"rr_om_matrix\"`, `\"rr_om_cadets\"`: ROTC board data\n    - `\"ur_om_matrix\"`, `\"ur_om_cadets\"`: USAFA board data\n    - `\"or_om_matrix\"`, `\"or_om_cadets\"`: OTS board data\n    - `\"usafa_cadets\"`: indices of USAFA cadets in the instance\n\n    Raises\n    ------\n    ValueError\n      If neither `\"Cadets Utility\"` nor `\"c_utilities\"` are provided in the inputs, since cadet utility data is required.\n\n    Notes\n    -----\n    - This function assumes the `\"Cadets\"` and `\"AFSCs\"` CSVs have already been processed.\n    - If raw preferences/utilities are not explicitly imported, they are reconstructed from `c_preferences` and `c_utilities`.\n    - Preference ranks use integers where `1` is most preferred (not `0`).\n    - Utility matrices are aligned by the order of `p[\"afscs\"]` and not by the file column order alone.\n    - AFSC utility and preference data are optional but support two-sided matching or board processes.\n    - Rated OM/Interest files enable specialty-specific board logic for each SOC.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Loop through the potential additional dataframes and import them if we have them\n    datasets = {}\n    for dataset in [\"Cadets Utility\", \"Cadets Preferences\", \"AFSCs Utility\", \"AFSCs Preferences\",\n                    \"ROTC Rated Interest\", \"ROTC Rated OM\", \"USAFA Rated OM\", \"OTS Rated OM\", 'Cadets Utility (Final)',\n                    \"Cadets Selected\", \"AFSCs Buckets\"]:\n\n        # If we have the dataset, import it\n        if dataset in import_filepaths:\n            datasets[dataset] = afccp.globals.import_csv_data(import_filepaths[dataset])\n\n    # First and last AFSC (for collecting matrices from dataframes)\n    afsc_1, afsc_M = p[\"afscs\"][0], p[\"afscs\"][p[\"M\"] - 1]\n\n    # Load in extra dataframes\n    for dataset, param in {'Cadets Selected': 'c_selected_matrix', 'AFSCs Buckets': 'a_bucket_matrix'}.items():\n        if dataset in datasets:\n            p[param] = np.array(datasets[dataset].loc[:, afsc_1: afsc_M])\n\n    # Determine how we incorporate the original cadets' utility matrix\n    if \"Cadets Utility\" in datasets:  # Load in the matrix directly\n        p[\"utility\"] = np.array(datasets[\"Cadets Utility\"].loc[:, afsc_1: afsc_M])\n    elif \"c_utilities\" in p:  # Create the matrix using the columns\n\n        # Create utility matrix (numpy array NxM) from the utility/preference column information\n        p[\"utility\"] = np.zeros([p[\"N\"], p[\"M\"]])\n        for i in range(p[\"N\"]):\n            for util in range(p['num_util']):\n                j = np.where(p[\"c_preferences\"][i, util] == p[\"afscs\"])[0]\n                if len(j) != 0:\n                    p['utility'][i, j[0]] = p[\"c_utilities\"][i, util]\n    else:\n        raise ValueError(\"Error. No cadet utility data provided which is required.\")\n\n    # Cadets \"Real\" Utility (after aggregating it with their ordinal rankings)\n    if 'Cadets Utility (Final)' in datasets:  # Load in the cadet utility matrix\n        p['cadet_utility'] = np.array(datasets[\"Cadets Utility (Final)\"].loc[:, afsc_1: afsc_M])\n\n    # Determine how we incorporate the cadets' preferences dataframe\n    if \"Cadets Preferences\" in datasets:  # Load in the preferences dataframe directly\n        p[\"c_pref_matrix\"] = np.array(datasets[\"Cadets Preferences\"].loc[:, afsc_1: afsc_M])\n    elif \"c_preferences\" in p:  # Create the preferences dataframe using the columns\n\n        # Create cadet preferences dataframe (numpy array NxM) from the preference column information\n        p[\"c_pref_matrix\"] = np.zeros([p[\"N\"], p[\"M\"]]).astype(int)\n        for i in range(p[\"N\"]):\n            for util in range(p['P']):\n                j = np.where(p[\"c_preferences\"][i, util] == p[\"afscs\"])[0]\n                if len(j) != 0:\n                    p['c_pref_matrix'][i, j[0]] = util + 1  # 1 is first choice (NOT 0)\n\n    # AFSC preferences and utilities are not required initial data elements (Depending on how we solve, they may be)\n    if \"AFSCs Utility\" in datasets:  # Load in the AFSC utility matrix\n        p[\"afsc_utility\"] = np.array(datasets[\"AFSCs Utility\"].loc[:, afsc_1: afsc_M])\n    if \"AFSCs Preferences\" in datasets:  # Load in the AFSC preferences dataframe\n        p[\"a_pref_matrix\"] = np.array(datasets[\"AFSCs Preferences\"].loc[:, afsc_1: afsc_M])\n\n    # All USAFA Cadets\n    p['usafa_cadets'] = np.where(p['usafa'])[0]\n\n    # Rated dataframes\n    if \"ROTC Rated Interest\" in datasets:\n        r_afscs = list(datasets['ROTC Rated Interest'].columns[1:])\n        p['rr_interest_matrix'] = np.array(datasets['ROTC Rated Interest'].loc[:, r_afscs[0]:r_afscs[len(r_afscs) - 1]])\n    if \"ROTC Rated OM\" in datasets:\n        r_afscs = list(datasets['ROTC Rated OM'].columns[1:])\n        p['rr_om_matrix'] = np.array(datasets['ROTC Rated OM'].loc[:, r_afscs[0]:r_afscs[len(r_afscs) - 1]])\n        p['rr_om_cadets'] = np.array(datasets['ROTC Rated OM']['Cadet'])\n    if \"USAFA Rated OM\" in datasets:\n        r_afscs = list(datasets['USAFA Rated OM'].columns[1:])\n        p['ur_om_matrix'] = np.array(datasets['USAFA Rated OM'].loc[:, r_afscs[0]:r_afscs[len(r_afscs) - 1]])\n        p['ur_om_cadets'] = np.array(datasets['USAFA Rated OM']['Cadet'])\n    if \"OTS Rated OM\" in datasets:\n        r_afscs = list(datasets['OTS Rated OM'].columns[1:])\n        p['or_om_matrix'] = np.array(datasets['OTS Rated OM'].loc[:, r_afscs[0]:r_afscs[len(r_afscs) - 1]])\n        p['or_om_cadets'] = np.array(datasets['OTS Rated OM']['Cadet'])\n\n    # Return dictionary of parameters\n    return p\n</code></pre>"},{"location":"reference/data/processing/#data.processing.import_value_parameters_data","title":"<code>import_value_parameters_data(import_filepaths, parameters, num_breakpoints=24)</code>","text":"<p>Imports and constructs value parameter sets for the model based on CSV definitions and analyst-defined breakpoints.</p> <p>This function reads and compiles all information associated with value-based decision modeling, including objective functions, breakpoints, weights, and value constraints for both cadets and AFSCs. It supports multiple sets of value parameters, each potentially with different assumptions or constraints.</p>"},{"location":"reference/data/processing/#data.processing.import_value_parameters_data--parameters","title":"Parameters","text":"<ul> <li> <p>import_filepaths : dict   Dictionary containing paths to relevant files. Required keys:</p> <ul> <li><code>\"Model Input\"</code>: folder path containing individual VP set CSVs.</li> <li><code>\"Value Parameters\"</code>: CSV listing metadata about each VP set. Optional keys:</li> <li><code>\"Cadets Utility Constraints\"</code>: file containing minimum cadet utility constraints by VP set.</li> </ul> </li> <li> <p>parameters : dict   Instance parameter dictionary already populated with <code>\"M\"</code>, <code>\"N\"</code>, and AFSC/cadet-level arrays.</p> </li> <li> <p>num_breakpoints : int, optional (default=24)   Number of breakpoints to discretize each value function unless exact breakpoints are provided.</p> </li> </ul>"},{"location":"reference/data/processing/#data.processing.import_value_parameters_data--returns","title":"Returns","text":"<p>dict A dictionary keyed by VP set names. Each value is a dictionary of value parameters containing:</p> <ul> <li>Objective definitions and weights</li> <li>Breakpoints (<code>a</code>) and values (<code>f^hat</code>)</li> <li>Minimum utility constraints</li> <li>AFSC objective indexed sets (<code>K^A</code>)</li> <li><code>cadet_weight</code>, <code>afsc_weight</code>, and associated metadata</li> <li>VP set weights and local weights for combination logic</li> </ul>"},{"location":"reference/data/processing/#data.processing.import_value_parameters_data--raises","title":"Raises","text":"<ul> <li> <p>FileNotFoundError   If required files are missing from the provided import paths.</p> </li> <li> <p>ValueError   If the <code>\"Value Parameters\"</code> file is missing or empty.</p> </li> </ul>"},{"location":"reference/data/processing/#data.processing.import_value_parameters_data--notes","title":"Notes","text":"<ul> <li>All AFSC objectives are indexed across <code>O</code> objectives per AFSC.</li> <li>The function automatically parses objective weight strings and reconstructs value functions if needed.</li> <li>For each VP set listed in the <code>\"Value Parameters\"</code> file, the function expects a matching CSV file named   <code>\"VP &lt;VP Name&gt;.csv\"</code> (e.g., <code>\"VP Baseline.csv\"</code>).</li> <li>Supports optional use of <code>\"Cadets Utility Constraints\"</code> to impose per-cadet minimums.</li> <li>If <code>num_breakpoints</code> is <code>None</code>, raw a/f^hat arrays are expected instead of constructing from strings.</li> <li>Value functions are compressed after loading to remove redundant zero segments for performance.</li> </ul>"},{"location":"reference/data/processing/#data.processing.import_value_parameters_data--see-also","title":"See Also","text":"<ul> <li><code>value_function_builder</code></li> <li><code>create_segment_dict_from_string</code></li> <li><code>condense_value_functions</code></li> <li><code>value_parameters_sets_additions</code></li> </ul> Source code in <code>afccp/data/processing.py</code> <pre><code>def import_value_parameters_data(import_filepaths, parameters, num_breakpoints=24):\n    \"\"\"\n    Imports and constructs value parameter sets for the model based on CSV definitions and analyst-defined breakpoints.\n\n    This function reads and compiles all information associated with value-based decision modeling, including\n    objective functions, breakpoints, weights, and value constraints for both cadets and AFSCs. It supports multiple\n    sets of value parameters, each potentially with different assumptions or constraints.\n\n    Parameters\n    ----------\n    - import_filepaths : dict\n      Dictionary containing paths to relevant files. Required keys:\n\n        - `\"Model Input\"`: folder path containing individual VP set CSVs.\n        - `\"Value Parameters\"`: CSV listing metadata about each VP set.\n        Optional keys:\n        - `\"Cadets Utility Constraints\"`: file containing minimum cadet utility constraints by VP set.\n\n    - parameters : dict\n      Instance parameter dictionary already populated with `\"M\"`, `\"N\"`, and AFSC/cadet-level arrays.\n\n    - num_breakpoints : int, optional (default=24)\n      Number of breakpoints to discretize each value function unless exact breakpoints are provided.\n\n    Returns\n    -------\n    dict\n    A dictionary keyed by VP set names. Each value is a dictionary of value parameters containing:\n\n    - Objective definitions and weights\n    - Breakpoints (`a`) and values (`f^hat`)\n    - Minimum utility constraints\n    - AFSC objective indexed sets (`K^A`)\n    - `cadet_weight`, `afsc_weight`, and associated metadata\n    - VP set weights and local weights for combination logic\n\n    Raises\n    ------\n    - FileNotFoundError\n      If required files are missing from the provided import paths.\n\n    - ValueError\n      If the `\"Value Parameters\"` file is missing or empty.\n\n    Notes\n    -----\n    - All AFSC objectives are indexed across `O` objectives per AFSC.\n    - The function automatically parses objective weight strings and reconstructs value functions if needed.\n    - For each VP set listed in the `\"Value Parameters\"` file, the function expects a matching CSV file named\n      `\"VP &lt;VP Name&gt;.csv\"` (e.g., `\"VP Baseline.csv\"`).\n    - Supports optional use of `\"Cadets Utility Constraints\"` to impose per-cadet minimums.\n    - If `num_breakpoints` is `None`, raw a/f^hat arrays are expected instead of constructing from strings.\n    - Value functions are compressed after loading to remove redundant zero segments for performance.\n\n    See Also\n    --------\n    - [`value_function_builder`](../../../afccp/reference/data/values/#data.values.value_function_builder)\n    - [`create_segment_dict_from_string`](../../../afccp/reference/data/values/#data.values.create_segment_dict_from_string)\n    - [`condense_value_functions`](../../../afccp/reference/data/values/#data.values.condense_value_functions)\n    - [`value_parameters_sets_additions`](../../../afccp/reference/data/values/#data.values.value_parameters_sets_additions)\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n    afccp_vp = afccp.data.values  # Reduce the module name so it fits on one line\n\n    # Import the cadets utility constraints dataframe if we have it.\n    if \"Cadets Utility Constraints\" in import_filepaths:\n        vp_cadet_df = afccp.globals.import_csv_data(import_filepaths[\"Cadets Utility Constraints\"])\n    else:\n        vp_cadet_df = None\n\n    # Import the \"Value Parameters\" dataframe if we have it. If we don't, the \"vp_dict\" will be \"None\"\n    if \"Value Parameters\" in import_filepaths:\n        overall_vp_df = afccp.globals.import_csv_data(import_filepaths[\"Value Parameters\"])\n    else:\n        return None  # Nothing more we can do now (No \"Value Parameters\" determined yet for this instance)\n\n    # Information about the sets of value parameters listed in the \"Value Parameters\" dataframe\n    vp_names = np.array(overall_vp_df['VP Name'])\n    num_vps = len(vp_names)\n    vp_weights = np.ones(num_vps) * 100  # Initially all weighted at 100%\n    if 'VP Weight' in overall_vp_df:\n        vp_weights = np.array(overall_vp_df['VP Weight'])\n\n    # Determine the filenames for the sets of value parameters (VP, VP_2, etc.)\n    vp_files = {}\n    for file in os.listdir(import_filepaths[\"Model Input\"]):\n        if \".csv\" not in file:\n            continue\n        check_vp = file.split(\" \")[1].replace(\".csv\", \"\")\n        if check_vp in vp_names and \"Utility\" not in file:  # Don't want VP Global Utility included here\n            vp_files[check_vp] = file\n\n    # Loop through each set of value parameters and load it into the dictionary\n    vp_dict = {}\n    for v, vp_name in enumerate(vp_names):\n\n        # Only load in the set of value parameters if we have it\n        if vp_name in vp_files:\n            filepath = import_filepaths[\"Model Input\"] + vp_files[vp_name]\n        else:\n            print(\"WARNING. Value Parameter set '\" + vp_name + \"' listed in the 'Value Parameters' dataframe but does\"\n                                                               \" not have its own dataframe (.csv) in 'Model Inputs'.\")\n            continue  # Skip this set of value parameters\n\n        # Load value parameter set dataframe\n        vp_df = afccp.globals.import_csv_data(filepath)\n        M, O = p['M'], int(len(vp_df) / p['M'])  # Number of AFSCs (M) and number of AFSC objectives (O)\n\n        # Initialize value parameters dictionary\n        value_parameters = {'O': O, \"afscs_overall_weight\": np.array(overall_vp_df['AFSCs Weight'])[v],\n                            \"cadets_overall_weight\": np.array(overall_vp_df['Cadets Weight'])[v],\n                            \"cadet_weight_function\": np.array(overall_vp_df['Cadet Weight Function'])[v],\n                            \"afsc_weight_function\": np.array(overall_vp_df['AFSC Weight Function'])[v],\n                            \"cadets_overall_value_min\": np.array(overall_vp_df['Cadets Min Value'])[v],\n                            \"afscs_overall_value_min\": np.array(overall_vp_df['AFSCs Min Value'])[v], \"M\": M,\n                            \"afsc_value_min\": np.zeros(M), 'cadet_value_min': np.zeros(p['N']),\n                            \"objective_value_min\": np.array([[\" \" * 20 for _ in range(O)] for _ in range(M)]),\n                            \"value_functions\": np.array([[\" \" * 200 for _ in range(O)] for _ in range(M)]),\n                            \"constraint_type\": np.zeros([M, O]), 'a': [[[] for _ in range(O)] for _ in range(M)],\n                            \"objective_target\": np.zeros([M, O]), 'f^hat': [[[] for _ in range(O)] for _ in range(M)],\n                            \"objective_weight\": np.zeros([M, O]), \"afsc_weight\": np.zeros(M),\n                            'objectives': np.array(vp_df.loc[:int(len(vp_df) / M - 1), 'Objective']), \"K^A\": {},\n                            'num_breakpoints': num_breakpoints}\n\n        # If we have constraints specified for cadet utility\n        if vp_cadet_df is not None:\n            value_parameters[\"cadet_value_min\"] = np.array(vp_cadet_df[vp_name]).astype(float)\n\n        # Determine weights on cadets\n        if 'merit_all' in parameters:\n            value_parameters['cadet_weight'] = afccp_vp.cadet_weight_function(\n                parameters['merit_all'], func=value_parameters['cadet_weight_function'])\n        else:\n            value_parameters['cadet_weight'] = afccp_vp.cadet_weight_function(\n                parameters['merit'], func=value_parameters['cadet_weight_function'])\n\n        # Load in value parameter data for each AFSC\n        for j in p[\"J\"]:  # These are Os (Ohs) not 0s (zeros)\n            value_parameters[\"objective_target\"][j, :] = np.array(vp_df.loc[j * O:(j * O + O - 1), 'Objective Target'])\n\n            # Force objective weights to sum to 1. K^A is the set of objectives that have non-zero weights for each AFSC\n            objective_weights = np.array(vp_df.loc[j * O:(j * O + O - 1), 'Objective Weight'])\n            value_parameters[\"objective_weight\"][j, :] = objective_weights / sum(objective_weights)\n            value_parameters['K^A'][j] = np.where(value_parameters['objective_weight'][j, :] &gt; 0)[0].astype(int)\n\n            value_parameters[\"objective_value_min\"][j, :] = np.array(vp_df.loc[j * O:(j * O + O - 1),\n                                                                     'Min Objective Value'])\n            value_parameters[\"constraint_type\"][j, :] = np.array(vp_df.loc[j * O:(j * O + O - 1), 'Constraint Type'])\n            value_parameters[\"value_functions\"][j, :] = np.array(vp_df.loc[j * O:(j * O + O - 1), 'Value Functions'])\n            value_parameters[\"afsc_weight\"][j] = vp_df.loc[j * O, \"AFSC Weight\"]\n            value_parameters[\"afsc_value_min\"][j] = vp_df.loc[j * O, \"Min Value\"]\n            cadets = parameters['I^E'][j]  # Indices of cadets that are eligible for this AFSC\n\n            # Loop through each objective for this AFSC\n            for k, objective in enumerate(value_parameters['objectives']):\n\n                # Refactored column names\n                if 'Function Breakpoints' in vp_df:\n                    measure_col_name = 'Function Breakpoints'\n                    value_col_name = 'Function Breakpoint Values'\n                else:\n                    measure_col_name = 'Function Breakpoint Measures (a)'\n                    value_col_name = 'Function Breakpoint Values (f^hat)'\n\n                # We import the functions directly from the breakpoints\n                if num_breakpoints is None:\n                    a_string = vp_df.loc[j * O + k, measure_col_name]\n                    if type(a_string) == str:\n                        value_parameters['a'][j][k] = [float(x) for x in a_string.split(\",\")]\n                    fhat_string = vp_df.loc[j * O + k, value_col_name]\n                    if type(fhat_string) == str:\n                        value_parameters['f^hat'][j][k] = [float(x) for x in fhat_string.split(\",\")]\n\n                # Recreate the functions from the vf strings\n                else:\n                    vf_string = value_parameters[\"value_functions\"][j, k]\n                    if vf_string != 'None':\n                        if objective == 'Merit':\n                            actual = np.mean(parameters['merit'][cadets])\n                        elif objective == 'USAFA Proportion':\n                            actual = np.mean(parameters['usafa'][cadets])\n                        else:\n                            actual = None\n\n                        # Adjust target information for the \"Combined Quota\" objective\n                        if objective == 'Combined Quota':\n                            minimum, maximum = p['quota_min'][j], p['quota_max'][j]\n                            target = p['quota_d'][j]  # Desired number of cadets\n                        else:\n                            minimum, maximum, target = None, None, value_parameters['objective_target'][j, k]\n\n                        # Construct the value function (get the breakpoint coordinates)\n                        segment_dict = afccp_vp.create_segment_dict_from_string(\n                            vf_string, target, actual=actual, maximum=maximum, minimum=minimum)\n                        value_parameters['a'][j][k], value_parameters['f^hat'][j][k] = afccp_vp.value_function_builder(\n                            segment_dict, num_breakpoints=num_breakpoints)\n\n        # Force AFSC weights to sum to 1\n        value_parameters[\"afsc_weight\"] = value_parameters[\"afsc_weight\"] / sum(value_parameters[\"afsc_weight\"])\n\n        # \"Condense\" the value functions by removing unnecessary zeros\n        value_parameters = afccp_vp.condense_value_functions(p, value_parameters)\n\n        # Add indexed sets and subsets of AFSCs and AFSC objectives\n        value_parameters = afccp_vp.value_parameters_sets_additions(p, value_parameters)\n\n        # Save the value parameters to the dictionary\n        vp_dict[vp_name] = copy.deepcopy(value_parameters)\n        vp_dict[vp_name]['vp_weight'] = vp_weights[v]\n        vp_dict[vp_name]['vp_local_weight'] = vp_weights[v] / sum(vp_weights)\n\n    # Return the dictionary of value parameter sets\n    return vp_dict\n</code></pre>"},{"location":"reference/data/processing/#data.processing.import_solutions_data","title":"<code>import_solutions_data(import_filepaths, parameters)</code>","text":"<p>Imports and assembles cadet assignment solutions from a saved output file (<code>&lt;data_name&gt; Solutions.csv</code>). Optionally, more files are read in for Base/Training Course solutions.</p> <p>This function reads solution files containing AFSC, base, and course assignments for each cadet, converts string labels to indexed arrays, and returns a structured dictionary containing all available solution configurations.</p>"},{"location":"reference/data/processing/#data.processing.import_solutions_data--parameters","title":"Parameters","text":"<ul> <li> <p>import_filepaths : dict Dictionary containing filepaths to solution files. Expected keys:</p> <ul> <li><code>\"Solutions\"</code>: required CSV file with AFSC assignments (one column per solution).</li> <li><code>\"Base Solutions\"</code>: optional CSV with base assignments (same column names as above).</li> <li><code>\"Course Solutions\"</code>: optional CSV with course assignments (same column names as above).</li> </ul> </li> <li> <p>parameters : dict Dictionary of instance parameters. Must contain:</p> <ul> <li><code>'afscs'</code>: array of valid AFSC names.</li> <li><code>'bases'</code>: array of valid base names (if <code>\"Base Solutions\"</code> is provided).</li> <li><code>'courses'</code>: list of valid course arrays for each AFSC (if <code>\"Course Solutions\"</code> is provided).</li> <li><code>'S'</code>: sentinel index value for unmatched bases.</li> </ul> </li> </ul>"},{"location":"reference/data/processing/#data.processing.import_solutions_data--returns","title":"Returns","text":"<p>dict Dictionary mapping solution names to their data. Each solution entry contains:</p> <ul> <li><code>'name'</code>: name of the solution (from CSV column header)</li> <li><code>'afsc_array'</code>: array of assigned AFSC strings</li> <li><code>'j_array'</code>: array of assigned AFSC indices (matching <code>parameters['afscs']</code>)</li> <li><code>'base_array'</code> (optional): array of base names (if base data is present)</li> <li><code>'b_array'</code> (optional): array of base indices (or sentinel <code>S</code> if unmatched)</li> <li><code>'course_array'</code> (optional): array of course names (if course data is present)</li> <li><code>'c_array'</code> (optional): array of <code>(j, c)</code> tuples representing AFSC/course index pairs</li> </ul>"},{"location":"reference/data/processing/#data.processing.import_solutions_data--raises","title":"Raises","text":"<ul> <li>FileNotFoundError   If the required <code>\"Solutions\"</code> file is not present in <code>import_filepaths</code>.</li> </ul>"},{"location":"reference/data/processing/#data.processing.import_solutions_data--notes","title":"Notes","text":"<ul> <li>If a course assignment is not found within any AFSC\u2019s course list, a fallback value of <code>(0, 0)</code> is added   and a warning is printed.</li> <li>Assumes that all solution files share the same cadet ordering and column headers for consistent mapping.</li> </ul>"},{"location":"reference/data/processing/#data.processing.import_solutions_data--see-also","title":"See Also","text":"<ul> <li><code>import_csv_data</code></li> <li><code>initialize_file_information</code></li> </ul> Source code in <code>afccp/data/processing.py</code> <pre><code>def import_solutions_data(import_filepaths, parameters):\n    \"\"\"\n    Imports and assembles cadet assignment solutions from a saved output file (`&lt;data_name&gt; Solutions.csv`). Optionally,\n    more files are read in for Base/Training Course solutions.\n\n    This function reads solution files containing AFSC, base, and course assignments for each cadet,\n    converts string labels to indexed arrays, and returns a structured dictionary containing all\n    available solution configurations.\n\n    Parameters\n    ----------\n    - import_filepaths : dict\n    Dictionary containing filepaths to solution files. Expected keys:\n\n        - `\"Solutions\"`: required CSV file with AFSC assignments (one column per solution).\n        - `\"Base Solutions\"`: optional CSV with base assignments (same column names as above).\n        - `\"Course Solutions\"`: optional CSV with course assignments (same column names as above).\n\n    - parameters : dict\n    Dictionary of instance parameters. Must contain:\n\n        - `'afscs'`: array of valid AFSC names.\n        - `'bases'`: array of valid base names (if `\"Base Solutions\"` is provided).\n        - `'courses'`: list of valid course arrays for each AFSC (if `\"Course Solutions\"` is provided).\n        - `'S'`: sentinel index value for unmatched bases.\n\n    Returns\n    -------\n    dict\n    Dictionary mapping solution names to their data. Each solution entry contains:\n\n    - `'name'`: name of the solution (from CSV column header)\n    - `'afsc_array'`: array of assigned AFSC strings\n    - `'j_array'`: array of assigned AFSC indices (matching `parameters['afscs']`)\n    - `'base_array'` (optional): array of base names (if base data is present)\n    - `'b_array'` (optional): array of base indices (or sentinel `S` if unmatched)\n    - `'course_array'` (optional): array of course names (if course data is present)\n    - `'c_array'` (optional): array of `(j, c)` tuples representing AFSC/course index pairs\n\n    Raises\n    ------\n    - FileNotFoundError\n      If the required `\"Solutions\"` file is not present in `import_filepaths`.\n\n    Notes\n    -----\n    - If a course assignment is not found within any AFSC\u2019s course list, a fallback value of `(0, 0)` is added\n      and a warning is printed.\n    - Assumes that all solution files share the same cadet ordering and column headers for consistent mapping.\n\n    See Also\n    --------\n    - [`import_csv_data`](../../../afccp/reference/globals/#globals.import_csv_data)\n    - [`initialize_file_information`](../../../afccp/reference/data/processing/#data.processing.initialize_file_information)\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Import the \"Solutions\" dataframe if we have it. If we don't, the \"solutions_dict\" will be \"None\"\n    if \"Solutions\" in import_filepaths:\n        solutions_df = afccp.globals.import_csv_data(import_filepaths[\"Solutions\"])\n    else:\n        return None  # Nothing more we can do now (No solutions determined yet for this instance)\n\n    # Get list of solution names\n    solution_names = list(solutions_df.keys())[1:]\n\n    # Loop through each solution, convert to a numpy array of AFSC indices, and then add it to the dictionary\n    solutions = {}\n    for solution_name in solution_names:\n\n        # Convert solution of AFSC names to indices and then save it to the dictionary\n        afsc_solution = np.array(solutions_df[solution_name])  # [\"15A\", \"14N\", \"17X\", ...]\n        solution = {'j_array': np.array([np.where(p['afscs'] == afsc)[0][0] for afsc in afsc_solution]), # [3, 2, 5, ...]\n                    'name': solution_name, 'afsc_array': afsc_solution}\n        solutions[solution_name] = copy.deepcopy(solution)\n\n    # If we have this extra component\n    if 'Base Solutions' in import_filepaths:\n        solutions_df = afccp.globals.import_csv_data(import_filepaths['Base Solutions'])\n\n        # Get list of solution names\n        solution_names = list(solutions_df.keys())[1:]\n\n        # Loop through each solution in this dataframe and add the base assignments\n        for solution_name in solution_names:\n            base_solution = np.array(solutions_df[solution_name])\n            solutions[solution_name]['base_array'] = base_solution\n            solutions[solution_name]['b_array'] = np.array(\n                [np.where(p['bases'] == base)[0][0] if base in base_solution else p['S'] for base in base_solution])\n\n    # If we have this extra component\n    if 'Course Solutions' in import_filepaths:\n        solutions_df = afccp.globals.import_csv_data(import_filepaths['Course Solutions'])\n\n        # Get list of solution names\n        solution_names = list(solutions_df.keys())[1:]\n\n        # Loop through each solution in this dataframe and add the course assignments\n        for solution_name in solution_names:\n            course_solution = np.array(solutions_df[solution_name])\n            solutions[solution_name]['course_array'] = course_solution\n            c_array = []\n            for i, course in enumerate(course_solution):\n                found = False\n                for j in range(p['M']):\n                    if course in p['courses'][j]:\n                        c = np.where(p['courses'][j] == course)[0][0]\n                        c_array.append((j, c))\n                        found = True\n                        break\n\n                # This shouldn't happen!\n                if not found:\n                    print(\"Course '\" + str(course) + \"' not valid for cadet\", i)\n                    c_array.append((0, 0))\n            solutions[solution_name]['c_array'] = np.array(c_array)\n\n    # Return the dictionary of solutions\n    return solutions\n</code></pre>"},{"location":"reference/data/processing/#data.processing.import_additional_data","title":"<code>import_additional_data(import_filepaths, parameters)</code>","text":"<p>Imports supplemental data files (if present) and updates the instance parameters dictionary.</p> <p>This function loads optional model extensions including base and course assignments, preference matrices, and CASTLE-specific AFSC data. These components are not required for basic operation but enhance downstream modeling functionality (e.g., course scheduling, base optimization, CASTLE implementation).</p>"},{"location":"reference/data/processing/#data.processing.import_additional_data--parameters","title":"Parameters","text":"<ul> <li> <p>import_filepaths : dict   Dictionary containing filepaths to additional optional data files. Expected keys include:</p> <ul> <li>\"Bases\", \"Bases Preferences\", \"Bases Utility\"</li> <li>\"Courses\", \"Castle Input\"</li> </ul> </li> <li> <p>parameters : dict   Dictionary of core model parameters. This dictionary will be updated with any new fields derived from imported files.</p> </li> </ul>"},{"location":"reference/data/processing/#data.processing.import_additional_data--returns","title":"Returns","text":"<p>dict Updated parameter dictionary with the following optional fields added if available:</p> <ul> <li><code>'bases'</code>: Array of base names</li> <li><code>'S'</code>: Number of bases</li> <li><code>'base_min'</code> / <code>'base_max'</code>: Base assignment bounds by AFSC</li> <li><code>'b_pref_matrix'</code>: Cadet base preference matrix</li> <li><code>'base_utility'</code>: Cadet base utility matrix</li> <li><code>'courses'</code>: Dict of course options by AFSC</li> <li><code>'course_start'</code>, <code>'course_min'</code>, <code>'course_max'</code>: Dicts with course metadata by AFSC</li> <li><code>'castle_afscs_arr'</code>, <code>'afpc_afscs_arr'</code>: Raw CASTLE vs AFPC AFSC labels</li> <li><code>'castle_afscs'</code>: Mapping of CASTLE AFSCs \u2192 AFPC AFSCs</li> <li><code>'J^CASTLE'</code>: CASTLE AFSCs mapped to indices in the AFPC AFSC array</li> <li><code>'ots_counts'</code>: OTS accession counts for CASTLE AFSCs</li> <li><code>'optimal_policy'</code>: Policy toggle per CASTLE AFSC</li> <li> <p><code>'castle_q'</code>: Dictionary of breakpoint-based value functions:</p> <ul> <li><code>'a'</code>, <code>'f^hat'</code>: Breakpoints and values</li> <li><code>'r'</code>: Number of breakpoints</li> <li><code>'L'</code>: Breakpoint indices</li> </ul> </li> </ul>"},{"location":"reference/data/processing/#data.processing.import_additional_data--notes","title":"Notes","text":"<ul> <li>Breakpoint information from <code>\"Castle Input\"</code> is stored under <code>castle_q</code>.</li> <li>Course and base matrices are assumed to be properly aligned with the cadet and AFSC indices already in memory.</li> <li>All newly imported data is optional and loaded only if the corresponding files are provided.</li> </ul>"},{"location":"reference/data/processing/#data.processing.import_additional_data--see-also","title":"See Also","text":"<ul> <li><code>initialize_file_information</code></li> <li><code>import_csv_data</code></li> </ul> Source code in <code>afccp/data/processing.py</code> <pre><code>def import_additional_data(import_filepaths, parameters):\n    \"\"\"\n    Imports supplemental data files (if present) and updates the instance parameters dictionary.\n\n    This function loads optional model extensions including base and course assignments, preference matrices,\n    and CASTLE-specific AFSC data. These components are not required for basic operation but enhance downstream\n    modeling functionality (e.g., course scheduling, base optimization, CASTLE implementation).\n\n    Parameters\n    ----------\n    - import_filepaths : dict\n      Dictionary containing filepaths to additional optional data files. Expected keys include:\n\n        - \"Bases\", \"Bases Preferences\", \"Bases Utility\"\n        - \"Courses\", \"Castle Input\"\n\n    - parameters : dict\n      Dictionary of core model parameters. This dictionary will be updated with any new fields derived from imported files.\n\n    Returns\n    -------\n    dict\n    Updated parameter dictionary with the following optional fields added if available:\n\n    - `'bases'`: Array of base names\n    - `'S'`: Number of bases\n    - `'base_min'` / `'base_max'`: Base assignment bounds by AFSC\n    - `'b_pref_matrix'`: Cadet base preference matrix\n    - `'base_utility'`: Cadet base utility matrix\n    - `'courses'`: Dict of course options by AFSC\n    - `'course_start'`, `'course_min'`, `'course_max'`: Dicts with course metadata by AFSC\n    - `'castle_afscs_arr'`, `'afpc_afscs_arr'`: Raw CASTLE vs AFPC AFSC labels\n    - `'castle_afscs'`: Mapping of CASTLE AFSCs \u2192 AFPC AFSCs\n    - `'J^CASTLE'`: CASTLE AFSCs mapped to indices in the AFPC AFSC array\n    - `'ots_counts'`: OTS accession counts for CASTLE AFSCs\n    - `'optimal_policy'`: Policy toggle per CASTLE AFSC\n    - `'castle_q'`: Dictionary of breakpoint-based value functions:\n\n        - `'a'`, `'f^hat'`: Breakpoints and values\n        - `'r'`: Number of breakpoints\n        - `'L'`: Breakpoint indices\n\n    Notes\n    -----\n    - Breakpoint information from `\"Castle Input\"` is stored under `castle_q`.\n    - Course and base matrices are assumed to be properly aligned with the cadet and AFSC indices already in memory.\n    - All newly imported data is optional and loaded only if the corresponding files are provided.\n\n    See Also\n    --------\n    - [`initialize_file_information`](../../../afccp/reference/data/processing/#data.processing.initialize_file_information)\n    - [`import_csv_data`](../../../afccp/reference/globals/#globals.import_csv_data)\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Loop through the potential additional dataframes and import them if we have them\n    datasets = {}\n    for dataset in [\"Bases\", \"Bases Preferences\", \"Bases Utility\", \"Courses\", \"Castle Input\"]:\n\n        # If we have the dataset, import it\n        if dataset in import_filepaths:\n            datasets[dataset] = afccp.globals.import_csv_data(import_filepaths[dataset])\n\n    # First and last AFSC (for collecting matrices from dataframes)\n    afsc_1, afsc_M = p[\"afscs\"][0], p[\"afscs\"][p[\"M\"] - 1]\n\n    # Extract data from \"Bases.csv\" if applicable\n    if \"Bases\" in datasets:\n        p['bases'] = np.array(datasets[\"Bases\"][\"Base\"])  # Set of bases (names)\n        p['S'] = len(p['bases'])  # Number of bases (S for \"Station\")\n        p['base_min'] = np.array(datasets['Bases'].loc[:, afsc_1 + \" Min\": afsc_M + \" Min\"])  # Minimum base # by AFSC\n        p['base_max'] = np.array(datasets['Bases'].loc[:, afsc_1 + \" Max\": afsc_M + \" Max\"])  # Maximum base # by AFSC\n\n    # Extract data from \"Base Preferences.csv\" and \"Base Utility.csv\" if applicable\n    for parameter, dataset in {'b_pref_matrix': 'Bases Preferences', 'base_utility': 'Bases Utility'}.items():\n        if dataset in datasets:\n            base_1, base_S = p['bases'][0], p['bases'][p['S'] - 1]\n            p[parameter] = np.array(datasets[dataset].loc[:, base_1: base_S])\n\n    # Extract data from \"Courses.csv\" if applicable\n    if \"Courses\" in datasets:\n\n        # Need a dictionary of indices of courses that apply to each AFSC\n        afscs = np.array(datasets[\"Courses\"][\"AFSC\"])\n        afsc_courses = {j: np.where(afscs == p['afscs'][j])[0] for j in range(p['M'])}\n\n        # Dictionary to translate parameter names to column names\n        column_translation = {\"Course\": 'courses', 'Start Date': 'course_start', 'Min': 'course_min',\n                              'Max': 'course_max'}\n\n        # Get each parameter from the columns of this dataset\n        for col, param in column_translation.items():\n            arr = np.array(datasets['Courses'][col])  # Convert dataframe column to numpy array\n            p[param] = {j: arr[afsc_courses[j]] for j in range(p['M'])}\n\n    # Extract data from \"Castle Input.csv\" if applicable\n    if \"Castle Input\" in datasets:\n\n        # Load in AFSC arrays\n        castle_afscs = np.array(datasets['Castle Input']['CASTLE AFSC'])\n        afpc_afscs = np.array(datasets['Castle Input']['AFPC AFSC'])\n        p['castle_afscs_arr'], p['afpc_afscs_arr'] = castle_afscs, afpc_afscs\n\n        # Create dictionary of CASTLE AFSCs -&gt; AFPC AFSCs (account for groupings)\n        p['castle_afscs'], p['J^CASTLE'] = {}, {}\n        for castle_afsc in np.unique(castle_afscs):\n            indices = np.where(castle_afscs == castle_afsc)[0]\n            p['castle_afscs'][castle_afsc] = afpc_afscs[indices]\n            p['J^CASTLE'][castle_afsc] = np.array([np.where(p['afscs'] == afsc)[0][0] for afsc in afpc_afscs[indices]])\n\n        # Initialize OTS counts and optimal policy dictionary\n        p['ots_counts'], p['optimal_policy'] = {}, {}\n\n        # Load in \"q\" dictionary information if it exists\n        df = datasets['Castle Input']  # Shorthand\n        if 'a' in df.columns:\n            q = {'a': {}, 'f^hat': {}, 'r': {}, 'L': {}}\n            for afsc in np.unique(castle_afscs):\n                row = df.loc[df['CASTLE AFSC'] == afsc].head(1).iloc[0]\n\n                # Add OTS count information and optimal policy information for this AFSC\n                p['ots_counts'][afsc] = row['OTS Count']\n                p['optimal_policy'][afsc] = row['Optimal']\n\n                # Load breakpoint coordinates into q dictionary\n                a_str, f_hat_str = str(row['a']), str(row['f^hat'])\n                q['a'][afsc] = np.array([float(x) for x in a_str.split(\",\")])\n                q['f^hat'][afsc] = np.array([float(x) for x in f_hat_str.split(\",\")])\n\n                # Save additional information to q dictionary\n                q['r'][afsc], q['L'][afsc] = len(q['a'][afsc]), np.arange(len(q['a'][afsc]))\n                p['castle_q'] = q  # Save to parameters dictionary\n\n    # Return parameters dictionary\n    return p\n</code></pre>"},{"location":"reference/data/processing/#data.processing.export_afscs_data","title":"<code>export_afscs_data(instance)</code>","text":"<p>Exports AFSC-level data from the given <code>Instance</code> object to a CSV file.</p> <p>This function collects Air Force Specialty Code (AFSC) parameters stored in the instance, organizes them into a structured dataframe, and writes the result to disk at the location specified by <code>instance.export_paths[\"AFSCs\"]</code>.</p>"},{"location":"reference/data/processing/#data.processing.export_afscs_data--parameters","title":"Parameters","text":"<ul> <li>instance : Instance   A fully initialized <code>Instance</code> object with a populated <code>parameters</code> dictionary and <code>export_paths</code> mapping.   The instance must include AFSC data such as quotas, eligibility, preference counts, and any   derived degree tier breakdowns.</li> </ul>"},{"location":"reference/data/processing/#data.processing.export_afscs_data--returns","title":"Returns","text":"<ul> <li>None   The function writes the output to disk and does not return a value.</li> </ul>"},{"location":"reference/data/processing/#data.processing.export_afscs_data--notes","title":"Notes","text":"<ul> <li> <p>The function dynamically detects and exports the following fields if present:</p> <ul> <li>Core AFSC descriptors: name, accession group, STEM tag, base assignment</li> <li>Quota targets: Desired, Estimated, Min, Max, PGL, commissioning source quotas</li> <li>Course counts (<code>T</code>) and bubble caps (<code>max_bubbles</code>)</li> <li>Eligibility counts per commissioning source</li> <li>Degree tier distributions and tier counts (if <code>\"Deg Tiers\"</code> and <code>\"I^D\"</code> are available)</li> <li>Cadet preference counts per AFSC (if <code>\"Choice Count\"</code> is present)</li> </ul> </li> <li> <p>Only the first <code>p[\"M\"]</code> AFSCs are included in the output. Any padding elements (e.g., \"*\") are excluded.</p> </li> <li> <p>The output file is named <code>\"AFSCs.csv\"</code> and stored in the directory determined by <code>instance.export_paths</code>.</p> </li> </ul>"},{"location":"reference/data/processing/#data.processing.export_afscs_data--see-also","title":"See Also","text":"<ul> <li><code>import_afscs_data</code></li> <li><code>initialize_file_information</code></li> </ul> Source code in <code>afccp/data/processing.py</code> <pre><code>def export_afscs_data(instance):\n    \"\"\"\n    Exports AFSC-level data from the given `Instance` object to a CSV file.\n\n    This function collects Air Force Specialty Code (AFSC) parameters stored in the instance,\n    organizes them into a structured dataframe, and writes the result to disk at the location\n    specified by `instance.export_paths[\"AFSCs\"]`.\n\n    Parameters\n    ----------\n    - instance : Instance\n      A fully initialized `Instance` object with a populated `parameters` dictionary and `export_paths` mapping.\n      The instance must include AFSC data such as quotas, eligibility, preference counts, and any\n      derived degree tier breakdowns.\n\n    Returns\n    -------\n    - None\n      The function writes the output to disk and does not return a value.\n\n    Notes\n    -----\n    - The function dynamically detects and exports the following fields if present:\n\n        - Core AFSC descriptors: name, accession group, STEM tag, base assignment\n        - Quota targets: Desired, Estimated, Min, Max, PGL, commissioning source quotas\n        - Course counts (`T`) and bubble caps (`max_bubbles`)\n        - Eligibility counts per commissioning source\n        - Degree tier distributions and tier counts (if `\"Deg Tiers\"` and `\"I^D\"` are available)\n        - Cadet preference counts per AFSC (if `\"Choice Count\"` is present)\n\n    - Only the first `p[\"M\"]` AFSCs are included in the output. Any padding elements (e.g., \"*\") are excluded.\n\n    - The output file is named `\"AFSCs.csv\"` and stored in the directory determined by `instance.export_paths`.\n\n    See Also\n    --------\n    - [`import_afscs_data`](../../../afccp/reference/data/processing/#data.processing.import_afscs_data)\n    - [`initialize_file_information`](../../../afccp/reference/data/processing/#data.processing.initialize_file_information)\n    \"\"\"\n\n    # Shorthand\n    p = instance.parameters\n\n    # Initialize dictionary translating AFSC parameters to their \"AFSCs\" df column counterparts\n    afsc_parameters_to_columns = {\"afscs\": \"AFSC\", \"acc_grp\": \"Accessions Group\", \"afscs_stem\": \"STEM\",\n                                  \"usafa_quota\": \"USAFA Target\", \"rotc_quota\": \"ROTC Target\", 'ots_quota': 'OTS Target',\n                                  \"pgl\": \"PGL Target\", \"quota_e\": \"Estimated\",\n                                  \"quota_d\": \"Desired\", \"quota_min\": \"Min\", \"quota_max\": \"Max\",\n                                  'max_bubbles': 'Max (Bubbles)',\n                                  \"afsc_assign_base\": 'Assign Base', 'T': 'Num Courses',\n                                  'usafa_eligible_count': 'USAFA Eligible', 'rotc_eligible_count': 'ROTC Eligible',\n                                  'ots_eligible_count': \"OTS Eligible\"}\n\n    # Loop through each parameter in the translation dictionary to create dictionary of \"AFSCs\" columns\n    afscs_columns = {}\n    for parameter in afsc_parameters_to_columns:\n\n        # If we have the parameter, create the column\n        if parameter in p:\n            col_name = afsc_parameters_to_columns[parameter]\n            afscs_columns[col_name] = p[parameter][:p[\"M\"]]  # Don't want to include the *!\n\n    # Create the degree tier columns\n    if \"Deg Tiers\" in p:\n        for t in range(4):\n            afscs_columns[\"Deg Tier \" + str(t + 1)] = p[\"Deg Tiers\"][:, t]\n\n    # Degree Tier Counts\n    if \"Tier 1\" in p['I^D']:\n        for t in ['1', '2', '3', '4']:\n            afscs_columns['Deg Tier ' + t + ' Count'] = [len(p['I^D']['Tier ' + t][j]) for j in p['J']]\n\n    # Preference Counts\n    if 'Choice Count' in p:\n        for choice in p['Choice Count']:\n            afscs_columns['Choice ' + str(choice + 1)] = p['Choice Count'][choice]\n\n    # Create dataframe\n    afscs_df = pd.DataFrame(afscs_columns)\n\n    # Export 'AFSCs' dataframe\n    afscs_df.to_csv(instance.export_paths[\"AFSCs\"], index=False)\n</code></pre>"},{"location":"reference/data/processing/#data.processing.export_cadets_data","title":"<code>export_cadets_data(instance)</code>","text":"<p>Exports cadet-level data from the given <code>Instance</code> object to a CSV file.</p> <p>This function builds the \"Cadets\" dataframe from internal model parameters stored in the instance, capturing individual cadet characteristics, preferences, and qualification data (if available). The output is saved to disk at the location specified by <code>instance.export_paths[\"Cadets\"]</code>.</p>"},{"location":"reference/data/processing/#data.processing.export_cadets_data--parameters","title":"Parameters","text":"<ul> <li>instance : Instance   A fully initialized <code>Instance</code> object containing model parameters (<code>parameters</code>) and a configured   export path for the \"Cadets\" CSV file.</li> </ul>"},{"location":"reference/data/processing/#data.processing.export_cadets_data--returns","title":"Returns","text":"<ul> <li>None   The function writes the cadet-level data to disk and does not return a value.</li> </ul>"},{"location":"reference/data/processing/#data.processing.export_cadets_data--notes","title":"Notes","text":"<ul> <li> <p>The following cadet-level attributes will be included if present in <code>parameters</code>:</p> <ul> <li>Basic profile: Cadet ID, gender, race, ethnicity, accession group, STEM tag, ASC codes</li> <li>Assignment metadata: must-match flags, base/course preferences, assigned AFSC</li> <li>Merit metrics: raw merit, real merit</li> <li>Training data: start date, preference rankings, course/base weights and thresholds</li> <li>Utility and preference columns: if present, the full <code>c_utilities</code> and <code>c_preferences</code> matrices will be exported</li> <li>Qualification data: if a <code>qual</code> matrix is present, columns are added for each AFSC (e.g., <code>qual_17X</code>, <code>qual_21R</code>)</li> </ul> </li> <li> <p>The preference and utility columns are labeled as <code>Pref_1</code>, <code>Pref_2</code>, ..., <code>Util_1</code>, <code>Util_2</code>, etc.</p> </li> <li>The output is saved as <code>\"Cadets.csv\"</code> under the directory given by <code>instance.export_paths</code>.</li> </ul>"},{"location":"reference/data/processing/#data.processing.export_cadets_data--see-also","title":"See Also","text":"<ul> <li><code>import_cadets_data</code></li> <li><code>initialize_file_information</code></li> </ul> Source code in <code>afccp/data/processing.py</code> <pre><code>def export_cadets_data(instance):\n    \"\"\"\n    Exports cadet-level data from the given `Instance` object to a CSV file.\n\n    This function builds the \"Cadets\" dataframe from internal model parameters stored in the instance,\n    capturing individual cadet characteristics, preferences, and qualification data (if available).\n    The output is saved to disk at the location specified by `instance.export_paths[\"Cadets\"]`.\n\n    Parameters\n    ----------\n    - instance : Instance\n      A fully initialized `Instance` object containing model parameters (`parameters`) and a configured\n      export path for the \"Cadets\" CSV file.\n\n    Returns\n    -------\n    - None\n      The function writes the cadet-level data to disk and does not return a value.\n\n    Notes\n    -----\n    - The following cadet-level attributes will be included if present in `parameters`:\n\n        - Basic profile: Cadet ID, gender, race, ethnicity, accession group, STEM tag, ASC codes\n        - Assignment metadata: must-match flags, base/course preferences, assigned AFSC\n        - Merit metrics: raw merit, real merit\n        - Training data: start date, preference rankings, course/base weights and thresholds\n        - Utility and preference columns: if present, the full `c_utilities` and `c_preferences` matrices will be exported\n        - Qualification data: if a `qual` matrix is present, columns are added for each AFSC (e.g., `qual_17X`, `qual_21R`)\n\n    - The preference and utility columns are labeled as `Pref_1`, `Pref_2`, ..., `Util_1`, `Util_2`, etc.\n    - The output is saved as `\"Cadets.csv\"` under the directory given by `instance.export_paths`.\n\n    See Also\n    --------\n    - [`import_cadets_data`](../../../afccp/reference/data/processing/#data.processing.import_cadets_data)\n    - [`initialize_file_information`](../../../afccp/reference/data/processing/#data.processing.initialize_file_information)\n    \"\"\"\n\n    # Shorthand\n    p = instance.parameters\n\n    # Initialize dictionary translating 'AFSCs' df columns to their parameter counterparts\n    cadet_parameters_to_columns = {\"cadets\": \"Cadet\", \"must_match\": \"Must Match\",\n                                   \"assigned\": \"Assigned\", \"acc_grp_constraint\": \"Accessions Group\",\n                                   'training_start': 'Start Date', 'training_preferences': 'Start Pref',\n                                   'base_threshold': 'Base Threshold', 'training_threshold': 'Course Threshold',\n                                   'weight_afsc': 'AFSC Weight', 'weight_base': 'Base Weight',\n                                   'weight_course': 'Course Weight',\n                                   \"sf_om\": \"SF OM\", 'usafa': 'USAFA', 'soc': 'SOC',\n                                   'male': 'Male', 'minority': 'Minority',\n                                   'race': 'Race', \"ethnicity\": \"Ethnicity\", 'asc1': 'ASC1', 'asc2': 'ASC2',\n                                   'stem': 'STEM', 'cip1': 'CIP1', 'cip2': 'CIP2', 'merit': 'Merit',\n                                   'merit_all': 'Real Merit', 'last_afsc': 'Least Desired AFSC',\n                                   'second_to_last_afscs': 'Second Least Desired AFSCs'}\n\n    # Loop through each parameter in the translation dictionary to get \"Cadets\" dataframe column counterpart\n    cadets_columns = {}\n    for parameter in cadet_parameters_to_columns:\n\n        # If we have the parameter, we create its column\n        if parameter in p:\n            col_name = cadet_parameters_to_columns[parameter]\n            cadets_columns[col_name] = p[parameter]\n\n    # If we had the cadet pafccp/reference/utility columns before, we'll add them back in\n    if \"c_preferences\" in p:\n\n        # Add utility columns\n        for c in range(p[\"num_util\"]):\n            cadets_columns[\"Util_\" + str(c + 1)] = p[\"c_utilities\"][:, c]\n\n        # Add preference columns\n        for c in range(p[\"P\"]):\n            cadets_columns[\"Pref_\" + str(c + 1)] = p[\"c_preferences\"][:, c]\n\n    # If we have the qual matrix, we add that here\n    if \"qual\" in p:\n\n        for j, afsc in enumerate(p[\"afscs\"][:p[\"M\"]]):\n            cadets_columns[\"qual_\" + afsc] = p['qual'][:, j]\n\n    # Create dataframe\n    cadets_df = pd.DataFrame(cadets_columns)\n\n    # Export 'Cadets' dataframe\n    cadets_df.to_csv(instance.export_paths[\"Cadets\"], index=False)\n</code></pre>"},{"location":"reference/data/processing/#data.processing.export_afsc_cadet_matrices_data","title":"<code>export_afsc_cadet_matrices_data(instance)</code>","text":"<p>Exports cadet-AFSC utility and preference matrices from the given <code>Instance</code> object to CSV files.</p> <p>This function checks for the presence of known matrix-style parameters in the model (e.g., utility values, preference rankings, interest scores) and exports them to disk. Each matrix is stored as a CSV with cadets as rows and AFSCs as columns (or vice versa), depending on the context.</p>"},{"location":"reference/data/processing/#data.processing.export_afsc_cadet_matrices_data--parameters","title":"Parameters","text":"<ul> <li>instance : Instance   A fully initialized <code>Instance</code> object containing model parameters (<code>parameters</code>),   value parameters (<code>value_parameters</code>), and export paths.</li> </ul>"},{"location":"reference/data/processing/#data.processing.export_afsc_cadet_matrices_data--returns","title":"Returns","text":"<ul> <li>None   The function writes one or more matrix-style datasets to disk if they exist.</li> </ul>"},{"location":"reference/data/processing/#data.processing.export_afsc_cadet_matrices_data--notes","title":"Notes","text":"<ul> <li> <p>The following parameters will be exported if present:</p> <ul> <li><code>utility</code>: Cadet utilities over all AFSCs \u2192 <code>\"Cadets Utility\"</code></li> <li><code>c_pref_matrix</code>: Cadet preferences over all AFSCs \u2192 <code>\"Cadets Preferences\"</code></li> <li><code>afsc_utility</code>: AFSC utilities over all cadets \u2192 <code>\"AFSCs Utility\"</code></li> <li><code>a_pref_matrix</code>: AFSC preferences over all cadets \u2192 <code>\"AFSCs Preferences\"</code></li> <li><code>rr_interest_matrix</code>: ROTC-rated interest scores \u2192 <code>\"ROTC Rated Interest\"</code></li> <li><code>rr_om_matrix</code>: ROTC OM values \u2192 <code>\"ROTC Rated OM\"</code></li> <li><code>ur_om_matrix</code>: USAFA OM values \u2192 <code>\"USAFA Rated OM\"</code></li> <li><code>or_om_matrix</code>: OTS OM values \u2192 <code>\"OTS Rated OM\"</code></li> <li><code>cadet_utility</code>: Finalized cadet utility values \u2192 <code>\"Cadets Utility (Final)\"</code></li> <li><code>c_selected_matrix</code>: Final cadet selection matrix \u2192 <code>\"Cadets Selected\"</code></li> <li><code>a_bucket_matrix</code>: AFSC bucket matrix \u2192 <code>\"AFSCs Buckets\"</code></li> </ul> </li> <li> <p>Each exported dataframe will have a <code>\"Cadet\"</code> column followed by one column per AFSC in the relevant set.   The set of AFSCs may vary depending on whether the data is specific to a commissioning source (SOC).</p> </li> <li> <p>Datasets related to specific SOCs (e.g., <code>\"ROTC Rated OM\"</code>) use filtered cadet subsets and   AFSCs determined by <code>determine_soc_rated_afscs()</code>.</p> </li> </ul>"},{"location":"reference/data/processing/#data.processing.export_afsc_cadet_matrices_data--see-also","title":"See Also","text":"<ul> <li><code>determine_soc_rated_afscs</code></li> <li><code>import_afsc_cadet_matrices_data</code></li> <li><code>initialize_file_information</code></li> </ul> Source code in <code>afccp/data/processing.py</code> <pre><code>def export_afsc_cadet_matrices_data(instance):\n    \"\"\"\n    Exports cadet-AFSC utility and preference matrices from the given `Instance` object to CSV files.\n\n    This function checks for the presence of known matrix-style parameters in the model (e.g., utility values,\n    preference rankings, interest scores) and exports them to disk. Each matrix is stored as a CSV with cadets\n    as rows and AFSCs as columns (or vice versa), depending on the context.\n\n    Parameters\n    ----------\n    - instance : Instance\n      A fully initialized `Instance` object containing model parameters (`parameters`),\n      value parameters (`value_parameters`), and export paths.\n\n    Returns\n    -------\n    - None\n      The function writes one or more matrix-style datasets to disk if they exist.\n\n    Notes\n    -----\n    - The following parameters will be exported if present:\n\n        - `utility`: Cadet utilities over all AFSCs \u2192 `\"Cadets Utility\"`\n        - `c_pref_matrix`: Cadet preferences over all AFSCs \u2192 `\"Cadets Preferences\"`\n        - `afsc_utility`: AFSC utilities over all cadets \u2192 `\"AFSCs Utility\"`\n        - `a_pref_matrix`: AFSC preferences over all cadets \u2192 `\"AFSCs Preferences\"`\n        - `rr_interest_matrix`: ROTC-rated interest scores \u2192 `\"ROTC Rated Interest\"`\n        - `rr_om_matrix`: ROTC OM values \u2192 `\"ROTC Rated OM\"`\n        - `ur_om_matrix`: USAFA OM values \u2192 `\"USAFA Rated OM\"`\n        - `or_om_matrix`: OTS OM values \u2192 `\"OTS Rated OM\"`\n        - `cadet_utility`: Finalized cadet utility values \u2192 `\"Cadets Utility (Final)\"`\n        - `c_selected_matrix`: Final cadet selection matrix \u2192 `\"Cadets Selected\"`\n        - `a_bucket_matrix`: AFSC bucket matrix \u2192 `\"AFSCs Buckets\"`\n\n    - Each exported dataframe will have a `\"Cadet\"` column followed by one column per AFSC in the relevant set.\n      The set of AFSCs may vary depending on whether the data is specific to a commissioning source (SOC).\n\n    - Datasets related to specific SOCs (e.g., `\"ROTC Rated OM\"`) use filtered cadet subsets and\n      AFSCs determined by `determine_soc_rated_afscs()`.\n\n    See Also\n    --------\n    - [`determine_soc_rated_afscs`](../../../afccp/reference/data/preferences/#data.preferences.determine_soc_rated_afscs)\n    - [`import_afsc_cadet_matrices_data`](../../../afccp/reference/data/processing/#data.processing.import_afsc_cadet_matrices_data)\n    - [`initialize_file_information`](../../../afccp/reference/data/processing/#data.processing.initialize_file_information)\n    \"\"\"\n\n    # Shorthand\n    p, vp = instance.parameters, instance.value_parameters\n\n    # Dataset name translations\n    parameter_trans_dict = {\"utility\": \"Cadets Utility\", \"c_pref_matrix\": \"Cadets Preferences\",\n                            \"afsc_utility\": \"AFSCs Utility\", \"a_pref_matrix\": \"AFSCs Preferences\",\n                            \"rr_interest_matrix\": \"ROTC Rated Interest\", \"rr_om_matrix\": \"ROTC Rated OM\",\n                            'ur_om_matrix': 'USAFA Rated OM', 'or_om_matrix': 'OTS Rated OM',\n                           'cadet_utility': 'Cadets Utility (Final)',\n                            'c_selected_matrix': 'Cadets Selected', 'a_bucket_matrix': 'AFSCs Buckets'\n                            }\n\n    # Get all rated AFSCs\n    all_rated_afscs = p['afscs'][p['J^Rated']]\n\n    # Loop through each potential dataset to export\n    for parameter in parameter_trans_dict:\n\n        # If we have this dataset, we export it\n        if parameter in p:\n            dataset = parameter_trans_dict[parameter]\n\n            # Construct the dataframe\n            if 'ROTC' in dataset:\n                cadet_indices = p[\"Rated Cadets\"]['rotc']\n                pref_df = pd.DataFrame({\"Cadet\": p['cadets'][cadet_indices]})\n                afscs = afccp.data.preferences.determine_soc_rated_afscs(\n                    soc='rotc', all_rated_afscs=all_rated_afscs)\n            elif 'USAFA' in dataset:\n                cadet_indices = p[\"Rated Cadets\"]['usafa']\n                pref_df = pd.DataFrame({\"Cadet\": p['cadets'][cadet_indices]})\n                afscs = afccp.data.preferences.determine_soc_rated_afscs(\n                    soc='usafa', all_rated_afscs=all_rated_afscs)\n            elif 'OTS' in dataset:\n                cadet_indices = p[\"Rated Cadets\"]['ots']\n                pref_df = pd.DataFrame({\"Cadet\": p['cadets'][cadet_indices]})\n                afscs = afccp.data.preferences.determine_soc_rated_afscs(\n                    soc='ots', all_rated_afscs=all_rated_afscs)\n            else:\n                pref_df = pd.DataFrame({\"Cadet\": p[\"cadets\"]})\n                afscs = p[\"afscs\"][:p[\"M\"]]\n\n            # Add the AFSC columns\n            for j, afsc in enumerate(afscs):\n                pref_df[afsc] = p[parameter][:, j]\n\n            # Export the dataset\n            pref_df.to_csv(instance.export_paths[dataset], index=False)\n</code></pre>"},{"location":"reference/data/processing/#data.processing.export_value_parameters_data","title":"<code>export_value_parameters_data(instance)</code>","text":"<p>Export value parameter datasets and related information to CSV files for analysis.</p> <p>This function extracts and exports optimization value parameter sets, global utility matrices (if available), and cadet-specific constraints. It supports multiple value parameter configurations by exporting separate files per set. This facilitates analysis, debugging, or visualization of value-based multi-objective optimization.</p>"},{"location":"reference/data/processing/#data.processing.export_value_parameters_data--parameters","title":"Parameters","text":"<ul> <li> <p>instance : Instance   A configured instance of the CadetCareerProblem class, including:</p> <ul> <li><code>vp_dict</code>: Dictionary of value parameter sets</li> <li><code>value_parameters</code>: Active value parameter configuration</li> <li><code>parameters</code>: General instance parameters (e.g., AFSCs, cadets)</li> <li><code>export_paths</code>: File paths for saving exports</li> </ul> </li> </ul>"},{"location":"reference/data/processing/#data.processing.export_value_parameters_data--returns","title":"Returns","text":"<p>None   The function writes multiple CSV files to disk for each available dataset.</p> <p>This command will generate: - A separate CSV file for each set of value parameters (e.g., weights, targets, value functions) - An overall summary CSV file of value parameter metadata - A cadet-level constraints CSV file (min values per cadet per VP set) - A global utility matrix CSV (if <code>global_utility</code> is present in a VP set)</p>"},{"location":"reference/data/processing/#data.processing.export_value_parameters_data--notes","title":"Notes","text":"<ul> <li>Value function breakpoints <code>a</code> and values <code>f^hat</code> are stored as comma-separated strings for readability.</li> <li>Objective weights are scaled to a 0\u2013100 range and normalized per AFSC.</li> <li> <p>The output files use naming conventions like:</p> <ul> <li><code>{data_name} {vp_name}.csv</code></li> <li><code>{data_name} {vp_name} Global Utility.csv</code></li> <li>These files are versioned if the instance's data version is not <code>\"Default\"</code>.</li> </ul> </li> </ul>"},{"location":"reference/data/processing/#data.processing.export_value_parameters_data--see-also","title":"See Also","text":"<ul> <li><code>import_value_parameters_data</code></li> <li><code>initialize_file_information</code></li> </ul> Source code in <code>afccp/data/processing.py</code> <pre><code>def export_value_parameters_data(instance):\n    \"\"\"\n    Export value parameter datasets and related information to CSV files for analysis.\n\n    This function extracts and exports optimization value parameter sets, global utility matrices (if available),\n    and cadet-specific constraints. It supports multiple value parameter configurations by exporting separate\n    files per set. This facilitates analysis, debugging, or visualization of value-based multi-objective optimization.\n\n    Parameters\n    ----------\n    - instance : Instance\n      A configured instance of the CadetCareerProblem class, including:\n\n        - `vp_dict`: Dictionary of value parameter sets\n        - `value_parameters`: Active value parameter configuration\n        - `parameters`: General instance parameters (e.g., AFSCs, cadets)\n        - `export_paths`: File paths for saving exports\n\n    Returns\n    -------\n    None\n      The function writes multiple CSV files to disk for each available dataset.\n\n    This command will generate:\n    - A separate CSV file for each set of value parameters (e.g., weights, targets, value functions)\n    - An overall summary CSV file of value parameter metadata\n    - A cadet-level constraints CSV file (min values per cadet per VP set)\n    - A global utility matrix CSV (if `global_utility` is present in a VP set)\n\n    Notes\n    -----\n    - Value function breakpoints `a` and values `f^hat` are stored as comma-separated strings for readability.\n    - Objective weights are scaled to a 0\u2013100 range and normalized per AFSC.\n    - The output files use naming conventions like:\n\n        - `{data_name} {vp_name}.csv`\n        - `{data_name} {vp_name} Global Utility.csv`\n    - These files are versioned if the instance's data version is not `\"Default\"`.\n\n    See Also\n    --------\n    - [`import_value_parameters_data`](../../../afccp/reference/data/processing/#data.processing.import_value_parameters_data)\n    - [`initialize_file_information`](../../../afccp/reference/data/processing/#data.processing.initialize_file_information)\n    \"\"\"\n\n    # Shorthand\n    p = instance.parameters\n\n    # Error data\n    if instance.vp_dict is None:\n        return None  # No value parameters to export!\n\n    # Determine how we're going to show merit for context in the Cadet Constraints dataframe\n    merit_col = \"merit\"\n    if \"merit_all\" in p:\n        merit_col = \"merit_all\"\n\n    # Initialize dataframes\n    vp_cadet_df = pd.DataFrame({\"Cadet\": p[\"cadets\"], \"Merit\": p[merit_col]})\n    vp_overall_df = pd.DataFrame({})\n\n    # Loop through each set of value parameters\n    for v, vp_name in enumerate(list(instance.vp_dict.keys())):\n        vp = instance.vp_dict[vp_name]\n\n        # Initialize Value Function breakpoint arrays\n        a_strings = np.array([[\" \" * 400 for _ in vp[\"K\"]] for _ in p[\"J\"]])\n        fhat_strings = np.array([[\" \" * 400 for _ in vp[\"K\"]] for _ in p[\"J\"]])\n        for j, afsc in enumerate(p['afscs'][:p[\"M\"]]):\n            for k, objective in enumerate(vp['objectives']):\n                a_string_list = [str(x) for x in vp['a'][j][k]]\n                a_strings[j, k] = \",\".join(a_string_list)\n                fhat_strings_list = [str(x) for x in vp['f^hat'][j][k]]\n                fhat_strings[j, k] = \",\".join(fhat_strings_list)\n\n        # Flatten the 2-d arrays to convert them into one long list that is sorted by AFSC and then by objective\n        objective_value_min = np.ndarray.flatten(vp['objective_value_min'])\n        constraint_type = np.ndarray.flatten(vp['constraint_type'])\n        objective_target = np.ndarray.flatten(vp['objective_target'])\n        value_functions = np.ndarray.flatten(vp['value_functions'])\n        breakpoint_a = np.ndarray.flatten(a_strings)\n        breakpoint_fhat = np.ndarray.flatten(fhat_strings)\n\n        # AFSC objective swing weights\n        max_weights = np.max(vp['objective_weight'], axis=1)\n        ow = np.array([[vp['objective_weight'][j, k] / max_weights[j] for k in vp[\"K\"]] for j in p[\"J\"]])\n        objective_weight = np.ndarray.flatten(np.around(ow * 100, 3))\n\n        # Repeating objectives\n        objectives = np.tile(vp['objectives'], p['M'])\n\n        # Repeating AFSCs\n        afscs = np.ndarray.flatten(np.array(list(np.repeat(p['afscs'][j], vp['O']) for j in p[\"J\"])))\n        afsc_value_min = np.ndarray.flatten(np.array(list(np.repeat(vp['afsc_value_min'][j], vp['O']) for j in p[\"J\"])))\n\n        # AFSC swing weights\n        afsc_weight = np.around(vp['afsc_weight'] / np.max(vp['afsc_weight']) * 100, 3)\n        afsc_weight = np.repeat(afsc_weight, vp['O'])\n\n        # Create the \"vp_df\"\n        vp_df = pd.DataFrame({'AFSC': afscs, 'Objective': objectives, 'Objective Weight': objective_weight,\n                              'Objective Target': objective_target, 'AFSC Weight': afsc_weight,\n                              'Min Value': afsc_value_min, 'Min Objective Value': objective_value_min,\n                              'Constraint Type': constraint_type, 'Function Breakpoint Measures (a)': breakpoint_a,\n                              'Function Breakpoint Values (f^hat)': breakpoint_fhat,\n                              'Value Functions': value_functions})\n\n        # Add the minimum value column for this set of value parameters to the cadets df\n        vp_cadet_df[vp_name] = vp[\"cadet_value_min\"]\n\n        # Initialize overall vp column dictionary\n        overall_vp_columns = {'VP Name': vp_name,\n                              'Cadets Weight': vp['cadets_overall_weight'],\n                              'AFSCs Weight': vp['afscs_overall_weight'],\n                              'Cadets Min Value': vp['cadets_overall_value_min'],\n                              'AFSCs Min Value': vp['afscs_overall_value_min'],\n                              'Cadet Weight Function': vp['cadet_weight_function'],\n                              'AFSC Weight Function': vp['afsc_weight_function']}\n\n        # Add the row for this set of value parameters to the overall df\n        for col in overall_vp_columns:\n            vp_overall_df.loc[v, col] = overall_vp_columns[col]\n\n        # Determine extension of VP file (in case it's a different version of data)\n        if instance.data_version == \"Default\":\n            extension = \".csv\"\n        else:\n            extension = \" (\" + instance.data_version + \").csv\"\n\n        # Export 'VP' dataframe\n        vp_df.to_csv(instance.export_paths[\"Model Input\"] + instance.data_name + \" \" + vp_name + extension, index=False)\n\n        # Create \"Global Utility\" dataframe if it's in the value parameters\n        if \"global_utility\" in vp:\n            gu_df = pd.DataFrame({'Cadet': p['cadets']})\n            for j, afsc in enumerate(p['afscs'][:p['M']]):\n                gu_df[afsc] = vp['global_utility'][:, j]\n\n            # Export \"Global Utility\" dataframe\n            filename = instance.data_name + \" \" + vp_name + \" Global Utility\" + extension\n            gu_df.to_csv(instance.export_paths[\"Model Input\"] + filename, index=False)\n\n    # Export 'Value Parameters' dataframe\n    vp_overall_df.to_csv(instance.export_paths[\"Value Parameters\"], index=False)\n\n    # Export 'Cadets Utility Constraints' dataframe\n    vp_cadet_df.to_csv(instance.export_paths[\"Cadets Utility Constraints\"], index=False)\n</code></pre>"},{"location":"reference/data/processing/#data.processing.export_solutions_data","title":"<code>export_solutions_data(instance)</code>","text":"<p>Export cadet-to-AFSC solution assignments to CSV files.</p> <p>This function exports all available cadet solution assignments (including AFSC, base, and course solutions) to CSV files for downstream analysis, visualization, or comparison. Each solution is saved as a column in the exported file, enabling side-by-side comparison of multiple optimization outcomes.</p>"},{"location":"reference/data/processing/#data.processing.export_solutions_data--parameters","title":"Parameters","text":"<ul> <li> <p>instance : Instance     The problem instance containing:</p> <ul> <li><code>parameters</code> \u2013 model parameter dictionary</li> <li><code>solutions</code> \u2013 dictionary of cadet-to-AFSC assignments by solution name</li> <li><code>export_paths</code> \u2013 dictionary of destination paths for saving outputs</li> </ul> </li> </ul>"},{"location":"reference/data/processing/#data.processing.export_solutions_data--returns","title":"Returns","text":"<p>None     The function writes 1 to 3 CSV files to disk, depending on available solution components.</p> <p>This exports: - <code>Solutions.csv</code>: Main cadet-to-AFSC assignment matrix - <code>Base Solutions.csv</code>: Optional cadet-to-base assignments, if present - <code>Course Solutions.csv</code>: Optional cadet-to-course assignments, if present</p>"},{"location":"reference/data/processing/#data.processing.export_solutions_data--notes","title":"Notes","text":"<ul> <li>Each file contains cadets in the first column and one or more solution columns following.</li> <li>Solution names (keys from <code>instance.solutions</code>) define the column headers.</li> <li>The function safely skips missing data (e.g., base or course assignments are only exported if they exist).</li> <li>Used primarily to track scenario-based solution outputs from multi-run experiments.</li> </ul>"},{"location":"reference/data/processing/#data.processing.export_solutions_data--see-also","title":"See Also","text":"<ul> <li><code>import_solutions_data</code></li> <li><code>initialize_file_information</code></li> </ul> Source code in <code>afccp/data/processing.py</code> <pre><code>def export_solutions_data(instance):\n    \"\"\"\n    Export cadet-to-AFSC solution assignments to CSV files.\n\n    This function exports all available cadet solution assignments (including AFSC, base, and course solutions)\n    to CSV files for downstream analysis, visualization, or comparison. Each solution is saved as a column in\n    the exported file, enabling side-by-side comparison of multiple optimization outcomes.\n\n    Parameters\n    ----------\n    - instance : Instance\n        The problem instance containing:\n\n        - `parameters` \u2013 model parameter dictionary\n        - `solutions` \u2013 dictionary of cadet-to-AFSC assignments by solution name\n        - `export_paths` \u2013 dictionary of destination paths for saving outputs\n\n    Returns\n    -------\n    None\n        The function writes 1 to 3 CSV files to disk, depending on available solution components.\n\n    This exports:\n    - `Solutions.csv`: Main cadet-to-AFSC assignment matrix\n    - `Base Solutions.csv`: Optional cadet-to-base assignments, if present\n    - `Course Solutions.csv`: Optional cadet-to-course assignments, if present\n\n    Notes\n    -----\n    - Each file contains cadets in the first column and one or more solution columns following.\n    - Solution names (keys from `instance.solutions`) define the column headers.\n    - The function safely skips missing data (e.g., base or course assignments are only exported if they exist).\n    - Used primarily to track scenario-based solution outputs from multi-run experiments.\n\n    See Also\n    --------\n    - [`import_solutions_data`](../../../afccp/reference/data/processing/#data.processing.import_solutions_data)\n    - [`initialize_file_information`](../../../afccp/reference/data/processing/#data.processing.initialize_file_information)\n    \"\"\"\n\n    # Shorthand\n    p = instance.parameters\n\n    # Error data\n    if instance.solutions is None:\n        return None  # No solutions to export!\n\n    # Initialize solutions dataframe\n    solutions_df = pd.DataFrame({\"Cadet\": p[\"cadets\"]})\n\n    # Loop through each solution and add it to the dataframe\n    for solution_name in instance.solutions:\n        solutions_df[solution_name] = instance.solutions[solution_name]['afsc_array']\n\n    # Export 'Solutions' dataframe\n    solutions_df.to_csv(instance.export_paths[\"Solutions\"], index=False)\n\n    # Initialize solutions dataframe\n    extra_dict = {\"Base Solutions\": \"base_array\", \"Course Solutions\": \"course_array\"}\n    for df_name, key in extra_dict.items():\n\n        # Get list of solutions that have this extra component\n        solution_names_found = []\n        for solution_name in instance.solutions:\n            if key in instance.solutions[solution_name]:\n                solution_names_found.append(solution_name)\n\n        # If we have at least one solution with this base or course component, we create this dataframe\n        if len(solution_names_found) &gt; 0:\n            solutions_df = pd.DataFrame({\"Cadet\": p[\"cadets\"]})\n\n            # Loop through each solution with this component and add it to the dataframe\n            for solution_name in solution_names_found:\n                solutions_df[solution_name] = instance.solutions[solution_name][key]\n\n            # Export extra 'Solutions' dataframe\n            solutions_df.to_csv(instance.export_paths[df_name], index=False)\n</code></pre>"},{"location":"reference/data/processing/#data.processing.export_additional_data","title":"<code>export_additional_data(instance)</code>","text":"<p>Export additional configuration and metadata to CSV files.</p> <p>This function exports all supplementary datasets associated with the problem instance, including base assignments, base preferences, utility scores, training course data, and CASTLE-AFSC mappings. These datasets are derived from the <code>instance.parameters</code> dictionary and written to disk using paths from <code>instance.export_paths</code>.</p>"},{"location":"reference/data/processing/#data.processing.export_additional_data--parameters","title":"Parameters","text":"<ul> <li> <p>instance : Instance     The problem instance containing:</p> <ul> <li><code>parameters</code> \u2013 dictionary of model inputs and outputs</li> <li><code>export_paths</code> \u2013 dictionary of file paths for each dataset</li> </ul> </li> </ul>"},{"location":"reference/data/processing/#data.processing.export_additional_data--returns","title":"Returns","text":"<p>None     Outputs are written to CSV files; no value is returned.</p> <p>This generates the following (if applicable): - <code>Bases.csv</code>: Min/max cadet assignments per AFSC at each base - <code>Bases Preferences.csv</code>: Cadet preferences over bases - <code>Bases Utility.csv</code>: Cadet utility scores for each base - <code>Courses.csv</code>: Course-level details per AFSC (min/max/start) - <code>Castle Input.csv</code>: CASTLE-to-AFPC AFSC mappings with optional value curves</p>"},{"location":"reference/data/processing/#data.processing.export_additional_data--notes","title":"Notes","text":"<ul> <li>The export is conditional: datasets are only written if their associated parameters exist in <code>instance.parameters</code>.</li> <li>CASTLE-related data (<code>castle_q</code>, <code>castle_afscs_arr</code>, etc.) must be present to trigger <code>Castle Input.csv</code> export.</li> <li>Base utility and preference matrices are assumed to be cadet-by-base numpy arrays.</li> </ul>"},{"location":"reference/data/processing/#data.processing.export_additional_data--see-also","title":"See Also","text":"<ul> <li><code>import_additional_data</code></li> <li><code>initialize_file_information</code></li> </ul> Source code in <code>afccp/data/processing.py</code> <pre><code>def export_additional_data(instance):\n    \"\"\"\n    Export additional configuration and metadata to CSV files.\n\n    This function exports all supplementary datasets associated with the problem instance, including base\n    assignments, base preferences, utility scores, training course data, and CASTLE-AFSC mappings. These\n    datasets are derived from the `instance.parameters` dictionary and written to disk using paths from\n    `instance.export_paths`.\n\n    Parameters\n    ----------\n    - instance : Instance\n        The problem instance containing:\n\n        - `parameters` \u2013 dictionary of model inputs and outputs\n        - `export_paths` \u2013 dictionary of file paths for each dataset\n\n    Returns\n    -------\n    None\n        Outputs are written to CSV files; no value is returned.\n\n    This generates the following (if applicable):\n    - `Bases.csv`: Min/max cadet assignments per AFSC at each base\n    - `Bases Preferences.csv`: Cadet preferences over bases\n    - `Bases Utility.csv`: Cadet utility scores for each base\n    - `Courses.csv`: Course-level details per AFSC (min/max/start)\n    - `Castle Input.csv`: CASTLE-to-AFPC AFSC mappings with optional value curves\n\n    Notes\n    -----\n    - The export is conditional: datasets are only written if their associated parameters exist in `instance.parameters`.\n    - CASTLE-related data (`castle_q`, `castle_afscs_arr`, etc.) must be present to trigger `Castle Input.csv` export.\n    - Base utility and preference matrices are assumed to be cadet-by-base numpy arrays.\n\n    See Also\n    --------\n    - [`import_additional_data`](../../../afccp/reference/data/processing/#data.processing.import_additional_data)\n    - [`initialize_file_information`](../../../afccp/reference/data/processing/#data.processing.initialize_file_information)\n    \"\"\"\n\n    # Shorthand\n    p = instance.parameters\n\n    # See if we can export the \"Bases\" csv file\n    if \"bases\" in p:\n\n        # Initialize dataframe\n        df = pd.DataFrame({\"Base\": p['bases']})\n\n        # Add \"minimum\" # to assign to each base by AFSC\n        for j in p['J']:\n            afsc = p['afscs'][j]\n            df[afsc + ' Min'] = p['base_min'][:, j]\n\n        # Add \"maximum\" # to assign to each base by AFSC\n        for j in p['J']:\n            afsc = p['afscs'][j]\n            df[afsc + ' Max'] = p['base_max'][:, j]\n\n        # Export the dataset\n        df.to_csv(instance.export_paths[\"Bases\"], index=False)\n\n    # Export base preferences/utility if applicable\n    for parameter, dataset in {'b_pref_matrix': 'Bases Preferences', 'base_utility': 'Bases Utility'}.items():\n        if parameter in p:\n\n            # Initialize dataframe\n            df = pd.DataFrame({\"Cadet\": p['cadets']})\n\n            # Add base columns\n            for b, base in enumerate(p['bases']):\n                df[base] = p[parameter][:, b]\n\n            # Export the dataset\n            df.to_csv(instance.export_paths[dataset], index=False)\n\n    # Export training course data if applicable\n    if 'courses' in p:\n\n        # Dictionary to translate parameter names to column names\n        column_translation = {\"Course\": 'courses', 'Start Date': 'course_start', 'Min': 'course_min', 'Max': 'course_max'}\n\n        # Initialize dictionary of new columns\n        new_cols = {'AFSC': [p['afscs'][j] for j in p['J'] for _ in range(p['T'][j])]}\n\n        # Create each column for this dataset\n        for col, param in column_translation.items():\n            new_cols[col] = [p[param][j][c] for j in p['J'] for c in range(p['T'][j])]\n\n        # Create dataframe\n        df = pd.DataFrame(new_cols)\n\n        # Export the dataframe\n        df.to_csv(instance.export_paths['Courses'], index=False)\n\n    # Export Castle AFSCs data\n    if 'castle_afscs_arr' in p:\n\n        # Create dataframe\n        df = pd.DataFrame({'AFPC AFSC': p['afpc_afscs_arr'],\n                           'CASTLE AFSC': p['castle_afscs_arr']})\n\n        # Add in value curve data\n        if 'castle_q' in p:\n            df['a'] = [', '.join(np.around(p['castle_q']['a'][afsc], 3).astype(str)) for afsc in p['castle_afscs_arr']]\n            df['f^hat'] = \\\n                [', '.join(np.around(p['castle_q']['f^hat'][afsc], 3).astype(str)) for afsc in p['castle_afscs_arr']]\n            df['Optimal'] = [p['optimal_policy'][afsc] for afsc in p['castle_afscs_arr']]\n            df['OTS Count'] = [p['ots_counts'][afsc] for afsc in p['castle_afscs_arr']]\n\n        # Export the dataframe\n        df.to_csv(instance.export_paths['Castle Input'], index=False)\n</code></pre>"},{"location":"reference/data/processing/#data.processing.export_solution_results","title":"<code>export_solution_results(instance, filepath)</code>","text":"<p>Export a comprehensive Excel workbook of solution results.</p> <p>This function generates an Excel file containing detailed outputs from a solved cadet-AFSC assignment instance, including objective values, cadet assignments, constraint violations, and other performance metrics. The resulting Excel workbook supports deep post-solution analysis and includes conditional formatting for visual clarity.</p>"},{"location":"reference/data/processing/#data.processing.export_solution_results--parameters","title":"Parameters","text":"<ul> <li> <p>instance : Instance   An object representing the solved assignment problem. Must contain:</p> </li> <li> <p><code>parameters</code> (dict): Problem data</p> </li> <li><code>value_parameters</code> (dict): Objective metadata and weights</li> <li><code>solution</code> (dict): Final solution output (e.g., assignments, utilities, choice rankings)</li> <li><code>mdl_p</code> (dict): Metadata including formatting options</li> <li>filepath : str   Full path where the Excel file will be saved (e.g., <code>\"output/solution_results.xlsx\"</code>)</li> </ul>"},{"location":"reference/data/processing/#data.processing.export_solution_results--returns","title":"Returns","text":"<p>None   Writes an <code>.xlsx</code> file to disk containing multiple sheets of structured solution data.</p>"},{"location":"reference/data/processing/#data.processing.export_solution_results--excel-output-includes","title":"Excel Output Includes","text":"<ul> <li>Main: High-level metrics, objective value, choice counts, and performance indicators</li> <li>Objective Measures: AFSC scores for each weighted objective</li> <li>Constraint Fails: Constraint violations by AFSC</li> <li>Objective Values: Weighted performance per AFSC with visual scoring heatmaps</li> <li>Solution: Per-cadet assignment breakdown with preferences, utilities, base/course matches</li> <li>X, V, Q (optional): Assignment matrices for AFSCs, bases, and training courses</li> <li>Lambda, Y (optional): Value function parameters per AFSC and objective</li> <li>Castle Metrics (if applicable): Metrics for CASTLE-mode AFSCs</li> <li>Blocking Pairs (if present): Cadet-AFSC blocking violations</li> </ul>"},{"location":"reference/data/processing/#data.processing.export_solution_results--notes","title":"Notes","text":"<ul> <li>Conditional formatting is applied to highlight preference rankings, merit scores, and match quality.</li> <li>The function handles presence or absence of optional components (e.g., base matching, training courses).</li> <li>Top 10 cadet choices and utilities are shown in the Solution tab for deeper preference analysis.</li> </ul>"},{"location":"reference/data/processing/#data.processing.export_solution_results--see-also","title":"See Also","text":"<ul> <li><code>draw_frame_border_outside</code></li> </ul> Source code in <code>afccp/data/processing.py</code> <pre><code>def export_solution_results(instance, filepath):\n    \"\"\"\n    Export a comprehensive Excel workbook of solution results.\n\n    This function generates an Excel file containing detailed outputs from a solved cadet-AFSC assignment instance,\n    including objective values, cadet assignments, constraint violations, and other performance metrics. The resulting\n    Excel workbook supports deep post-solution analysis and includes conditional formatting for visual clarity.\n\n    Parameters\n    ----------\n    - instance : Instance\n      An object representing the solved assignment problem. Must contain:\n\n      - `parameters` (dict): Problem data\n      - `value_parameters` (dict): Objective metadata and weights\n      - `solution` (dict): Final solution output (e.g., assignments, utilities, choice rankings)\n      - `mdl_p` (dict): Metadata including formatting options\n    - filepath : str\n      Full path where the Excel file will be saved (e.g., `\"output/solution_results.xlsx\"`)\n\n    Returns\n    -------\n    None\n      Writes an `.xlsx` file to disk containing multiple sheets of structured solution data.\n\n    Excel Output Includes\n    ---------------------\n    - Main: High-level metrics, objective value, choice counts, and performance indicators\n    - Objective Measures: AFSC scores for each weighted objective\n    - Constraint Fails: Constraint violations by AFSC\n    - Objective Values: Weighted performance per AFSC with visual scoring heatmaps\n    - Solution: Per-cadet assignment breakdown with preferences, utilities, base/course matches\n    - X, V, Q (optional): Assignment matrices for AFSCs, bases, and training courses\n    - Lambda, Y (optional): Value function parameters per AFSC and objective\n    - Castle Metrics (if applicable): Metrics for CASTLE-mode AFSCs\n    - Blocking Pairs (if present): Cadet-AFSC blocking violations\n\n    Notes\n    -----\n    - Conditional formatting is applied to highlight preference rankings, merit scores, and match quality.\n    - The function handles presence or absence of optional components (e.g., base matching, training courses).\n    - Top 10 cadet choices and utilities are shown in the Solution tab for deeper preference analysis.\n\n    See Also\n    --------\n    - [`draw_frame_border_outside`](../../../afccp/reference/data/processing/#data.processing.draw_frame_border_outside)\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = instance.parameters, instance.value_parameters, instance.solution\n    mdl_p = instance.mdl_p\n\n    # Get list of excel columns in order (\"A\", \"AB\", etc.)\n    alphabet = list(string.ascii_uppercase)\n    excel_columns = copy.deepcopy(alphabet)\n    for letter in alphabet:\n        for letter_2 in alphabet:\n            excel_columns.append(letter + letter_2)\n\n    # Create a Pandas Excel writer using XlsxWriter as the engine.\n    writer = pd.ExcelWriter(filepath, engine='xlsxwriter')\n\n    # Get the xlsxwriter objects from the dataframe writer object.\n    workbook = writer.book\n    worksheet = workbook.add_worksheet(\"Main\")\n\n    # Make the background white initially\n    white_format = workbook.add_format({'bold': False, 'font_color': 'black', 'bg_color': 'white',\n                                       'font_size': 14, 'font_name': 'Calibri'})\n    for r in range(200):\n        for c in range(50):\n            worksheet.write(r, c, '', white_format)\n\n    # Merge cells\n    merge_format = workbook.add_format({'bold': True, 'font_color': 'black', 'bg_color': 'white',\n                                       'font_size': 14, 'font_name': 'Calibri', 'align': 'center',\n                                        'valign': 'vcenter', 'border_color': 'black', 'border': 1})\n    worksheet.merge_range(\"B2:D2\", \"VFT Overall Metrics\", merge_format)\n    worksheet.merge_range(\"F2:G2\", \"Additional Metrics\", merge_format)\n    worksheet.write('I2', 'Preference', merge_format)\n    worksheet.write('J2', 'Count', merge_format)\n    worksheet.write('K2', 'Proportion', merge_format)\n\n    # Objective Value\n    obj_format = workbook.add_format({'bold': True, 'font_color': 'black', 'bg_color': 'yellow',\n                                      'font_size': 14, 'font_name': 'Calibri', 'align': 'center',\n                                      'valign': 'vcenter', 'border_color': 'black', 'border': 1})\n    worksheet.merge_range(\"C6:D6\", round(solution['z'], 4), obj_format)\n\n    # Other cells\n    cell_format = workbook.add_format({'bold': False, 'font_color': 'black', 'bg_color': 'white',\n                                       'font_size': 14, 'font_name': 'Calibri', 'align': 'center',\n                                        'valign': 'vcenter', 'border_color': 'black', 'border': 1})\n    worksheet.write('B3', 'VFT', cell_format)\n    worksheet.write('B4', 'Cadets', cell_format)\n    worksheet.write('B5', 'AFSCs', cell_format)\n    worksheet.write('B6', 'Z', cell_format)\n    worksheet.write('C3', 'Value', cell_format)\n    worksheet.write('D3', 'Weight', cell_format)\n\n    # Basic format\n    cell_format = workbook.add_format({'bold': False, 'font_color': 'black', 'bg_color': 'white',\n                                        'font_size': 14, 'font_name': 'Calibri', 'border_color': 'black', 'border': 1})\n\n    # Choice Counts\n    choice_dict = {1: \"First\", 2: \"Second\", 3: \"Third\", 4: \"Fourth\", 5: \"Fifth\", 6: \"Sixth\", 7: \"Seventh\",\n                   8: \"Eighth\", 9: \"Ninth\", 10: \"Tenth\"}\n    for choice in choice_dict:\n        worksheet.write(\"J\" + str(2 + choice), int(solution['cadet_choice_counts'][choice]), cell_format)\n        worksheet.write(\"I\" + str(2 + choice), choice_dict[choice], cell_format)\n        worksheet.write(\"K\" + str(2 + choice), round(solution['cadet_choice_counts'][choice] / p['N^Match'], 3),\n                        cell_format)\n    worksheet.write(\"I\" + str(3 + choice), \"All Others\", cell_format)\n    worksheet.write(\"J\" + str(3 + choice), int(solution['cadet_choice_counts']['All Others']), cell_format)\n    worksheet.write(\"K\" + str(3 + choice), round(solution['cadet_choice_counts'][\"All Others\"] / p['N^Match'], 3),\n                    cell_format)\n\n    # Additional solution metrics\n    name_metric_dict = {'Blocking Pairs': 'num_blocking_pairs', 'Ineligible Cadets': 'num_ineligible',\n                        'Unmatched Cadets': 'num_unmatched',\n                        'Top 3 Choices (Proportion) for USSF': 'top_3_ussf_count',\n                        'Top 3 Choices (Proportion) for USAF': 'top_3_usaf_count',\n                        'Top 3 Choices (Proportion) for USAFA': 'top_3_usafa_count',\n                        'Top 3 Choices (Proportion) for ROTC': 'top_3_rotc_count',\n                        'Top 3 Choices (Proportion) for OTS': 'top_3_ots_count',\n                        'Average Cadet Choice': 'average_cadet_choice',\n                        'Average Normalized AFSC Score': 'weighted_average_afsc_score',\n                        'Average NRL Normalized AFSC Score': 'weighted_average_nrl_afsc_score',\n                        'Failed Constraints': 'total_failed_constraints', 'USSF OM': 'ussf_om',\n                        'Global Utility': 'z^gu', 'Cadet Utility': 'cadet_utility_overall',\n                        'z^CASTLE': 'z^CASTLE', 'z^CASTLE (Values)': 'z^CASTLE (Values)',\n                        'AFSC Utility': 'afsc_utility_overall',\n                        'USAFA Cadet Utility': 'usafa_cadet_utility',\n                        'ROTC Cadet Utility': 'rotc_cadet_utility',\n                        'OTS Cadet Utility': 'ots_cadet_utility',\n                        'USSF Cadet Utility': 'ussf_cadet_utility',\n                        'USAF Cadet Utility': 'usaf_cadet_utility',\n                        'USSF AFSC Utility': 'ussf_afsc_utility',\n                        'USAF AFSC Utility': 'usaf_afsc_utility',\n                        'OTS Average Cadet Utility': 'OTS Average Cadet Utility',\n                        'OTS Average AFSC Utility': 'OTS Average AFSC Utility',\n                        'Average Normalized AFSC Score (USSF)': 'weighted_average_ussf_afsc_score',\n                        'Average Normalized AFSC Score (USAF)': 'weighted_average_usaf_afsc_score',\n                        'USAFA USSF Cadets / USAFA USSF PGL': 'ussf_usafa_pgl_target',\n                        'ROTC USSF Cadets / ROTC USSF PGL': 'ussf_rotc_pgl_target',\n                        'Cadets Successfully Constrained to Accessions Group / Total Fixed Accession Group Slots':\n                            'constrained_acc_grp_target',\n                        \"Cadets Successfully Constrained to AFSC / Total Fixed AFSC Slots\":\n                            'cadets_fixed_correctly',\n                        \"Cadets Successfully Reserved to AFSC / Total Reserved AFSC Slots\":\n                            'cadets_reserved_correctly',\n                        \"Successful Alternate List Scenarios / Total Possible Alternate List Scenarios\":\n                            'alternate_list_metric',\n                        'OTS \"Must Match\" Candidates / Total Matched OTS Candidates': 'matched_out_of_must_match',\n                        'OTS Candidates receiving an AFSC they selected ': 'OTS Selected Pref Count'}\n    for acc_grp in p['afscs_acc_grp']:\n        name_metric_dict[acc_grp + \" Racial Simpson Index\"] = 'simpson_index_' + acc_grp\n\n    # Add these metrics into excel\n    for r, name in enumerate(list(name_metric_dict.keys())):\n        if name_metric_dict[name] in solution:\n\n            # Sometimes we can't write in a value for a solution metric that is incomplete\n            try:\n                worksheet.write('F' + str(3 + r), name, cell_format)\n                worksheet.write('G' + str(3 + r), solution[name_metric_dict[name]], cell_format)\n            except:\n                pass\n\n    # VFT Metrics\n    worksheet.write('C4', round(solution['cadets_overall_value'], 4), cell_format)\n    worksheet.write('C5', round(solution['afscs_overall_value'], 4), cell_format)\n    worksheet.write('D4', round(vp['cadets_overall_weight'], 4), cell_format)\n    worksheet.write('D5', round(vp['afscs_overall_weight'], 4), cell_format)\n\n    # Draw bigger borders\n    draw_frame_border_outside(workbook, worksheet, 1, 1, 5, 3, color='black', width=2)\n    draw_frame_border_outside(workbook, worksheet, 1, 5, len(name_metric_dict.keys()) + 1, 2, color='black', width=2)\n    draw_frame_border_outside(workbook, worksheet, 1, 8, 12, 3, color='black', width=2)\n\n    # Adjust Column Widths\n    column_widths = {0: 1.50, 4: 1.50, 5: 31, 7: 1.50, 8: 14, 10: 12}\n    for c in column_widths:\n        worksheet.set_column(c, c, column_widths[c])\n\n    def export_results_dfs():\n        \"\"\"\n        This nested function is here to export all other dataframes\n        \"\"\"\n\n        # Get the xlsxwriter worksheet object.\n        workbook = writer.book\n\n        # AFSC Objective measures dataframe\n        df = pd.DataFrame({'AFSC': p['afscs'][:p['M']]})\n        for k, objective in enumerate(vp['objectives']):\n            df[objective] = np.around(solution['objective_measure'][:, k], 2)\n\n        # Convert the dataframe to an XlsxWriter Excel object.\n        df.to_excel(writer, sheet_name='Objective Measures', index=False)\n\n        # Add Castle Data if it exists\n        if 'castle_q' in p:\n            castle_afscs = [afsc for afsc, _ in p['J^CASTLE'].items()]\n            castle_counts = [solution['castle_counts'][afsc] for afsc in castle_afscs]\n            castle_values = [solution['castle_v'][afsc] for afsc in castle_afscs]\n            df = pd.DataFrame({'AFSC': castle_afscs, 'Count': castle_counts, 'Value': castle_values})\n            df.to_excel(writer, sheet_name='Castle Metrics', index=False)\n\n        # AFSC Constraint Fail dataframe\n        df = pd.DataFrame({'AFSC': p['afscs'][:p['M']]})\n        for k, objective in enumerate(vp['objectives']):\n            df[objective] = solution['objective_constraint_fail'][:, k]\n\n        # Convert the dataframe to an XlsxWriter Excel object.\n        df.to_excel(writer, sheet_name='Constraint Fails', index=False)\n\n        # AFSC Objective values dataframe\n        df = pd.DataFrame({'AFSC': p['afscs'][:p['M']]})\n        for k, objective in enumerate(vp['objectives']):\n            values = np.empty((p['M']))\n            values[:] = np.nan\n            np.put(values, vp['J^A'][k], np.around(solution['objective_value'][vp['J^A'][k], k], 2))\n\n            df[objective] = values\n\n        # Convert the dataframe to an XlsxWriter Excel object.\n        df.to_excel(writer, sheet_name='Objective Values', index=False)\n\n        # Get the xlsxwriter worksheet object.\n        worksheet = writer.sheets[\"Objective Values\"]\n\n        # Add a percent number format\n        percent_format = workbook.add_format({\"num_format\": \"0.0%\"})\n        worksheet.set_column(1, vp['O'] + 1, None, percent_format)\n\n        # Conditional formatting to highlight which objectives were met/not met\n        worksheet.conditional_format(\"B2:\" + excel_columns[vp['O']] + str(p['M'] + 1), {\"type\": \"3_color_scale\"})\n\n        # Solution Dataframe\n        df = pd.DataFrame({'Cadet': p['cadets']})\n        df['USAFA'] = p['usafa']\n        df['Merit'] = p['merit']\n        df[\"Matched AFSC\"] = solution['afsc_array']\n        if \"base_array\" in solution:\n            df[\"Matched Base\"] = solution['base_array']\n            df[\"Matched Course\"] = solution['course_array']\n            col_dict = {'Base Choice': 'base_choice', 'Cadet State': 'cadet_state_achieved',\n                        'State Utility': 'state_utility_used', 'Cadet Value': 'cadet_value_achieved',\n                        'AFSC Weight': 'afsc_weight_used', 'Base Weight': 'base_weight_used',\n                        'Course Weight': 'course_weight_used', 'Base Utility': 'base_utility_achieved',\n                        'Course Utility': 'course_utility_achieved'}\n            for key, val in col_dict.items():\n                if val in solution:\n                    df[key] = solution[val]\n        df['Cadet Choice'] = solution['cadet_choice']\n        df['AFSC Choice'] = solution['afsc_choice']\n        df['Cadet Utility'] = solution['cadet_utility_achieved']\n        df['AFSC Utility'] = solution['afsc_utility_achieved']\n        df['Global Utility'] = solution['global_utility_achieved']\n        df['Matched Deg Tier'] = [  # \"U\" for unmatched cadets\n            p['qual'][i, solution['j_array'][i]] if solution['j_array'][i] in p['J'] else 'U' for i in p['I']]\n\n        # Rated Reserves/Matches/Alternates\n        for s_name in ['Rated Matches', 'Rated Reserves', 'Rated Alternates (Hard)', 'Rated Alternates (Soft)']:\n            if s_name in instance.solutions:\n                df[s_name] = instance.solutions[s_name]['afsc_array']\n            else:\n                df[s_name] = [\"*\" for _ in p['I']]\n\n        # Rated Rankings\n        for j in p['J^Rated']:\n            df[p['afscs'][j] + \" Rank\"] = p['a_pref_matrix'][:, j]\n\n        # Add the cadet's top 10 choices for more information!\n        for choice in range(min(p['P'], 10)):\n            df['Choice ' + str(choice + 1)] = p['c_preferences'][:, choice]\n\n        # Capture preference columns\n        preference_columns = excel_columns[len(df.columns) - min(p['P'], 10): len(df.columns)]\n\n        # Add the cadet's top 10 utilities for more information!\n        for choice in range(min(p['P'], 10)):\n            df['Utility ' + str(choice + 1)] = np.zeros(p['N'])\n            for i in p['I']:\n\n                # Might run out of utilities\n                if len(p['cadet_preferences'][i]) &gt; choice:\n                    j = p['cadet_preferences'][i][choice]\n                    df['Utility ' + str(choice + 1)][i] = p['cadet_utility'][i, j]\n\n        # Convert the dataframe to an XlsxWriter Excel object.\n        df.to_excel(writer, sheet_name='Solution', index=False, startrow=1, header=False)\n\n        # Get the xlsxwriter worksheet object.\n        worksheet = writer.sheets[\"Solution\"]\n\n        # Add additional formatting to top row\n        header_format = workbook.add_format({'bold': True, 'text_wrap': True, 'align': 'center', 'valign': 'vcenter'})\n        for col_num, value in enumerate(df.columns.values):\n            worksheet.write(0, col_num, value, header_format)\n\n        # Get numpy array of df columns\n        df_columns = np.array(df.columns)\n\n        # Conditional Formatting on preferences\n        cadet_choice_col = excel_columns[np.where(df_columns == 'Cadet Choice')[0][0]]\n        for col, c in enumerate(preference_columns):\n            format1 = workbook.add_format({'bg_color': mdl_p['choice_colors'][col + 1]})\n            worksheet.conditional_format(c + \"2:\" + c + str(p['N'] + 1),\n                                         {'type': 'cell', 'value': 'D2',\n                                          'criteria': '=',\n                                          'format': format1\n                                          })\n            # Cadet Choice Column\n            worksheet.conditional_format(cadet_choice_col + \"2:\" + cadet_choice_col + str(p['N'] + 1),\n                                         {'type': 'cell', 'value': col + 1,\n                                          'criteria': '=',\n                                          'format': format1\n                                          })\n\n        # Freeze top row\n        worksheet.freeze_panes(1, 0)\n\n        # Add filter to headers\n        worksheet.autofilter('A1:' + str(excel_columns[len(df.columns) - 1]) + str(p['N'] + 1))\n\n        # Replace unassigned base values\n        if 'Base Choice' in df:\n            cell_format = workbook.add_format({})\n            for i in p['I']:\n                if df.loc[i, 'Base Choice'] == 0:\n                    letters = [excel_columns[np.where(df_columns == col)[0][0]] for col in\n                               ['Base Weight', 'Base Choice', 'Base Utility']]\n                    for letter in letters:\n                        worksheet.write(letter + str(i + 2), '', cell_format)\n\n        # Small values good (1, 2, 3, 4, ...) Conditional Formatting\n        sv_excel_cols = []\n        for col in ['AFSC Choice', 'Base Choice', 'Cadet State']:\n            if col in df:\n                sv_excel_cols.append(excel_columns[np.where(df_columns == col)[0][0]])\n        for c in sv_excel_cols:\n            worksheet.conditional_format(\n                c + \"2:\" + c + str(p['N'] + 1), {'type': '3_color_scale', 'min_color': '#63be7b',\n                                                 'mid_color': '#ffeb84', 'max_color': '#f8696b'})\n\n        # Large values good (1, ...,  0) Conditional Formatting\n        lv_excel_cols = []\n        for col in ['Merit', 'Cadet Utility', 'AFSC Utility', 'Global Utility', 'Base Utility', 'Course Utility',\n                    'State Utility', 'Cadet Value', 'Cadet Value (Pyomo)']:\n            if col in df:\n                lv_excel_cols.append(excel_columns[np.where(df_columns == col)[0][0]])\n        for c in lv_excel_cols:\n            worksheet.conditional_format(c + \"2:\" + c + str(p['N'] + 1), {\"type\": \"3_color_scale\"})\n\n        # \"All Others\" for the choice column\n        format1 = workbook.add_format({'bg_color': mdl_p['all_other_choice_colors']})\n        worksheet.conditional_format(cadet_choice_col + \"2:\" + cadet_choice_col + str(p['N'] + 1),\n                                     {'type': 'cell', 'value': 10, 'criteria': '&gt;', 'format': format1})\n\n        # Add a percent number format to certain columns\n        percent_cols = ['Merit', 'State Utility', 'Cadet Value', 'AFSC Weight', 'Base Weight', 'Course Weight',\n                        'Base Utility', 'Course Utility', 'Cadet Utility', 'AFSC Utility', 'Global Utility']\n        percent_format = workbook.add_format({\"num_format\": \"0.0%\"})\n        for col in percent_cols:\n            if col in df_columns:\n                c_num = np.where(df_columns == col)[0][0]\n                worksheet.set_column(c_num, c_num, None, percent_format)\n\n        # Solution/X Matrix\n        if 'x' in solution:\n            df = pd.DataFrame({'Cadet': p['cadets']})\n            df[instance.solution_name] = instance.solution['afsc_array']\n            for j, afsc in enumerate(p['afscs'][:p['M']]):\n                df[afsc] = instance.solution['x'][:, j]\n\n            # Convert the dataframe to an XlsxWriter Excel object.\n            df.to_excel(writer, sheet_name='X', index=False)\n\n        # Base Matrix\n        if 'v' in solution:\n            df = pd.DataFrame({'Cadet': p['cadets']})\n            df[instance.solution_name] = instance.solution['base_array']\n            for b, base in enumerate(p['bases'][:p['S']]):\n                df[base] = instance.solution['v'][:, b]\n\n            # Convert the dataframe to an XlsxWriter Excel object.\n            df.to_excel(writer, sheet_name='V', index=False)\n\n        # Training Matrix\n        if 'q' in solution:\n\n            df = pd.DataFrame({'Cadet': p['cadets']})\n            df[instance.solution_name] = instance.solution['course_array']\n            for j, afsc in enumerate(p['afscs'][:p['M']]):\n                for c, course in enumerate(p['courses'][j]):\n                    df[afsc + \"-\" + course] = instance.solution['q'][:, j, c]\n\n            # Convert the dataframe to an XlsxWriter Excel object.\n            df.to_excel(writer, sheet_name='Q', index=False)\n\n        # Value Function Matrices\n        if 'lambda' in solution:\n\n            afsc_arr = [afsc for afsc in p['afscs'][:p['M']] for _ in vp['K']]\n            objective_arr = [objective for _ in p['J'] for objective in vp['objectives']]\n\n            df = pd.DataFrame({'AFSC': afsc_arr, 'Objective': objective_arr})\n            for l in range(solution['r^max']):\n                arr = [solution['lambda'][j, k, l] for j in p['J'] for k in vp['K']]\n                df['l_' + str(l + 1)] =  arr\n\n            # Convert the dataframe to an XlsxWriter Excel object.\n            df.to_excel(writer, sheet_name='Lambda', index=False)\n\n            df = pd.DataFrame({'AFSC': afsc_arr, 'Objective': objective_arr})\n            for l in range(solution['r^max']):\n                arr = [solution['y'][j, k, l] for j in p['J'] for k in vp['K']]\n                df['y_' + str(l + 1)] = arr\n\n            # Convert the dataframe to an XlsxWriter Excel object.\n            df.to_excel(writer, sheet_name='Y', index=False)\n\n        # Blocking Pairs\n        if 'blocking_pairs' in solution:\n\n            # Create \"blocking pairs\" dataframe and export it to excel\n            blocking_cadets = [tuple[0] for tuple in solution['blocking_pairs']]\n            blocking_afscs = [p['afscs'][tuple[1]] for tuple in solution['blocking_pairs']]\n            df = pd.DataFrame({'Blocking Cadet': blocking_cadets, 'Blocking AFSC': blocking_afscs})\n            df.to_excel(writer, sheet_name='Blocking Pairs', index=False)\n\n        # Close the workbook\n        writer.close()\n    export_results_dfs()\n</code></pre>"},{"location":"reference/data/processing/#data.processing.draw_frame_border_outside","title":"<code>draw_frame_border_outside(workbook, worksheet, first_row, first_col, rows_count, cols_count, color='#0000FF', width=2)</code>","text":"<p>Draws an outer border around a rectangular cell range using conditional formatting.</p> <ul> <li>Applies a frame to the specified region starting at (first_row, first_col) with size (rows_count x cols_count)</li> <li>Border color and width are customizable</li> <li>Assumes 0-based indexing and adjusts if row/column values are less than 1</li> </ul>"},{"location":"reference/data/processing/#data.processing.draw_frame_border_outside--parameters","title":"Parameters","text":"<ul> <li>workbook : xlsxwriter.Workbook</li> <li>worksheet : xlsxwriter.Worksheet</li> <li>first_row : int</li> <li>first_col : int</li> <li>rows_count : int</li> <li>cols_count : int</li> <li>color : str, default '#0000FF'</li> <li>width : int, default 2</li> </ul> Source code in <code>afccp/data/processing.py</code> <pre><code>def draw_frame_border_outside(workbook, worksheet, first_row, first_col, rows_count, cols_count,\n                              color='#0000FF', width=2):\n    \"\"\"\n    Draws an outer border around a rectangular cell range using conditional formatting.\n\n    - Applies a frame to the specified region starting at (first_row, first_col) with size (rows_count x cols_count)\n    - Border color and width are customizable\n    - Assumes 0-based indexing and adjusts if row/column values are less than 1\n\n    Parameters\n    ----------\n    - workbook : xlsxwriter.Workbook\n    - worksheet : xlsxwriter.Worksheet\n    - first_row : int\n    - first_col : int\n    - rows_count : int\n    - cols_count : int\n    - color : str, default '#0000FF'\n    - width : int, default 2\n    \"\"\"\n\n    # verify type of data passed in\n    if first_row &lt;= 0:\n        first_row = 1\n    if first_col &lt;= 0:\n        first_col = 1\n    cols_count = abs(cols_count)\n    rows_count = abs(rows_count)\n\n    # top left corner\n    worksheet.conditional_format(first_row - 1, first_col,\n                                 first_row - 1, first_col,\n                                 {'type': 'formula', 'criteria': 'True',\n                                  'format': workbook.add_format({'bottom': width, 'border_color': color})})\n    worksheet.conditional_format(first_row, first_col - 1,\n                                 first_row, first_col - 1,\n                                 {'type': 'formula', 'criteria': 'True',\n                                  'format': workbook.add_format({'right': width, 'border_color': color})})\n    # top right corner\n    worksheet.conditional_format(first_row - 1, first_col + cols_count - 1,\n                                 first_row - 1, first_col + cols_count - 1,\n                                 {'type': 'formula', 'criteria': 'True',\n                                  'format': workbook.add_format({'bottom': width, 'border_color': color})})\n    worksheet.conditional_format(first_row, first_col + cols_count,\n                                 first_row, first_col + cols_count,\n                                 {'type': 'formula', 'criteria': 'True',\n                                  'format': workbook.add_format({'left': width, 'border_color': color})})\n    # bottom left corner\n    worksheet.conditional_format(first_row + rows_count - 1, first_col - 1,\n                                 first_row + rows_count - 1, first_col - 1,\n                                 {'type': 'formula', 'criteria': 'True',\n                                  'format': workbook.add_format({'right': width, 'border_color': color})})\n    worksheet.conditional_format(first_row + rows_count, first_col,\n                                 first_row + rows_count, first_col,\n                                 {'type': 'formula', 'criteria': 'True',\n                                  'format': workbook.add_format({'top': width, 'border_color': color})})\n    # bottom right corner\n    worksheet.conditional_format(first_row + rows_count - 1, first_col + cols_count,\n                                 first_row + rows_count - 1, first_col + cols_count,\n                                 {'type': 'formula', 'criteria': 'True',\n                                  'format': workbook.add_format({'left': width, 'border_color': color})})\n    worksheet.conditional_format(first_row + rows_count, first_col + cols_count - 1,\n                                 first_row + rows_count, first_col + cols_count - 1,\n                                 {'type': 'formula', 'criteria': 'True',\n                                  'format': workbook.add_format({'top': width, 'border_color': color})})\n    # top\n    worksheet.conditional_format(first_row - 1, first_col + 1,\n                                 first_row - 1, first_col + cols_count - 2,\n                                 {'type': 'formula', 'criteria': 'True',\n                                  'format': workbook.add_format({'bottom': width, 'border_color': color})})\n    # left\n    worksheet.conditional_format(first_row + 1, first_col - 1,\n                                 first_row + rows_count - 2, first_col - 1,\n                                 {'type': 'formula', 'criteria': 'True',\n                                  'format': workbook.add_format({'right': width, 'border_color': color})})\n    # bottom\n    worksheet.conditional_format(first_row + rows_count, first_col + 1,\n                                 first_row + rows_count, first_col + cols_count - 2,\n                                 {'type': 'formula', 'criteria': 'True',\n                                  'format': workbook.add_format({'top': width, 'border_color': color})})\n    # right\n    worksheet.conditional_format(first_row + 1, first_col + cols_count,\n                                 first_row + rows_count - 2, first_col + cols_count,\n                                 {'type': 'formula', 'criteria': 'True',\n                                  'format': workbook.add_format({'left': width, 'border_color': color})})\n</code></pre>"},{"location":"reference/data/support/","title":"Support","text":""},{"location":"reference/data/support/#data.support","title":"<code>data.support</code>","text":""},{"location":"reference/data/support/#data.support--data-support-module","title":"Data Support Module","text":"<p>Provides supporting functions for configuring problem instances and generating AFSC-related visualization and qualification metadata in the AFCCP system.</p> <p>This module contains helper functions used to initialize and update key parameter sets related to AFSCs, cadet eligibility, solution comparison, and qualification tiers. These functions support both the modeling pipeline and result interpretation by preparing model-specific parameters and simplifying downstream visualization or analysis tasks.</p>"},{"location":"reference/data/support/#data.support--functions","title":"Functions","text":"<ul> <li><code>initialize_instance_functional_parameters</code>: Adds AFCCP-specific keys to the model parameters, including default display and export options.</li> <li><code>determine_afsc_plot_details</code>: Sets visualization attributes for each AFSC (e.g., colors, abbreviations, names) used in plots and diagrams.</li> <li><code>determine_afscs_in_image</code>: Filters AFSCs to display in charts based on the solution scope, accession source, or eligibility threshold.</li> <li><code>pick_most_changed_afscs</code>: Identifies the AFSCs with the greatest variability in cadet assignments across multiple solutions.</li> <li><code>cip_to_qual_tiers</code>: Computes cadet qualification tiers (e.g., M1, D2, P3) based on their CIP degree codes for each AFSC.</li> </ul>"},{"location":"reference/data/support/#data.support--typical-use-cases","title":"Typical Use Cases","text":"<ul> <li>Automatically setting up model parameters based on the data inputs (<code>initialize_instance_functional_parameters</code>)</li> <li>Preparing AFSC visuals for comparison charts or preference graphs (<code>determine_afsc_plot_details</code>, <code>determine_afscs_in_image</code>)</li> <li>Analyzing how different modeling approaches affect AFSC-level cadet outcomes (<code>pick_most_changed_afscs</code>)</li> <li>Generating qualification matrices for cadets using AFOCD-based tiering rules (<code>cip_to_qual_tiers</code>)</li> </ul>"},{"location":"reference/data/support/#data.support.initialize_instance_functional_parameters","title":"<code>initialize_instance_functional_parameters(N)</code>","text":"<p>Initializes the functional parameters used by the CadetCareerProblem object.</p>"},{"location":"reference/data/support/#data.support.initialize_instance_functional_parameters--parameters","title":"Parameters","text":"<p>N : int     Number of cadets in the problem instance. Used to scale certain algorithm parameters.</p>"},{"location":"reference/data/support/#data.support.initialize_instance_functional_parameters--returns","title":"Returns","text":"<p>dict     A dictionary of instance parameters (<code>mdl_p</code>) controlling behavior, algorithms, chart rendering,     Pyomo integration, CASTLE compatibility, and more.</p>"},{"location":"reference/data/support/#data.support.initialize_instance_functional_parameters--overview","title":"Overview","text":"<p>This function provides a centralized configuration for the CadetCareerProblem object. Parameters are grouped by functionality and define the default settings for:</p> <ul> <li>Generic Solution Handling: Toggles for storing, naming, and gathering metrics from solutions.</li> <li>Matching Algorithm Parameters: Controls for deterministic/rated/genetic matching algorithms.</li> <li>Rated Matching Parameters: Defines logic for cross-commissioning and board behavior for rated tracks.</li> <li>Genetic Algorithm Settings: Population size, mutation logic, crossover mechanics, and GA heuristics.</li> <li>Pyomo Integration: Solver-specific options, time limits, and accessions logic.</li> <li>Constraint Logic: Bounds and options for special constraints (e.g., USSF-specific, merit floors).</li> <li>VFT and Constraint Placement: Value Function Tool (VFT) control and constraint modeling logic.</li> <li>Chart Parameters: Configuration for Bubble, AFSC, utility, and comparison charts.</li> <li>Sensitivity Analysis: Controls for PGL iteration studies and Pareto frontier evaluations.</li> <li>CASTLE Integration: Optional toggles for syncing with the CASTLE system (e.g., GUO compatibility).</li> <li>Chart Color Palettes: A full color dictionary for use across demographics, performance, and visuals.</li> <li>Animation and Interaction Colors: Highlights for matched/unmatched cadets and choice levels.</li> <li>Slide Export and Layout: Coordinates and chart choices for building slides or figures.</li> </ul>"},{"location":"reference/data/support/#data.support.initialize_instance_functional_parameters--notes","title":"Notes","text":"<ul> <li>Analysts can modify these values in-place or pass an updated version of this dictionary into   CadetCareerProblem methods. See the <code>p_dict</code> parameter option of the <code>CadetCareerProblem</code> class</li> <li>Chart rendering behavior (figures, legends, annotations) is also fully parameterized here.</li> <li>Default values are tuned for USAFA cadet datasets but can be adapted to ROTC/OTS or simulation needs.</li> </ul>"},{"location":"reference/data/support/#data.support.initialize_instance_functional_parameters--see-also","title":"See Also","text":"<ul> <li>CadetCareerProblem</li> </ul> Source code in <code>afccp/data/support.py</code> <pre><code>def initialize_instance_functional_parameters(N):\n    \"\"\"\n    Initializes the functional parameters used by the CadetCareerProblem object.\n\n    Parameters\n    ----------\n    N : int\n        Number of cadets in the problem instance. Used to scale certain algorithm parameters.\n\n    Returns\n    -------\n    dict\n        A dictionary of instance parameters (`mdl_p`) controlling behavior, algorithms, chart rendering,\n        Pyomo integration, CASTLE compatibility, and more.\n\n    Overview\n    --------\n    This function provides a centralized configuration for the CadetCareerProblem object.\n    Parameters are grouped by functionality and define the default settings for:\n\n    - **Generic Solution Handling**: Toggles for storing, naming, and gathering metrics from solutions.\n    - **Matching Algorithm Parameters**: Controls for deterministic/rated/genetic matching algorithms.\n    - **Rated Matching Parameters**: Defines logic for cross-commissioning and board behavior for rated tracks.\n    - **Genetic Algorithm Settings**: Population size, mutation logic, crossover mechanics, and GA heuristics.\n    - **Pyomo Integration**: Solver-specific options, time limits, and accessions logic.\n    - **Constraint Logic**: Bounds and options for special constraints (e.g., USSF-specific, merit floors).\n    - **VFT and Constraint Placement**: Value Function Tool (VFT) control and constraint modeling logic.\n    - **Chart Parameters**: Configuration for Bubble, AFSC, utility, and comparison charts.\n    - **Sensitivity Analysis**: Controls for PGL iteration studies and Pareto frontier evaluations.\n    - **CASTLE Integration**: Optional toggles for syncing with the CASTLE system (e.g., GUO compatibility).\n    - **Chart Color Palettes**: A full color dictionary for use across demographics, performance, and visuals.\n    - **Animation and Interaction Colors**: Highlights for matched/unmatched cadets and choice levels.\n    - **Slide Export and Layout**: Coordinates and chart choices for building slides or figures.\n\n    Notes\n    -----\n    - Analysts can modify these values in-place or pass an updated version of this dictionary into\n      CadetCareerProblem methods. See the `p_dict` parameter option of the `CadetCareerProblem` class\n    - Chart rendering behavior (figures, legends, annotations) is also fully parameterized here.\n    - Default values are tuned for USAFA cadet datasets but can be adapted to ROTC/OTS or simulation needs.\n\n    See Also\n    --------\n    - [CadetCareerProblem](../../../afccp/reference/main/cadetcareerproblem_overview/)\n    \"\"\"\n\n    # Parameters for the graphs\n    mdl_p = {\n\n        # Generic Solution Handling (for multiple algorithms/models)\n        \"initial_solutions\": None, \"solution_names\": None, \"add_to_dict\": True, \"set_to_instance\": True,\n        \"initialize_new_heuristics\": False, 'gather_all_metrics': True, 're-calculate x': True, 'solution_method': None,\n\n        # Matching Algorithm Parameters\n        'ma_printing': False, 'capacity_parameter': 'quota_max', 'collect_solution_iterations': True,\n        'create_new_rated_solutions': True,\n\n        # Rated Matching Algorithm Parameters\n        'rated_alternate_afscs': None, 'rated_alternates': True, 'rotc_rated_board_afsc_order': None, 'soc': 'usafa',\n        'incorporate_rated_results': True, 'usafa_soc_pilot_cross_in': False, 'socs_to_use': None,\n\n        # Genetic Matching Algorithm Parameters\n        \"gma_pop_size\": 4, 'gma_max_time': 20, 'gma_num_crossover_points': 2, 'gma_mutations': 1,\n        'gma_mutation_rate': 1, 'gma_printing': False, 'stopping_conditions': 'Time', 'gma_num_generations': 200,\n\n        # Genetic Algorithm Parameters\n        \"pop_size\": 12, \"ga_max_time\": 60, \"num_crossover_points\": 3, \"initialize\": True, \"ga_printing\": True,\n        \"mutation_rate\": 0.05, \"num_time_points\": 100, \"num_mutations\": int(np.ceil(N / 75)), \"time_eval\": False,\n        \"percent_step\": 10, \"ga_constrain_first_only\": False, 'mutation_function': 'cadet_choice',\n        'preference_mutation_rate': 0.5,\n\n        # Pyomo General Parameters\n        \"real_usafa_n\": 960, \"solver_name\": \"cbc\", \"pyomo_max_time\": None, \"provide_executable\": False,\n        \"executable\": None, \"exe_extension\": False, 'alternate_list_iterations_printing': False,\n        'ots_accessions': None, 'ots_selected_preferences_only': True, 'ots_constrain_must_match': False,\n        'pyomo_tee': False,\n\n        # Additional Constraints/Modeling\n        \"assignment_model_obj\": \"Global Utility\", 'ussf_merit_bound': 0.03, 'ussf_soc_pgl_constraint': False,\n        'ussf_soc_pgl_constraint_bound': 0.01, 'USSF OM': False,\n        'USAFA-Constrained AFSCs': None,\n\n        # Base/Training Parameters\n        'BIG M': 100, 'solve_extra_components': False,\n\n        # VFT Model Parameters\n        \"pyomo_constraint_based\": True, \"constraint_tolerance\": 0.95, \"warm_start\": None, \"init_from_X\": False,\n        \"obtain_warm_start_variables\": True, \"add_breakpoints\": True, \"approximate\": True,\n\n        # VFT Population Generation Parameters\n        \"populate\": True, \"iterate_from_quota\": True, \"max_quota_iterations\": 5, \"population_additions\": 10,\n        \"population_generation_model\": \"Assignment\",\n\n        # Model Constraint Placement Algorithm parameters\n        'constraint_model_to_use': 'Assignment', \"skip_quota_constraint\": False,\n\n        # Sensitivity Analysis\n        \"pareto_step\": 10, \"num_pgl_analysis_iterations\": 30, \"import_pgl_analysis_folder\": None,\n\n        # Goal Programming Parameters\n        \"get_reward\": False, \"con_term\": None, \"get_new_rewards_penalties\": False, \"use_gp_df\": True,\n\n        # CASTLE Integration Parameters\n        \"w^G\": 0.8,  # Weight on GUO solution relative to CASTLE\n        \"solve_castle_guo\": False,  # Whether we should solve the castle version of GUO or not\n\n        # Value Parameter Generation\n        \"new_vp_weight\": 100, \"num_breakpoints\": 24,\n\n        # BubbleChart Parameters\n        'b_figsize': (13.33, 7.5), 's': 1, 'fw': 100, 'circle_radius_percent': 0.8,\n        'fh_ratio': 0.5, 'bw^t_ratio': 0.05, 'bw^l_ratio': 0, 'bw^r_ratio': 0, 'b_title': None,\n        'bw^b_ratio': 0, 'bw^u_ratio': 0.02, 'abw^lr_ratio': 0.01, 'abw^ud_ratio': 0.02, 'b_title_size': 30,\n        'lh_ratio': 0.1, 'lw_ratio': 0.1, 'dpi': 200, 'pgl_linestyle': '-', 'pgl_color': 'gray',\n        'pgl_alpha': 0.5, 'surplus_linestyle': '--', 'surplus_color': 'white', 'surplus_alpha': 1,\n        'usafa_pgl_color': 'blue', 'rotc_pgl_color': 'red', 'usafa_bubble': 'blue', 'rotc_bubble': 'red',\n        'ots_pgl_color': 'yellow', 'ots_bubble': 'yellow',\n        'cb_edgecolor': 'black', 'save_board_default': True, 'circle_color': 'black', 'focus': 'Cadet Choice',\n        'save_iteration_frames': True, 'afsc_title_size': 20, 'afsc_names_sized_box': False,\n        'b_solver_name': 'couenne', 'b_pyomo_max_time': None, 'row_constraint': False, 'n^rows': 3,\n        'simplified_model': True, 'use_pyomo_model': True, 'sort_cadets_by': 'AFSC Preferences', 'add_legend': False,\n        'draw_containers': False, 'figure_color': 'black', 'text_color': 'white', 'afsc_text_to_show': 'Norm Score',\n        'use_rainbow_hex': True, 'build_orientation_slides': True, 'b_legend': True, 'b_legend_size': 20,\n        'b_legend_marker_size': 20, 'b_legend_title_size': 20, 'x_ext_left': 0, 'x_ext_right': 0, 'y_ext_left': 0,\n        'y_ext_right': 0, 'show_rank_text': False, 'rank_text_color': 'white', 'fontsize_single_digit_adj': 0.6,\n        'b_legend_loc': 'upper right', 'redistribute_x': True, 'cadets_solved_for': None, \"y_val_to_pin\": 0.03,\n        'show_white_surplus_boxes': False,\n\n        # These parameters pertain to the AFSCs that will ultimately show up in the visualizations\n        'afscs_solved_for': 'All', 'afscs_to_show': 'All',\n\n        # Generic Chart Handling\n        \"save\": True, \"figsize\": (19, 10), \"facecolor\": \"white\", \"title\": None, \"filename\": None, \"display_title\": True,\n        \"label_size\": 25, \"afsc_tick_size\": 20, \"yaxis_tick_size\": 25, \"bar_text_size\": 15, \"xaxis_tick_size\": 20,\n        \"afsc_rotation\": None, \"bar_color\": \"#3287cd\", \"alpha\": 1, \"legend_size\": 25, \"title_size\": 25,\n        \"text_size\": 15, 'text_bar_threshold': 400, 'dot_size': 35, 'legend_dot_size': 15, 'ncol': 1,\n        \"color_afsc_text_by_grp\": True, \"proportion_legend_size\": 15, 'proportion_text_bar_threshold': 10,\n        \"square_figsize\": (11, 10), 'legend_fontsize': 15, 'bar_text_offset': None,\n\n        # AFSC Chart Elements\n        \"eligibility\": True, \"eligibility_limit\": None, \"skip_afscs\": None, \"all_afscs\": True, \"y_max\": 1.1,\n        \"y_exact_max\": None, \"preference_chart\": False, \"preference_proportion\": False, \"dot_chart\": False,\n        \"sort_by_pgl\": True, \"solution_in_title\": True, \"afsc\": None, \"only_desired_graphs\": True,\n        'add_legend_afsc_chart': True, 'legend_loc': 'upper right', \"add_bound_lines\": False,\n        \"large_afsc_distinction\": False,\n\n        # Cadet Utility Chart Elements\n        \"cadet\": 0, \"util_type\": \"Final Utility\",\n\n        # Accessions Chart Elements\n        \"label_size_acc\": 25, \"acc_text_size\": 25, \"acc_bar_text_size\": 25, \"acc_legend_size\": 15,\n        \"acc_text_bar_threshold\": 10,\n\n        # Macro Chart Controls\n        \"cadets_graph\": True, \"data_graph\": \"AFOCD Data\", \"results_graph\": \"Measure\", \"objective\": \"Merit\",\n        \"version\": \"bar\", \"macro_chart_kind\": \"AFSC Chart\",\n\n        # Similarity Chart Elements\n        \"sim_dot_size\": 220, \"new_similarity_matrix\": True, 'default_sim_color': 'black',\n        'default_sim_marker': 'o',\n\n        # Value Function Chart Elements\n        \"smooth_value_function\": False,\n\n        # Solution Comparison Chart Information\n        \"compare_solutions\": False, \"vp_name\": None,\n        \"color_choices\": [\"red\", \"blue\", \"green\", \"orange\", \"purple\", \"black\", \"magenta\"],\n        \"marker_choices\": ['o', 'D', '^', 'P', 'v', '*', 'h'], \"marker_size\": 20, \"comparison_afscs\": None,\n        \"zorder_choices\": [2, 3, 2, 2, 2, 2, 2], \"num_solutions\": None,\n\n        # Multi-Criteria Chart\n        \"num_afscs_to_compare\": 8, \"comparison_criteria\": [\"Utility\", \"Merit\", \"AFOCD\"],\n\n        # Slide Parameters\n        \"ch_top\": 2.35, \"ch_left\": 0.59, \"ch_height\": 4.64, \"ch_width\": 8.82,\n\n        # Subset of charts I actually really care about\n        \"desired_charts\": [(\"Combined Quota\", \"quantity_bar\"),\n                           (\"Norm Score\", \"quantity_bar_proportion\"),\n                           (\"Norm Score\", \"bar\"),\n                           (\"Norm Score\", \"quantity_bar_choice\"),\n                           (\"Utility\", \"quantity_bar_proportion\"),\n                           (\"Utility\", \"quantity_bar_choice\"),\n                           (\"Merit\", \"bar\"),\n                           (\"USAFA Proportion\", \"quantity_bar_proportion\"),\n                           (\"USAFA Proportion\", \"preference_chart\"),\n                           ('Extra', 'SOC Chart'),\n                           ('Extra', 'SOC Chart_proportion')],\n\n        \"desired_comparison_charts\": [('Utility', 'median_preference'), ('Combined Quota', 'dot'), ('Utility', 'dot'),\n                                      ('Norm Score', 'dot'), ('Merit', 'dot'), ('Tier 1', 'dot'),\n                                      # ('Extra', 'Race Chart'),\n                                      ('USAFA Proportion', 'dot'),\n                                      # ('Male', 'dot'),\n                                      ('Utility', 'mean_preference')],\n\n        'desired_other_charts': [\n                                # (\"Accessions Group\", \"Race Chart\"), (\"Accessions Group\", \"Gender Chart\"),\n                                #  (\"Accessions Group\", \"Ethnicity Chart\"),\n                                 (\"Accessions Group\", \"SOC Chart\"),\n            ]\n\n    }\n\n    # AFSC Measure Chart Versions\n    afsc_chart_versions = {\"Merit\": [\"large_only_bar\", \"bar\", \"quantity_bar_gradient\", \"quantity_bar_proportion\"],\n                           \"USAFA Proportion\": [\"large_only_bar\", \"bar\", \"preference_chart\", \"quantity_bar_proportion\"],\n                           \"Male\": [\"bar\", \"preference_chart\", \"quantity_bar_proportion\"],\n                           \"Combined Quota\": [\"dot\", \"quantity_bar\"],\n                           \"Minority\": [\"bar\", \"preference_chart\", \"quantity_bar_proportion\"],\n                           \"Utility\": [\"bar\", \"quantity_bar_gradient\", \"quantity_bar_proportion\", \"quantity_bar_choice\"],\n                           \"Mandatory\": [\"dot\"], \"Desired\": [\"dot\"], \"Permitted\": [\"dot\"],\n                           \"Tier 1\": [\"dot\"], \"Tier 2\": [\"dot\"], \"Tier 3\": [\"dot\"], \"Tier 4\": [\"dot\"],\n                           \"Norm Score\": [\"dot\", \"quantity_bar_proportion\", \"bar\", 'quantity_bar_choice'],\n                           'Extra': ['Race Chart', 'Race Chart_proportion', 'Gender Chart', 'SOC Chart',\n                                     'Ethnicity Chart', 'Gender Chart_proportion', 'SOC Chart_proportion',\n                                     'Ethnicity Chart_proportion']}\n\n    # Colors for the various bar types:\n    colors = {\n\n        # Cadet Preference Charts\n        \"top_choices\": \"#5490f0\", \"mid_choices\": \"#eef09e\", \"bottom_choices\": \"#f25d50\",\n        \"Volunteer\": \"#5490f0\", \"Non-Volunteer\": \"#f25d50\", \"Top 6 Choices\": \"#5490f0\", \"7+ Choice\": \"#f25d50\",\n\n        # Quartile Charts\n        \"quartile_1\": \"#373aed\", \"quartile_2\": \"#0b7532\", \"quartile_3\": \"#d1bd4d\", \"quartile_4\": \"#cc1414\",\n\n        # AFOCD Charts\n        \"Mandatory\": \"#311cd4\", \"Desired\": \"#085206\", \"Permitted\": \"#bda522\", \"Ineligible\": \"#f25d50\",\n\n        # Cadet Demographics\n        \"male\": \"#6531d6\", \"female\": \"#73d631\", \"usafa\": \"#5ea0bf\", \"rotc\": \"#cc9460\", \"ots\": \"green\",  # TODO: change\n        \"minority\": \"#eb8436\",\n        \"non-minority\": \"#b6eb6c\",\n\n        # Misc. AFSC Criteria  #cdddf7\n        \"large_afscs\": \"#060d47\", \"small_afscs\": \"#3287cd\", \"merit_above\": \"#c7b93a\", \"merit_within\": \"#3d8ee0\",\n        \"merit_below\": \"#bf4343\", \"large_within\": \"#3d8ee0\", \"large_else\": \"#c7b93a\",\n\n        # Utility Chart Colors\n        \"Utility Ascribed\": \"#4793AF\", \"Normalized Rank\": \"#FFC470\", \"Not Bottom 3\": \"#DD5746\",\n        \"Not Last Choice\": \"#8B322C\",\n\n        # PGL Charts\n        \"pgl\": \"#5490f0\", \"surplus\": \"#eef09e\", \"failed_pgl\": \"#f25d50\",\n\n        # Race Colors\n        \"American Indian/Alaska Native\": \"#d46013\", \"American Indian or Alaska Native\": \"#d46013\",\n        \"Asian\": \"#3ad413\",\n        \"Black or African American\": \"#1100ff\", \"Native Hawaiian/Pacific Islander\": \"#d4c013\",\n        \"Native Hawaiian or Other Pacific Islander\": \"#d4c013\",\n        \"Two or more races\": \"#ff0026\", \"Unknown\": \"#27dbe8\", \"White\": \"#a3a3a2\",\n\n        # Gender/SOC written differently (need to fix this later)\n        \"Male\": \"#6531d6\", \"Female\": \"#73d631\", \"USAFA\": \"#5ea0bf\", \"ROTC\": \"#cc9460\", \"OTS\": \"green\",  # TODO: Change\n\n        # Accessions group colors\n        \"All Cadets\": \"#000000\", \"Rated\": \"#ff0011\", \"USSF\": \"#0015ff\", \"NRL\": \"#000000\",\n\n        \"Hispanic or Latino\": \"#66d4ce\", \"Not Hispanic\": \"#e09758\", \"Not Hispanic or Latino\": \"#e09758\",\n        \"Unknown Ethnicity\": \"#9e9e9e\"\n\n    }\n\n    # Animation Colors\n    choice_colors = {1: '#3700ff', 2: '#008dff', 3: '#00e7ff', 4: '#00FF93', 5: '#17FF00',  # #00ff04\n                     6: '#BDFF00', 7: '#FFFF00', 8: '#FFCD00', 9: '#FF8700', 10: '#FF5100'}\n    mdl_p['all_other_choice_colors'] = '#FF0000'\n    mdl_p['choice_colors'] = choice_colors\n    mdl_p['interest_colors'] = {'High': '#3700ff', 'Med': '#dad725', 'Low': '#ff9100', 'None': '#ff000a'}\n    mdl_p['reserved_slot_color'] = \"#ac9853\"\n    mdl_p['matched_slot_color'] = \"#3700ff\"\n    mdl_p['unfocused_color'] = \"#aaaaaa\"\n    mdl_p['unmatched_color'] = \"#aaaaaa\"\n    mdl_p['exception_edge'] = \"#FFD700\"\n    mdl_p['base_edge'] = 'black'\n\n    # Add these elements to the main dictionary\n    mdl_p[\"afsc_chart_versions\"] = afsc_chart_versions\n    mdl_p[\"bar_colors\"] = colors\n\n    # Value Function Chart parameters\n    mdl_p['ValueFunctionChart'] = {'x_pt': None, 'y_pt': None, 'title': None, 'display_title': True, 'figsize': (10, 10),\n                                   'facecolor': 'white', 'save': True, 'breakpoints': None, 'x_ticks': None,\n                                   'crit_point': None, 'label_size': 25, 'yaxis_tick_size': 25, 'xaxis_tick_size': 25,\n                                   'x_label': None, 'filepath': None, 'graph_color': 'black', 'breakpoint_color': 'black'}\n\n    return mdl_p\n</code></pre>"},{"location":"reference/data/support/#data.support.determine_afsc_plot_details","title":"<code>determine_afsc_plot_details(instance, results_chart=False)</code>","text":"<p>Configures AFSC chart display parameters based on the instance settings and chart type.</p> <p>This function adjusts plotting parameters such as which AFSCs to display, label rotation, selected AFSC objective, color schemes, and solution settings. It ensures that the plotting context is consistent with the data variant and chart type requested.</p>"},{"location":"reference/data/support/#data.support.determine_afsc_plot_details--parameters","title":"Parameters","text":"<p>instance : object     The CadetCareerProblem instance containing parameters, solution data, and metadata     used to configure the plot behavior.</p> <p>results_chart : bool, optional     Whether this is a results-oriented plot (e.g., for solution comparison). When True,     solution names, objective validation, and plotting colors/markers are configured.</p>"},{"location":"reference/data/support/#data.support.determine_afsc_plot_details--returns","title":"Returns","text":"<p>dict     The updated <code>mdl_p</code> dictionary containing plot-specific parameters.</p>"},{"location":"reference/data/support/#data.support.determine_afsc_plot_details--behavior","title":"Behavior","text":"<ul> <li>Automatically determines AFSCs to display (<code>afscs_to_show</code>) based on instance context.</li> <li>Decides whether to skip or rotate AFSC x-axis labels, depending on the number of AFSCs and data source.</li> <li>Ensures a valid AFSC and corresponding objective are selected for chart generation.</li> <li>Validates compatibility of the selected chart <code>version</code> with the chosen <code>objective</code>.</li> <li>Limits solution comparisons to a maximum of 4 solutions unless <code>Multi-Criteria Comparison</code> is specified.</li> <li>Assigns distinct colors, markers, and z-order to each solution when <code>results_chart=True</code>.</li> </ul>"},{"location":"reference/data/support/#data.support.determine_afsc_plot_details--raises","title":"Raises","text":"<p>ValueError     If an unsupported objective or chart version is selected, or if too many solutions     are selected for a results plot.</p>"},{"location":"reference/data/support/#data.support.determine_afsc_plot_details--see-also","title":"See Also","text":"<ul> <li><code>determine_afscs_in_image</code></li> </ul> Source code in <code>afccp/data/support.py</code> <pre><code>def determine_afsc_plot_details(instance, results_chart=False):\n    \"\"\"\n    Configures AFSC chart display parameters based on the instance settings and chart type.\n\n    This function adjusts plotting parameters such as which AFSCs to display, label rotation,\n    selected AFSC objective, color schemes, and solution settings. It ensures that the\n    plotting context is consistent with the data variant and chart type requested.\n\n    Parameters\n    ----------\n    instance : object\n        The CadetCareerProblem instance containing parameters, solution data, and metadata\n        used to configure the plot behavior.\n\n    results_chart : bool, optional\n        Whether this is a results-oriented plot (e.g., for solution comparison). When True,\n        solution names, objective validation, and plotting colors/markers are configured.\n\n    Returns\n    -------\n    dict\n        The updated `mdl_p` dictionary containing plot-specific parameters.\n\n    Behavior\n    --------\n    - Automatically determines AFSCs to display (`afscs_to_show`) based on instance context.\n    - Decides whether to skip or rotate AFSC x-axis labels, depending on the number of AFSCs and data source.\n    - Ensures a valid AFSC and corresponding objective are selected for chart generation.\n    - Validates compatibility of the selected chart `version` with the chosen `objective`.\n    - Limits solution comparisons to a maximum of 4 solutions unless `Multi-Criteria Comparison` is specified.\n    - Assigns distinct colors, markers, and z-order to each solution when `results_chart=True`.\n\n    Raises\n    ------\n    ValueError\n        If an unsupported objective or chart version is selected, or if too many solutions\n        are selected for a results plot.\n\n    See Also\n    --------\n    - [`determine_afscs_in_image`](../../../afccp/reference/data/support/#data.support.determine_afscs_in_image)\n    \"\"\"\n\n    # Shorthand\n    p, mdl_p = instance.parameters, instance.mdl_p\n\n    # Get list of AFSCs we're showing\n    mdl_p = determine_afscs_in_image(p, mdl_p)\n\n    # Determine if we are \"skipping\" AFSC labels in the x-axis\n    if mdl_p[\"skip_afscs\"] is None:\n        if instance.data_variant == \"Year\" or \"CTGAN\" in instance.data_name:  # Real AFSCs don't get skipped!\n            mdl_p[\"skip_afscs\"] = False\n        else:\n            if mdl_p[\"M\"] &lt; p['M']:\n                mdl_p[\"skip_afscs\"] = False\n            else:  # \"C2, C4, C6\" could be appropriate\n                mdl_p[\"skip_afscs\"] = True\n\n    # Determine if we are rotating the AFSC labels in the x-axis\n    if mdl_p[\"afsc_rotation\"] is None:\n        if mdl_p[\"skip_afscs\"]:  # If we skip the AFSCs, then we don't rotate them\n            mdl_p[\"afsc_rotation\"] = 0\n        else:\n\n            # We're not skipping the AFSCs, but we could rotate them\n            if instance.data_variant == \"Year\" or \"CTGAN\" in instance.data_name:\n                if mdl_p['M'] &gt; 32:\n                    mdl_p[\"afsc_rotation\"] = 80\n                elif mdl_p[\"M\"] &gt; 18:\n                    mdl_p[\"afsc_rotation\"] = 45\n                else:\n                    mdl_p[\"afsc_rotation\"] = 0\n            else:\n                if mdl_p[\"M\"] &lt; 25:\n                    mdl_p[\"afsc_rotation\"] = 0\n                else:\n                    mdl_p[\"afsc_rotation\"] = 45\n\n    # Get AFSC\n    if mdl_p[\"afsc\"] is None:\n        mdl_p[\"afsc\"] = p['afscs'][0]\n\n    # Get AFSC index\n    j = np.where(p[\"afscs\"] == mdl_p[\"afsc\"])[0][0]\n\n    # Get objective\n    if mdl_p[\"objective\"] is None:\n        k = instance.value_parameters[\"K^A\"][j][0]\n        mdl_p[\"objective\"] = instance.value_parameters['objectives'][k]\n\n    # Determine how high above the bars to put the text\n    if mdl_p['bar_text_offset'] is None:\n        mdl_p['bar_text_offset'] = p['pgl'].max() / 260\n\n    # Figure out which solutions to show, what the colors/markers are going to be, and some error data\n    if results_chart:\n\n        # Only applies to AFSC charts\n        if mdl_p[\"results_graph\"] in [\"Measure\", \"Value\"]:\n            if mdl_p[\"objective\"] not in mdl_p[\"afsc_chart_versions\"]:\n                raise ValueError(\"Objective \" + mdl_p[\"objective\"] +\n                                 \" does not have any charts available\")\n\n            if mdl_p[\"version\"] not in mdl_p[\"afsc_chart_versions\"][mdl_p[\"objective\"]]:\n\n                if not mdl_p[\"compare_solutions\"]:\n                    raise ValueError(\"Objective '\" + mdl_p[\"objective\"] +\n                                     \"' does not have chart version '\" + mdl_p[\"version\"] + \"'.\")\n\n            if mdl_p[\"objective\"] == \"Norm Score\" and mdl_p[\"version\"] == \"quantity_bar_proportion\":\n                if \"afsc_utility\" not in p:\n                    raise ValueError(\"The AFSC Utility matrix is needed for the Norm Score \"\n                                     \"'quantity_bar_proportion' chart. \")\n\n        if mdl_p[\"solution_names\"] is None:\n\n            # Default to the current active solutions\n            mdl_p[\"solution_names\"] = list(instance.solutions.keys())\n            num_solutions = len(mdl_p[\"solution_names\"])  # Number of solutions in dictionary\n\n            # Get number of solutions\n            if mdl_p[\"num_solutions\"] is None:\n                mdl_p[\"num_solutions\"] = num_solutions\n\n            # Can't have more than 4 solutions\n            if num_solutions &gt; 4:\n                mdl_p[\"num_solutions\"] = 4\n                mdl_p[\"solution_names\"] = list(instance.solutions.keys())[:4]\n\n        else:\n            mdl_p[\"num_solutions\"] = len(mdl_p[\"solution_names\"])\n            if mdl_p[\"num_solutions\"] &gt; 4 and mdl_p[\"results_graph\"] != \"Multi-Criteria Comparison\":\n                raise ValueError(\"Error. Can't have more than 4 solutions shown in the results plot.\")\n\n        # Don't need to do this for the Multi-Criteria Comparison chart\n        if mdl_p[\"results_graph\"] != \"Multi-Criteria Comparison\":\n\n            # Load in the colors and markers for each of the solutions\n            mdl_p[\"colors\"], mdl_p[\"markers\"], mdl_p[\"zorder\"] = {}, {}, {}\n            for s, solution in enumerate(mdl_p[\"solution_names\"]):\n                mdl_p[\"colors\"][solution] = mdl_p[\"color_choices\"][s]\n                mdl_p[\"markers\"][solution] = mdl_p[\"marker_choices\"][s]\n                mdl_p[\"zorder\"][solution] = mdl_p[\"zorder_choices\"][s]\n\n            # This only applies to the Merit and USAFA proportion objectives\n            if mdl_p[\"version\"] == \"large_only_bar\":\n                mdl_p[\"all_afscs\"] = False\n            else:\n                mdl_p[\"all_afscs\"] = True\n\n        # Value Parameters\n        if mdl_p[\"vp_name\"] is None:\n            mdl_p[\"vp_name\"] = instance.vp_name\n\n    return mdl_p\n</code></pre>"},{"location":"reference/data/support/#data.support.determine_afscs_in_image","title":"<code>determine_afscs_in_image(p, mdl_p)</code>","text":"<p>Determines which AFSCs were included in the optimization and which should be displayed in the visualization.</p> <p>This function updates the <code>mdl_p</code> dictionary with: - AFSCs that were solved for (<code>afscs_in_solution</code>) - AFSCs that should be shown in the plots (<code>afscs</code>) - The corresponding AFSC indices (<code>J</code>) and total count (<code>M</code>)</p> <p>It handles various ways the user may specify AFSC subsets to visualize, including: - 'All' to show all solved AFSCs - A specific accessions group like 'Rated', 'NRL', or 'USSF' - A commissioning source like 'USAFA', 'ROTC', or 'OTS' - A user-supplied list of AFSC names</p> <p>If <code>eligibility_limit</code> is set, only AFSCs with a number of eligible cadets below that threshold are included.</p>"},{"location":"reference/data/support/#data.support.determine_afscs_in_image--parameters","title":"Parameters","text":"<p>p : dict     The problem parameters, including AFSCs, eligibility mappings, and accessions group information.</p> <p>mdl_p : dict     The model parameters used for chart configuration and visualization. This dictionary is updated in place     with the resolved AFSCs to include in plots.</p>"},{"location":"reference/data/support/#data.support.determine_afscs_in_image--returns","title":"Returns","text":"<p>dict The updated <code>mdl_p</code> dictionary with the following keys updated or added:</p> <ul> <li>'afscs_in_solution': list of AFSCs optimized in the current instance</li> <li>'afscs': list of AFSCs to display in the current visualization</li> <li>'J': numpy array of AFSC indices corresponding to <code>afscs</code></li> <li>'M': integer count of AFSCs in the chart</li> </ul> Source code in <code>afccp/data/support.py</code> <pre><code>def determine_afscs_in_image(p, mdl_p):\n    \"\"\"\n    Determines which AFSCs were included in the optimization and which should be displayed in the visualization.\n\n    This function updates the `mdl_p` dictionary with:\n    - AFSCs that were solved for (`afscs_in_solution`)\n    - AFSCs that should be shown in the plots (`afscs`)\n    - The corresponding AFSC indices (`J`) and total count (`M`)\n\n    It handles various ways the user may specify AFSC subsets to visualize, including:\n    - 'All' to show all solved AFSCs\n    - A specific accessions group like 'Rated', 'NRL', or 'USSF'\n    - A commissioning source like 'USAFA', 'ROTC', or 'OTS'\n    - A user-supplied list of AFSC names\n\n    If `eligibility_limit` is set, only AFSCs with a number of eligible cadets below that threshold are included.\n\n    Parameters\n    ----------\n    p : dict\n        The problem parameters, including AFSCs, eligibility mappings, and accessions group information.\n\n    mdl_p : dict\n        The model parameters used for chart configuration and visualization. This dictionary is updated in place\n        with the resolved AFSCs to include in plots.\n\n    Returns\n    -------\n    dict\n    The updated `mdl_p` dictionary with the following keys updated or added:\n\n    - 'afscs_in_solution': list of AFSCs optimized in the current instance\n    - 'afscs': list of AFSCs to display in the current visualization\n    - 'J': numpy array of AFSC indices corresponding to `afscs`\n    - 'M': integer count of AFSCs in the chart\n    \"\"\"\n\n    # Determine what AFSCs we solved for\n    if mdl_p['afscs_solved_for'] == 'All':\n        mdl_p['afscs_in_solution'] = p['afscs'][:p['M']]  # All AFSCs (without unmatched)\n    else:\n\n        # We solved for some subset of Rated, NRL, or USSF AFSCs\n        mdl_p['afscs_in_solution'] = []\n        for acc_grp in ['Rated', 'NRL', 'USSF']:\n\n            # If this accessions group was specified by the user\n            if acc_grp in mdl_p['afscs_solved_for']:\n\n                # Make sure this is an accessions group for which we have data\n                if acc_grp in p['afscs_acc_grp']:\n\n                    # Add each of these AFSCs to the list\n                    for afsc in p['afscs_acc_grp'][acc_grp]:\n                        mdl_p['afscs_in_solution'].append(afsc)\n\n                # We don't have data on this group\n                else:\n                    raise ValueError(\n                        \"Error. Accessions group '\" + str(acc_grp) + \"' not found in this problem instance.\")\n        mdl_p['afscs_in_solution'] = np.array(mdl_p['afscs_in_solution'])  # Convert to numpy array\n\n    # Now Determine what AFSCs we want to show in this visualization (must be a subset of AFSCs in the solution)\n    if mdl_p['afscs_to_show'] == 'All':\n        mdl_p['afscs'] = mdl_p['afscs_in_solution']  # All AFSCs that we solved for\n\n    elif 'USAFA' in mdl_p['afscs_to_show'] or 'ROTC' in mdl_p['afscs_to_show'] or 'OTS' in mdl_p['afscs_to_show']:\n\n        # Determine which SOC we're trying to show\n        socs = []\n        for soc in p['SOCs']:\n            if soc.upper() in mdl_p['afscs_to_show']:\n                socs.append(soc)\n\n        # Get list of AFSCs that these SOC(s) can be assigned to\n        mdl_p['afscs'] = []\n        for j in p['J']:\n            if p['acc_grp'][j] == 'NRL':\n                mdl_p['afscs'].append(p['afscs'][j])\n            else:\n\n                # Make sure we have cadets from this SOC represented by this AFSC\n                include = False\n                for soc in socs:\n                    if len(np.intersect1d(p['I^E'][j], p[f'I^{soc.upper()}'])) &gt; 0:\n                        include = True\n                        break\n                if include:\n                    mdl_p['afscs'].append(p['afscs'][j])\n        mdl_p['afscs'] = np.array(mdl_p['afscs'])  # Convert to numpy array\n\n    # If the user still supplied a string, we know we're looking for the three accessions groups\n    elif type(mdl_p['afscs_to_show']) == str:\n\n        # Loop through each of the three groups\n        mdl_p['afscs'] = []\n        for acc_grp in ['Rated', 'NRL', 'USSF']:\n\n            # If this accessions group was specified by the user\n            if acc_grp in mdl_p['afscs_to_show']:\n\n                # Make sure this is an accessions group for which we have data\n                if acc_grp in p['afscs_acc_grp']:\n\n                    # Add each of these AFSCs to the list if they were also in the list of AFSCs we solved for\n                    for afsc in p['afscs_acc_grp'][acc_grp]:\n                        if afsc in mdl_p['afscs_in_solution']:\n                            mdl_p['afscs'].append(afsc)\n\n                # We don't have data on this group\n                else:\n                    raise ValueError(\n                        \"Error. Accessions group '\" + str(acc_grp) + \"' not found in this problem instance.\")\n        mdl_p['afscs'] = np.array(mdl_p['afscs'])  # Convert to numpy array\n\n    # The user supplied a list of AFSCs\n    else:\n\n        # Loop through each AFSC in the supplied list and add it if it is also in the list of AFSCs we solved for\n        mdl_p['afscs'] = []\n        for afsc in mdl_p['afscs_to_show']:\n            if afsc in mdl_p['afscs_in_solution']:\n                mdl_p['afscs'].append(afsc)\n        mdl_p['afscs'] = np.array(mdl_p['afscs'])  # Convert to numpy array\n\n    # New set of AFSC indices\n    mdl_p['J'] = np.array([np.where(p['afscs'] == afsc)[0][0] for afsc in mdl_p['afscs']])\n    mdl_p['M'] = len(mdl_p['J'])\n\n    # Determine if we only want to view smaller AFSCs (those with fewer eligible cadets than the specified limit)\n    if mdl_p[\"eligibility_limit\"] is not None:\n\n        # Update set of AFSCs\n        mdl_p['J'] = np.array([j for j in mdl_p['J'] if len(p['I^E'][j]) &lt;= mdl_p[\"eligibility_limit\"]])\n        mdl_p['afscs'] = np.array([p['afscs'][j] for j in mdl_p['J']])\n        mdl_p['M'] = len(mdl_p['J'])\n    else:\n        mdl_p[\"eligibility_limit\"] = p['N']\n\n    return mdl_p\n</code></pre>"},{"location":"reference/data/support/#data.support.pick_most_changed_afscs","title":"<code>pick_most_changed_afscs(instance)</code>","text":"<p>Identifies the AFSCs with the most variation in cadet assignments across solutions.</p> <p>This function analyzes multiple solutions in a \"Multi-Criteria Comparison\" context and selects the AFSCs whose cadet assignments vary the most. For each AFSC, it computes how many cadets are consistently assigned to it across all solutions and compares that to the maximum number of cadets ever assigned to it in any single solution.</p>"},{"location":"reference/data/support/#data.support.pick_most_changed_afscs--parameters","title":"Parameters","text":"<p>instance : object An instance of the problem containing:</p> <ul> <li><code>parameters</code>: a dictionary of static problem data</li> <li><code>solutions</code>: a dictionary of named solution outputs</li> <li><code>mdl_p</code>: model parameters including 'solution_names' and 'num_afscs_to_compare'</li> </ul>"},{"location":"reference/data/support/#data.support.pick_most_changed_afscs--returns","title":"Returns","text":"<p>np.ndarray     An array of AFSC names (strings) corresponding to the most changed AFSCs,     ranked by variability in cadet assignments.</p>"},{"location":"reference/data/support/#data.support.pick_most_changed_afscs--examples","title":"Examples","text":"<pre><code>afscs = pick_most_changed_afscs(instance)\nprint(\"Top variable AFSCs across solutions:\", afscs)\n</code></pre> Source code in <code>afccp/data/support.py</code> <pre><code>def pick_most_changed_afscs(instance):\n    \"\"\"\n    Identifies the AFSCs with the most variation in cadet assignments across solutions.\n\n    This function analyzes multiple solutions in a \"Multi-Criteria Comparison\" context and selects\n    the AFSCs whose cadet assignments vary the most. For each AFSC, it computes how many cadets\n    are consistently assigned to it across all solutions and compares that to the maximum number of\n    cadets ever assigned to it in any single solution.\n\n    Parameters\n    ----------\n    instance : object\n    An instance of the problem containing:\n\n    - `parameters`: a dictionary of static problem data\n    - `solutions`: a dictionary of named solution outputs\n    - `mdl_p`: model parameters including 'solution_names' and 'num_afscs_to_compare'\n\n    Returns\n    -------\n    np.ndarray\n        An array of AFSC names (strings) corresponding to the most changed AFSCs,\n        ranked by variability in cadet assignments.\n\n    Examples\n    --------\n    ```python\n    afscs = pick_most_changed_afscs(instance)\n    print(\"Top variable AFSCs across solutions:\", afscs)\n    ```\n    \"\"\"\n\n    # Get necessary info\n    p = instance.parameters\n    assigned_cadets = {}\n    max_assigned = np.zeros(p[\"M\"])\n    solution_names = instance.mdl_p[\"solution_names\"]\n\n    # Loop through each solution to get the max number of cadets assigned to each AFSC across each solution\n    for solution_name in solution_names:\n        solution = instance.solutions[solution_name]\n        assigned_cadets[solution_name] = {j: np.where(solution['j_array'] == j)[0] for j in p[\"J\"]}\n        num_assigned = np.array([len(assigned_cadets[solution_name][j]) for j in p[\"J\"]])\n        max_assigned = np.array([max(max_assigned[j], num_assigned[j]) for j in p[\"J\"]])\n\n    # Loop through each AFSC to get the number of cadets shared across each solution for each AFSC\n    shared_cadet_count = np.zeros(p[\"M\"])\n    for j in p[\"J\"]:\n\n        # Pick the first solution as a baseline\n        baseline_cadets = assigned_cadets[solution_names[0]][j]\n\n        # Loop through each cadet assigned to this AFSC in the \"baseline\" solution\n        for i in baseline_cadets:\n\n            # Check if the cadet is assigned to this AFSC in all solutions\n            cadet_in_each_solution = True\n            for solution_name in solution_names:\n                if i not in assigned_cadets[solution_name][j]:\n                    cadet_in_each_solution = False\n                    break\n\n            # If the cadet is assigned in all solutions, we add one to the shared count\n            if cadet_in_each_solution:\n                shared_cadet_count[j] += 1\n\n    # The difference between the maximum number of cadets assigned to a given AFSC across all solutions and the number\n    # of cadets that are common to said AFSC across all solutions is our \"Delta\"\n    delta_afsc = max_assigned - shared_cadet_count\n\n    # Return the AFSCs that change the most\n    indices = np.argsort(delta_afsc)[::-1]\n    afscs = p[\"afsc_vector\"][indices][:instance.mdl_p[\"num_afscs_to_compare\"]]\n    return afscs\n</code></pre>"},{"location":"reference/data/support/#data.support.cip_to_qual_tiers","title":"<code>cip_to_qual_tiers(afscs, cip1, cip2=None, cip3=None, business_hours=None, true_tiers=True)</code>","text":"<p>Generate qualification tiers for cadets based on CIP codes and AFSCs. Current as of Oct '2024</p> <p>This function determines the qualification tiers (e.g., M1, D2, P3, I4) for a set of cadets based on the Classification of Instructional Programs (CIP) codes associated with their degrees. It evaluates the suitability of each cadet for each Air Force Specialty Code (AFSC) using official AFOCD guidance and updates from career field managers.</p> <p>If multiple CIP sources are available (e.g., primary, secondary, tertiary degrees), the function returns the best qualifying tier across all provided sources.</p>"},{"location":"reference/data/support/#data.support.cip_to_qual_tiers--parameters","title":"Parameters","text":"<ul> <li>afscs : list of str     List of Air Force Specialty Codes (AFSCs) to evaluate against cadet degree qualifications.</li> <li>cip1 : numpy.ndarray     Primary degree CIP codes for each cadet. Expected to be a string or numeric array of length N.</li> <li>cip2 : numpy.ndarray, optional     Secondary degree CIP codes for each cadet (if available).</li> <li>cip3 : numpy.ndarray, optional     Tertiary or external CIP codes (e.g., scraped from catalog websites or manually added).</li> <li>business_hours : numpy.ndarray, optional     Number of business-related credit hours per cadet. Used for disambiguation in certain AFSCs (e.g., 63A).</li> <li>true_tiers : bool, default=True     If True, applies refined qualification tiers based on updates from CFMs and AFOCD (as of June 2023 and later).</li> </ul>"},{"location":"reference/data/support/#data.support.cip_to_qual_tiers--returns","title":"Returns","text":"<ul> <li>numpy.ndarray     A matrix of shape (N, M), where each entry is a qualification tier string (e.g., 'M1', 'D2', 'P3', 'I4') for     cadet i and AFSC j.</li> </ul>"},{"location":"reference/data/support/#data.support.cip_to_qual_tiers--examples","title":"Examples","text":"<pre><code>afscs = ['17X', '62EXE', '21R']\ncip1 = np.array(['110102', '141001', '520409'])\nqual_matrix = cip_to_qual_tiers(afscs, cip1)\nprint(qual_matrix)\n</code></pre>"},{"location":"reference/data/support/#data.support.cip_to_qual_tiers--details","title":"Details","text":"<ul> <li> <p>Qualification tiers follow AFOCD conventions:</p> <ul> <li>M = Mandatory</li> <li>D = Desired</li> <li>P = Permitted</li> <li>I = Ineligible</li> <li>The second number (e.g., 1 in 'M1') indicates how strong the tier is within that category (1 = best).</li> <li>If multiple CIP sources are provided, the best (lowest) tier number is selected for each cadet\u2013AFSC pair.</li> <li>Covers dozens of AFSCs and handles specific CIP-to-AFSC mappings with multiple tiers per AFSC.</li> </ul> </li> </ul>"},{"location":"reference/data/support/#data.support.cip_to_qual_tiers--notes","title":"Notes","text":"<ul> <li>Includes recent updates from AFOCD Oct '24 and refinements from Air Force CFMs.</li> <li>Used in the cadet-career field qualification model to help filter and prioritize match options.</li> </ul> Source code in <code>afccp/data/support.py</code> <pre><code>def cip_to_qual_tiers(afscs, cip1, cip2=None, cip3=None, business_hours=None, true_tiers=True):\n    \"\"\"\n    Generate qualification tiers for cadets based on CIP codes and AFSCs. Current as of Oct '2024\n\n    This function determines the qualification tiers (e.g., M1, D2, P3, I4) for a set of cadets based on the\n    Classification of Instructional Programs (CIP) codes associated with their degrees. It evaluates the suitability\n    of each cadet for each Air Force Specialty Code (AFSC) using official AFOCD guidance and updates from\n    career field managers.\n\n    If multiple CIP sources are available (e.g., primary, secondary, tertiary degrees), the function returns the\n    best qualifying tier across all provided sources.\n\n    Parameters\n    ----------\n    - afscs : list of str\n        List of Air Force Specialty Codes (AFSCs) to evaluate against cadet degree qualifications.\n    - cip1 : numpy.ndarray\n        Primary degree CIP codes for each cadet. Expected to be a string or numeric array of length N.\n    - cip2 : numpy.ndarray, optional\n        Secondary degree CIP codes for each cadet (if available).\n    - cip3 : numpy.ndarray, optional\n        Tertiary or external CIP codes (e.g., scraped from catalog websites or manually added).\n    - business_hours : numpy.ndarray, optional\n        Number of business-related credit hours per cadet. Used for disambiguation in certain AFSCs (e.g., 63A).\n    - true_tiers : bool, default=True\n        If True, applies refined qualification tiers based on updates from CFMs and AFOCD (as of June 2023 and later).\n\n    Returns\n    -------\n    - numpy.ndarray\n        A matrix of shape (N, M), where each entry is a qualification tier string (e.g., 'M1', 'D2', 'P3', 'I4') for\n        cadet i and AFSC j.\n\n    Examples\n    --------\n    ```python\n    afscs = ['17X', '62EXE', '21R']\n    cip1 = np.array(['110102', '141001', '520409'])\n    qual_matrix = cip_to_qual_tiers(afscs, cip1)\n    print(qual_matrix)\n    ```\n\n    Details\n    -------\n    - Qualification tiers follow AFOCD conventions:\n\n        - M = Mandatory\n        - D = Desired\n        - P = Permitted\n        - I = Ineligible\n    - The second number (e.g., 1 in 'M1') indicates how strong the tier is within that category (1 = best).\n    - If multiple CIP sources are provided, the best (lowest) tier number is selected for each cadet\u2013AFSC pair.\n    - Covers dozens of AFSCs and handles specific CIP-to-AFSC mappings with multiple tiers per AFSC.\n\n    Notes\n    -----\n    - Includes recent updates from AFOCD Oct '24 and refinements from Air Force CFMs.\n    - Used in the cadet-career field qualification model to help filter and prioritize match options.\n    \"\"\"\n\n    # AFOCD CLASSIFICATION\n    N = len(cip1)  # Number of Cadets\n    M = len(afscs)  # Number of AFSCs we're building the qual matrix for\n\n    # Dictionary of CIP codes\n    cips = {1: cip1, 2: cip2, 3: cip3}\n\n    # List of CIP degrees that are not empty\n    degrees = []\n    for d in cips:\n        if cips[d] is not None:\n            degrees.append(d)\n\n    # Initialize qual dictionary\n    qual = {}\n\n    # Loop through both sets of degrees (if applicable)\n    for d in degrees:\n\n        # Initialize qual matrix (for this set of degrees)\n        qual[d] = np.array([[\"I5\" for _ in range(M)] for _ in range(N)])\n\n        # Loop through each cadet and AFSC pair\n        for i in range(N):\n            cip = str(cips[d][i])\n            cip = \"0\" * (6 - len(cip)) + cip\n            for j, afsc in enumerate(afscs):\n\n                # Rated Career Fields\n                if afsc in [\"11U\", \"11XX\", \"12XX\", \"13B\", \"18X\", \"92T0\", \"92T1\", \"92T2\", \"92T3\",\n                            \"11XX_R\", \"11XX_U\", \"11XX_O\", \"USSF\", \"USSF_U\", \"USSF_R\"]:\n                    qual[d][i, j] = \"P1\"\n\n                # Aerospace Physiologist\n                elif afsc == '13H':  # Proportions/Degrees Updated Oct '23\n                    if cip in ['302701', '260912', '310505', '260908', '260707', '260403']:\n                        qual[d][i, j] = 'M1'\n                    elif cip in ['290402', '261501', '422813'] or cip[:4] in ['2609']:\n                        qual[d][i, j] = 'P2'\n                    else:\n                        qual[d][i, j] = 'I3'\n\n                # Airfield Ops\n                elif afsc == '13M':  # Proportions Updated Oct '23\n                    if cip == '290402' or cip[:4] == '4901':\n                        qual[d][i, j] = 'D1'\n                    elif cip[:4] in ['5201', '5202', '5206', '5207', '5211', '5212', '5213',\n                                     '5214', '5218', '5219', '5220']:\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'P3'\n\n                # Nuclear and Missile Operations\n                elif afsc == '13N':  # Updated Oct '23\n                    qual[d][i, j] = 'P1'\n\n                # Space Operations\n                elif afsc in ['13S', '13S1S']:\n                    m_list4 = ['1402', '1410', '1419', '1427', '4002']\n                    d_list4 = ['1101', '1102', '1104', '1105', '1107', '1108', '1109', '1110', '1404', '1406', '1407',\n                               '1408', '1409', '1411', '1412', '1413', '1414', '1418', '1420', '1423', '1432', '1435',\n                               '1436', '1437', '1438', '1439', '1441', '1442', '1444', '3006', '3008', '3030', '4008']\n                    d_list6 = ['140101', '290203', '290204', '290205', '290207', '290301', '290302', '290304']\n                    if cip[:4] in m_list4 or cip[:2] == '27' or cip == '290305':\n                        qual[d][i, j] = 'M1'\n                    elif cip[:4] in d_list4 or cip in d_list6:\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'P3'\n\n                # Information Operations\n                elif afsc == '14F':\n                    m_list4 = ['3017', '4201', '4227', '4511']\n                    d_list4 = ['5214', '3023', '3026']\n                    p_list4 = ['4509', '4502', '3025', '0901']\n                    if cip[:4] in m_list4:\n                        qual[d][i, j] = 'M1'\n                    elif cip[:4] in d_list4 or cip in [\"090902\", \"090903\", \"090907\"]:\n                        qual[d][i, j] = 'D2'\n                    elif cip[:4] in p_list4:\n                        qual[d][i, j] = 'P3'\n                    else:\n                        qual[d][i, j] = 'I4'\n\n                # Intelligence\n                elif afsc in ['14N', '14N1S']:\n                    m_list2 = ['05', '16', '22', '24', '28', '29', '45', '54']\n                    d_list2 = ['13', '09', '23', '28', '29', '30', '35', '38', '42', '43', '52']\n                    if cip[:2] in ['11', '14', '27', '40'] or cip == '307001':\n                        qual[d][i, j] = 'M1'\n                    elif cip[:2] in m_list2 or cip == '301701':\n                        qual[d][i, j] = 'M2'\n                    elif cip[:2] in d_list2 or cip == '490101':\n                        qual[d][i, j] = 'D3'\n                    else:\n                        qual[d][i, j] = 'P4'\n\n                # Operations Research Analyst\n                elif afsc in ['15A', '61A']:\n                    m_list4 = ['1437', '1435', '3070', '3030', '3008']\n                    if cip[:4] in m_list4 or cip[:2] == '27' or cip == '110102':\n                        qual[d][i, j] = 'M1'\n                    elif cip in ['110804', '450603'] or cip[:4] in ['1427', '1107', '3039', '3049']:\n                        qual[d][i, j] = 'D2'\n                    elif (cip[:2] == '14' and cip != '140102') or cip[:4] in ['4008', '4506', '2611', '3071', '5213']:\n                        qual[d][i, j] = 'P3'\n                    else:\n                        qual[d][i, j] = 'I4'\n\n                # Weather and Environmental Sciences (Current a/o Apr '24 AFOCD)\n                elif afsc == '15W':\n                    if cip[:4] == '4004':\n                        qual[d][i, j] = 'M1'\n                    elif cip in ['270301', '270303', '270304', '303501', '303001', '140802',\n                                 '303801', '141201', '141301', '400601', '400605', '400607', '400801', '400805',\n                                 '400806', '400807', '400809']:\n                        qual[d][i, j] = 'P2'\n                    elif cip[:2] in ['40'] or cip in ['040999', '030104', '110102', '110101', '110803', '110201',\n                                                      '110701', '110802', '110104', '110804']:\n                        qual[d][i, j] = 'P3'\n\n                    else:\n                        qual[d][i, j] = 'I4'\n\n                # Cyberspace Operations\n                elif afsc in ['17D', '17S', '17X', '17S1S']:\n                    m_list6 = ['150303', '151202', '290207', '303001', '307001', '270103', '270303', '270304']\n                    d_list4 = ['1503', '1504', '1508', '1512', '1514', '4008', '4005']\n                    if cip[:4] in ['3008', '3016', '5212'] or cip in m_list6 or \\\n                            (cip[:2] == '11' and cip[:4] not in ['1103', '1106']) or (\n                            cip[:2] == '14' and cip != '140102'):\n                        qual[d][i, j] = 'M1'\n                    elif cip[:4] in d_list4 or cip[:2] == '27':\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'P3'\n\n                # Aircraft Maintenance\n                elif afsc == '21A':  # Proportions Updated Oct '23\n                    d_list4 = ['5202', '5206', '1101', '1102', '1103', '1104', '1107', '1110', '5212']\n                    if cip[:2] == '14':\n                        qual[d][i, j] = 'D1'\n                    elif cip[:4] in d_list4 or cip[:2] == '40' or cip in ['151501', '520409', '490104', '490101']:\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'P3'\n\n                # Munitions and Missile Maintenance\n                elif afsc == '21M':  # Proportions Updated Oct '23\n                    d_list4 = ['1107', '1101', '1110', '5202', '5206', '5213']\n                    d_list2 = ['27', '40']\n\n                    # Added \"Data Processing\" (no CIPs in AFOCD, and others are already captured in other tiers)\n                    d_list6 = ['290407', '290408', '151501', '520409', \"110301\"]\n                    if cip[:2] == \"14\":\n                        qual[d][i, j] = 'D1'\n                    elif cip[:2] in d_list2 or cip[:4] in d_list4 or cip in d_list6:\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'P3'\n\n                # Logistics Readiness: Conversations w/CFMs changed this!\n                elif afsc == '21R':\n                    if true_tiers:  # More accurate than current AFOCD a/o Oct '23\n                        cip_list = ['520203', '520409', '142501', '490199', '520209', '499999', '521001', '520201',\n                                    '140101', '143501', '280799', '450601', '520601', '520304', '520899', '520213',\n                                    '520211', '143701', '110802']\n                        if cip in cip_list:\n                            qual[d][i, j] = 'D1'\n                        else:\n                            qual[d][i, j] = 'P2'\n                    else:\n                        d_list4 = ['1101', '1102', '1103', '1104', '1107', '1110', '4506', '5202', '5203', '5206',\n                                   '5208']\n                        d_list6 = ['151501', '490101', '520409']\n\n                        # Added Ops Research and Data Processing (no CIPs in AFOCD)\n                        d_list6_add = ['143701', '110301']\n                        if cip[:4] in ['1425', '1407']:\n                            qual[d][i, j] = 'D1'\n                        elif cip[:4] in d_list4 or cip in d_list6 or cip in d_list6_add or cip[:3] == \"521\":\n                            qual[d][i, j] = 'D2'\n                        else:\n                            qual[d][i, j] = 'P3'\n\n                # Security Forces\n                elif afsc == '31P':  # Updated Oct '23\n                    qual[d][i, j] = 'P1'\n\n                # Civil Engineering: Architect/Architectural Engineer\n                elif afsc == '32EXA':\n                    if cip[:4] == '0402' or cip in ['140401']:  # Sometimes 402010 is included\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Civil Engineering: Civil Engineer\n                elif afsc == '32EXC':\n                    if cip[:4] == '1408':\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Civil Engineering: Electrical Engineer  *added 1447 per CFM conversation 2 Jun '23\n                elif afsc == '32EXE':\n                    if cip[:4] in ['1410', '1447']:\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Civil Engineering: Mechanical Engineer\n                elif afsc == '32EXF':\n                    if cip == '141901':\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Civil Engineering: General Engineer  *Updated AFOCD a/o 30 Apr '23 w/further adjustments a/o 2 Jun '23\n                elif afsc == '32EXG':\n                    if cip[:4] in ['1408', '1410'] or cip in ['140401', '141401', '141901', '143301', '143501',\n                                                              '144701']:\n                        qual[d][i, j] = 'M1'\n                    elif cip in [\"140701\"] or cip[:4] in [\"1405\", \"1425\", \"1402\", \"5220\", '1510']:  # added 1510\n                        qual[d][i, j] = 'D2'  # FY23 added a desired tier to 32EXG!\n                    else:\n                        qual[d][i, j] = 'I3'\n\n                # Civil Engineering: Environmental Engineer\n                elif afsc == '32EXJ':\n                    if cip == '141401':\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Public Affairs\n                elif afsc == '35P':\n                    if cip[:2] == '09':\n                        qual[d][i, j] = 'M1'\n                    elif cip[:4] in ['2313', '4509', '4510', '5214'] or cip[:2] == '42':\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'P3'\n\n                # Force Support\n                elif afsc in ['38F', '38P']:  # Updated Oct '24\n                    d_list4 = ['4404', '5202', '5210', '5214']\n                    if cip[:4] == ['4506', '3017'] or cip in ['143701', '520213']:\n                        qual[d][i, j] = 'M1'\n                    elif cip[:2] == ['13', '27', '42'] or cip[:4] in d_list4 or cip in ['301701', '450901',\n                                                                                        '520304', '520901']:\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'P3'\n\n                # Old 14F (Information Operations)\n                elif afsc == '61B':\n                    m_list4 = ['3017', '4502', '4511', '4513', '4514', '4501']\n                    if cip[:2] == '42' or cip[:4] in m_list4 or cip in ['450501', '451201']:\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Chemist/Nuclear Chemist\n                elif afsc == '61C':\n                    d_list6 = ['140601', '141801', '143201', '144301', '144401', '260299']\n                    if cip[:4] in ['1407', '4005'] or cip in ['260202', '260205']:\n                        qual[d][i, j] = 'M1'\n                    elif cip in d_list6 or cip[:5] == '26021' or cip[:4] == '4010':\n                        qual[d][i, j] = 'D2'\n                    elif cip in ['140501', '142001', '142501', '144501']:\n                        qual[d][i, j] = 'P3'\n                    else:\n                        qual[d][i, j] = 'I4'\n\n                # Physicist/Nuclear Engineer\n                elif afsc == '61D':\n                    if cip[:4] in ['1412', '1423', '4002', '4008']:\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Developmental Engineering: Aeronautical Engineer\n                elif afsc in ['62EXA', '62E1A1S']:\n                    if cip[:4] == '1402':\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Developmental Engineering: Astronautical Engineer\n                elif afsc in ['62EXB', '62E1B1S']:\n                    if cip[:4] == '1402':\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Developmental Engineering: Computer Systems Engineer\n                elif afsc in ['62EXC', '62E1C1S']:  # Updated Oct '24\n                    if cip[:4] == '1409':\n                        qual[d][i, j] = 'M1'\n                    elif cip[:4] == '1101' or cip == '110701':\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'I3'\n\n                # Developmental Engineering: Electrical/Electronic Engineer\n                elif afsc in ['62EXE', '62E1E1S']:\n                    if cip[:4] in ['1410', '1447']:\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Developmental Engineering: Flight Test Engineer\n                elif afsc == '62EXF':\n                    if cip[:2] in ['27', '40'] or (cip[:2] == '14' and cip != '140102'):\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Developmental Engineering: Project/General Engineer\n                elif afsc in ['62EXG', '62E1G1S']:  # Updated Oct '24\n                    if cip[:2] == '14' and cip not in ['140102', '141001', '144701'] and cip[:4] not in [\"1437\",\n                                                                                                         \"1408\"]:\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Developmental Engineering: Mechanical Engineer\n                elif afsc in ['62EXH', '62E1H1S']:  # Updated Oct '24\n                    if cip[:4] == '1419':  # and cip != '141901': (Is this a mistake? 141901 seems to be popular among\n                        qual[d][i, j] = 'M1'  # cadets that want this AFSC)\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Developmental Engineering: Systems/Human Factors Engineer\n                elif afsc in ['62EXI', '62EXS', '62E1I1S']:\n                    if cip[:4] in ['1427', '1435']:\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Acquisition Manager\n                elif afsc in ['63A', '63A1S']:\n                    if cip[:2] in ['14', '40']:\n                        qual[d][i, j] = 'M1'\n                    elif cip[:2] in ['11', '27'] or cip[:4] == '4506' or (cip[:2] == '52' and cip[:4] != '5204'):\n                        qual[d][i, j] = 'D2'\n                    else:\n                        if business_hours is not None:\n                            if business_hours[i] &gt;= 24:\n                                qual[d][i, j] = 'P3'\n                            else:\n                                qual[d][i, j] = 'I4'\n                        else:\n                            qual[d][i, j] = 'P3'\n\n                # Contracting\n                elif afsc == '64P':\n                    d_list2 = ['28', '44', '54', '16', '23', '05', '42']\n                    if cip[:2] == \"52\":\n                        qual[d][i, j] = 'D1'\n                    elif cip[:2] in ['14', '15', '26', '27', '29', '40', '41']:\n                        qual[d][i, j] = 'D2'\n                    elif cip[:2] in d_list2 or (cip[:2] == '45' and cip[:4] != '4506') or \\\n                            cip[:4] in ['2200', '2202'] or cip == '220101':\n                        qual[d][i, j] = 'D3'\n                    else:\n                        qual[d][i, j] = 'P4'\n\n                # Financial Management\n                elif afsc == '65F':\n                    if cip[:4] in ['4506', '5203', '5206', '5213', '5208']:\n                        qual[d][i, j] = 'D1'\n                    elif cip[:2] in ['27', '52', '14']:\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'P3'\n\n                # This shouldn't happen... but here's some error checking!\n                else:\n                    raise ValueError(\"Error. AFSC '\" + str(afsc) + \"' not a valid AFSC that this code recognizes.\")\n\n    # If no other CIP list is specified, we just take the qual matrix from the first degrees\n    if len(degrees) == 1:\n        qual_matrix = copy.deepcopy(qual[1])\n\n    # If CIP2 is specified, we take the highest tier that the cadet qualifies for\n    else:\n        qual_matrix = np.array([[\"I5\" for _ in range(M)] for _ in range(N)])\n\n        # Loop though each cadet and AFSC pair\n        for i in range(N):\n            for j in range(M):\n\n                # Get degree tier qualifications from both degrees\n                qual_1 = qual[1][i, j]\n                qual_2 = qual[2][i, j]\n\n                if cip3 is not None:\n                    qual_3 = qual[3][i, j]\n                else:\n                    qual_3 = \"I9\"  # Dummy value\n\n                # Determine which qualification is best\n                if int(qual_1[1]) &lt; int(qual_2[1]):  # D1 beats D2\n                    if int(qual_1[1]) &lt; int(qual_3[1]): # D1 beats D3\n                        qual_matrix[i, j] = qual_1  # Qual 1 wins!\n                    else:  # D3 beats D1\n                        qual_matrix[i, j] = qual_3  # Qual 3 wins!\n                else:  # D2 beats D1\n                    if int(qual_2[1]) &lt; int(qual_3[1]):  # D2 beats D3\n                        qual_matrix[i, j] = qual_2  # Qual 2 wins!\n                    else:  # D3 beats D2\n                        qual_matrix[i, j] = qual_3  # Qual 3 wins!\n\n    return qual_matrix\n</code></pre>"},{"location":"reference/data/values/","title":"Values","text":""},{"location":"reference/data/values/#data.values","title":"<code>data.values</code>","text":""},{"location":"reference/data/values/#data.values--value-parameter-processing-module-for-afccp","title":"Value Parameter Processing Module for AFCCP","text":"<p>This module manages the construction, manipulation, transformation, and comparison of value parameters for the <code>CadetCareerProblem</code> object. Value parameters define the objectives, weights, and nonlinear utility functions used to evaluate cadet-to-AFSC assignments under Value-Focused Thinking (VFT) and Goal Programming (GP) frameworks.</p> <p>The functions in this module enable dynamic adjustment of value preferences, conversion between modeling formats, and consistent export or validation of weight/value configurations for modeling, diagnostics, or user inspection.</p>"},{"location":"reference/data/values/#data.values--main-functionalities","title":"Main Functionalities","text":"<ul> <li>Build and scale value functions based on cadet and AFSC preferences</li> <li>Generate AFOCD-based weights and objectives using tiered education alignment</li> <li>Update and regenerate weights and utility functions after changes</li> <li>Condense redundant value function breakpoints for speed and clarity</li> <li>Translate between VFT and Goal Programming formats (e.g., for GP solver compatibility)</li> <li>Export value parameters to Excel for audit and transparency</li> <li>Compare multiple value parameter sets for consistency diagnostics</li> </ul>"},{"location":"reference/data/values/#data.values--key-concepts","title":"Key Concepts","text":"<ul> <li>Value Parameters: Contain objective weights, utility functions, and constraints used in the optimization.</li> <li>Breakpoints: Discrete x/y points used to approximate nonlinear value functions.</li> <li>Objective Types: Tier-based education goals, demographic balancing, quota constraints, cadet merit, etc.</li> <li>Constraint Types: Enforce structural bounds (e.g., minimum quotas, tier alignment).</li> <li>AFOCD Alignment: Relates cadet degrees (via CIP codes) to tiered AFSC requirements.</li> <li>Merit-Based Assignment: Rewards cadet-AFSC matches according to percentile rank.</li> </ul>"},{"location":"reference/data/values/#data.values--available-functions","title":"Available Functions","text":"<ul> <li><code>update_value_and_weight_functions</code> \u2014 Rebuilds weight/value functions after updates</li> <li><code>value_function_builder</code> \u2014 Generates piecewise exponential approximations of utility functions</li> <li><code>generate_afocd_value_parameters</code> \u2014 Applies AFOCD rules to populate objective targets and constraints</li> <li><code>model_value_parameters_to_defaults</code> \u2014 Exports value parameter set to Excel for auditing</li> <li><code>compare_value_parameters</code> \u2014 Compares two value parameter dictionaries for equivalency</li> <li><code>condense_value_functions</code> \u2014 Removes redundant zeros in piecewise value functions</li> <li><code>translate_vft_to_gp_parameters</code> \u2014 Converts VFT model structure to Goal Programming inputs</li> </ul>"},{"location":"reference/data/values/#data.values.value_parameters_sets_additions","title":"<code>value_parameters_sets_additions(parameters, value_parameters, printing=False)</code>","text":"<p>Enhances the <code>value_parameters</code> dictionary by adding derived sets and metadata required for optimization and constraint evaluation in the cadet-AFSC matching problem.</p> <p>This function precomputes various subset structures (e.g., AFSCs relevant to specific objectives, cadets with utility constraints, constrained objectives, etc.) to avoid unnecessary computation during model solving and value function evaluations.</p>"},{"location":"reference/data/values/#data.values.value_parameters_sets_additions--parameters","title":"Parameters","text":"<p>parameters : dict     Dictionary of fixed model parameters (cadets, AFSCs, quotas, preferences, etc.). value_parameters : dict     Dictionary of value model parameters including objectives, weights, constraints, and utility functions. printing : bool, optional     Whether to print diagnostic output during execution. Default is False.</p>"},{"location":"reference/data/values/#data.values.value_parameters_sets_additions--returns","title":"Returns","text":"<p>dict     Updated <code>value_parameters</code> dictionary with added sets and utility matrices, including:</p> <ul> <li> <p><code>K</code> : np.ndarray   Indices for all objectives</p> </li> <li> <p><code>K^A[j]</code> : dict[int \u2192 np.ndarray]   Objectives with non-zero weights for AFSC <code>j</code></p> </li> <li> <p><code>K^C[j]</code> : dict[int \u2192 np.ndarray]   Constrained objectives (non-zero constraint types) for AFSC <code>j</code></p> </li> <li> <p><code>J^A[k]</code> : dict[int \u2192 np.ndarray]   AFSCs that include objective <code>k</code></p> </li> <li> <p><code>I^C</code> : np.ndarray   Cadets with value constraints (non-zero minimum value)</p> </li> <li> <p><code>J^Top_Choice[i]</code> : dict[int \u2192 np.ndarray]   Preferred AFSCs for cadet <code>i</code> that satisfy the cadet's value constraint</p> </li> <li> <p><code>J^C</code> : np.ndarray   AFSCs with value constraints</p> </li> <li> <p><code>r[j, k]</code> : np.ndarray   Number of breakpoints in the value function for AFSC <code>j</code> and objective <code>k</code></p> </li> <li> <p><code>L[j][k]</code> : np.ndarray   Indices for breakpoints in the value function</p> </li> <li> <p><code>objective_min</code>, <code>objective_max</code> : np.ndarray   Lower and upper bounds on constrained objectives by AFSC</p> </li> <li> <p><code>global_utility</code> : np.ndarray   Combined cadet and AFSC utility used for global utility optimization (if available)</p> </li> </ul>"},{"location":"reference/data/values/#data.values.value_parameters_sets_additions--notes","title":"Notes","text":"<ul> <li>The function corrects legacy constraint types (3 and 4 \u2192 1 and 2 respectively).</li> <li>It supports objectives tied to cadet demographics such as <code>USAFA Proportion</code>, and <code>Tier</code> objectives.</li> <li>The function also scales and rounds weights for numerical stability.</li> </ul> Source code in <code>afccp/data/values.py</code> <pre><code>def value_parameters_sets_additions(parameters, value_parameters, printing=False):\n    \"\"\"\n    Enhances the `value_parameters` dictionary by adding derived sets and metadata required\n    for optimization and constraint evaluation in the cadet-AFSC matching problem.\n\n    This function precomputes various subset structures (e.g., AFSCs relevant to specific objectives,\n    cadets with utility constraints, constrained objectives, etc.) to avoid unnecessary computation\n    during model solving and value function evaluations.\n\n    Parameters\n    ----------\n    parameters : dict\n        Dictionary of fixed model parameters (cadets, AFSCs, quotas, preferences, etc.).\n    value_parameters : dict\n        Dictionary of value model parameters including objectives, weights, constraints, and utility functions.\n    printing : bool, optional\n        Whether to print diagnostic output during execution. Default is False.\n\n    Returns\n    -------\n    dict\n        Updated `value_parameters` dictionary with added sets and utility matrices, including:\n\n    - `K` : np.ndarray\n      Indices for all objectives\n\n    - `K^A[j]` : dict[int \u2192 np.ndarray]\n      Objectives with non-zero weights for AFSC `j`\n\n    - `K^C[j]` : dict[int \u2192 np.ndarray]\n      Constrained objectives (non-zero constraint types) for AFSC `j`\n\n    - `J^A[k]` : dict[int \u2192 np.ndarray]\n      AFSCs that include objective `k`\n\n    - `I^C` : np.ndarray\n      Cadets with value constraints (non-zero minimum value)\n\n    - `J^Top_Choice[i]` : dict[int \u2192 np.ndarray]\n      Preferred AFSCs for cadet `i` that satisfy the cadet's value constraint\n\n    - `J^C` : np.ndarray\n      AFSCs with value constraints\n\n    - `r[j, k]` : np.ndarray\n      Number of breakpoints in the value function for AFSC `j` and objective `k`\n\n    - `L[j][k]` : np.ndarray\n      Indices for breakpoints in the value function\n\n    - `objective_min`, `objective_max` : np.ndarray\n      Lower and upper bounds on constrained objectives by AFSC\n\n    - `global_utility` : np.ndarray\n      Combined cadet and AFSC utility used for global utility optimization (if available)\n\n    Notes\n    -----\n    - The function corrects legacy constraint types (3 and 4 \u2192 1 and 2 respectively).\n    - It supports objectives tied to cadet demographics such as `USAFA Proportion`, and `Tier` objectives.\n    - The function also scales and rounds weights for numerical stability.\n    \"\"\"\n    if printing:\n        print('Adding AFSC and objective subsets to value parameters...')\n\n    # Shorthand\n    p, vp = parameters, value_parameters\n\n    # Temporary manual adjustment of constraint_type matrix\n    indices_3 = np.where(vp['constraint_type'] == 3)\n    indices_4 = np.where(vp['constraint_type'] == 4)\n    vp['constraint_type'][indices_3] = 1\n    vp['constraint_type'][indices_4] = 2\n\n    # Set of Objectives\n    vp['K'] = np.arange(vp[\"O\"])\n\n    # Set of objectives for each AFSC\n    vp['K^A'] = {}  # objectives\n    vp['K^C'] = {}  # constrained objectives\n    for j in p[\"J\"]:\n        vp['K^A'][j] = np.where(vp['objective_weight'][j, :] &gt; 0)[0].astype(int)\n        vp['K^C'][j] = np.where(vp['constraint_type'][j, :] &gt; 0)[0].astype(int)\n\n    # 5% of total USAFA graduating class set\n    vp[\"J^USAFA\"] = None\n\n    # Add the AFSC indices to the set\n    if \"USAFA-Constrained AFSCs\" in vp:\n        if \",\" in vp[\"USAFA-Constrained AFSCs\"]:\n            vp[\"J^USAFA\"] = np.array([])\n            usafa_afscs = vp[\"USAFA-Constrained AFSCs\"].split(\",\")\n            for afsc in usafa_afscs:\n                afsc = afsc.strip()\n                j = np.where(p[\"afscs\"] == afsc)[0]\n                if len(j) == 0:\n                    print(\"WARNING: Something is wrong with the USAFA-Constrained AFSCs! \"\n                          \"'\" + afsc + \"' is not in the list of AFSCs.\")\n                else:\n                    vp[\"J^USAFA\"] = np.hstack((vp[\"J^USAFA\"], j))\n            vp[\"J^USAFA\"] = vp[\"J^USAFA\"].astype(int)\n\n    # Set of objectives that seek to balance some cadet demographic\n    vp['K^D'] = ['USAFA Proportion', 'Mandatory', 'Desired', 'Permitted', 'Tier 1', 'Tier 2', 'Tier 3', 'Tier 4']\n\n    # Set of AFSCs for each objective:\n    vp['J^A'] = {}\n    for k in range(vp[\"O\"]):\n        vp['J^A'][k] = np.where(vp['objective_weight'][:, k] &gt; 0)[0].astype(int)\n\n    # Cadet Value Constraint Set\n    vp['I^C'] = np.where(vp['cadet_value_min'] &gt; 0)[0]\n\n    # Create a set of preferred AFSCs that are constrained for cadets with utility constraints\n    vp['J^Top_Choice'] = {}\n    for i in vp['I^C']:\n        vp['J^Top_Choice'][i] = np.intersect1d(np.where(p['cadet_utility'][i, :] &gt;= vp['cadet_value_min'][i])[0],\n                                               p['J^E'][i])\n\n    # AFSC Value Constraint Set\n    vp['J^C'] = np.where(vp['afsc_value_min'] &gt; 0)[0]\n\n    # number of breakpoints\n    vp['r'] = np.array([[len(vp['a'][j][k]) for k in vp[\"K\"]] for j in p[\"J\"]])\n\n    # set of breakpoints\n    vp['L'] = np.array([[np.arange(vp['r'][j, k]) for k in range(vp[\"O\"])] for j in range(p[\"M\"])], dtype=object)\n\n    # Round weights\n    vp['objective_weight'] = np.around(vp['objective_weight'], 8)\n    vp['afsc_weight'] = np.around(vp['afsc_weight'], 8)\n    vp['cadet_weight'] = np.around(vp['cadet_weight'], 8)\n\n    # Extract AFSC objective min/max measures\n    vp[\"objective_min\"], vp[\"objective_max\"] = np.zeros([p['M'], vp['O']]), np.zeros([p[\"M\"], vp[\"O\"]])\n    for j in p['J']:\n        for k in vp['K^C'][j]:\n            value_list = vp['objective_value_min'][j, k].split(\",\")\n            vp[\"objective_min\"][j, k] = float(value_list[0].strip())\n            vp[\"objective_max\"][j, k] = float(value_list[1].strip())\n\n    # \"Global Utility\" matrix\n    if \"afsc_utility\" in p and \"cadet_utility\" in p:\n        vp['global_utility'] = np.zeros([p['N'], p['M'] + 1])\n        for j in p['J']:\n            vp['global_utility'][:, j] = vp['cadets_overall_weight'] * p['cadet_utility'][:, j] + \\\n                                         vp['afscs_overall_weight'] * p['afsc_utility'][:, j]\n\n    return vp\n</code></pre>"},{"location":"reference/data/values/#data.values.model_value_parameters_to_defaults","title":"<code>model_value_parameters_to_defaults(instance, filepath, printing=False)</code>","text":"<p>Export Instance Value Parameters to Excel Defaults File.</p> <p>This function extracts the current value parameters from the provided AFCCP model <code>instance</code> and saves them into a structured Excel file. This allows users to export and preserve a particular configuration of value weights, objectives, and constraints for cadets and AFSCs.</p>"},{"location":"reference/data/values/#data.values.model_value_parameters_to_defaults--parameters","title":"Parameters:","text":"<ul> <li>instance (<code>CadetCareerProblem</code>): The current problem instance containing value parameters in <code>instance.value_parameters</code>.</li> <li>filepath (str): Full path (including <code>.xlsx</code> extension) where the Excel file will be saved.</li> <li>printing (bool, optional): If True, prints progress message during export. Default is False.</li> </ul>"},{"location":"reference/data/values/#data.values.model_value_parameters_to_defaults--returns","title":"Returns:","text":"<p>None: Saves structured Excel file to disk with sheets for overall weights, AFSC weights, and objective components.</p>"},{"location":"reference/data/values/#data.values.model_value_parameters_to_defaults--examples","title":"Examples:","text":"<pre><code>model_value_parameters_to_defaults(instance, filepath='outputs/vp_defaults.xlsx', printing=True)\n</code></pre> Source code in <code>afccp/data/values.py</code> <pre><code>def model_value_parameters_to_defaults(instance, filepath, printing=False):\n    \"\"\"\n    Export Instance Value Parameters to Excel Defaults File.\n\n    This function extracts the current value parameters from the provided AFCCP model `instance`\n    and saves them into a structured Excel file. This allows users to export and preserve\n    a particular configuration of value weights, objectives, and constraints for cadets and AFSCs.\n\n    Parameters:\n    --------\n    - instance (`CadetCareerProblem`): The current problem instance containing value parameters in `instance.value_parameters`.\n    - filepath (str): Full path (including `.xlsx` extension) where the Excel file will be saved.\n    - printing (bool, optional): If True, prints progress message during export. Default is False.\n\n    Returns:\n    --------\n    None: Saves structured Excel file to disk with sheets for overall weights, AFSC weights, and objective components.\n\n    Examples:\n    --------\n    ```python\n    model_value_parameters_to_defaults(instance, filepath='outputs/vp_defaults.xlsx', printing=True)\n    ```\n    \"\"\"\n    if printing:\n        print('Exporting value parameters as defaults to excel...')\n\n    # Shorthand\n    p, vp = instance.parameters, instance.value_parameters\n\n    # Create \"Overall Weights\" dataframe\n    overall_weights_df = pd.DataFrame({'Cadets Weight': [vp['cadets_overall_weight']],\n                                       'AFSCs Weight': [vp['afscs_overall_weight']],\n                                       'Cadets Min Value': [vp['cadets_overall_value_min']],\n                                       'AFSCs Min Value': [vp['afscs_overall_value_min']],\n                                       'Cadet Weight Function': [vp['cadet_weight_function']],\n                                       'AFSC Weight Function': [vp['afsc_weight_function']]})\n\n    # Construct other dataframes\n    afsc_weights_df = pd.DataFrame({'AFSC': p['afscs'][:p[\"M\"]],\n                                    'AFSC Swing Weight': np.around((vp['afsc_weight'] / max(vp['afsc_weight'])) * 100, 2),\n                                    'AFSC Min Value': vp['afsc_value_min']})\n\n    # AFSC Objective Components Translations Dictionary\n    ao_trans_dict = {'AFSC Objective Weights': 'objective_weight', 'AFSC Objective Targets': 'objective_target',\n                     'AFSC Objective Min Value': 'objective_value_min', 'Constraint Type': 'constraint_type',\n                     'Value Functions': 'value_functions'}\n\n    # Create the AFSC Objective Components DataFrames\n    ao_dfs = {component: pd.DataFrame({'AFSC': p['afscs'][:p[\"M\"]]}) for component in ao_trans_dict}\n    for component in ao_dfs:\n\n        # Scale AFSC Objective Weights so that the largest is set to 100 rather than forcing them all to sum to 1\n        if component == \"AFSC Objective Weights\":\n            comp_arr = np.array([(vp[\"objective_weight\"][j] / max(vp[\"objective_weight\"][j])) * 100 for j in p[\"J\"]])\n        else:\n            comp_arr = vp[ao_trans_dict[component]]  # \"Component Array\", vp[\"objective_target\"] for example\n\n        # Load columns of the dataframe\n        for k, objective in enumerate(vp['objectives']):\n            ao_dfs[component][objective] = comp_arr[:, k]\n\n    # Export to excel\n    with pd.ExcelWriter(filepath) as writer:\n        overall_weights_df.to_excel(writer, sheet_name=\"Overall Weights\", index=False)\n        afsc_weights_df.to_excel(writer, sheet_name=\"AFSC Weights\", index=False)\n        for component in ao_dfs:\n            ao_dfs[component].to_excel(writer, sheet_name=component, index=False)\n</code></pre>"},{"location":"reference/data/values/#data.values.generate_afocd_value_parameters","title":"<code>generate_afocd_value_parameters(parameters, default_value_parameters)</code>","text":"<p>Generate AFOCD-Based Value Parameters for AFSC Assignment.</p> <p>This function builds out the objective weights, targets, and constraints for each AFSC based on their tiered degree requirements as specified in the AFOCD (Air Force Officer Classification Directory). Each tier (1\u20134) contributes differently based on whether the degree requirement is Mandatory, Desired, or Permitted.</p> <p>The function modifies the provided value parameters dictionary in-place by populating:</p> <ul> <li><code>objective_weight</code></li> <li><code>objective_target</code></li> <li><code>objective_value_min</code></li> <li><code>constraint_type</code></li> <li><code>value_functions</code></li> </ul> <p>It uses multipliers for tier importance and maps the degree tier qualifications to model-ready value and constraint settings.</p>"},{"location":"reference/data/values/#data.values.generate_afocd_value_parameters--parameters","title":"Parameters:","text":"<ul> <li>parameters (dict): Problem instance parameters dictionary (contains tier structure, tier types, and tier proportions).</li> <li>default_value_parameters (dict): Template or pre-initialized dictionary of value parameters to be modified and returned.</li> </ul>"},{"location":"reference/data/values/#data.values.generate_afocd_value_parameters--returns","title":"Returns:","text":"<ul> <li>dict: Updated <code>default_value_parameters</code> dictionary with AFOCD-based settings applied.</li> </ul>"},{"location":"reference/data/values/#data.values.generate_afocd_value_parameters--examples","title":"Examples:","text":"<p>```python updated_value_parameters = generate_afocd_value_parameters(instance.parameters, default_vp)</p> Source code in <code>afccp/data/values.py</code> <pre><code>def generate_afocd_value_parameters(parameters, default_value_parameters):\n    \"\"\"\n    Generate AFOCD-Based Value Parameters for AFSC Assignment.\n\n    This function builds out the objective weights, targets, and constraints for each AFSC\n    based on their tiered degree requirements as specified in the AFOCD (Air Force Officer\n    Classification Directory). Each tier (1\u20134) contributes differently based on whether the degree\n    requirement is Mandatory, Desired, or Permitted.\n\n    The function modifies the provided value parameters dictionary in-place by populating:\n\n    - `objective_weight`\n    - `objective_target`\n    - `objective_value_min`\n    - `constraint_type`\n    - `value_functions`\n\n    It uses multipliers for tier importance and maps the degree tier qualifications to model-ready\n    value and constraint settings.\n\n    Parameters:\n    --------\n    - parameters (dict): Problem instance parameters dictionary (contains tier structure, tier types, and tier proportions).\n    - default_value_parameters (dict): Template or pre-initialized dictionary of value parameters to be modified and returned.\n\n    Returns:\n    --------\n    - dict: Updated `default_value_parameters` dictionary with AFOCD-based settings applied.\n\n    Examples:\n    --------\n    ```python\n    updated_value_parameters = generate_afocd_value_parameters(instance.parameters, default_vp)\n    \"\"\"\n    p, vp = parameters, default_value_parameters\n\n    # AFOCD Objective Indices\n    tier_objectives = np.array([np.where(vp[\"objectives\"] == \"Tier \" + t)[0][0] for t in [\"1\", \"2\", \"3\", \"4\"]])\n\n    # Tier multipliers\n    tm = {1: 1, 2: 0.8, 3: 0.6, 4: 0.4}\n\n    # Loop through each AFSC\n    for j in p[\"J\"]:\n\n        # Loop through each AFOCD tier\n        for t, k in enumerate(tier_objectives):\n            tier = t + 1\n\n            # We only do this for valid AFOCD tiers\n            if tier &lt;= p[\"t_count\"][j]:\n\n                # Objective Weight\n                if p[\"t_mandatory\"][j, t] == 1:\n                    vp[\"objective_weight\"][j, k] = round(90 * tm[tier], 2)\n                elif p[\"t_desired\"][j, t] == 1:\n                    vp[\"objective_weight\"][j, k] = round(70 * tm[tier], 2)\n                elif p[\"t_permitted\"][j, t] == 1:\n                    vp[\"objective_weight\"][j, k] = round(50 * tm[tier], 2)\n                else:\n                    vp[\"objective_weight\"][j, k] = 0  # Tier doesn't exist or is an ineligible tier\n\n                # Objective Target\n                vp[\"objective_target\"][j, k] = p[\"t_proportion\"][j, t]\n\n                # Objective Min Value\n                if p[\"t_leq\"][j, t] == 1:\n                    vp[\"objective_value_min\"][j, k] = \"0, \" + str(p[\"t_proportion\"][j, t])\n                else:  # &lt;= OR ==\n                    vp[\"objective_value_min\"][j, k] = str(p[\"t_proportion\"][j, t]) + \", 5\"\n\n                # Constraint Type (Default to turning all constraints on. It's easier to make them zeros later...)\n                if p[\"t_mandatory\"][j, t] == 1:\n                    vp[\"constraint_type\"][j, k] = 1  # Easier to meet \"at least\" constraint (M &gt;/= x) based on PGL\n                elif p[\"t_desired\"][j, t] == 1:\n                    if p[\"t_leq\"][j, t] == 1:\n                        vp[\"constraint_type\"][j, k] = 2  # Easier to meet \"at most\" constraint (D &lt; x) based on proportion\n                    elif p[\"t_geq\"][j, t] == 1:\n                        vp[\"constraint_type\"][j, k] = 1  # Easier to meet \"at least\" constraint (D &gt; x) based on PGL\n                elif p[\"t_permitted\"][j, t] == 1:\n                    vp[\"constraint_type\"][j, k] = 2  # Easier to meet \"at most\" constraint (P &lt; x) based on proportion\n\n                # Value Functions\n                if p['t_leq'][j, t] == 1:\n                    vp['value_functions'][j, k] = \"Min Decreasing|0.3\"\n                else:  # &lt;= OR ==\n                    vp['value_functions'][j, k] = \"Min Increasing|0.3\"\n\n    return vp\n</code></pre>"},{"location":"reference/data/values/#data.values.update_value_and_weight_functions","title":"<code>update_value_and_weight_functions(instance, num_breakpoints=None)</code>","text":"<p>Update Value and Weight Functions for the Current Value Parameter Set.</p> <p>This function recalculates the cadet weights, AFSC weights, and value function breakpoints (<code>a</code> and <code>f^hat</code>) for the currently loaded set of value parameters in the instance. It is useful for refreshing value structures after manual edits to the value parameters, such as changes in weight functions or objective targets.</p> <p>It does not add or remove objectives from the current set \u2014 only updates the internal structure based on the existing configuration. For structural changes (adding/removing objectives), you must reinitialize the value parameter set entirely.</p>"},{"location":"reference/data/values/#data.values.update_value_and_weight_functions--parameters","title":"Parameters:","text":"<ul> <li>instance (CadetCareerProblem): The active problem instance containing <code>parameters</code> and <code>value_parameters</code>.</li> <li>num_breakpoints (int, optional): Number of breakpoints used to approximate the nonlinear value functions.   If not specified, defaults to internal value function settings.</li> </ul>"},{"location":"reference/data/values/#data.values.update_value_and_weight_functions--returns","title":"Returns:","text":"<ul> <li>dict: The updated <code>value_parameters</code> dictionary with recalculated weights and piecewise linear segments.</li> </ul>"},{"location":"reference/data/values/#data.values.update_value_and_weight_functions--examples","title":"Examples:","text":"<pre><code>instance.value_parameters = update_value_and_weight_functions(instance, num_breakpoints=10)\n</code></pre>"},{"location":"reference/data/values/#data.values.update_value_and_weight_functions--see-also","title":"See Also:","text":"<ul> <li><code>cadet_weight_function</code>:   Generates cadet weights from merit scores using a user-defined weighting function.</li> <li><code>afsc_weight_function</code>:   Generates AFSC weights based on PGL using either 'Linear', 'Square', or 'Custom' mappings.</li> <li><code>value_function_builder</code>:   Builds piecewise linear approximations (<code>a</code>, <code>f^hat</code>) of nonlinear value functions.</li> <li><code>create_segment_dict_from_string</code>:   Parses the string representation of a value function and returns a segment definition.</li> </ul> Source code in <code>afccp/data/values.py</code> <pre><code>def update_value_and_weight_functions(instance, num_breakpoints=None):\n    \"\"\"\n    Update Value and Weight Functions for the Current Value Parameter Set.\n\n    This function recalculates the cadet weights, AFSC weights, and value function breakpoints\n    (`a` and `f^hat`) for the currently loaded set of value parameters in the instance. It is useful\n    for refreshing value structures after manual edits to the value parameters, such as changes\n    in weight functions or objective targets.\n\n    It does not add or remove objectives from the current set \u2014 only updates the internal structure\n    based on the existing configuration. For structural changes (adding/removing objectives), you must\n    reinitialize the value parameter set entirely.\n\n    Parameters:\n    --------\n    - instance (CadetCareerProblem): The active problem instance containing `parameters` and `value_parameters`.\n    - num_breakpoints (int, optional): Number of breakpoints used to approximate the nonlinear value functions.\n      If not specified, defaults to internal value function settings.\n\n    Returns:\n    --------\n    - dict: The updated `value_parameters` dictionary with recalculated weights and piecewise linear segments.\n\n    Examples:\n    --------\n    ```python\n    instance.value_parameters = update_value_and_weight_functions(instance, num_breakpoints=10)\n    ```\n\n    See Also:\n    --------\n    - [`cadet_weight_function`](../../../../afccp/reference/data/values/#data.values.cadet_weight_function):\n      Generates cadet weights from merit scores using a user-defined weighting function.\n    - [`afsc_weight_function`](../../../../afccp/reference/data/values/#data.values.afsc_weight_function):\n      Generates AFSC weights based on PGL using either 'Linear', 'Square', or 'Custom' mappings.\n    - [`value_function_builder`](../../../../afccp/reference/data/values/#data.values.value_function_builder):\n      Builds piecewise linear approximations (`a`, `f^hat`) of nonlinear value functions.\n    - [`create_segment_dict_from_string`](../../../../afccp/reference/data/values/#data.values.create_segment_dict_from_string):\n      Parses the string representation of a value function and returns a segment definition.\n    \"\"\"\n\n    # Shorthand\n    p, vp = instance.parameters, instance.value_parameters\n\n    # Determine weights on cadets\n    if 'merit_all' in p:\n        vp['cadet_weight'] = cadet_weight_function(p['merit_all'], func=vp['cadet_weight_function'])\n    else:\n        vp['cadet_weight'] = cadet_weight_function(p['merit'], func=vp['cadet_weight_function'])\n\n    # Determine weights on AFSCs\n    if vp['afsc_weight_function'] != 'Custom':  # If the AFSC weight function is not \"custom\", we regenerate the weights\n        vp['afsc_weight'] = afsc_weight_function(p[\"pgl\"], vp['afsc_weight_function'])\n\n    # Initialize breakpoints\n    vp['a'] = [[[] for _ in range(vp['O'])] for _ in p[\"J\"]]\n    vp['f^hat'] = [[[] for _ in range(vp['O'])] for _ in p[\"J\"]]\n\n    # Loop through each AFSC\n    for j, afsc in enumerate(p['afscs'][:p['M']]):  # Skip the \"unmatched AFSC\": '*'\n\n        # Loop through each objective\n        for k, objective in enumerate(vp['objectives']):\n\n            # Value Function specific parameters\n            actual, minimum, maximum = None, None, None\n            if objective == 'Merit':\n                actual = np.mean(p['merit'][p['I^E'][j]])\n            if objective in ['USAFA Proportion', 'Male', 'Minority']:\n                actual = len(p['I^D'][objective][j]) / len(p['I^E'][j])\n            if objective in ['Combined Quota', 'ROTC Quota', 'USAFA Quota', 'OTS Quota']:\n\n                # Dictionaries for getting the right value for the specific quota objective\n                min_dict = {\"Combined Quota\": 'quota_min', 'ROTC Quota': 'rotc_quota',\n                            'USAFA Quota': 'usafa_quota', 'OTS Quota': 'ots_quota'}\n                target_dict = {\"Combined Quota\": 'quota_d', 'ROTC Quota': 'rotc_quota',\n                               'USAFA Quota': 'usafa_quota', 'OTS Quota': 'ots_quota'}\n                minimum, maximum = int(p[min_dict[objective]][j]), int(p['quota_max'][j])\n\n                # Update minimum values for combined quota objective\n                vp['objective_value_min'][j, k] = str(minimum) + ', ' + str(maximum)\n                vp['objective_min'][j, k], vp['objective_max'][j, k] = minimum, maximum\n                vp['objective_target'][j, k] = p[target_dict[objective]][j]\n\n            # If we care about this objective, we load in its value function breakpoints\n            if vp['objective_weight'][j, k] != 0:\n\n                # Create the non-linear piecewise exponential segment dictionary\n                segment_dict = create_segment_dict_from_string(vp['value_functions'][j, k],\n                                                               vp['objective_target'][j, k],\n                                                               minimum=minimum, maximum=maximum, actual=actual)\n\n                # Linearize the non-linear function using the specified number of breakpoints\n                vp['a'][j][k], vp['f^hat'][j][k] = value_function_builder(\n                    segment_dict, num_breakpoints=num_breakpoints)\n\n        # Scale the objective weights for this AFSC, so they sum to 1\n        vp['objective_weight'][j] = vp['objective_weight'][j] / sum(vp['objective_weight'][j])\n\n    # Scale the weights across all AFSCs, so they sum to 1\n    vp['afsc_weight'] = vp['afsc_weight'] / sum(vp['afsc_weight'])\n\n    return vp  # Return set of value parameters\n</code></pre>"},{"location":"reference/data/values/#data.values.generate_value_parameters_from_defaults","title":"<code>generate_value_parameters_from_defaults(parameters, default_value_parameters, generate_afsc_weights=True, num_breakpoints=None, printing=False)</code>","text":"<p>Generates structured value parameters for the assignment problem based on the factory defaults.</p> <p>This function constructs a complete <code>vp</code> dictionary used by value-focused optimization models. It loads and modifies default parameters to match the structure and constraints of the current problem instance, accounting for objective targets, weights, breakpoints, and constraint types.</p> <p>Note</p> <ul> <li>If <code>Qual Type</code> is <code>\"Tiers\"</code>, the function replaces legacy AFOCD objectives with Tiered ones.</li> <li>If <code>Qual Type</code> is <code>\"Relaxed\"</code>, Tier objectives are removed.</li> </ul> <p>Note</p> <p>Use this function when you have:</p> <ul> <li>Loaded default value parameters from Excel</li> <li>A structured cadet-AFSC assignment problem (<code>parameters</code>)</li> <li>Need to prepare a consistent set of inputs for a value-based matching model (e.g., VFT)</li> </ul>"},{"location":"reference/data/values/#data.values.generate_value_parameters_from_defaults--parameters","title":"Parameters","text":"<p>parameters : dict     Dictionary of instance parameters (cadets, AFSCs, quotas, preferences, etc.).</p> <p>default_value_parameters : dict     Dictionary of default value parameters imported via <code>default_value_parameters_from_excel</code>.</p> <p>generate_afsc_weights : bool, optional     If True (default), compute AFSC weights using the specified function in defaults.     If False, use static AFSC weights from the defaults (used for \"Custom\").</p> <p>num_breakpoints : int, optional     Number of breakpoints used to discretize value functions. Defaults to what's in defaults.</p> <p>printing : bool, optional     Whether to print status updates during generation (default is False).</p>"},{"location":"reference/data/values/#data.values.generate_value_parameters_from_defaults--returns","title":"Returns","text":"<p>dict A structured dictionary <code>vp</code> containing:</p> <ul> <li><code>objectives</code>: List of active objective names</li> <li><code>objective_weight</code>: Array of objective weights by AFSC</li> <li><code>objective_target</code>: Array of target values for each AFSC-objective pair</li> <li><code>objective_value_min</code>: Text bounds for constrained objectives</li> <li><code>constraint_type</code>: Type of constraint (e.g., inequality, convex) for each objective</li> <li><code>afsc_weight</code>, <code>afsc_value_min</code>, <code>cadet_weight</code>, <code>cadets_overall_weight</code>, ...</li> <li><code>a</code>, <code>f^hat</code>: Piecewise value function breakpoints</li> <li><code>K^A</code>: Dictionary mapping AFSC index to active objective indices</li> </ul> Source code in <code>afccp/data/values.py</code> <pre><code>def generate_value_parameters_from_defaults(parameters, default_value_parameters, generate_afsc_weights=True,\n                                            num_breakpoints=None, printing=False):\n    \"\"\"\n    Generates structured value parameters for the assignment problem based on the factory defaults.\n\n    This function constructs a complete `vp` dictionary used by value-focused optimization models.\n    It loads and modifies default parameters to match the structure and constraints of the current\n    problem instance, accounting for objective targets, weights, breakpoints, and constraint types.\n\n    !!! note\n        - If `Qual Type` is `\"Tiers\"`, the function replaces legacy AFOCD objectives with Tiered ones.\n        - If `Qual Type` is `\"Relaxed\"`, Tier objectives are removed.\n\n    !!! note\n        Use this function when you have:\n\n        - Loaded default value parameters from Excel\n        - A structured cadet-AFSC assignment problem (`parameters`)\n        - Need to prepare a consistent set of inputs for a value-based matching model (e.g., VFT)\n\n    Parameters\n    ----------\n    parameters : dict\n        Dictionary of instance parameters (cadets, AFSCs, quotas, preferences, etc.).\n\n    default_value_parameters : dict\n        Dictionary of default value parameters imported via `default_value_parameters_from_excel`.\n\n    generate_afsc_weights : bool, optional\n        If True (default), compute AFSC weights using the specified function in defaults.\n        If False, use static AFSC weights from the defaults (used for \"Custom\").\n\n    num_breakpoints : int, optional\n        Number of breakpoints used to discretize value functions. Defaults to what's in defaults.\n\n    printing : bool, optional\n        Whether to print status updates during generation (default is False).\n\n    Returns\n    -------\n    dict\n    A structured dictionary `vp` containing:\n\n    - `objectives`: List of active objective names\n    - `objective_weight`: Array of objective weights by AFSC\n    - `objective_target`: Array of target values for each AFSC-objective pair\n    - `objective_value_min`: Text bounds for constrained objectives\n    - `constraint_type`: Type of constraint (e.g., inequality, convex) for each objective\n    - `afsc_weight`, `afsc_value_min`, `cadet_weight`, `cadets_overall_weight`, ...\n    - `a`, `f^hat`: Piecewise value function breakpoints\n    - `K^A`: Dictionary mapping AFSC index to active objective indices\n    \"\"\"\n    if printing:\n        print('Generating value parameters from defaults...')\n\n    # Shorthand\n    p, dvp = parameters, default_value_parameters\n\n    # Variable to control if we load in AFOCD value parameters from the default excel workbook or create them here\n    init_afocd = False\n\n    # Manipulate AFOCD objectives based on what \"system\" we're using (Tiers or \"Old\")\n    if p[\"Qual Type\"] == \"Tiers\":\n\n        # Weight \"Old\" AFOCD Objectives at zero (but keep them in because we can select them if needed)\n        for objective in [\"Mandatory\", \"Desired\", \"Permitted\"]:\n            if objective in dvp[\"objectives\"]:\n                k = np.where(dvp[\"objectives\"] == objective)[0][0]\n                dvp[\"objective_weight\"][:, k] = np.zeros(len(dvp[\"objective_weight\"]))\n\n        # Add in \"Tier\" AFOCD Objectives\n        for t in [\"1\", \"2\", \"3\", \"4\"]:\n            objective = \"Tier \" + t\n            if objective not in dvp[\"objectives\"]:\n                init_afocd = True  # We're going to initialize the value parameters for AFOCD objectives\n                dvp[\"objectives\"] = np.hstack([dvp[\"objectives\"], objective])\n\n                # Add these columns in the other arrays as well\n                for vp_key in [\"objective_weight\", \"objective_value_min\", \"constraint_type\", \"objective_target\",\n                               \"value_functions\"]:\n                    if vp_key in [\"objective_weight\", \"constraint_type\", \"objective_target\"]:\n                        new_column = np.array([[0] for _ in p[\"J\"]])\n                    else:\n                        new_column = np.array([[\"0\"] for _ in p[\"J\"]])\n                    dvp[vp_key] = np.hstack((dvp[vp_key], new_column))\n\n    elif p[\"Qual Type\"] == \"Relaxed\":\n\n        # Remove \"Tier\" AFOCD Objectives\n        for t in [\"1\", \"2\", \"3\", \"4\"]:\n            objective = \"Tier \" + t\n            if objective in dvp[\"objectives\"]:\n                k = np.where(dvp[\"objectives\"] == objective)[0][0]\n                dvp[\"objectives\"] = np.delete(dvp[\"objectives\"], k)\n\n    # Generate AFOCD value parameters if necessary\n    if init_afocd:\n        dvp = generate_afocd_value_parameters(p, dvp)\n\n    # Objective to parameters lookup dictionary (if the parameter is in \"p\", we include the objective)\n    objective_lookups = {'Norm Score': 'a_pref_matrix', 'Merit': 'merit', 'USAFA Proportion': 'usafa',\n                         'Combined Quota': 'quota_d', 'USAFA Quota': 'usafa_quota', 'ROTC Quota': 'rotc_quota',\n                         'OTS Quota': 'ots_quota',\n                         'Mandatory': 'mandatory', 'Desired': 'desired', 'Permitted': 'permitted',\n                         'Utility': 'utility', 'Male': 'male', 'Minority': 'minority'}\n    for t in [\"1\", \"2\", \"3\", \"4\"]:  # Add in AFOCD Degree tiers\n        objective_lookups[\"Tier \" + t] = \"tier \" + t\n\n    # Add the AFSC objectives that are included in this instance (check corresponding parameters using dict above)\n    objectives = []\n    objective_indices = []\n    for k, objective in enumerate(dvp[\"objectives\"]):\n        if objective_lookups[objective] in p:\n            objectives.append(objective)\n            objective_indices.append(k)\n\n    # Convert to numpy arrays\n    objectives = np.array(objectives)\n    objective_indices = np.array(objective_indices)\n\n    # Additional information\n    afsc_indices = np.array([np.where(dvp['complete_afscs'] == p['afscs'][j])[0][0] for j in p[\"J\"]])\n    O = len(objectives)\n    if num_breakpoints is None:\n        num_breakpoints = dvp['num_breakpoints']\n\n    # Initialize set of value p\n    vp = {'cadets_overall_weight': dvp['cadets_overall_weight'],\n          'afscs_overall_weight': dvp['afscs_overall_weight'],\n          'cadet_weight_function': dvp['cadet_weight_function'],\n          'afsc_weight_function': dvp['afsc_weight_function'],\n          'cadets_overall_value_min': dvp['cadets_overall_value_min'],\n          'afscs_overall_value_min': dvp['afscs_overall_value_min'],\n          'afsc_value_min': np.zeros(p[\"M\"]), 'cadet_value_min': np.zeros(p[\"N\"]),\n          'objective_weight': np.zeros([p[\"M\"], O]), 'afsc_weight': np.zeros(p[\"M\"]), \"M\": p[\"M\"],\n          'objective_target': np.zeros([p[\"M\"], O]), 'objectives': objectives, 'O': O,\n          'objective_value_min': np.array([[\" \" * 20 for _ in range(O)] for _ in p[\"J\"]]),\n          'constraint_type': np.zeros([p[\"M\"], O]).astype(int),\n          'num_breakpoints': num_breakpoints}\n\n    # Determine weights on cadets\n    if 'merit_all' in p:\n        vp['cadet_weight'] = cadet_weight_function(p['merit_all'], func=vp['cadet_weight_function'])\n    else:\n        vp['cadet_weight'] = cadet_weight_function(p['merit'], func=vp['cadet_weight_function'])\n\n    # Determine weights on AFSCs\n    if generate_afsc_weights:\n        func = vp['afsc_weight_function']\n        if func == 'Custom':  # We take the AFSC weights directly from the defaults\n            generate_afsc_weights = False\n        else:\n            vp['afsc_weight'] = afsc_weight_function(p[\"pgl\"], func)\n\n    # Initialize breakpoints\n    vp['a'] = [[[] for _ in range(O)] for _ in p[\"J\"]]\n    vp['f^hat'] = [[[] for _ in range(O)] for _ in p[\"J\"]]\n\n    # Load value function strings\n    value_functions = dvp['value_functions'][:, objective_indices]\n    value_functions = value_functions[afsc_indices, :]\n    vp['value_functions'] = value_functions\n\n    # Initialize objective set\n    vp['K^A'] = {}\n\n    # Loop through each AFSC to load in their value parameters\n    for j, afsc in enumerate(p['afscs']):\n\n        if afsc != \"*\":\n\n            # Get location of afsc in the default value parameters (matters if this set of afscs does not match)\n            loc = np.where(dvp['complete_afscs'] == afsc)[0][0]\n\n            # Initially assign all default weights, targets, etc.\n            vp['objective_weight'][j, :] = dvp['objective_weight'][loc, objective_indices]\n            vp['objective_target'][j] = dvp['objective_target'][loc, objective_indices]\n            vp['objective_value_min'][j] = dvp['objective_value_min'][loc, objective_indices]\n            vp['afsc_value_min'][j] = dvp['afsc_value_min'][loc]\n            vp['constraint_type'][j] = dvp['constraint_type'][loc, objective_indices]\n            vp['K^A'][j] = np.where(vp['objective_weight'][j, :] &gt; 0)[0].astype(int)\n\n            # If we're not generating afsc weights using the specified weight function...\n            if not generate_afsc_weights:  # Also, if the weight function is \"Custom\"\n                vp['afsc_weight'][j] = dvp['afsc_weight'][loc]\n\n            # Loop through each objective to load their targets\n            for k, objective in enumerate(vp['objectives']):\n\n                maximum, minimum, actual = None, None, None\n                if objective == 'Merit':\n                    vp['objective_target'][j, k] = p['sum_merit'] / p['N']\n                    actual = np.mean(p['merit'][p['I^E'][j]])\n\n                elif objective == 'USAFA Proportion':\n                    vp['objective_target'][j, k] = p['usafa_proportion']\n                    if len(p['I^E'][j]) == 0:  # In case there are no eligible USAFA cadets\n                        actual = 0\n                    else:\n                        actual = len(p['I^D'][objective][j]) / len(p['I^E'][j])\n\n                elif objective == 'Combined Quota':\n                    vp['objective_target'][j, k] = p['quota_d'][j]\n\n                    # Get bounds\n                    minimum, maximum = p['quota_min'][j], p['quota_max'][j]\n                    vp['objective_value_min'][j, k] = str(int(minimum)) + \", \" + str(int(maximum))\n\n                elif objective == 'USAFA Quota':\n                    vp['objective_target'][j, k] = p['usafa_quota'][j]\n                    vp['objective_value_min'][j, k] = str(int(p['usafa_quota'][j])) + \", \" + \\\n                                                                    str(int(p['quota_max'][j]))\n\n                elif objective == 'ROTC Quota':\n                    vp['objective_target'][j, k] = p['rotc_quota'][j]\n                    vp['objective_value_min'][j, k] = str(int(p['rotc_quota'][j])) + \", \" + \\\n                                                                    str(int(p['quota_max'][j]))\n                elif objective == 'OTS Quota':\n                    vp['objective_target'][j, k] = p['ots_quota'][j]\n                    vp['objective_value_min'][j, k] = str(int(p['ots_quota'][j])) + \", \" + \\\n                                                                    str(int(p['quota_max'][j]))\n\n                elif objective == 'Male':\n                    vp['objective_target'][j, k] = p['male_proportion']\n                    if len(p['I^E'][j]) == 0:  # In case there are no eligible male cadets\n                        actual = 0\n                    else:\n                        actual = len(p['I^D'][objective][j]) / len(p['I^E'][j])\n\n                elif objective == 'Minority':\n                    vp['objective_target'][j, k] = p['minority_proportion']\n                    if len(p['I^E'][j]) == 0:  # In case there are no eligible minority cadets\n                        actual = 0\n                    else:\n                        actual = len(p['I^D'][objective][j]) / len(p['I^E'][j])\n\n                # If we care about this objective, we load in its value function breakpoints\n                if vp['objective_weight'][j, k] != 0:\n\n                    # Create the non-linear piecewise exponential segment dictionary\n                    segment_dict = create_segment_dict_from_string(value_functions[j, k],\n                                                                   vp['objective_target'][j, k],\n                                                                   minimum=minimum, maximum=maximum, actual=actual)\n\n                    # Linearize the non-linear function using the specified number of breakpoints\n                    vp['a'][j][k], vp['f^hat'][j][k] = value_function_builder(\n                        segment_dict, num_breakpoints=num_breakpoints)\n\n            # Scale the objective weights for this AFSC, so they sum to 1\n            vp['objective_weight'][j] = vp['objective_weight'][j] / sum(vp['objective_weight'][j])\n\n    # Scale the weights across all AFSCs, so they sum to 1\n    vp['afsc_weight'] = vp['afsc_weight'] / sum(vp['afsc_weight'])\n\n    return vp\n</code></pre>"},{"location":"reference/data/values/#data.values.default_value_parameters_from_excel","title":"<code>default_value_parameters_from_excel(filepath, num_breakpoints=24, printing=False)</code>","text":"<p>Loads the factory default value parameters from an Excel file into a structured dictionary.</p> <p>This function is typically used to initialize a consistent baseline for value-focused models (such as VFT and GP), including AFSC weights, objective weights/targets, constraint types, and breakpoint-based value functions.</p> <p>It pulls multiple sheets from a specified Excel file and organizes them into a structured dictionary suitable for assignment model optimization.</p> <p>Note</p> <p>The <code>filepath</code> must point to a valid Excel file containing the following sheets:</p> <ul> <li>\"Overall Weights\"</li> <li>\"AFSC Weights\"</li> <li>\"AFSC Objective Weights\"</li> <li>\"AFSC Objective Targets\"</li> <li>\"AFSC Objective Min Value\"</li> <li>\"Constraint Type\"</li> <li>\"Value Functions\"</li> </ul>"},{"location":"reference/data/values/#data.values.default_value_parameters_from_excel--parameters","title":"Parameters","text":"<p>filepath : str     Path to the Excel file containing all value parameter sheets. num_breakpoints : int, optional     Number of breakpoints to use for piecewise value functions (default is 24). printing : bool, optional     Whether to print status messages during execution (default is False).</p>"},{"location":"reference/data/values/#data.values.default_value_parameters_from_excel--returns","title":"Returns","text":"<p>dict A dictionary containing all default value parameter arrays and scalars:</p> <ul> <li><code>cadet_weight_function</code>: str</li> <li><code>afsc_weight_function</code>: str</li> <li><code>cadets_overall_weight</code>: float</li> <li><code>afscs_overall_weight</code>: float</li> <li><code>afsc_weight</code>: np.ndarray</li> <li><code>objective_weight</code>: np.ndarray</li> <li><code>objective_target</code>: np.ndarray</li> <li><code>objective_value_min</code>: np.ndarray</li> <li><code>constraint_type</code>: np.ndarray</li> <li><code>value_functions</code>: np.ndarray</li> <li><code>cadets_overall_value_min</code>: float</li> <li><code>afscs_overall_value_min</code>: float</li> <li><code>afsc_value_min</code>: np.ndarray</li> <li><code>objectives</code>: np.ndarray of objective names</li> <li><code>complete_afscs</code>: np.ndarray of AFSC names</li> <li><code>num_breakpoints</code>: int (copied from input)</li> <li><code>M</code>: int (number of AFSCs)</li> </ul> Source code in <code>afccp/data/values.py</code> <pre><code>def default_value_parameters_from_excel(filepath, num_breakpoints=24, printing=False):\n    \"\"\"\n    Loads the factory default value parameters from an Excel file into a structured dictionary.\n\n    This function is typically used to initialize a consistent baseline for value-focused models\n    (such as VFT and GP), including AFSC weights, objective weights/targets, constraint types,\n    and breakpoint-based value functions.\n\n    It pulls multiple sheets from a specified Excel file and organizes them into a structured dictionary\n    suitable for assignment model optimization.\n\n    !!! note\n        The `filepath` must point to a valid Excel file containing the following sheets:\n\n        - \"Overall Weights\"\n        - \"AFSC Weights\"\n        - \"AFSC Objective Weights\"\n        - \"AFSC Objective Targets\"\n        - \"AFSC Objective Min Value\"\n        - \"Constraint Type\"\n        - \"Value Functions\"\n\n    Parameters\n    ----------\n    filepath : str\n        Path to the Excel file containing all value parameter sheets.\n    num_breakpoints : int, optional\n        Number of breakpoints to use for piecewise value functions (default is 24).\n    printing : bool, optional\n        Whether to print status messages during execution (default is False).\n\n    Returns\n    -------\n    dict\n    A dictionary containing all default value parameter arrays and scalars:\n\n    - `cadet_weight_function`: str\n    - `afsc_weight_function`: str\n    - `cadets_overall_weight`: float\n    - `afscs_overall_weight`: float\n    - `afsc_weight`: np.ndarray\n    - `objective_weight`: np.ndarray\n    - `objective_target`: np.ndarray\n    - `objective_value_min`: np.ndarray\n    - `constraint_type`: np.ndarray\n    - `value_functions`: np.ndarray\n    - `cadets_overall_value_min`: float\n    - `afscs_overall_value_min`: float\n    - `afsc_value_min`: np.ndarray\n    - `objectives`: np.ndarray of objective names\n    - `complete_afscs`: np.ndarray of AFSC names\n    - `num_breakpoints`: int (copied from input)\n    - `M`: int (number of AFSCs)\n    \"\"\"\n    if printing:\n        print('Importing default value parameters...')\n\n    # Get dataframes\n    overall_weights_df = afccp.globals.import_data(filepath, sheet_name=\"Overall Weights\")\n    afsc_weights_df = afccp.globals.import_data(filepath, sheet_name=\"AFSC Weights\")\n    afsc_objective_weights_df = afccp.globals.import_data(filepath, sheet_name=\"AFSC Objective Weights\")\n    afsc_objective_targets_df = afccp.globals.import_data(filepath, sheet_name=\"AFSC Objective Targets\")\n    afsc_objective_value_min_df = afccp.globals.import_data(filepath, sheet_name=\"AFSC Objective Min Value\")\n    afsc_objective_convex_constraints_df = afccp.globals.import_data(filepath, sheet_name=\"Constraint Type\")\n    afsc_value_functions_df = afccp.globals.import_data(filepath, sheet_name=\"Value Functions\")\n    objectives = np.array(afsc_objective_weights_df.keys()[1:])\n    default_value_parameters = {'cadet_weight_function': overall_weights_df['Cadet Weight Function'][0],\n                                'afsc_weight_function': overall_weights_df['AFSC Weight Function'][0],\n                                'cadets_overall_weight': overall_weights_df['Cadets Weight'][0],\n                                'afscs_overall_weight': overall_weights_df['AFSCs Weight'][0],\n                                'afsc_weight': np.array(afsc_weights_df['AFSC Swing Weight']),\n                                'objective_weight': np.array(afsc_objective_weights_df.iloc[:,\n                                                             1:(len(objectives) + 1)]),\n                                'objective_target': np.array(\n                                    afsc_objective_targets_df.iloc[:, 1:(len(objectives) + 1)]),\n                                'objective_value_min': np.array(\n                                    afsc_objective_value_min_df.iloc[:, 1:(len(objectives) + 1)]),\n                                'constraint_type': np.array(\n                                    afsc_objective_convex_constraints_df.iloc[:, 1:(len(objectives) + 1)]),\n                                'value_functions': np.array(afsc_value_functions_df.iloc[:, 1:(len(objectives) + 1)]),\n                                'cadets_overall_value_min': overall_weights_df['Cadets Min Value'][0],\n                                'afscs_overall_value_min': overall_weights_df['AFSCs Min Value'][0],\n                                'afsc_value_min': np.array(afsc_weights_df['AFSC Min Value']),\n                                'objectives': objectives,\n                                'complete_afscs': np.array(afsc_weights_df['AFSC']),\n                                'num_breakpoints': num_breakpoints, \"M\": len(afsc_weights_df)}\n\n    return default_value_parameters\n</code></pre>"},{"location":"reference/data/values/#data.values.cadet_weight_function","title":"<code>cadet_weight_function(merit, func='Curve_1')</code>","text":"<p>Take in a merit array and generate cadet weights depending on function specified</p> Source code in <code>afccp/data/values.py</code> <pre><code>def cadet_weight_function(merit, func=\"Curve_1\"):\n    \"\"\"\n    Take in a merit array and generate cadet weights depending on function specified\n    \"\"\"\n\n    # Number of Cadets\n    N = len(merit)\n\n    # Generate Swing Weights based on function\n    if func == 'Linear':\n        swing_weights = np.array([1 + (2 * x) for x in merit])\n    elif func == \"Direct\":\n        swing_weights = merit\n    elif func == 'Curve_1':\n        swing_weights = np.array([1 + 2 / (1 + exp(-10 * (x - 0.5))) for x in merit])\n    elif func == 'Curve_2':\n        swing_weights = np.array([1 + 2 / (1 + exp(-12 * (x - 0.7))) for x in merit])\n    elif func == 'Equal':\n        swing_weights = np.ones(N)\n    else:  # Exponential Function\n        rho = -0.3\n        swing_weights = np.array([(1 - exp(-x / rho)) / (1 - exp(-1 / rho)) for x in merit])\n\n    # Normalize weights and return them\n    weights = swing_weights / sum(swing_weights)\n    return weights\n</code></pre>"},{"location":"reference/data/values/#data.values.afsc_weight_function","title":"<code>afsc_weight_function(quota, func='Curve')</code>","text":"<p>Take in an AFSC quota array and generate AFSC weights depending on function specified</p> Source code in <code>afccp/data/values.py</code> <pre><code>def afsc_weight_function(quota, func=\"Curve\"):\n    \"\"\"\n    Take in an AFSC quota array and generate AFSC weights depending on function specified\n    \"\"\"\n\n    # Number of AFSCs\n    M = len(quota)\n\n    # Scale quota to be 0-1 (referencing biggest AFSC)\n    quota_scale = quota / np.max(quota)\n\n    # Generate Swing Weights based on function\n    if func == 'Linear':\n        swing_weights = np.array([1 + (10 * x) for x in quota_scale])\n    elif func in [\"Direct\", \"Size\"]:  # Direct relationship between size and importance\n        swing_weights = quota\n    elif func == \"Piece\":\n        swing_weights = np.zeros(M)\n        for j, x in enumerate(quota):\n            if x &gt;= 200:\n                swing_weights[j] = 1\n            elif 150 &lt;= x &lt; 200:\n                swing_weights[j] = 0.9\n            elif 100 &lt;= x &lt; 150:\n                swing_weights[j] = 0.8\n            elif 50 &lt;= x &lt; 100:\n                swing_weights[j] = 0.7\n            elif 25 &lt;= x &lt; 50:\n                swing_weights[j] = 0.6\n            else:\n                swing_weights[j] = 0.5\n    elif func == 'Curve_1':  # Sigmoid Function\n        swing_weights = np.array([1 + 10 / (1 + exp(-5 * (x - 0.5))) for x in quota_scale])\n    elif func == 'Curve_2':  # Sigmoid Function\n        swing_weights = np.array([1 + 12 / (1 + exp(-20 * (x - 0.5))) for x in quota_scale])\n    elif func == 'Equal':  # They're all the same\n        swing_weights = np.ones(M)\n    else:  # Exponential Function\n        rho = -0.3\n        swing_weights = np.array([(1 - exp(-x / rho)) / (1 - exp(-1 / rho)) for x in quota_scale])\n\n    # Scale weights and return them\n    weights = swing_weights / sum(swing_weights)\n    return weights\n</code></pre>"},{"location":"reference/data/values/#data.values.create_segment_dict_from_string","title":"<code>create_segment_dict_from_string(vf_string, target=None, maximum=None, actual=None, multiplier=False, minimum=None)</code>","text":"<p>Converts a value function string into a segment dictionary.</p> <p>Args:</p> <ul> <li>vf_string (str): Value function string.</li> <li>target (float, optional): Target objective measure.</li> <li>maximum (float, optional): Maximum objective measure.</li> <li>actual (float, optional): Proportion of eligible cadets.</li> <li>multiplier (bool, optional): Specifies whether the target values are multiplied by a scalar for quota objectives.</li> <li>minimum (float, optional): Minimum objective measure.</li> </ul> <p>Returns:     segment_dict (dict): A dictionary representing the segments of the value function.</p> <p>Notes:</p> <ul> <li>The function assumes that the value function string follows a specific format.</li> <li>The segment dictionary contains keys representing the segment number and values representing the segment details.</li> <li> <p>Each segment is represented by a dictionary with the following keys:</p> <ul> <li>'x1': The starting point on the x-axis.</li> <li>'y1': The starting point on the y-axis.</li> <li>'x2': The ending point on the x-axis.</li> <li>'y2': The ending point on the y-axis.</li> <li>'rho': The value of the rho parameter for the segment.</li> </ul> </li> </ul> Source code in <code>afccp/data/values.py</code> <pre><code>def create_segment_dict_from_string(vf_string, target=None, maximum=None, actual=None, multiplier=False, minimum=None):\n    \"\"\"\n    Converts a value function string into a segment dictionary.\n\n    Args:\n\n    - vf_string (str): Value function string.\n    - target (float, optional): Target objective measure.\n    - maximum (float, optional): Maximum objective measure.\n    - actual (float, optional): Proportion of eligible cadets.\n    - multiplier (bool, optional): Specifies whether the target values are multiplied by a scalar for quota objectives.\n    - minimum (float, optional): Minimum objective measure.\n\n    Returns:\n        segment_dict (dict): A dictionary representing the segments of the value function.\n\n    Notes:\n\n    - The function assumes that the value function string follows a specific format.\n    - The segment dictionary contains keys representing the segment number and values representing the segment details.\n    - Each segment is represented by a dictionary with the following keys:\n\n        - 'x1': The starting point on the x-axis.\n        - 'y1': The starting point on the y-axis.\n        - 'x2': The ending point on the x-axis.\n        - 'y2': The ending point on the y-axis.\n        - 'rho': The value of the rho parameter for the segment.\n    \"\"\"\n\n    # Collect the kind of function we're creating\n    split_list = vf_string.split('|')\n    f_type = split_list[0]\n\n    if f_type == 'Balance':\n\n        # Receive values from string\n        f_param_list = split_list[1]\n        split_list = f_param_list.split(',')\n        left_bm = float(split_list[0].strip())\n        right_bm = float(split_list[1].strip())\n        rho1 = float(split_list[2].strip())\n        rho2 = float(split_list[3].strip())\n        rho3 = float(split_list[4].strip())\n        rho4 = float(split_list[5].strip())\n        buffer_y = float(split_list[6].strip())\n\n        if actual &lt; target:\n            left_margin = (target - actual) / 4 + left_bm\n            right_margin = right_bm\n        elif actual &gt; target:\n            left_margin = left_bm\n            right_margin = (actual - target) / 4 + right_bm\n        else:\n            left_margin = left_bm\n            right_margin = right_bm\n\n        # Build segments\n        segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': round(target - left_margin, 3), 'y2': buffer_y, 'rho': -rho1},\n                        2: {'x1': round(target - left_margin, 3), 'y1': buffer_y, 'x2': target, 'y2': 1, 'rho': rho2},\n                        3: {'x1': target, 'y1': 1, 'x2': round(target + right_margin, 3), 'y2': buffer_y, 'rho': rho3},\n                        4: {'x1': round(target + right_margin, 3), 'y1': buffer_y, 'x2': 1, 'y2': 0, 'rho': -rho4}}\n\n    elif f_type == 'Quota_Normal':  # \"Method 1\" as described in thesis\n\n        # Receive values from string\n        f_param_list = split_list[1]\n        split_list = f_param_list.split(',')\n        domain_max = float(split_list[0].strip())\n        rho1 = float(split_list[1].strip()) * target\n        rho2 = float(split_list[2].strip()) * target\n        if multiplier:\n            maximum = int(target * maximum)\n        real_max = max(int(target + (maximum - target) + target * domain_max), maximum + 1)\n\n        # Build segments\n        segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': target, 'y2': 1, 'rho': -rho1},\n                        2: {'x1': maximum, 'y1': 1, 'x2': real_max, 'y2': 0, 'rho': -rho2}}\n\n    elif f_type == 'Quota_Over':  # \"Method 2\" as described in thesis\n\n        # Receive values from string\n        f_param_list = split_list[1]\n        split_list = f_param_list.split(',')\n        domain_max = float(split_list[0].strip())\n        rho1 = float(split_list[1].strip()) * target\n        rho2 = float(split_list[2].strip()) * target\n        rho3 = float(split_list[3].strip()) * target\n        buffer_y = float(split_list[4].strip())\n        if multiplier:\n            maximum = int(target * maximum)\n            actual = int(target * actual)\n        real_max = max(int(target + (actual - target) + target * domain_max), actual + 1)\n\n        # Build segments\n        segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': target, 'y2': 1, 'rho': -rho1},\n                        2: {'x1': maximum, 'y1': 1, 'x2': actual, 'y2': buffer_y, 'rho': rho2},\n                        3: {'x1': actual, 'y1': buffer_y, 'x2': real_max, 'y2': 0, 'rho': -rho3}}\n\n    elif f_type == 'Quota_Direct':  # The benefit of value functions is here! Captures ambiguity of PGL/constraints\n\n        # Receive values from string\n        f_param_list = split_list[1]\n        split_list = f_param_list.split(',')\n        domain_max = 1.05  # Arbitrary max (this doesn't really matter since we constrain quota anyway)\n        rho1 = float(split_list[0].strip())\n        rho2 = float(split_list[1].strip())\n        rho3 = float(split_list[2].strip())\n        rho4 = float(split_list[3].strip())\n        y1 = float(split_list[4].strip())\n        y2 = float(split_list[5].strip())\n\n        assert rho1 &gt; 0, f\"rho1 must be greater than 0 for a Quota_Direct value function, got: {rho1}\"\n        assert rho2 &gt; 0, f\"rho2 must be greater than 0 for a Quota_Direct value function, got: {rho2}\"\n        assert rho3 &gt; 0, f\"rho3 must be greater than 0 for a Quota_Direct value function, got: {rho3}\"\n        assert rho4 &gt; 0, f\"rho4 must be greater than 0 for a Quota_Direct value function, got: {rho4}\"\n        assert 0 &lt; y1 &lt; 1, f\"y1 must be between 0 and 1 for a Quota_Direct value function, got: {y1}\"\n        assert 0 &lt; y2 &lt; 1, f\"y2 must be between 0 and 1 for a Quota_Direct value function, got: {y2}\"\n\n        # Build segments\n        if target == minimum:\n            if target == maximum:\n                segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': target, 'y2': 1, 'rho': -(rho1 * target)},\n                                2: {'x1': maximum, 'y1': 1, 'x2': domain_max * maximum, 'y2': 0,\n                                    'rho': -(rho4 * (maximum - target))}}\n            else:\n                segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': target, 'y2': 1, 'rho': -(rho1 * target)},\n                                2: {'x1': target, 'y1': 1, 'x2': maximum, 'y2': y2,\n                                    'rho': (rho3 * (maximum - target))},\n                                3: {'x1': maximum, 'y1': y2, 'x2': domain_max * maximum, 'y2': 0,\n                                    'rho': -(rho4 * (domain_max * maximum - maximum))}}\n\n        else:\n            if target == maximum:\n                segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': minimum, 'y2': y1, 'rho': -(rho1 * (minimum - 0))},\n                                2: {'x1': minimum, 'y1': y1, 'x2': target, 'y2': 1,\n                                    'rho': (rho2 * (target - minimum))},\n                                3: {'x1': target, 'y1': 1, 'x2': domain_max * maximum, 'y2': 0,\n                                    'rho': -(rho4 * (domain_max * maximum - maximum))}}\n            else:\n                segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': minimum, 'y2': y1, 'rho': -(rho1 * (minimum - 0))},\n                                2: {'x1': minimum, 'y1': y1, 'x2': target, 'y2': 1,\n                                    'rho': (rho2 * (target - minimum))},\n                                3: {'x1': target, 'y1': 1, 'x2': maximum, 'y2': y2,\n                                    'rho': (rho3 * (maximum - target))},\n                                4: {'x1': maximum, 'y1': y2, 'x2': domain_max * maximum, 'y2': 0,\n                                    'rho': -(rho4 * (domain_max * maximum - maximum))}}\n\n    else:  # Must be a \"Min Increasing/Decreasing\" function\n\n        # Receive values from string\n        f_param_list = split_list[1]\n        split_list = f_param_list.split(',')\n        rho = float(split_list[0].strip()) * target  # Multiplying by the target normalizes the domain space\n\n        # Build segments\n        if f_type == 'Min Increasing':\n            segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': target, 'y2': 1, 'rho': -rho}}\n        else:\n            segment_dict = {1: {'x1': target, 'y1': 1, 'x2': 1, 'y2': 0, 'rho': -rho}}\n\n    return segment_dict\n</code></pre>"},{"location":"reference/data/values/#data.values.value_function_builder","title":"<code>value_function_builder(segment_dict=None, num_breakpoints=None, derivative_locations=False)</code>","text":"<p>Build Piecewise Linear Value Function from Exponential Segments.</p> <p>This function takes a dictionary of exponential segment definitions and returns a pair of arrays representing the piecewise linear approximation of the nonlinear value function: one for the x-axis breakpoints (<code>a</code>) and one for the corresponding values (<code>f^hat</code>).</p> <p>The segment dictionary defines the start and end points, curvature (via <code>rho</code>), and optionally the number of breakpoints to use for each segment. The function supports both fixed-interval spacing along the x-axis and derivative-based breakpoint spacing.</p>"},{"location":"reference/data/values/#data.values.value_function_builder--parameters","title":"Parameters:","text":"<ul> <li> <p>segment_dict (dict, optional): A dictionary specifying exponential segments. Each key maps to a sub-dictionary with:</p> <ul> <li><code>'x1'</code>, <code>'y1'</code>: Starting point of the segment</li> <li><code>'x2'</code>, <code>'y2'</code>: Ending point of the segment</li> <li><code>'rho'</code>: Curvature parameter controlling steepness of the segment</li> <li><code>'r'</code> (optional): Number of breakpoints for this segment</li> <li>num_breakpoints (int, optional): Overrides the per-segment breakpoint count. Distributes breakpoints equally if specified.</li> <li>derivative_locations (bool, optional): If True, breakpoints are spaced using derivative intervals   instead of uniform spacing on the x-axis.</li> </ul> </li> </ul>"},{"location":"reference/data/values/#data.values.value_function_builder--returns","title":"Returns:","text":"<ul> <li>a (np.ndarray): Array of breakpoint locations (measures) on the x-axis.</li> <li>fhat (np.ndarray): Array of function values at those breakpoint locations.</li> </ul>"},{"location":"reference/data/values/#data.values.value_function_builder--examples","title":"Examples:","text":"<pre><code>segment_def = {\n    1: {'x1': 0, 'y1': 0, 'x2': 0.5, 'y2': 1, 'rho': 0.1, 'r': 10},\n    2: {'x1': 0.5, 'y1': 1, 'x2': 1, 'y2': 0, 'rho': -0.1, 'r': 10}\n}\na, fhat = value_function_builder(segment_def, num_breakpoints=20, derivative_locations=False)\n</code></pre>"},{"location":"reference/data/values/#data.values.value_function_builder--see-also","title":"See Also:","text":"<ul> <li><code>exponential_function</code>:   Computes the value for an exponential segment at a given x.</li> <li><code>derivative_function</code>:   Returns the derivative of the exponential function at a given x.</li> <li><code>inverse_derivative_function</code>:   Finds the x-value corresponding to a specific derivative magnitude for exponential functions.</li> </ul> Source code in <code>afccp/data/values.py</code> <pre><code>def value_function_builder(segment_dict=None, num_breakpoints=None, derivative_locations=False):\n    \"\"\"\n    Build Piecewise Linear Value Function from Exponential Segments.\n\n    This function takes a dictionary of exponential segment definitions and returns a pair of\n    arrays representing the piecewise linear approximation of the nonlinear value function:\n    one for the x-axis breakpoints (`a`) and one for the corresponding values (`f^hat`).\n\n    The segment dictionary defines the start and end points, curvature (via `rho`), and optionally\n    the number of breakpoints to use for each segment. The function supports both fixed-interval\n    spacing along the x-axis and derivative-based breakpoint spacing.\n\n    Parameters:\n    --------\n    - segment_dict (dict, optional): A dictionary specifying exponential segments. Each key maps to a sub-dictionary with:\n\n        - `'x1'`, `'y1'`: Starting point of the segment\n        - `'x2'`, `'y2'`: Ending point of the segment\n        - `'rho'`: Curvature parameter controlling steepness of the segment\n        - `'r'` (optional): Number of breakpoints for this segment\n    - num_breakpoints (int, optional): Overrides the per-segment breakpoint count. Distributes breakpoints equally if specified.\n    - derivative_locations (bool, optional): If True, breakpoints are spaced using derivative intervals\n      instead of uniform spacing on the x-axis.\n\n    Returns:\n    --------\n    - a (np.ndarray): Array of breakpoint locations (measures) on the x-axis.\n    - fhat (np.ndarray): Array of function values at those breakpoint locations.\n\n    Examples:\n    --------\n    ```python\n    segment_def = {\n        1: {'x1': 0, 'y1': 0, 'x2': 0.5, 'y2': 1, 'rho': 0.1, 'r': 10},\n        2: {'x1': 0.5, 'y1': 1, 'x2': 1, 'y2': 0, 'rho': -0.1, 'r': 10}\n    }\n    a, fhat = value_function_builder(segment_def, num_breakpoints=20, derivative_locations=False)\n    ```\n\n    See Also:\n    --------\n    - [`exponential_function`](../../../../afccp/reference/data/values/#data.values.exponential_function):\n      Computes the value for an exponential segment at a given x.\n    - [`derivative_function`](../../../../afccp/reference/data/values/#data.values.derivative_function):\n      Returns the derivative of the exponential function at a given x.\n    - [`inverse_derivative_function`](../../../../afccp/reference/data/values/#data.values.inverse_derivative_function):\n      Finds the x-value corresponding to a specific derivative magnitude for exponential functions.\n    \"\"\"\n\n    if segment_dict is None:\n        segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': 0.2, 'y2': 0.8, 'rho': -0.2, 'r': 10},\n                        2: {'x1': 0.2, 'y1': 0.8, 'x2': 0.3, 'y2': 1, 'rho': 0.2, 'r': 10},\n                        3: {'x1': 0.5, 'y1': 1, 'x2': 0.7, 'y2': 0.8, 'rho': 0.2, 'r': 10},\n                        4: {'x1': 0.7, 'y1': 0.8, 'x2': 1, 'y2': 0, 'rho': -0.2, 'r': 10}}\n\n    # Collect segments\n    segments = list(segment_dict.keys())\n    num_segments = len(segments)\n\n    # We need number of breakpoints for each exponential segment\n    if num_breakpoints is None:\n        num_breakpoints = 0\n        for segment in segments:\n            if 'r' in segment_dict[segment].keys():\n                segment_dict[segment]['r'] = segment_dict[segment]['r']\n            else:\n                segment_dict[segment]['r'] = 10\n\n            num_breakpoints += segment_dict[segment]['r']\n\n    else:\n        new_num_breakpoints = 0\n        for segment in segments:\n            if 'r' in segment_dict[segment].keys():\n                segment_dict[segment]['r'] = max(int(num_breakpoints / num_segments), segment_dict[segment]['r'])\n            else:\n                segment_dict[segment]['r'] = int(num_breakpoints / num_segments)\n            new_num_breakpoints += segment_dict[segment]['r']\n        num_breakpoints = new_num_breakpoints\n\n    # Number of breakpoints are determined based on which kinds of exponential segments we're using\n    add_bp = False\n    extra = False\n    insert = False\n    if (num_segments == 4 and segment_dict[2]['x2'] != segment_dict[3]['x1']) or num_segments == 2:\n        a = np.zeros(num_breakpoints + 2)\n        fhat = np.zeros(num_breakpoints + 2)\n        extra = True\n    elif num_segments == 1 and segment_dict[1]['x2'] &lt; 1:\n        a = np.zeros(num_breakpoints + 2)\n        fhat = np.zeros(num_breakpoints + 2)\n        add_bp = True\n    elif num_segments == 1 and segment_dict[1]['x1'] != 0:\n        a = np.zeros(num_breakpoints + 2)\n        fhat = np.zeros(num_breakpoints + 2)\n        fhat[0] = 1\n        insert = True\n    else:\n        a = np.zeros(num_breakpoints + 1)\n        fhat = np.zeros(num_breakpoints + 1)\n\n    # Loop through each exponential segment\n    i = 1\n    for segment in segments:\n\n        # Load variables\n        x1 = segment_dict[segment]['x1']\n        y1 = segment_dict[segment]['y1']\n        x2 = segment_dict[segment]['x2']\n        y2 = segment_dict[segment]['y2']\n        rho = segment_dict[segment]['rho']\n        r = segment_dict[segment]['r']\n\n        # Necessary operations\n        x_diff = x2 - x1\n        y_diff = y2 - y1\n        x_over_y = abs(x_diff / y_diff)\n        if y_diff &lt; 0:\n            positive = False\n        else:\n            positive = True\n\n        if derivative_locations:  # We place x breakpoints at fixed intervals based on derivative\n            y_prime_i = round(derivative_function(0, x_over_y, rho, positive), 2)\n            y_prime_f = round(derivative_function(x_over_y, x_over_y, rho, positive), 2)\n            y_prime_step = (y_prime_f - y_prime_i) / r\n            y_prime_arr = np.array([y_prime_i + y_prime_step * i for i in range(1, r + 1)])\n            x_arr = np.array([\n                inverse_derivative_function(y_prime, x_over_y, rho, positive) for y_prime in y_prime_arr])\n\n        else:  # We place them at fixed intervals based on x\n            x_arr = (np.arange(1, r + 1) / r) * x_over_y\n\n        vals = np.array([exponential_function(x, 0, x_over_y, rho, positive) for x in x_arr])\n\n        # If we need to add extra breakpoints\n        if y1 == 1 and extra:\n            a[i] = x1\n            fhat[i] = 1\n            i += 1\n\n        if insert:\n            a[1] = x1\n            fhat[1] = 1\n            a[2:2 + r] = x1 + x_arr * abs(y_diff)\n            fhat[2:2 + r] = y2 + vals * abs(y_diff)\n        else:\n            a[i:i + r] = x1 + x_arr * abs(y_diff)\n            if positive:\n                fhat[i:i + r] = y1 + vals * y_diff\n            else:\n                fhat[i:i + r] = y2 + vals * abs(y_diff)\n            i += r\n\n            if add_bp:\n                a[r + 1] = 1\n                fhat[r + 1] = 1\n\n    # Return breakpoint measures and values used in value function\n    a = np.around(a, 5)\n    fhat = np.around(fhat, 5)\n    return a, fhat\n</code></pre>"},{"location":"reference/data/values/#data.values.exponential_function","title":"<code>exponential_function(x, x_i, x_f, rho, positive)</code>","text":"<p>This function returns the value obtained from the specified exponential value function</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>current x</p> required <code>x_i</code> <p>initial x from segment</p> required <code>x_f</code> <p>final x from segment</p> required <code>rho</code> <p>rho parameter</p> required <code>positive</code> <p>if we have an increasing function or not</p> required <p>Returns:</p> Type Description <p>current y</p> Source code in <code>afccp/data/values.py</code> <pre><code>def exponential_function(x, x_i, x_f, rho, positive):\n    \"\"\"\n    This function returns the value obtained from the specified exponential value function\n    :param x: current x\n    :param x_i: initial x from segment\n    :param x_f: final x from segment\n    :param rho: rho parameter\n    :param positive: if we have an increasing function or not\n    :return: current y\n    \"\"\"\n    if positive:\n        y = (1 - exp(-(x - x_i) / rho)) / \\\n            (1 - exp(-(x_f - x_i) / rho))\n    else:\n\n        y = (1 - exp(-(x_f - x) / rho)) / \\\n            (1 - exp(-(x_f - x_i) / rho))\n\n    return y\n</code></pre>"},{"location":"reference/data/values/#data.values.derivative_function","title":"<code>derivative_function(x, x_f, rho, positive)</code>","text":"<p>This function calculates the derivative of x for some point along a line segment</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>some x</p> required <code>x_f</code> <p>final x from segment</p> required <code>rho</code> <p>rho parameter</p> required <code>positive</code> <p>if we have an increasing function or not</p> required <p>Returns:</p> Type Description <p>y_prime</p> Source code in <code>afccp/data/values.py</code> <pre><code>def derivative_function(x, x_f, rho, positive):\n    \"\"\"\n    This function calculates the derivative of x for some point\n    along a line segment\n    :param x: some x\n    :param x_f: final x from segment\n    :param rho: rho parameter\n    :param positive: if we have an increasing function or not\n    :return: y_prime\n    \"\"\"\n    if positive:\n        y_prime = exp(-x / rho) / (rho * (1 - exp(-x_f / rho)))\n    else:\n        y_prime = -exp(-(x_f - x) / rho) / (rho * (1 - exp(-x_f / rho)))\n    return y_prime\n</code></pre>"},{"location":"reference/data/values/#data.values.inverse_derivative_function","title":"<code>inverse_derivative_function(y_prime, x_f, rho, positive)</code>","text":"<p>This function calculates the position of x based on its derivative</p> <p>Parameters:</p> Name Type Description Default <code>y_prime</code> <p>first derivative of x</p> required <code>x_f</code> <p>final x from segment</p> required <code>rho</code> <p>rho parameter</p> required <code>positive</code> <p>if we have an increasing function or not</p> required <p>Returns:</p> Type Description <p>x</p> Source code in <code>afccp/data/values.py</code> <pre><code>def inverse_derivative_function(y_prime, x_f, rho, positive):\n    \"\"\"\n    This function calculates the position of x based on its derivative\n    :param y_prime: first derivative of x\n    :param x_f: final x from segment\n    :param rho: rho parameter\n    :param positive: if we have an increasing function or not\n    :return: x\n    \"\"\"\n    if positive:\n        x = -rho * log(rho * (1 - exp(-x_f / rho)) * y_prime)\n    else:\n        x = x_f + rho * log(-rho * (1 - exp(-x_f / rho)) * y_prime)\n\n    return x\n</code></pre>"},{"location":"reference/data/values/#data.values.condense_value_functions","title":"<code>condense_value_functions(parameters, value_parameters)</code>","text":"<p>Remove Redundant Zero Segments in Value Functions.</p> <p>This procedure cleans up the value function breakpoints (<code>a</code>, <code>f^hat</code>) by removing unnecessary internal segments where the value remains zero, which do not affect the overall utility calculation but may clutter the optimization model.</p>"},{"location":"reference/data/values/#data.values.condense_value_functions--parameters","title":"Parameters:","text":"<ul> <li>parameters (dict): Dictionary of cadet/AFSC parameters (e.g., <code>J</code>, <code>K^A</code>, etc.).</li> <li> <p>value_parameters (dict): Dictionary of value and weight parameter arrays, including:</p> <ul> <li><code>a</code>: Breakpoint measures (list of lists by AFSC and objective index)</li> <li><code>f^hat</code>: Breakpoint values (list of lists by AFSC and objective index)</li> </ul> </li> </ul>"},{"location":"reference/data/values/#data.values.condense_value_functions--returns","title":"Returns:","text":"<ul> <li>value_parameters (dict): Updated dictionary with condensed <code>a</code> and <code>f^hat</code> arrays,   where redundant zero-valued breakpoints have been removed.</li> </ul>"},{"location":"reference/data/values/#data.values.condense_value_functions--examples","title":"Examples:","text":"<pre><code>new_value_parameters = condense_value_functions(parameters, value_parameters)\n</code></pre> Source code in <code>afccp/data/values.py</code> <pre><code>def condense_value_functions(parameters, value_parameters):\n    \"\"\"\n    Remove Redundant Zero Segments in Value Functions.\n\n    This procedure cleans up the value function breakpoints (`a`, `f^hat`) by removing\n    unnecessary internal segments where the value remains zero, which do not affect\n    the overall utility calculation but may clutter the optimization model.\n\n    Parameters:\n    --------\n    - parameters (dict): Dictionary of cadet/AFSC parameters (e.g., `J`, `K^A`, etc.).\n    - value_parameters (dict): Dictionary of value and weight parameter arrays, including:\n\n        - `a`: Breakpoint measures (list of lists by AFSC and objective index)\n        - `f^hat`: Breakpoint values (list of lists by AFSC and objective index)\n\n    Returns:\n    --------\n    - value_parameters (dict): Updated dictionary with condensed `a` and `f^hat` arrays,\n      where redundant zero-valued breakpoints have been removed.\n\n    Examples:\n    --------\n    ```python\n    new_value_parameters = condense_value_functions(parameters, value_parameters)\n    ```\n    \"\"\"\n\n    # Shorthand\n    p, vp = parameters, value_parameters\n    for j in p['J']:\n        for k in vp['K^A'][j]:\n            a = np.array(vp['a'][j][k])\n            fhat = np.array(vp['f^hat'][j][k])\n\n            # Find unnecessary zeros\n            zero_indices = np.where(fhat == 0)[0]\n            last_i = len(a) - 1\n            removals = []\n            for i in zero_indices:\n                if i + 1 in zero_indices and i + 1 != last_i and i != 0:\n                    removals.append(i)\n\n            # Remove unnecessary zeros\n            vp['a'][j][k] = np.delete(a, removals)\n            vp['f^hat'][j][k] = np.delete(fhat, removals)\n\n    return vp\n</code></pre>"},{"location":"reference/data/values/#data.values.compare_value_parameters","title":"<code>compare_value_parameters(parameters, vp1, vp2, vp1name, vp2name, printing=False)</code>","text":"<p>Compare Two Sets of Value Parameters for Equality.</p> <p>This function compares two dictionaries of value parameters used in cadet-AFSC utility modeling. It checks structural consistency (array shapes) and content equality across keys that define objective weights, constraints, value functions, and other relevant configurations.</p>"},{"location":"reference/data/values/#data.values.compare_value_parameters--parameters","title":"Parameters:","text":"<ul> <li>parameters (dict): The shared cadet-AFSC parameter dictionary used for indexing and labels.</li> <li>vp1 (dict): The first value parameter dictionary to compare.</li> <li>vp2 (dict): The second value parameter dictionary to compare.</li> <li>vp1name (str): Name label for the first value parameter set (used in print statements).</li> <li>vp2name (str): Name label for the second value parameter set (used in print statements).</li> <li>printing (bool, optional): If True, prints the first detected mismatch with context. Default is False.</li> </ul>"},{"location":"reference/data/values/#data.values.compare_value_parameters--returns","title":"Returns:","text":"<ul> <li>identical (bool): True if all structure and content matches exactly between the two value parameter sets;   False otherwise.</li> </ul>"},{"location":"reference/data/values/#data.values.compare_value_parameters--examples","title":"Examples:","text":"<pre><code>result = compare_value_parameters(p, vp_baseline, vp_candidate, 'Baseline', 'Candidate', printing=True)\nif not result:\n    print(\"Differences found between value parameter sets.\")\n</code></pre> Source code in <code>afccp/data/values.py</code> <pre><code>def compare_value_parameters(parameters, vp1, vp2, vp1name, vp2name, printing=False):\n    \"\"\"\n    Compare Two Sets of Value Parameters for Equality.\n\n    This function compares two dictionaries of value parameters used in cadet-AFSC utility modeling.\n    It checks structural consistency (array shapes) and content equality across keys that define\n    objective weights, constraints, value functions, and other relevant configurations.\n\n    Parameters:\n    --------\n    - parameters (dict): The shared cadet-AFSC parameter dictionary used for indexing and labels.\n    - vp1 (dict): The first value parameter dictionary to compare.\n    - vp2 (dict): The second value parameter dictionary to compare.\n    - vp1name (str): Name label for the first value parameter set (used in print statements).\n    - vp2name (str): Name label for the second value parameter set (used in print statements).\n    - printing (bool, optional): If True, prints the first detected mismatch with context. Default is False.\n\n    Returns:\n    --------\n    - identical (bool): True if all structure and content matches exactly between the two value parameter sets;\n      False otherwise.\n\n    Examples:\n    --------\n    ```python\n    result = compare_value_parameters(p, vp_baseline, vp_candidate, 'Baseline', 'Candidate', printing=True)\n    if not result:\n        print(\"Differences found between value parameter sets.\")\n    ```\n    \"\"\"\n    # Shorthand\n    p = parameters\n\n    # Assume identical until proven otherwise\n    identical = True\n\n    # Loop through each value parameter key\n    for key in vp1:\n\n        if np.shape(vp1[key]) != np.shape(vp2[key]):\n            if printing:\n                print(vp1name + ' and ' + vp2name + ' not the same. ' + key + ' is a different size.')\n            identical = False\n            break\n\n        if key in ['afscs_overall_weight', 'cadets_overall_weight', 'cadet_weight_function', 'afsc_weight_function',\n                   'cadets_overall_value_min', 'afscs_overall_value_min']:\n            if vp1[key] != vp2[key]:\n                if printing:\n                    print(vp1name + ' and ' + vp2name + ' not the same. ' + key + ' is different.')\n                identical = False\n                break\n\n        elif key in ['afsc_value_min', 'cadet_value_min', 'objective_value_min', 'value_functions', 'objective_target',\n                     'objective_weight', 'afsc_weight', 'cadet_weight', 'I^C', 'J^C', 'value_functions',\n                     'constraint_type']:\n            if key not in ['objective_value_min', 'value_functions']:\n                vp_1_arr, vp_2_arr = np.ravel(np.around(vp1[key], 4)), np.ravel(np.around(vp2[key], 4))\n            else:\n                vp_1_arr, vp_2_arr = np.ravel(vp1[key]), np.ravel(vp2[key])\n\n            diff_arr = np.array([vp_1_arr[i] != vp_2_arr[i] for i in range(len(vp_1_arr))])\n            if sum(diff_arr) != 0 and (vp1[key] != [] or vp2[key] != []):\n                if printing:\n                    print(vp1name + ' and ' + vp2name + ' not the same. ' + key + ' is different.')\n                identical = False\n                break\n\n        elif key == 'a':  # Check the breakpoints\n\n            for j in p['J']:\n                afsc = p[\"afscs\"][j]\n                for k in vp1['K^A'][j]:\n                    objective = vp1[\"objectives\"][k]\n                    for l in vp1['L'][j][k]:\n                        try:\n                            if vp1[key][j][k][l] != vp2[key][j][k][l]:\n                                identical = False\n                                if printing:\n                                    print(vp1name + ' and ' + vp2name + ' not the same. '\n                                                                        'Breakpoints are different for AFSC ' + afsc +\n                                          ' Objective ' + objective + '.')\n                                    print(vp1name + \":\", vp1[key][j][k])\n                                    print(vp2name + \":\", vp2[key][j][k])\n                                break\n                        except:  # If there was a range error, then the breakpoints are not the same\n                            identical = False\n                            if printing:\n                                print(vp1name + ' and ' + vp2name + ' not the same. '\n                                                                    'Breakpoints are different for AFSC ' + afsc +\n                                      ' Objective ' + objective + '.')\n                                print(vp1name + \":\", vp1[key][j][k])\n                                print(vp2name + \":\", vp2[key][j][k])\n                            break\n                    if not identical:\n                        break\n                if not identical:\n                    break\n            if not identical:\n                break\n\n    if identical and printing:\n        print(vp1name + ' and ' + vp2name + ' are the same.')\n\n    return identical\n</code></pre>"},{"location":"reference/data/values/#data.values.translate_vft_to_gp_parameters","title":"<code>translate_vft_to_gp_parameters(instance)</code>","text":"<p>Translates VFT (Value-Focused Thinking) Parameters to Goal Programming (GP) Model Parameters.</p> <p>This function maps the VFT-based cadet-AFSC assignment model parameters stored in a <code>CadetCareerProblem</code> instance into a format suitable for a separate goal programming model structure (e.g., Rebecca's model). It builds constraint sets, cadet eligibility mappings, parameter values, and associated reward/penalty weights.</p>"},{"location":"reference/data/values/#data.values.translate_vft_to_gp_parameters--parameters","title":"Parameters","text":"<ul> <li> <p>instance : CadetCareerProblem     An instance containing:</p> <ul> <li><code>parameters</code> (dict): Core cadet and AFSC parameter structures.</li> <li><code>value_parameters</code> (dict): Weighting schemes, objective values, and constraints.</li> <li><code>gp_df</code> (DataFrame): Reward and penalty configurations used in GP model.</li> </ul> </li> </ul>"},{"location":"reference/data/values/#data.values.translate_vft_to_gp_parameters--returns","title":"Returns","text":"<ul> <li> <p>gp : dict A dictionary of goal programming model parameters with the following structure:</p> </li> <li> <p>Sets: <code>A</code>, <code>C</code>, <code>A^</code>, <code>C^</code> for AFSCs and Cadets by constraint type.</p> </li> <li>Parameters: <code>param</code> for bounds and targets, <code>utility</code>, <code>merit</code>, <code>Big_M</code>, <code>u_limit</code>.</li> <li>Reward/Penalty: <code>lam^</code>, <code>mu^</code> representing incentive structures.</li> <li>Constraint Types: <code>con</code> defines the list of all modeled constraints.</li> </ul>"},{"location":"reference/data/values/#data.values.translate_vft_to_gp_parameters--notes","title":"Notes","text":"<ul> <li>The model assumes AFSCs are indexed by <code>A</code> (0 to M-1), cadets by <code>C</code> (0 to N-1).</li> <li> <p>Constraint types include:</p> <ul> <li><code>T</code>: Target quotas (min)</li> <li><code>F</code>: Over-classification limits (max)</li> <li><code>M</code>, <code>D_under</code>, <code>D_over</code>, <code>P</code>: Education tier constraints</li> <li><code>U_under</code>, <code>U_over</code>: Bounds on USAFA proportions</li> <li><code>R_under</code>, <code>R_over</code>: Percentile constraints (e.g., merit)</li> <li><code>W</code>: Minimum preference coverage</li> <li>Cadets\u2019 eligible and expressed-preference AFSCs are stored in <code>A^['E']</code> and <code>A^['W^E']</code>.</li> <li><code>lam^['S']</code> rewards assignments that match cadet preferences in order of merit.</li> <li>Constraint-specific cadet sets are available via <code>C^[con]</code>, e.g., <code>C^['D_under']</code>.</li> </ul> </li> </ul>"},{"location":"reference/data/values/#data.values.translate_vft_to_gp_parameters--examples","title":"Examples","text":"<pre><code>gp_parameters = translate_vft_to_gp_parameters(instance)\n</code></pre> Source code in <code>afccp/data/values.py</code> <pre><code>def translate_vft_to_gp_parameters(instance):\n    \"\"\"\n    Translates VFT (Value-Focused Thinking) Parameters to Goal Programming (GP) Model Parameters.\n\n    This function maps the VFT-based cadet-AFSC assignment model parameters stored in a `CadetCareerProblem`\n    instance into a format suitable for a separate goal programming model structure (e.g., Rebecca's model).\n    It builds constraint sets, cadet eligibility mappings, parameter values, and associated reward/penalty weights.\n\n    Parameters\n    --------\n    - instance : CadetCareerProblem\n        An instance containing:\n\n        - `parameters` (dict): Core cadet and AFSC parameter structures.\n        - `value_parameters` (dict): Weighting schemes, objective values, and constraints.\n        - `gp_df` (DataFrame): Reward and penalty configurations used in GP model.\n\n    Returns\n    --------\n    - gp : dict\n    A dictionary of goal programming model parameters with the following structure:\n\n    - Sets: `A`, `C`, `A^`, `C^` for AFSCs and Cadets by constraint type.\n    - Parameters: `param` for bounds and targets, `utility`, `merit`, `Big_M`, `u_limit`.\n    - Reward/Penalty: `lam^`, `mu^` representing incentive structures.\n    - Constraint Types: `con` defines the list of all modeled constraints.\n\n    Notes\n    --------\n    - The model assumes AFSCs are indexed by `A` (0 to M-1), cadets by `C` (0 to N-1).\n    - Constraint types include:\n\n        - `T`: Target quotas (min)\n        - `F`: Over-classification limits (max)\n        - `M`, `D_under`, `D_over`, `P`: Education tier constraints\n        - `U_under`, `U_over`: Bounds on USAFA proportions\n        - `R_under`, `R_over`: Percentile constraints (e.g., merit)\n        - `W`: Minimum preference coverage\n    - Cadets\u2019 eligible and expressed-preference AFSCs are stored in `A^['E']` and `A^['W^E']`.\n    - `lam^['S']` rewards assignments that match cadet preferences in order of merit.\n    - Constraint-specific cadet sets are available via `C^[con]`, e.g., `C^['D_under']`.\n\n    Examples\n    --------\n    ```python\n    gp_parameters = translate_vft_to_gp_parameters(instance)\n    ```\n    \"\"\"\n\n    # Shorthand\n    p = instance.parameters\n    vp = instance.value_parameters\n    objectives = vp['objectives']\n\n    # Other parameters\n    large_afscs = np.where(p['pgl'] &gt;= 40)[0]  # set of large AFSCs\n    mand_k = np.where(objectives == 'Mandatory')[0][0]  # mandatory objective index\n    des_k = np.where(objectives == 'Desired')[0][0]  # desired objective index\n    perm_k = np.where(objectives == 'Permitted')[0][0]  # permitted objective index\n    usafa_k = np.where(objectives == 'USAFA Proportion')[0][0]  # USAFA proportion objective index\n\n    # Initialize \"gp\" dictionary (Goal Programming Model Parameters)\n    gp = {}\n\n    # Main sets\n    A = np.arange(p['M'])\n    C = np.arange(p['N'])\n    gp['A'], gp['M'] = A, len(A)  # AFSCs, number of AFSCs\n    gp['C'], gp['N'] = C, len(C)  # Cadets, number of Cadets\n\n    # List of constraints\n    gp['con'] = ['T',  # Target constraint\n                 'F',  # Over-classification constraint\n                 'M',  # Mandatory education constraint\n                 'D_under',  # Desired education constraint (lower bound)\n                 'D_over',  # Desired education constraint (upper bound)\n                 'P',  # Permitted education constraint\n                 'U_under',  # USAFA proportion constraint (lower bound)\n                 'U_over',  # USAFA proportion constraint (upper bound)\n                 'R_under',  # Percentile constraint (lower bound)\n                 'R_over',  # Percentile constraint (upper bound)\n                 'W']  # Cadet preference constraint\n\n    # Subsets of AFSCs that pertain to each constraint (1 dimensional arrays)\n    gp['A^'] = {'T': A,  # Subset of AFSCs with a minimum target quota: assumed all AFSCs\n                'F': A,  # Subset of AFSCs with over-classification limits: assumed all AFSCs\n                'M': np.array([a for a in A if 'Mandatory' in objectives[vp['K^A'][a]]]),  # Mandatory AFSCs\n                'D_under': np.array([a for a in A if 'Increasing' in vp['value_functions'][a, des_k]]),  # Desired AFSCs\n                'D_over': np.array([a for a in A if 'Decreasing' in vp['value_functions'][a, des_k]]),  # Desired AFSCs\n                'P': np.array([a for a in A if 'Permitted' in objectives[vp['K^A'][a]]]),  # Permitted AFSCs\n                'U_under': large_afscs,  # USAFA Proportion constrained AFSCs\n                'U_over': large_afscs,  # USAFA Proportion constrained AFSCs\n                'R_under': large_afscs,  # Percentile constrained AFSCs\n                'R_over': large_afscs,  # Percentile constrained AFSCs\n                'W': A}  # Subset of AFSCs with a cadet preference constraint: assumed all AFSCs\n\n    # Subset of AFSCs for which each cadet is eligible (Replaced A | A^I)\n    gp['A^']['E'] = p['J^E']\n\n    # Subset of AFSCs that each cadet has placed a preference for\n    A_Utility = [np.where(p['utility'][c, :] &gt; 0)[0] for c in C]\n\n    # Subset of AFSCs that each cadet has placed a preference for and is also eligible for\n    gp['A^']['W^E'] = [np.intersect1d(A_Utility[c], gp['A^']['E'][c]) for c in C]\n\n    # Subset of AFSCs which have an upper bound on the number of USAFA cadets\n    gp['A^']['U_lim'] = np.array([a for a in A if ',' in vp['objective_value_min'][a, usafa_k]])\n\n    # Set of cadets that have placed preferences on each of the AFSCs\n    C_Utility = [np.where(p['utility'][:, a] &gt; 0)[0] for a in A]\n\n    # Subsets of Cadets that pertain to each constraint  (2 dimensional arrays)\n    gp['C^'] = {'T': p['I^E'],  # Eligible Cadets for each AFSC\n                'F': p['I^E'],  # Eligible Cadets for each AFSC\n                'M': p['I^D']['Mandatory'],  # Cadets that have mandatory degrees for each AFSC\n                'D_under': p['I^D']['Desired'],  # Cadets that have desired degrees for each AFSC\n                'D_over': p['I^D']['Desired'],  # Cadets that have desired degrees for each AFSC\n                'P': p['I^D']['Permitted'],  # Cadets that have permitted degrees for each AFSC\n                'U_under': p['I^D']['USAFA Proportion'],  # Eligible USAFA Cadets for each AFSC\n                'U_over': p['I^D']['USAFA Proportion'],  # Eligible USAFA Cadets for each AFSC\n                'R_under': p['I^E'],  # Eligible Cadets for each AFSC\n                'R_over': p['I^E'],  # Eligible Cadets for each AFSC\n\n                # Eligible Cadets that have placed preferences for each AFSC\n                'W': [np.intersect1d(C_Utility[a], p['I^E'][a]) for a in A]}\n\n    # Subset of eligible cadets for each AFSC\n    gp['C^']['E'] = p['I^E']\n\n    # Subset of eligible usafa cadets for each AFSC\n    gp['C^']['U'] = p['I^D']['USAFA Proportion']\n\n    # Parameters for each of the constraints (1 dimensional arrays)\n    gp['param'] = {'T': p['quota_min'],  # Target quotas\n                   'F': p['quota_max'],  # Over-classification amounts\n                   'M': vp['objective_target'][:, mand_k],  # Mandatory targets\n                   'D_under': vp['objective_target'][:, des_k],  # Desired targets\n                   'D_over': vp['objective_target'][:, des_k],  # Desired targets\n                   'P': vp['objective_target'][:, perm_k],  # Permitted targets\n                   'U_under': np.repeat(0.2, p['M']),  # USAFA Proportion lower bound\n                   'U_over': np.repeat(0.4, p['M']),  # USAFA Proportion upper bound\n                   'R_under': np.repeat(0.35, p['M']),  # Percentile lower bound\n                   'R_over': np.repeat(0.65, p['M']),  # Percentile upper bound\n                   'W': np.repeat(0.5, p['M'])}  # Cadet preference lower bound\n\n    # Other parameters\n    gp['utility'] = p['utility']  # utility matrix (replaced \"w\" since \"w\" was already a parameter in her model)\n    gp['Big_M'] = 2000  # sufficiently large number\n    gp['u_limit'] = 0.05  # limit on number of USAFA cadets for certain AFSCs\n    gp['merit'] = p['merit']  # cadet percentiles\n\n    # Penalty and Reward parameters\n    columns = ['Normalized Penalty', 'Normalized Reward', 'Run Penalty', 'Run Reward']\n    column_dict = {column: np.array(instance.gp_df[column]) for column in columns}\n\n    # actual reward parameters\n    reward = column_dict['Normalized Reward'] * column_dict['Run Reward']\n\n    # actual penalty parameters\n    penalty = column_dict['Normalized Penalty'] * column_dict['Run Penalty']\n\n    # mu parameters (Penalties)\n    gp['mu^'] = {con: penalty[index] for index, con in enumerate(gp['con'])}\n\n    # lambda parameters (Rewards)\n    gp['lam^'] = {con: reward[index] for index, con in enumerate(gp['con'])}\n    gp['lam^']['S'] = reward[len(gp['con'])]  # extra reward for preference in order of merit\n\n    return gp\n</code></pre>"},{"location":"reference/data/generation/basic/","title":"Generation- 'Basic'","text":""},{"location":"reference/data/generation/basic/#data.generation.basic","title":"<code>data.generation.basic</code>","text":""},{"location":"reference/data/generation/basic/#data.generation.basic.generate_random_instance","title":"<code>generate_random_instance(N=1600, M=32, P=6, S=6, generate_only_nrl=False, generate_extra=False)</code>","text":"<p>This procedure takes in the specified parameters (defined below) and then simulates new random \"fixed\" cadet/AFSC input parameters. These parameters are then returned and can be used to solve the VFT model.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>number of cadets</p> <code>1600</code> <code>M</code> <p>number of AFSCs</p> <code>32</code> <code>P</code> <p>number of preferences allowed</p> <code>6</code> <code>S</code> <p>number of Bases</p> <code>6</code> <code>generate_only_nrl</code> <p>Only generate NRL AFSCs (default to False)</p> <code>False</code> <code>generate_extra</code> <p>Whether to generate extra components (bases/IST). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>model fixed parameters</p> Source code in <code>afccp/data/generation/basic.py</code> <pre><code>def generate_random_instance(N=1600, M=32, P=6, S=6, generate_only_nrl=False, generate_extra=False):\n    \"\"\"\n    This procedure takes in the specified parameters (defined below) and then simulates new random \"fixed\" cadet/AFSC\n    input parameters. These parameters are then returned and can be used to solve the VFT model.\n    :param N: number of cadets\n    :param M: number of AFSCs\n    :param P: number of preferences allowed\n    :param S: number of Bases\n    :param generate_only_nrl: Only generate NRL AFSCs (default to False)\n    :param generate_extra: Whether to generate extra components (bases/IST). Defaults to False.\n    :return: model fixed parameters\n    \"\"\"\n\n    # Initialize parameter dictionary\n    # noinspection PyDictCreation\n    p = {'N': N, 'P': P, 'M': M, 'num_util': P, 'cadets': np.arange(N),\n         'usafa': np.random.choice([0, 1], size=N, p=[2 / 3, 1 / 3]), 'merit': np.random.rand(N)}\n\n    # Generate various features of the cadets\n    p['merit_all'] = p['merit']\n    p['assigned'] = np.array(['' for _ in range(N)])\n    p['soc'] = np.array(['USAFA' for _ in range(p['N'])])\n    p['soc'][np.where(p['usafa'] == 0)[0]] = 'ROTC'\n\n    # Calculate quotas for each AFSC\n    p['pgl'], p['usafa_quota'], p['rotc_quota'] = np.zeros(M), np.zeros(M), np.zeros(M)\n    p['quota_min'], p['quota_max'] = np.zeros(M), np.zeros(M)\n    p['quota_e'], p['quota_d'] = np.zeros(M), np.zeros(M)\n    for j in range(M):\n\n        # Get PGL target\n        p['pgl'][j] = max(10, np.random.normal(1000 / M, 100))\n\n    # Scale PGL and force integer values and minimum of 1\n    p['pgl'] = np.around((p['pgl'] / np.sum(p['pgl'])) * N * 0.8)\n    indices = np.where(p['pgl'] == 0)[0]\n    p['pgl'][indices] = 1\n\n    # Sort PGL by size\n    p['pgl'] = np.sort(p['pgl'])[::-1]\n\n    # USAFA/ROTC Quotas\n    p['usafa_quota'] = np.around(np.random.rand(M) * 0.3 + 0.1 * p['pgl'])\n    p['rotc_quota'] = p['pgl'] - p['usafa_quota']\n\n    # Min/Max\n    p['quota_min'], p['quota_max'] = p['pgl'], np.around(p['pgl'] * (1 + np.random.rand(M) * 0.9))\n\n    # Target is a random integer between the minimum and maximum targets\n    target = np.around(p['quota_min'] + np.random.rand(M) * (p['quota_max'] - p['quota_min']))\n    p['quota_e'], p['quota_d'] = target, target\n\n    # Generate AFSCs\n    p['afscs'] = np.array(['R' + str(j + 1) for j in range(M)])\n\n    # Determine what \"accessions group\" each AFSC is in\n    if generate_only_nrl:\n        p['acc_grp'] = np.array([\"NRL\" for _ in range(M)])\n    else:\n\n        # If there are 3 or more AFSCs, we want all three accessions groups represented\n        if M &gt;= 3:\n            invalid = True\n            while invalid:\n\n                # If we have 6 or fewer, limit USSF to just one AFSC\n                if M &lt;= 6:\n                    p['acc_grp'] = ['USSF']\n                    for _ in range(M - 1):\n                        p['acc_grp'].append(np.random.choice(['NRL', 'Rated']))\n                else:\n                    p['acc_grp'] = [np.random.choice(['NRL', 'Rated', 'USSF']) for _ in range(M)]\n\n                # Make sure we have at least one AFSC from each accession's group\n                invalid = False  # \"Innocent until proven guilty\"\n                for grp in ['NRL', 'Rated', 'USSF']:\n                    if grp not in p['acc_grp']:\n                        invalid = True\n                        break\n\n                # If we have 4 or more AFSCs, make sure we have at least two Rated\n                if M &gt;= 4:\n                    if p['acc_grp'].count('Rated') &lt; 2:\n                        invalid = True\n            p['acc_grp'] = np.array(p['acc_grp'])  # Convert to numpy array\n\n        # If we only have one or two AFSCs, they'll all be NRL\n        else:\n            p['acc_grp'] = np.array([\"NRL\" for _ in range(M)])\n\n    # Add an \"*\" to the list of AFSCs to be considered the \"Unmatched AFSC\"\n    p[\"afscs\"] = np.hstack((p[\"afscs\"], \"*\"))\n\n    # Add degree tier qualifications to the set of parameters\n    def generate_degree_tier_qualifications():\n        \"\"\"\n        I made this nested function, so I could have a designated section to generate degree qualifications and such\n        \"\"\"\n\n        # Determine degree tiers and qualification information\n        p['qual'] = np.array([['P1' for _ in range(M)] for _ in range(N)])\n        p['Deg Tiers'] = np.array([[' ' * 10 for _ in range(4)] for _ in range(M)])\n        for j in range(M):\n\n            if p['acc_grp'][j] == 'Rated':  # All Degrees eligible for Rated\n                p['qual'][:, j] = np.array(['P1' for _ in range(N)])\n                p['Deg Tiers'][j, :] = ['P = 1', 'I = 0', '', '']\n\n                # Pick 20% of the cadets at random to be ineligible for this Rated AFSC\n                indices = random.sample(list(np.arange(N)), k=int(0.2 * N))\n                p['qual'][indices, j] = 'I2'\n            else:\n                # Determine what tiers to use on this AFSC\n                if N &lt; 100:\n                    random_number = np.random.rand()\n                    if random_number &lt; 0.2:\n                        tiers = ['M1', 'I2']\n                        p['Deg Tiers'][j, :] = ['M = 1', 'I = 0', '', '']\n                    elif 0.2 &lt; random_number &lt; 0.4:\n                        tiers = ['D1', 'P2']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['D &gt; ' + str(target_num), 'P &lt; ' + str(1 - target_num), '', '']\n                    elif 0.4 &lt; random_number &lt; 0.6:\n                        tiers = ['P1']\n                        p['Deg Tiers'][j, :] = ['P = 1', '', '', '']\n                    else:\n                        tiers = ['M1', 'P2']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num), 'P &lt; ' + str(1 - target_num), '', '']\n                else:\n                    random_number = np.random.rand()\n                    if random_number &lt; 0.1:\n                        tiers = ['M1', 'I2']\n                        p['Deg Tiers'][j, :] = ['M = 1', 'I = 0', '', '']\n                    elif 0.1 &lt; random_number &lt; 0.2:\n                        tiers = ['D1', 'P2']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['D &gt; ' + str(target_num), 'P &lt; ' + str(1 - target_num), '', '']\n                    elif 0.2 &lt; random_number &lt; 0.3:\n                        tiers = ['P1']\n                        p['Deg Tiers'][j, :] = ['P = 1', '', '', '']\n                    elif 0.3 &lt; random_number &lt; 0.4:\n                        tiers = ['M1', 'P2']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num), 'P &lt; ' + str(1 - target_num), '', '']\n                    elif 0.4 &lt; random_number &lt; 0.5:\n                        tiers = ['M1', 'D2', 'P3']\n                        target_num_1 = round(np.random.rand() * 0.7, 2)\n                        target_num_2 = round(np.random.rand() * (1 - target_num_1) * 0.8, 2)\n                        target_num_3 = round(1 - target_num_1 - target_num_2, 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num_1), 'D &gt; ' + str(target_num_2),\n                                                'P &lt; ' + str(target_num_3), '']\n                    elif 0.5 &lt; random_number &lt; 0.6:\n                        tiers = ['D1', 'D2', 'P3']\n                        target_num_1 = round(np.random.rand() * 0.7, 2)\n                        target_num_2 = round(np.random.rand() * (1 - target_num_1) * 0.8, 2)\n                        target_num_3 = round(1 - target_num_1 - target_num_2, 2)\n                        p['Deg Tiers'][j, :] = ['D &gt; ' + str(target_num_1), 'D &gt; ' + str(target_num_2),\n                                                'P &lt; ' + str(target_num_3), '']\n                    elif 0.6 &lt; random_number &lt; 0.7:\n                        tiers = ['M1', 'D2', 'I3']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num), 'D &lt; ' + str(1 - target_num), 'I = 0', '']\n                    elif 0.7 &lt; random_number &lt; 0.8:\n                        tiers = ['M1', 'P2', 'I3']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num), 'P &lt; ' + str(1 - target_num), 'I = 0', '']\n                    else:\n                        tiers = ['M1', 'D2', 'P3', 'I4']\n                        target_num_1 = round(np.random.rand() * 0.7, 2)\n                        target_num_2 = round(np.random.rand() * (1 - target_num_1) * 0.8, 2)\n                        target_num_3 = round(1 - target_num_1 - target_num_2, 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num_1), 'D &gt; ' + str(target_num_2),\n                                                'P &lt; ' + str(target_num_3), 'I = 0']\n\n                # Generate the tiers for the cadets\n                c_tiers = np.random.randint(0, len(tiers), N)\n                p['qual'][:, j] = np.array([tiers[c_tiers[i]] for i in range(N)])\n\n        # NxM qual matrices with various features\n        p[\"ineligible\"] = (np.core.defchararray.find(p['qual'], \"I\") != -1) * 1\n        p[\"eligible\"] = (p[\"ineligible\"] == 0) * 1\n        for t in [1, 2, 3, 4]:\n            p[\"tier \" + str(t)] = (np.core.defchararray.find(p['qual'], str(t)) != -1) * 1\n        p[\"mandatory\"] = (np.core.defchararray.find(p['qual'], \"M\") != -1) * 1\n        p[\"desired\"] = (np.core.defchararray.find(p['qual'], \"D\") != -1) * 1\n        p[\"permitted\"] = (np.core.defchararray.find(p['qual'], \"P\") != -1) * 1\n\n        # NEW: Exception to degree qualification based on CFM ranks\n        p[\"exception\"] = (np.core.defchararray.find(p['qual'], \"E\") != -1) * 1\n\n        # Initialize information for AFSC degree tiers\n        p[\"t_count\"] = np.zeros(p['M']).astype(int)\n        p[\"t_proportion\"] = np.zeros([p['M'], 4])\n        p[\"t_leq\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"&lt;\") != -1) * 1\n        p[\"t_geq\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"&gt;\") != -1) * 1\n        p[\"t_eq\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"=\") != -1) * 1\n        p[\"t_mandatory\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"M\") != -1) * 1\n        p[\"t_desired\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"D\") != -1) * 1\n        p[\"t_permitted\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"P\") != -1) * 1\n\n        # Loop through each AFSC\n        for j, afsc in enumerate(p[\"afscs\"][:p['M']]):\n\n            # Loop through each potential degree tier\n            for t in range(4):\n                val = p[\"Deg Tiers\"][j, t]\n\n                # Empty degree tier\n                if 'M' not in val and 'D' not in val and 'P' not in val and 'I' not in val:\n                # if val in [\"nan\", \"\", ''] or pd.isnull(val):\n                    t -= 1\n                    break\n\n                # Degree Tier Proportion\n                p[\"t_proportion\"][j, t] = val.split(\" \")[2]\n\n            # Num tiers\n            p[\"t_count\"][j] = t + 1\n\n        return p   # Return updated parameters\n    p = generate_degree_tier_qualifications()\n\n    # Cadet preferences\n    utility = np.random.rand(N, M)  # random utility matrix\n    max_util = np.max(utility, axis=1)\n    p['utility'] = np.around(utility / np.array([[max_util[i]] for i in range(N)]), 2)\n    p['c_preferences'], p['c_utilities'] = afccp.data.preferences.get_utility_preferences(p)\n    p['c_preferences'] = p['c_preferences'][:, :P]\n    p['c_utilities'] = p['c_utilities'][:, :P]\n\n    # Get cadet preferences\n    p[\"c_pref_matrix\"] = np.zeros([p[\"N\"], p[\"M\"]]).astype(int)\n    for i in range(p['N']):\n\n        # Sort the utilities to get the preference list\n        utilities = p[\"utility\"][i, :p[\"M\"]]\n        sorted_indices = np.argsort(utilities)[::-1]\n        preferences = np.argsort(\n            sorted_indices) + 1  # Add 1 to change from python index (at 0) to rank (start at 1)\n        p[\"c_pref_matrix\"][i, :] = preferences\n\n    # If we want to generate extra components to match with, we do so here\n    if generate_extra:\n        p['S'] = S\n        p = generate_extra_components(p)\n\n    # Update set of parameters\n    p = afccp.data.adjustments.parameter_sets_additions(p)\n\n    return p  # Return updated parameters\n</code></pre>"},{"location":"reference/data/generation/basic/#data.generation.basic.generate_random_value_parameters","title":"<code>generate_random_value_parameters(parameters, num_breakpoints=24)</code>","text":"<p>Generate Random Value Parameters for a Cadet-AFSC Assignment Problem.</p> <p>This function constructs a randomized set of value-focused thinking (VFT) parameters for a given cadet-AFSC matching instance. These include AFSC weights, cadet weights, value function definitions, and constraint structures across defined objectives. It supports a mix of manually assigned logic and randomized components and can be used to simulate plausible input conditions for testing the assignment algorithm.</p>"},{"location":"reference/data/generation/basic/#data.generation.basic.generate_random_value_parameters--parameters","title":"Parameters","text":"<p>parameters : dict     The problem instance parameters, including cadet/AFSC info, merit scores, eligibility, quotas, and utilities. num_breakpoints : int, optional     Number of breakpoints to use in piecewise linear value functions, by default 24.</p>"},{"location":"reference/data/generation/basic/#data.generation.basic.generate_random_value_parameters--returns","title":"Returns","text":"<p>dict     A dictionary <code>vp</code> containing generated value parameters, including objectives, weights, constraints,     value functions, and breakpoints.</p>"},{"location":"reference/data/generation/basic/#data.generation.basic.generate_random_value_parameters--examples","title":"Examples","text":"<pre><code>vp = generate_random_value_parameters(parameters, num_breakpoints=16)\n</code></pre>"},{"location":"reference/data/generation/basic/#data.generation.basic.generate_random_value_parameters--see-also","title":"See Also","text":"<ul> <li><code>generate_afocd_value_parameters</code>:   Adds tiered AFOCD objectives and fills in default VFT structure for a given instance.</li> <li><code>create_segment_dict_from_string</code>:   Parses string definitions into nonlinear segment dictionaries for value functions.</li> <li><code>value_function_builder</code>:   Linearizes nonlinear value functions using a fixed number of breakpoints.</li> <li><code>cadet_weight_function</code>:   Creates weights across cadets based on merit scores and function type.</li> <li><code>afsc_weight_function</code>:   Creates weights across AFSCs based on projected gains/losses and selected function type.</li> </ul> Source code in <code>afccp/data/generation/basic.py</code> <pre><code>def generate_random_value_parameters(parameters, num_breakpoints=24):\n    \"\"\"\n    Generate Random Value Parameters for a Cadet-AFSC Assignment Problem.\n\n    This function constructs a randomized set of value-focused thinking (VFT) parameters for a given cadet-AFSC\n    matching instance. These include AFSC weights, cadet weights, value function definitions, and constraint structures\n    across defined objectives. It supports a mix of manually assigned logic and randomized components and can be\n    used to simulate plausible input conditions for testing the assignment algorithm.\n\n    Parameters\n    ----------\n    parameters : dict\n        The problem instance parameters, including cadet/AFSC info, merit scores, eligibility, quotas, and utilities.\n    num_breakpoints : int, optional\n        Number of breakpoints to use in piecewise linear value functions, by default 24.\n\n    Returns\n    -------\n    dict\n        A dictionary `vp` containing generated value parameters, including objectives, weights, constraints,\n        value functions, and breakpoints.\n\n    Examples\n    --------\n    ```python\n    vp = generate_random_value_parameters(parameters, num_breakpoints=16)\n    ```\n\n    See Also\n    --------\n    - [`generate_afocd_value_parameters`](../../../afccp/reference/data/values/#data.values.generate_afocd_value_parameters):\n      Adds tiered AFOCD objectives and fills in default VFT structure for a given instance.\n    - [`create_segment_dict_from_string`](../../../afccp/reference/data/values/#data.values.create_segment_dict_from_string):\n      Parses string definitions into nonlinear segment dictionaries for value functions.\n    - [`value_function_builder`](../../../afccp/reference/data/values/#data.values.value_function_builder):\n      Linearizes nonlinear value functions using a fixed number of breakpoints.\n    - [`cadet_weight_function`](../../../afccp/reference/data/values/#data.values.cadet_weight_function):\n      Creates weights across cadets based on merit scores and function type.\n    - [`afsc_weight_function`](../../../afccp/reference/data/values/#data.values.afsc_weight_function):\n      Creates weights across AFSCs based on projected gains/losses and selected function type.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Objective to parameters lookup dictionary (if the parameter is in \"p\", we include the objective)\n    objective_lookups = {'Norm Score': 'a_pref_matrix', 'Merit': 'merit', 'USAFA Proportion': 'usafa',\n                         'Combined Quota': 'quota_d', 'USAFA Quota': 'usafa_quota', 'ROTC Quota': 'rotc_quota',\n                         'Utility': 'utility', 'Mandatory': 'mandatory',\n                         'Desired': 'desired', 'Permitted': 'permitted'}\n    for t in [\"1\", \"2\", \"3\", \"4\"]:  # Add in AFOCD Degree tiers\n        objective_lookups[\"Tier \" + t] = \"tier \" + t\n\n    # Add the AFSC objectives that are included in this instance (check corresponding parameters using dict above)\n    objectives = np.array([objective for objective in objective_lookups if objective_lookups[objective] in p])\n\n    # Initialize set of value parameters\n    vp = {'objectives': objectives, 'cadets_overall_weight': np.random.rand(), 'O': len(objectives),\n          'K': np.arange(len(objectives)), 'num_breakpoints': num_breakpoints, 'cadets_overall_value_min': 0,\n          'afscs_overall_value_min': 0}\n    vp['afscs_overall_weight'] = 1- vp['cadets_overall_weight']\n\n    # Generate AFSC and cadet weights\n    weight_functions = ['Linear', 'Direct', 'Curve_1', 'Curve_2', 'Equal']\n    vp['cadet_weight_function'] = np.random.choice(weight_functions)\n    vp['afsc_weight_function'] = np.random.choice(weight_functions)\n    vp['cadet_weight'] = afccp.data.values.cadet_weight_function(p['merit_all'], func= vp['cadet_weight_function'])\n    vp['afsc_weight'] = afccp.data.values.afsc_weight_function(p['pgl'], func = vp['afsc_weight_function'])\n\n    # Stuff that doesn't matter here\n    vp['cadet_value_min'], vp['afsc_value_min'] = np.zeros(p['N']), np.zeros(p['N'])\n    vp['USAFA-Constrained AFSCs'], vp['Cadets Top 3 Constraint'] = '', ''\n    vp['USSF OM'] = False\n\n    # Initialize arrays\n    vp['objective_weight'], vp['objective_target'] = np.zeros([p['M'], vp['O']]), np.zeros([p['M'], vp['O']])\n    vp['constraint_type'] = np.zeros([p['M'], vp['O']])\n    vp['objective_value_min'] = np.array([[' ' * 20 for _ in vp['K']] for _ in p['J']])\n    vp['value_functions'] = np.array([[' ' * 200 for _ in vp['K']] for _ in p['J']])\n\n    # Initialize breakpoints\n    vp['a'] = [[[] for _ in vp['K']] for _ in p[\"J\"]]\n    vp['f^hat'] = [[[] for _ in vp['K']] for _ in p[\"J\"]]\n\n    # Initialize objective set\n    vp['K^A'] = {}\n\n    # Get AFOCD Tier objectives\n    vp = afccp.data.values.generate_afocd_value_parameters(p, vp)\n    vp['constraint_type'] = np.zeros([p['M'], vp['O']])  # Turn off all the constraints again\n\n    # Loop through all AFSCs\n    for j in p['J']:\n\n        # Loop through all AFSC objectives\n        for k, objective in enumerate(vp['objectives']):\n\n            maximum, minimum, actual = None, None, None\n            if objective == 'Norm Score':\n                vp['objective_weight'][j, k] = (np.random.rand() * 0.2 + 0.3) * 100  # Scale up to 100\n                vp['value_functions'][j, k] = 'Min Increasing|0.3'\n                vp['objective_target'][j, k] = 1\n\n            if objective == 'Merit':\n                vp['objective_weight'][j, k] = (np.random.rand() * 0.4 + 0.05) * 100\n                vp['value_functions'][j, k] = 'Min Increasing|-0.3'\n                vp['objective_target'][j, k] = p['sum_merit'] / p['N']\n                actual = np.mean(p['merit'][p['I^E'][j]])\n\n            elif objective == 'USAFA Proportion':\n                vp['objective_weight'][j, k] = (np.random.rand() * 0.3 + 0.05) * 100\n                vp['value_functions'][j, k] = 'Balance|0.15, 0.15, 0.1, 0.08, 0.08, 0.1, 0.6'\n                vp['objective_target'][j, k] = p['usafa_proportion']\n                actual = len(p['I^D'][objective][j]) / len(p['I^E'][j])\n\n            elif objective == 'Combined Quota':\n                vp['objective_weight'][j, k] = (np.random.rand() * 0.8 + 0.2) * 100\n                vp['value_functions'][j, k] = 'Quota_Normal|0.2, 0.25, 0.2'\n                vp['objective_target'][j, k] = p['quota_d'][j]\n\n                # Get bounds and turn on this constraint\n                minimum, maximum = p['quota_min'][j], p['quota_max'][j]\n                vp['objective_value_min'][j, k] = str(int(minimum)) + \", \" + str(int(maximum))\n                vp['constraint_type'][j, k] = 2\n\n            elif objective == 'USAFA Quota':\n                vp['objective_weight'][j, k] = 0\n                vp['value_functions'][j, k] = 'Min Increasing|0.3'\n                vp['objective_target'][j, k] = p['usafa_quota'][j]\n\n                # Bounds on this constraint (but leave it off)\n                vp['objective_value_min'][j, k] = str(int(p['usafa_quota'][j])) + \", \" + \\\n                                                  str(int(p['quota_max'][j]))\n\n            elif objective == 'ROTC Quota':\n                vp['objective_weight'][j, k] = 0\n                vp['value_functions'][j, k] = 'Min Increasing|0.3'\n                vp['objective_target'][j, k] = p['rotc_quota'][j]\n\n                # Bounds on this constraint (but leave it off)\n                vp['objective_value_min'][j, k] = str(int(p['rotc_quota'][j])) + \", \" + \\\n                                                  str(int(p['quota_max'][j]))\n\n            # If we care about this objective, we load in its value function breakpoints\n            if vp['objective_weight'][j, k] != 0:\n\n                # Create the non-linear piecewise exponential segment dictionary\n                segment_dict = afccp.data.values.create_segment_dict_from_string(\n                    vp['value_functions'][j, k], vp['objective_target'][j, k],\n                    minimum=minimum, maximum=maximum, actual=actual)\n\n                # Linearize the non-linear function using the specified number of breakpoints\n                vp['a'][j][k], vp['f^hat'][j][k] = afccp.data.values.value_function_builder(\n                    segment_dict, num_breakpoints=num_breakpoints)\n\n        # Scale the objective weights for this AFSC, so they sum to 1\n        vp['objective_weight'][j] = vp['objective_weight'][j] / sum(vp['objective_weight'][j])\n        vp['K^A'][j] = np.where(vp['objective_weight'][j] != 0)[0]\n\n    return vp\n</code></pre>"},{"location":"reference/data/generation/basic/#data.generation.basic.generate_extra_components","title":"<code>generate_extra_components(parameters)</code>","text":"<p>If we generate extra components (such as bases and IST) for the CadetCareerProblem instance</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <p>instance parameters</p> required <p>Returns:</p> Type Description <p>updated parameters</p> Source code in <code>afccp/data/generation/basic.py</code> <pre><code>def generate_extra_components(parameters):\n    \"\"\"\n    If we generate extra components (such as bases and IST) for the CadetCareerProblem instance\n    :param parameters: instance parameters\n    :return: updated parameters\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Get list of ordered letters (based on Excel column names)\n    alphabet = list(string.ascii_uppercase)\n    excel_columns = copy.deepcopy(alphabet)\n    for letter in alphabet:\n        for letter_2 in alphabet:\n            excel_columns.append(letter + letter_2)\n\n    # Determine which AFSCs we assign bases for\n    p['afsc_assign_base'] = np.zeros(p['M']).astype(int)\n    for j in range(p['M']):\n        if p['acc_grp'][j] != \"Rated\" and np.random.rand() &gt; 0.3:\n            p['afsc_assign_base'][j] = 1\n\n    # Name the bases according to the Excel columns (just a method of generating unique ordered letters)\n    p['bases'] = np.array([\"Base \" + excel_columns[b] for b in range(p['S'])])\n\n    # Get capacities for each AFSC at each base\n    p['base_min'] = np.zeros((p['S'], p['M'])).astype(int)\n    p['base_max'] = np.zeros((p['S'], p['M'])).astype(int)\n    afscs_with_base_assignments = np.where(p['afsc_assign_base'])[0]\n    for j in afscs_with_base_assignments:\n        total_max = p['pgl'][j] * 1.5\n        base_max = np.array([np.random.rand() for _ in range(p['S'])])\n        base_max = (base_max / np.sum(base_max)) * total_max\n        p['base_max'][:, j] = base_max.astype(int)\n        p['base_min'][:, j] = (base_max * 0.4).astype(int)\n\n    # Generate random cadet preferences for bases\n    bases = copy.deepcopy(p['bases'])\n    p['base_preferences'] = {}\n    p['b_pref_matrix'] = np.zeros((p['N'], p['S'])).astype(int)\n    p['base_utility'] = np.zeros((p['N'], p['S']))\n    for i in range(p['N']):\n        random.shuffle(bases)\n        num_base_pref = np.random.choice(np.arange(2, p['S'] + 1))\n        p['base_preferences'][i] = np.array([np.where(p['bases'] == base)[0][0] for base in bases[:num_base_pref]])\n\n        # Convert to base preference matrix\n        p['b_pref_matrix'][i, p['base_preferences'][i]] = np.arange(1, len(p['base_preferences'][i]) + 1)\n\n        utilities = np.around(np.random.rand(num_base_pref), 2)\n        p['base_utility'][i, p['base_preferences'][i]] = np.sort(utilities)[::-1]\n        p['base_utility'][i, p['base_preferences'][i][0]] = 1.0  # First choice is always utility of 1!\n\n    # Get the baseline starting date (January 1st of the year we're classifying)\n    next_year = datetime.datetime.now().year + 1\n    p['baseline_date'] = datetime.date(next_year, 1, 1)\n\n    # Generate training preferences for each cadet\n    p['training_preferences'] = np.array(\n        [random.choices(['Early', 'Late'], weights=[0.9, 0.1])[0] for _ in range(p['N'])])\n\n    # Generate base/training \"thresholds\" for when these preferences kick in (based on preferences for AFSCs)\n    p['training_threshold'] = np.array([np.random.choice(np.arange(p['M'] + 1)) for _ in range(p['N'])])\n    p['base_threshold'] = np.array([np.random.choice(np.arange(p['M'] + 1)) for _ in range(p['N'])])\n\n    # Generate weights for AFSCs, bases, and courses\n    p['weight_afsc'], p['weight_base'], p['weight_course'] = np.zeros(p['N']), np.zeros(p['N']), np.zeros(p['N'])\n    for i in range(p['N']):\n\n        # Force some percentage of cadets to make their threshold the last possible AFSC (this means these don't matter)\n        if np.random.rand() &gt; 0.8:\n            p['base_threshold'][i] = p['M']\n        if np.random.rand() &gt; 0.7:\n            p['training_threshold'][i] = p['M']\n\n        # Generate weights for bases, training (courses), and AFSCs\n        if p['base_threshold'][i] == p['M']:\n            w_b = 0\n        else:\n            w_b = np.random.triangular(0, 50, 100)\n        if p['training_threshold'][i] == p['M']:\n            w_c = 0\n        else:\n            w_c = np.random.triangular(0, 20, 100)\n        w_a = np.random.triangular(0, 90, 100)\n\n        # Scale weights so that they sum to one and load into arrays\n        p['weight_afsc'][i] = w_a / (w_a + w_b + w_c)\n        p['weight_base'][i] = w_b / (w_a + w_b + w_c)\n        p['weight_course'][i] = w_c / (w_a + w_b + w_c)\n\n    # Generate training start dates for each cadet\n    p['training_start'] = []\n    for i in range(p['N']):\n\n        # If this cadet is a USAFA cadet\n        if p['usafa'][i]:\n\n            # Make it May 28th of this year\n            p['training_start'].append(datetime.date(next_year, 5, 28))\n\n        # If it's an ROTC cadet, we sample from two different distributions (on-time and late grads)\n        else:\n\n            # 80% should be in spring\n            if np.random.rand() &lt; 0.8:\n                dt = datetime.date(next_year, 4, 15) + datetime.timedelta(int(np.random.triangular(0, 30, 60)))\n                p['training_start'].append(dt)\n\n            # 20% should be after\n            else:\n                dt = datetime.date(next_year, 6, 1) + datetime.timedelta(int(np.random.triangular(0, 30*5, 30*6)))\n                p['training_start'].append(dt)\n    p['training_start'] = np.array(p['training_start'])\n\n    # Generate training courses for each AFSC\n    p['courses'], p['course_start'], p['course_min'], p['course_max'] = {}, {}, {}, {}\n    p['course_count'] = np.zeros(p['M'])\n    for j in range(p['M']):\n\n        # Determine total number of training slots to divide up\n        total_max = p['pgl'][j] * 1.5\n\n        # Determine number of courses to generate\n        if total_max &lt;= 3:\n            T = 1\n        elif total_max &lt;= 10:\n            T = np.random.choice([1, 2])\n        elif total_max &lt; 25:\n            T = np.random.choice([2, 3])\n        elif total_max &lt; 100:\n            T = np.random.choice([3, 4, 5])\n        else:\n            T = np.random.choice([4, 5, 6, 7, 8, 9])\n\n        # Course minimums and maximums\n        random_nums = np.random.rand(T)\n        p['course_max'][j] = np.around(total_max * (random_nums / np.sum(random_nums))).astype(int)\n        p['course_min'][j] = np.zeros(T).astype(int)\n\n        # Generate course specific information\n        p['courses'][j], p['course_start'][j] = [], []\n        current_date = p['baseline_date'] + datetime.timedelta(int(np.random.triangular(30*5, 30*9, 30*11)))\n        for _ in range(T):\n\n            # Course names (random strings of letters)\n            num_letters = random.choice(np.arange(4, 10))\n            p['courses'][j].append(''.join(random.choices(alphabet, k=num_letters)))\n\n            # Course start date\n            p['course_start'][j].append(current_date)\n\n            # Get next course start date\n            current_date += datetime.timedelta(int(np.random.triangular(30, 30*4, 30*6)))\n\n        # Convert to numpy arrays\n        for param in ['courses', 'course_start', 'course_max', 'course_min']:\n            p[param][j] = np.array(p[param][j])\n\n    # Number of training courses per AFSC\n    p['T'] = np.array([len(p['courses'][j]) for j in range(p['M'])])\n\n    # Return updated parameters\n    return p\n</code></pre>"},{"location":"reference/data/generation/basic/#data.generation.basic.generate_concave_curve","title":"<code>generate_concave_curve(num_points, max_x)</code>","text":"<p>Generates x and y coordinates for a concave function.</p> <p>Args:     num_points (int): Number of points to generate.     max_x (float): Maximum value along the x-axis.</p> <p>Returns:     tuple: (x_values, y_values) as numpy arrays.</p> Source code in <code>afccp/data/generation/basic.py</code> <pre><code>def generate_concave_curve(num_points, max_x):\n    \"\"\"\n    Generates x and y coordinates for a concave function.\n\n    Args:\n        num_points (int): Number of points to generate.\n        max_x (float): Maximum value along the x-axis.\n\n    Returns:\n        tuple: (x_values, y_values) as numpy arrays.\n    \"\"\"\n    x_values = np.linspace(0, max_x, num_points)\n    y_values = 1 - np.exp(-x_values / (max_x / 6))  # Adjust curvature\n    return x_values, y_values\n</code></pre>"},{"location":"reference/data/generation/basic/#data.generation.basic.generate_realistic_castle_value_curves","title":"<code>generate_realistic_castle_value_curves(parameters, num_breakpoints: int = 10)</code>","text":"<p>Generate Concave Value Curves for CASTLE AFSCs.</p> <p>Creates piecewise linear approximations of realistic concave value functions for each CASTLE-level AFSC. These curves are used to evaluate the marginal utility of inventory across AFSCs, enabling smooth optimization and modeling in the CASTLE simulation.</p> <p>Parameters:     parameters (dict): Problem instance parameters containing CASTLE AFSC groups and PGL values.     num_breakpoints (int, optional): Number of breakpoints to use in the piecewise value curve.         Defaults to 10.</p> <p>Returns:     dict: A dictionary <code>q</code> containing the following keys for each CASTLE AFSC:         - <code>'a'</code>: Array of x-values (inventory levels).         - <code>'f^hat'</code>: Array of corresponding y-values (utility).         - <code>'r'</code>: Number of breakpoints.         - <code>'L'</code>: Index array of breakpoints.</p> <p>Example:     <pre><code>q = generate_realistic_castle_value_curves(parameters, num_breakpoints=12)\nx_vals = q['a']['21A']       # x-values for AFSC 21A\ny_vals = q['f^hat']['21A']   # corresponding utility values\n</code></pre></p> <p>See Also:     - <code>generate_concave_curve</code>:       Generates a concave (diminishing returns) curve with specified number of points and max range.</p> Source code in <code>afccp/data/generation/basic.py</code> <pre><code>def generate_realistic_castle_value_curves(parameters, num_breakpoints: int = 10):\n    \"\"\"\n    Generate Concave Value Curves for CASTLE AFSCs.\n\n    Creates piecewise linear approximations of realistic concave value functions for each CASTLE-level AFSC.\n    These curves are used to evaluate the marginal utility of inventory across AFSCs, enabling smooth\n    optimization and modeling in the CASTLE simulation.\n\n    Parameters:\n        parameters (dict): Problem instance parameters containing CASTLE AFSC groups and PGL values.\n        num_breakpoints (int, optional): Number of breakpoints to use in the piecewise value curve.\n            Defaults to 10.\n\n    Returns:\n        dict: A dictionary `q` containing the following keys for each CASTLE AFSC:\n            - `'a'`: Array of x-values (inventory levels).\n            - `'f^hat'`: Array of corresponding y-values (utility).\n            - `'r'`: Number of breakpoints.\n            - `'L'`: Index array of breakpoints.\n\n    Example:\n        ```python\n        q = generate_realistic_castle_value_curves(parameters, num_breakpoints=12)\n        x_vals = q['a']['21A']       # x-values for AFSC 21A\n        y_vals = q['f^hat']['21A']   # corresponding utility values\n        ```\n\n    See Also:\n        - [`generate_concave_curve`](../../../afccp/reference/data/generation/#data.generation.generate_concave_curve):\n          Generates a concave (diminishing returns) curve with specified number of points and max range.\n    \"\"\"\n    # Shorthand\n    p = parameters\n\n    # Define \"q\" dictionary for value function components\n    q = {'a': {}, 'f^hat': {}, 'r': {}, 'L': {}}\n    for afsc in p['castle_afscs']:\n        # Sum up the PGL targets for all \"AFPC\" AFSCs grouped for this \"CASTLE\" AFSC\n        pgl = np.sum(p['pgl'][p['J^CASTLE'][afsc]])\n\n        # Generate x and y coordinates for concave shape\n        x, y = generate_concave_curve(num_points=num_breakpoints, max_x=pgl * 2)\n\n        # Save breakpoint information to q dictionary\n        q['a'][afsc], q['f^hat'][afsc] = x, y\n        q['r'][afsc], q['L'][afsc] = len(x), np.arange(len(x))\n\n    return q\n</code></pre>"},{"location":"reference/data/generation/realistic/","title":"Generation- 'Realistic'","text":""},{"location":"reference/data/generation/realistic/#data.generation.realistic","title":"<code>data.generation.realistic</code>","text":""},{"location":"reference/data/generation/realistic/#data.generation.realistic.train_ctgan","title":"<code>train_ctgan(epochs=1000, printing=True, name='CTGAN_Full')</code>","text":"<p>Train CTGAN to produce realistic data based on the current \"ctgan_data\" file in the support sub-folder. This function then saves the \".pkl\" file back to the support sub-folder</p> Source code in <code>afccp/data/generation/realistic.py</code> <pre><code>def train_ctgan(epochs=1000, printing=True, name='CTGAN_Full'):\n    \"\"\"\n    Train CTGAN to produce realistic data based on the current \"ctgan_data\" file in the support sub-folder. This\n    function then saves the \".pkl\" file back to the support sub-folder\n    \"\"\"\n\n    # Import data\n    data = afccp.globals.import_csv_data(afccp.globals.paths['support'] + 'data/ctgan_data.csv')\n    data = data[[col for col in data.columns if col not in ['YEAR']]]\n    metadata = SingleTableMetadata()  # SDV requires this now\n    metadata.detect_from_dataframe(data=data)  # get the metadata from dataframe\n\n    # Create the synthesizer model\n    model = CTGANSynthesizer(metadata, epochs=epochs, verbose=True)\n\n    # List of constraints for CTGAN\n    constraints = []\n\n    # Get list of columns that must be between 0 and 1\n    zero_to_one_columns = [\"Merit\"]\n    for col in data.columns:\n        if \"_Cadet\" in col or \"_AFSC\" in col:\n            zero_to_one_columns.append(col)\n\n    # Create the \"zero to one\" constraints and add them to our list of constraints\n    for col in zero_to_one_columns:\n        zero_to_one_constraint = {\"constraint_class\": \"ScalarRange\",\n                                  \"constraint_parameters\": {\n                                      'column_name': col,\n                                      'low_value': 0,\n                                      'high_value': 1,\n                                      'strict_boundaries': False\n                                  }}\n        constraints.append(zero_to_one_constraint)\n\n    # Add the constraints to the model\n    model.add_constraints(constraints)\n\n    # Train the model\n    if printing:\n        print(\"Training the model...\")\n    model.fit(data)\n\n    # Save the model\n    filepath = afccp.globals.paths[\"support\"] + name + '.pkl'\n    model.save(filepath)\n    if printing:\n        print(\"Model saved to\", filepath)\n</code></pre>"},{"location":"reference/data/generation/realistic/#data.generation.realistic.generate_ctgan_instance","title":"<code>generate_ctgan_instance(N=1600, name='CTGAN_Full', pilot_condition=False, degree_qual_type='Consistent')</code>","text":"<p>This procedure takes in the specified number of cadets and then generates a representative problem instance using CTGAN that has been trained from a real class year of cadets</p> <p>Parameters:</p> Name Type Description Default <code>pilot_condition</code> <p>If we want to sample cadets according to pilot preferences (make this more representative)</p> <code>False</code> <code>name</code> <p>Name of the CTGAN model to import</p> <code>'CTGAN_Full'</code> <code>N</code> <p>number of cadets</p> <code>1600</code> <p>Returns:</p> Type Description <p>model fixed parameters</p> Source code in <code>afccp/data/generation/realistic.py</code> <pre><code>def generate_ctgan_instance(N=1600, name='CTGAN_Full', pilot_condition=False, degree_qual_type='Consistent'):\n    \"\"\"\n    This procedure takes in the specified number of cadets and then generates a representative problem\n    instance using CTGAN that has been trained from a real class year of cadets\n    :param pilot_condition: If we want to sample cadets according to pilot preferences\n    (make this more representative)\n    :param name: Name of the CTGAN model to import\n    :param N: number of cadets\n    :return: model fixed parameters\n    \"\"\"\n\n    # Load in the model\n    filepath = afccp.globals.paths[\"support\"] + name + '.pkl'\n    model = CTGANSynthesizer.load(filepath)\n\n    # Split up the number of ROTC/USAFA cadets\n    N_usafa = round(np.random.triangular(0.25, 0.33, 0.4) * N)\n    N_rotc = N - N_usafa\n\n    # Pilot is by far the #1 desired career field, let's make sure this is represented here\n    N_usafa_pilots = round(np.random.triangular(0.3, 0.4, 0.43) * N_usafa)\n    N_usafa_generic = N_usafa - N_usafa_pilots\n    N_rotc_pilots = round(np.random.triangular(0.25, 0.3, 0.33) * N_rotc)\n    N_rotc_generic = N_rotc - N_rotc_pilots\n\n    # Condition the data generated to produce the right composition of pilot first choice preferences\n    usafa_pilot_first_choice = Condition(num_rows = N_usafa_pilots, column_values={'SOC': 'USAFA', '11XX_Cadet': 1})\n    usafa_generic_cadets = Condition(num_rows=N_usafa_generic, column_values={'SOC': 'USAFA'})\n    rotc_pilot_first_choice = Condition(num_rows=N_rotc_pilots, column_values={'SOC': 'ROTC', '11XX_Cadet': 1})\n    rotc_generic_cadets = Condition(num_rows=N_rotc_generic, column_values={'SOC': 'ROTC'})\n\n    # Sample data  (Sampling from conditions may take too long!)\n    if pilot_condition:\n        data = model.sample_from_conditions(conditions=[usafa_pilot_first_choice, usafa_generic_cadets,\n                                                        rotc_pilot_first_choice, rotc_generic_cadets])\n    else:\n        data = model.sample(N)\n\n    # Load in AFSCs data\n    filepath = afccp.globals.paths[\"support\"] + 'data/afscs_data.csv'\n    afscs_data = afccp.globals.import_csv_data(filepath)\n\n    # Get list of AFSCs\n    afscs = np.array(afscs_data['AFSC'])\n\n    # Initialize parameter dictionary\n    p = {'afscs': afscs, 'N': N, 'P': len(afscs), 'M': len(afscs), 'merit': np.array(data['Merit']),\n         'cadets': np.arange(N), 'usafa': np.array(data['SOC'] == 'USAFA') * 1,\n         'cip1': np.array(data['CIP1']), 'cip2': np.array(data['CIP2']), 'num_util': 10,  # 10 utilities taken\n         'rotc': np.array(data['SOC'] == 'ROTC'), 'I': np.arange(N), 'J': np.arange(len(afscs))}\n\n    # Clean up degree columns (remove the leading \"c\" I put there if it's there)\n    for i in p['I']:\n        if p['cip1'][i][0] == 'c':\n            p['cip1'][i] = p['cip1'][i][1:]\n        if p['cip2'][i][0] == 'c':\n            p['cip2'][i] = p['cip2'][i][1:]\n\n    # Fix percentiles for USAFA and ROTC\n    re_scaled_om = p['merit']\n    for soc in ['usafa', 'rotc']:\n        indices = np.where(p[soc])[0]  # Indices of these SOC-specific cadets\n        percentiles = p['merit'][indices]  # The percentiles of these cadets\n        N = len(percentiles)  # Number of cadets from this SOC\n        sorted_indices = np.argsort(percentiles)[::-1]  # Sort these percentiles (descending)\n        new_percentiles = (np.arange(N)) / (N - 1)  # New percentiles we want to replace these with\n        magic_indices = np.argsort(sorted_indices)  # Indices that let us put the new percentiles in right place\n        new_percentiles = new_percentiles[magic_indices]  # Put the new percentiles back in the right place\n        np.put(re_scaled_om, indices, new_percentiles)  # Put these new percentiles in combined SOC OM spot\n\n    # Replace merit\n    p['merit'] = re_scaled_om\n\n    # Add AFSC features to parameters\n    p['acc_grp'] = np.array(afscs_data['Accessions Group'])\n    p['Deg Tiers'] = np.array(afscs_data.loc[:, 'Deg Tier 1': 'Deg Tier 4'])\n    p['Deg Tiers'][pd.isnull(p[\"Deg Tiers\"])] = ''  # TODO\n\n    # Determine AFSCs by Accessions Group\n    p['afscs_acc_grp'] = {}\n    if 'acc_grp' in p:\n        for acc_grp in ['Rated', 'USSF', 'NRL']:\n            p['J^' + acc_grp] = np.where(p['acc_grp'] == acc_grp)[0]\n            p['afscs_acc_grp'][acc_grp] = p['afscs'][p['J^' + acc_grp]]\n\n    # Useful data elements to help us generate PGL targets\n    usafa_prop, rotc_prop, pgl_prop = np.array(afscs_data['USAFA Proportion']), \\\n                                      np.array(afscs_data['ROTC Proportion']), \\\n                                      np.array(afscs_data['PGL Proportion'])\n\n    # Total targets needed to distribute\n    total_targets = int(p['N'] * min(0.95, np.random.normal(0.93, 0.08)))\n\n    # PGL targets\n    p['pgl'] = np.zeros(p['M']).astype(int)\n    p['usafa_quota'] = np.zeros(p['M']).astype(int)\n    p['rotc_quota'] = np.zeros(p['M']).astype(int)\n    for j in p['J']:\n\n        # Create the PGL target by sampling from the PGL proportion triangular distribution\n        p_min = max(0, 0.8 * pgl_prop[j])\n        p_max = 1.2 * pgl_prop[j]\n        prop = np.random.triangular(p_min, pgl_prop[j], p_max)\n        p['pgl'][j] = int(max(1, prop * total_targets))\n\n        # Get the ROTC proportion of this PGL target to allocate\n        if rotc_prop[j] in [1, 0]:\n            prop = rotc_prop[j]\n        else:\n            rotc_p_min = max(0, 0.8 * rotc_prop[j])\n            rotc_p_max = min(1, 1.2 * rotc_prop[j])\n            prop = np.random.triangular(rotc_p_min, rotc_prop[j], rotc_p_max)\n\n        # Create the SOC-specific targets\n        p['rotc_quota'][j] = int(prop * p['pgl'][j])\n        p['usafa_quota'][j] = p['pgl'][j] - p['rotc_quota'][j]\n\n    # Initialize the other pieces of information here\n    for param in ['quota_e', 'quota_d', 'quota_min', 'quota_max']:\n        p[param] = p['pgl']\n\n    # Break up USSF and 11XX AFSC by SOC\n    for afsc in ['USSF', '11XX']:\n        for col in ['Cadet', 'AFSC']:\n            for soc in ['USAFA', 'ROTC']:\n                data[f'{afsc}_{soc[0]}_{col}'] = 0\n                data.loc[data['SOC'] == soc, f'{afsc}_{soc[0]}_{col}'] = data.loc[data['SOC'] == soc, f'{afsc}_{col}']\n\n    c_pref_cols = [f'{afsc}_Cadet' for afsc in afscs]\n    util_original = np.around(np.array(data[c_pref_cols]), 2)\n\n    # Initialize cadet preference information\n    p['c_utilities'] = np.zeros((p['N'], 10))\n    p['c_preferences'] = np.array([[' ' * 6 for _ in range(p['M'])] for _ in range(p['N'])])\n    p['cadet_preferences'] = {}\n    p['c_pref_matrix'] = np.zeros((p['N'], p['M'])).astype(int)\n    p['utility'] = np.zeros((p['N'], p['M']))\n\n    # Loop through each cadet to tweak their preferences\n    for i in p['cadets']:\n\n        # Manually fix 62EXE preferencing from eligible cadets\n        ee_j = np.where(afscs == '62EXE')[0][0]\n        if '1410' in data.loc[i, 'CIP1'] or '1447' in data.loc[i, 'CIP1']:\n            if np.random.rand() &gt; 0.6:\n                util_original[i, ee_j] = np.around(max(util_original[i, ee_j], min(1, np.random.normal(0.8, 0.18))),\n                                                   2)\n\n        # Fix rated/USSF volunteer situation\n        for acc_grp in ['Rated', 'USSF']:\n            if data.loc[i, f'{acc_grp} Vol']:\n                if np.max(util_original[i, p[f'J^{acc_grp}']]) &lt; 0.6:\n                    util_original[i, p[f'J^{acc_grp}']] = 0\n                    data.loc[i, f'{acc_grp} Vol'] = False\n            else:  # Not a volunteer\n\n                # We have a higher preference for these kinds of AFSCs\n                if np.max(util_original[i, p[f'J^{acc_grp}']]) &gt;= 0.6:\n                    data.loc[i, f'{acc_grp} Vol'] = True  # Make them a volunteer now\n\n        # Was this the last choice AFSC? Remove from our lists\n        ordered_list = np.argsort(util_original[i])[::-1]\n        last_choice = data.loc[i, 'Last Choice']\n        if last_choice in afscs:\n            j = np.where(afscs == last_choice)[0][0]\n            ordered_list = ordered_list[ordered_list != j]\n\n        # Add the \"2nd least desired AFSC\" to list\n        second_last_choice = data.loc[i, '2nd-Last Choice']\n        bottom = []\n        if second_last_choice in afscs and afsc != last_choice:  # Check if valid and not in bottom choices\n            j = np.where(afscs == second_last_choice)[0][0]  # Get index of AFSC\n            ordered_list = ordered_list[ordered_list != j]  # Remove index from preferences\n            bottom.append(second_last_choice)  # Add it to the list of bottom choices\n\n        # If it's a valid AFSC that isn't already in the bottom choices\n        third_last_choice = data.loc[i, '3rd-Last Choice']  # Add the \"3rd least desired AFSC\" to list\n        if third_last_choice in afscs and afsc not in [last_choice, second_last_choice]:\n            j = np.where(afscs == third_last_choice)[0][0]  # Get index of AFSC\n            ordered_list = ordered_list[\n                ordered_list != j]  # Reordered_list = np.argsort(util_original[i])[::-1]move index from preferences\n            bottom.append(third_last_choice)  # Add it to the list of bottom choices\n\n        # If we have an AFSC in the bottom choices, but NOT the LAST choice, move one to the last choice\n        if len(bottom) &gt; 0 and pd.isnull(last_choice):\n            afsc = bottom.pop(0)\n            data.loc[i, 'Last Choice'] = afsc\n        data.loc[i, 'Second Least Desired AFSCs'] = ', '.join(bottom)  # Put it in the dataframe\n\n        # Save cadet preference information\n        num_pref = 10 if np.random.rand() &gt; 0.1 else int(np.random.triangular(11, 15, 26))\n        p['c_utilities'][i] = util_original[i, ordered_list[:10]]\n        p['cadet_preferences'][i] = ordered_list[:num_pref]\n        p['c_preferences'][i, :num_pref] = afscs[p['cadet_preferences'][i]]\n        p['c_pref_matrix'][i, p['cadet_preferences'][i]] = np.arange(1, len(p['cadet_preferences'][i]) + 1)\n        p['utility'][i, p['cadet_preferences'][i][:10]] = p['c_utilities'][i]\n\n    # Get qual matrix information\n    p['Qual Type'] = degree_qual_type\n    p = afccp.data.adjustments.gather_degree_tier_qual_matrix(cadets_df=None, parameters=p)\n\n    # Get the qual matrix to know what people are eligible for\n    ineligible = (np.core.defchararray.find(p['qual'], \"I\") != -1) * 1\n    eligible = (ineligible == 0) * 1\n    I_E = [np.where(eligible[:, j])[0] for j in p['J']]  # set of cadets that are eligible for AFSC j\n\n    # Modify AFSC utilities based on eligibility\n    a_pref_cols = [f'{afsc}_AFSC' for afsc in afscs]\n    p['afsc_utility'] = np.around(np.array(data[a_pref_cols]), 2)\n    for acc_grp in ['Rated', 'USSF']:\n        for j in p['J^' + acc_grp]:\n            volunteer_col = np.array(data['Rated Vol'])\n            volunteers = np.where(volunteer_col)[0]\n            not_volunteers = np.where(volunteer_col == False)[0]\n            ranked = np.where(p['afsc_utility'][:, j] &gt; 0)[0]\n            unranked = np.where(p['afsc_utility'][:, j] == 0)[0]\n\n            # Fill in utility values with OM for rated folks who don't have an AFSC score\n            volunteer_unranked = np.intersect1d(volunteers, unranked)\n            p['afsc_utility'][volunteer_unranked, j] = p['merit'][volunteer_unranked]\n\n            # If the cadet didn't actually volunteer, they should have utility of 0\n            non_volunteer_ranked = np.intersect1d(not_volunteers, ranked)\n            p['afsc_utility'][non_volunteer_ranked, j] = 0\n\n    # Remove cadets from this AFSC's preferences if the cadet is not eligible\n    for j in p['J^NRL']:\n\n        # Get appropriate sets of cadets\n        eligible_cadets = I_E[j]\n        ineligible_cadets = np.where(ineligible[:, j])[0]\n        ranked_cadets = np.where(p['afsc_utility'][:, j] &gt; 0)[0]\n        unranked_cadets = np.where(p['afsc_utility'][:, j] == 0)[0]\n\n        # Fill in utility values with OM for eligible folks who don't have an AFSC score\n        eligible_unranked = np.intersect1d(eligible_cadets, unranked_cadets)\n        p['afsc_utility'][eligible_unranked, j] = p['merit'][eligible_unranked]\n\n        # If the cadet isn't actually eligible, they should have utility of 0\n        ineligible_ranked = np.intersect1d(ineligible_cadets, ranked_cadets)\n        p['afsc_utility'][ineligible_ranked, j] = 0\n\n    # Collect AFSC preference information\n    p['afsc_preferences'] = {}\n    p['a_pref_matrix'] = np.zeros((p['N'], p['M'])).astype(int)\n    for j in p['J']:\n\n        # Sort the utilities to get the preference list\n        utilities = p[\"afsc_utility\"][:, j]\n        ineligible_indices = np.where(utilities == 0)[0]\n        sorted_indices = np.argsort(utilities)[::-1][:p['N'] - len(ineligible_indices)]\n        p['afsc_preferences'][j] = sorted_indices\n\n        # Since 'afsc_preferences' is an array of AFSC indices, we can do this\n        p['a_pref_matrix'][p['afsc_preferences'][j], j] = np.arange(1, len(p['afsc_preferences'][j]) + 1)\n\n    # Needed information for rated OM matrices\n    dataset_dict = {'rotc': 'rr_om_matrix', 'usafa': 'ur_om_matrix'}\n    cadets_dict = {'rotc': 'rr_om_cadets', 'usafa': 'ur_om_cadets'}\n    p[\"Rated Cadets\"] = {}\n\n    # Create rated OM matrices for each SOC\n    for soc in ['usafa', 'rotc']:\n\n        # Rated AFSCs for this SOC\n        if soc == 'rotc':\n            rated_J_soc = np.array([j for j in p['J^Rated'] if '_U' not in p['afscs'][j]])\n        else:  # usafa\n            rated_J_soc = np.array([j for j in p['J^Rated'] if '_R' not in p['afscs'][j]])\n\n        # Cadets from this SOC\n        soc_cadets = np.where(p[soc])[0]\n\n        # Determine which cadets are eligible for at least one rated AFSC\n        p[\"Rated Cadets\"][soc] = np.array([i for i in soc_cadets if np.sum(p['c_pref_matrix'][i, rated_J_soc]) &gt; 0])\n        p[cadets_dict[soc]] = p[\"Rated Cadets\"][soc]\n\n        # Initialize OM dataset\n        p[dataset_dict[soc]] = np.zeros([len(p[\"Rated Cadets\"][soc]), len(rated_J_soc)])\n\n        # Create OM dataset\n        for col, j in enumerate(rated_J_soc):\n\n            # Get the maximum rank someone had\n            max_rank = np.max(p['a_pref_matrix'][p[\"Rated Cadets\"][soc], j])\n\n            # Loop through each cadet to convert rank to percentile\n            for row, i in enumerate(p[\"Rated Cadets\"][soc]):\n                rank = p['a_pref_matrix'][i, j]\n                if rank == 0:\n                    p[dataset_dict[soc]][row, col] = 0\n                else:\n                    p[dataset_dict[soc]][row, col] = (max_rank - rank + 1) / max_rank\n\n    # Return parameters\n    return p\n</code></pre>"},{"location":"reference/data/generation/realistic/#data.generation.realistic.safe_round","title":"<code>safe_round(data, decimals=0, axis=-1)</code>","text":"<p>Round <code>data</code> to <code>decimals</code> decimals along <code>axis</code>, preserving the sum of each slice (to <code>decimals</code>), using a \"difference\" style strategy.</p> Source code in <code>afccp/data/generation/realistic.py</code> <pre><code>def safe_round(data, decimals=0, axis=-1):\n    \"\"\"\n    Round `data` to `decimals` decimals along `axis`, preserving the sum of each\n    slice (to `decimals`), using a \"difference\" style strategy.\n    \"\"\"\n    data_type = type(data)\n    constructor = {}\n\n    # 1) Scale by 10^decimals\n    scale = 10.0 ** decimals\n    scaled = data * scale\n\n    # 2) Naively round each element to the nearest integer\n    rounded = np.rint(scaled)\n\n    # 3) Compute how many integer \"units\" the sum *should* have in each slice\n    sum_rounded = np.sum(rounded, axis=axis, keepdims=True)\n    sum_desired = np.rint(np.sum(scaled, axis=axis, keepdims=True))\n    difference = sum_desired - sum_rounded\n\n    n = data.shape[axis]\n    leftover_div = np.floor_divide(difference, n)\n    leftover_mod = difference - leftover_div * n\n    rounded += leftover_div\n\n    # 5) Select elements to tweak\n    difference = scaled - rounded\n    leftover_sign = np.sign(leftover_mod)\n    difference_sign = np.sign(difference)\n    candidate_mask = (difference_sign == leftover_sign) &amp; (difference_sign != 0)\n    sort_key = np.where(candidate_mask, -np.abs(difference), np.inf)\n    sorted_idx = np.argsort(sort_key, axis=axis, kind='stable')\n\n    ranks = np.empty_like(sorted_idx)\n    shape_for_r = [1] * data.ndim\n    shape_for_r[axis] = n\n    r_array = np.arange(n, dtype=sorted_idx.dtype).reshape(shape_for_r)\n    np.put_along_axis(ranks, sorted_idx, r_array, axis=axis)\n\n    leftover_mod_int = np.abs(leftover_mod).astype(int)\n    choose_mask = ranks &lt; leftover_mod_int\n    rounded += leftover_sign * choose_mask\n\n    result = rounded / scale\n\n    if data_type is np.ndarray:\n        return result\n\n    return data_type(result.squeeze(), **constructor)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_data_visualizations/","title":"CadetCareerProblem \u2013 Data Visualizations Methods","text":""},{"location":"reference/main/cadetcareerproblem_data_visualizations/#afccp.main.CadetCareerProblem.display_data_graph","title":"<code>display_data_graph(p_dict={}, printing=None)</code>","text":"<p>This method plots different aspects of the fixed parameters of the problem instance.</p> Source code in <code>afccp/main.py</code> <pre><code>def display_data_graph(self, p_dict={}, printing=None):\n    \"\"\"\n    This method plots different aspects of the fixed parameters of the problem instance.\n    \"\"\"\n\n    # Print statement\n    if printing is None:\n        printing = self.printing\n\n    # Adjust instance plot parameters\n    self._reset_functional_parameters(p_dict)\n    self.mdl_p = afccp.data.support.determine_afsc_plot_details(self)\n\n    # Initialize the AFSC Chart object\n    afsc_chart = afccp.visualizations.charts.AFSCsChart(self)\n\n    # Construct the specific chart\n    return afsc_chart.build(printing=printing)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_data_visualizations/#afccp.main.CadetCareerProblem.display_all_data_graphs","title":"<code>display_all_data_graphs(p_dict={}, printing=None)</code>","text":"<p>This method runs through all the different versions of graphs we have and saves them to the corresponding folder.</p> Source code in <code>afccp/main.py</code> <pre><code>def display_all_data_graphs(self, p_dict={}, printing=None):\n    \"\"\"\n    This method runs through all the different versions of graphs we have and saves\n    them to the corresponding folder.\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Saving all data graphs to the corresponding folder...\")\n\n    # Regular Charts\n    charts = []\n    for graph in [\"Average Utility\", \"USAFA Proportion\", \"Average Merit\", \"AFOCD Data\", \"Eligible Quota\"]:\n        p_dict[\"data_graph\"] = graph\n        charts.append(self.display_data_graph(p_dict, printing=printing))\n\n    # Cadet Preference Analysis Charts\n    p_dict[\"data_graph\"] = \"Cadet Preference Analysis\"\n    for version in range(1, 8):\n        p_dict[\"version\"] = str(version)\n        charts.append(self.display_data_graph(p_dict, printing=printing))\n\n    return charts\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_data_visualizations/#afccp.main.CadetCareerProblem.show_value_function","title":"<code>show_value_function(p_dict={}, printing=None)</code>","text":"<p>This method plots a specific AFSC objective value function</p> Source code in <code>afccp/main.py</code> <pre><code>def show_value_function(self, p_dict={}, printing=None):\n    \"\"\"\n    This method plots a specific AFSC objective value function\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Shorthand\n    p, vp = self.parameters, self.value_parameters\n\n    # Reset instance model parameters\n    self._reset_functional_parameters(p_dict)\n    self.mdl_p = afccp.data.support.determine_afsc_plot_details(self)\n    ip = self.mdl_p  # More shorthand\n\n    if printing:\n        print('Creating value function chart for objective ' + ip['objective'] + ' for AFSC ' + ip['afsc'])\n\n    # Determine AFSC and objective shown in this chart\n    j, k = np.where(p[\"afscs\"] == ip[\"afsc\"])[0][0], np.where(vp[\"objectives\"] == ip[\"objective\"])[0][0]\n\n    # ValueFunctionChart specific parameters\n    vfc = ip['ValueFunctionChart']\n    vfc['x_label'] = afccp.globals.obj_label_dict[ip['objective']]  # Get x label for this objective\n\n    # Value Function specific coordinates to plot\n    if vfc['x_pt'] is not None:\n        vfc['y_pt'] = afccp.solutions.handling.value_function(vp['a'][j][k], vp['f^hat'][j][k], vp['r'][j][k],\n                                                              vfc[\"x_pt\"])\n\n    # Determine x and y arrays\n    if ip['smooth_value_function']:\n        x_arr = (np.arange(1001) / 1000) * vp['a'][j][k][vp['r'][j][k] - 1]\n        y_arr = np.array([afccp.solutions.handling.value_function(\n            vp['a'][j][k], vp['f^hat'][j][k], vp['r'][j][k], x) for x in x_arr])\n    else:\n        x_arr, y_arr = vp['a'][j][k], vp['f^hat'][j][k]\n\n    # Title and filepath for this value function!\n    vfc['title'] = ip['afsc'] + ' ' + ip['objective'] + ' Value Function'\n    vfc['filepath'] = self.export_paths['Analysis &amp; Results'] + \\\n                      'Value Functions/' + self.data_name + ' ' + vfc['title'] + ' (' + self.vp_name + ').png'\n\n    # Create and return the chart\n    return afccp.visualizations.charts.ValueFunctionChart(x_arr, y_arr, vfc)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_data_visualizations/#afccp.main.CadetCareerProblem.display_weight_function","title":"<code>display_weight_function(p_dict={}, printing=None)</code>","text":"<p>This method plots the weight function used for either cadets or AFSCs</p> Source code in <code>afccp/main.py</code> <pre><code>def display_weight_function(self, p_dict={}, printing=None):\n    \"\"\"\n    This method plots the weight function used for either cadets or AFSCs\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self._reset_functional_parameters(p_dict)\n    self.mdl_p = afccp.data.support.determine_afsc_plot_details(self)\n\n    # Make the folder\n    if 'Value Parameters' not in os.listdir(self.export_paths['Analysis &amp; Results']):\n        os.mkdir(self.export_paths['Analysis &amp; Results'] + 'Value Parameters')\n\n    if printing:\n        if self.mdl_p[\"cadets_graph\"]:\n            print(\"Creating cadet weight chart...\")\n        else:\n            print(\"Creating AFSC weight chart...\")\n\n    # Build the chart\n    chart = afccp.visualizations.charts.individual_weight_graph(self)\n\n    if printing:\n        chart.show()\n\n    return chart\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_export_data/","title":"CadetCareerProblem \u2013 Export Data Methods","text":""},{"location":"reference/main/cadetcareerproblem_export_data/#afccp.main.CadetCareerProblem.export_data","title":"<code>export_data(datasets=None, printing=None)</code>","text":"<p>Exports the desired problem instance datasets back to csvs.</p> <p>Parameters: datasets (list of str): List of datasets to export. By default, the method exports the \"Value Parameters\" and     \"Solutions\" datasets, as these are the ones that are likely to change the most. Other possible datasets are     \"AFSCs\", \"Cadets\", \"Preferences\", and \"Goal Programming\". printing (bool): Whether to print status updates or not. If not specified, the value of <code>self.printing</code> will     be used.</p> <p>Returns: None</p> <p>This method exports the specified datasets using the <code>export_&lt;dataset_name&gt;_data</code> functions from the <code>afccp.data.processing</code> module. The exported csvs are saved in the paths specified in the <code>self.export_paths</code> dictionary.</p> <p>If the <code>self.import_paths</code> and <code>self.export_paths</code> attributes are not set, this method will call the <code>afccp_dp.initialize_file_information</code> function to create the necessary directories and set the paths.</p> <p>If the \"Goal Programming\" dataset is included in the <code>datasets</code> parameter and the <code>gp_df</code> attribute is not None, the method exports the <code>gp_df</code> dataframe to a csv using the file path specified in the <code>export_paths</code> dictionary.</p> Source code in <code>afccp/main.py</code> <pre><code>def export_data(self, datasets=None, printing=None):\n    \"\"\"\n    Exports the desired problem instance datasets back to csvs.\n\n    Parameters:\n    datasets (list of str): List of datasets to export. By default, the method exports the \"Value Parameters\" and\n        \"Solutions\" datasets, as these are the ones that are likely to change the most. Other possible datasets are\n        \"AFSCs\", \"Cadets\", \"Preferences\", and \"Goal Programming\".\n    printing (bool): Whether to print status updates or not. If not specified, the value of `self.printing` will\n        be used.\n\n    Returns:\n    None\n\n    This method exports the specified datasets using the `export_&lt;dataset_name&gt;_data` functions from the\n    `afccp.data.processing` module. The exported csvs are saved in the paths specified in the\n    `self.export_paths` dictionary.\n\n    If the `self.import_paths` and `self.export_paths` attributes are not set, this method will call the\n    `afccp_dp.initialize_file_information` function to create the necessary directories and set the paths.\n\n    If the \"Goal Programming\" dataset is included in the `datasets` parameter and the `gp_df` attribute is not None,\n    the method exports the `gp_df` dataframe to a csv using the file path specified in the `export_paths` dictionary.\n    \"\"\"\n\n    # Parameter initialization\n    if datasets is None:\n        datasets = [\"Cadets\", \"AFSCs\", \"Preferences\", \"Goal Programming\", \"Value Parameters\",\n                    \"Solutions\", \"Additional\", \"Base Solutions\", \"Course Solutions\"]\n    if printing is None:\n        printing = self.printing\n\n    # Print statement\n    if printing:\n        print(\"Exporting datasets\", datasets)\n\n    # Shorten module name\n    afccp_dp = afccp.data.processing\n\n    # Check to make sure we have file data information\n    for attribute in [self.import_paths, self.export_paths]:\n\n        # If we don't have this information, that means this is a new instance to export\n        if attribute is None:\n            self.import_paths, self.export_paths = afccp_dp.initialize_file_information(self.data_name,\n                                                                                        self.data_version)\n            break\n\n    # Export various data using the different functions\n    dataset_function_dict = {\"AFSCs\": afccp_dp.export_afscs_data,\n                             \"Cadets\": afccp_dp.export_cadets_data,\n                             \"Preferences\": afccp_dp.export_afsc_cadet_matrices_data,\n                             \"Value Parameters\": afccp_dp.export_value_parameters_data,\n                             \"Solutions\": afccp_dp.export_solutions_data,\n                             \"Additional\": afccp_dp.export_additional_data}\n    for dataset in dataset_function_dict:\n        if dataset in datasets:\n            dataset_function_dict[dataset](self)\n\n    # Goal Programming dataframe is an easy export (dataframe is already constructed)\n    if \"Goal Programming\" in datasets and self.gp_df is not None:\n        self.gp_df.to_csv(self.export_paths[\"Goal Programming\"], index=False)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_export_data/#afccp.main.CadetCareerProblem.export_solution_results","title":"<code>export_solution_results(printing=None)</code>","text":"<p>This function exports the metrics for one solution back to excel for review</p> Source code in <code>afccp/main.py</code> <pre><code>def export_solution_results(self, printing=None):\n    \"\"\"\n    This function exports the metrics for one solution back to excel for review\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    # Make sure we have a solution\n    self._error_checking('Solution')\n\n    # Create solution folder if necessary\n    self._manage_solution_folder()\n\n    # Filepath to export to\n    filename = self.data_name + \" \" + self.solution_name + \" (\" + self.vp_name + \").xlsx\"\n    filepath = self.export_paths['Analysis &amp; Results'] + self.solution_name + '/' + filename\n\n    # Print statement\n    if printing:\n        print(\"Exporting solution\", self.solution_name, \"results to \" + filepath + \"...\")\n\n    # Export results\n    afccp.data.processing.export_solution_results(self, filepath)\n\n    if printing:\n        print(\"Done.\")\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/","title":"CadetCareerProblem \u2013 Generated Data Corrections Methods","text":""},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.fix_generated_data","title":"<code>fix_generated_data(printing=None)</code>","text":"<p>Fix Generated Data Instance.</p> <p>This method prepares a synthetic cadet\u2013AFSC instance by populating missing data, generating preferences, updating qualification matrices, and ensuring valid preference and utility structures. It is intended only for generated (synthetic) data instances and should not be used on real-world datasets.</p>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.fix_generated_data--parameters","title":"Parameters","text":"<p>printing : bool, optional     If True, print progress updates at each step. Defaults to the instance's <code>self.printing</code>.</p>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.fix_generated_data--notes","title":"Notes","text":"<p>This function assumes that no valid AFSC preference or utility data currently exists. It will:</p> <ul> <li>Convert utility values to preference ranks</li> <li>Generate fake AFSC preference lists</li> <li>Create separate rated datasets for each SOC</li> <li>Update the qualification matrix based on preferences</li> <li>Remove ineligible cadets from all matrices</li> <li>Normalize preference matrices to eliminate ranking gaps</li> <li>Force first-choice utilities to 100%</li> <li>Convert AFSC preferences to percentile scores</li> <li>Update cadet preference columns</li> <li>Create new utility matrices from cadet columns</li> <li>Rebuild rated eligibility lists</li> <li>Generate random value parameters</li> <li>Perform a final parameter sanity check</li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def fix_generated_data(self, printing=None):\n    \"\"\"\n    Fix Generated Data Instance.\n\n    This method prepares a synthetic cadet\u2013AFSC instance by populating missing data, generating preferences,\n    updating qualification matrices, and ensuring valid preference and utility structures. It is intended\n    **only** for generated (synthetic) data instances and should not be used on real-world datasets.\n\n    Parameters\n    ----------\n    printing : bool, optional\n        If True, print progress updates at each step. Defaults to the instance's `self.printing`.\n\n    Notes\n    -----\n    This function assumes that no valid AFSC preference or utility data currently exists. It will:\n\n    - Convert utility values to preference ranks\n    - Generate fake AFSC preference lists\n    - Create separate rated datasets for each SOC\n    - Update the qualification matrix based on preferences\n    - Remove ineligible cadets from all matrices\n    - Normalize preference matrices to eliminate ranking gaps\n    - Force first-choice utilities to 100%\n    - Convert AFSC preferences to percentile scores\n    - Update cadet preference columns\n    - Create new utility matrices from cadet columns\n    - Rebuild rated eligibility lists\n    - Generate random value parameters\n    - Perform a final parameter sanity check\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Get \"c_pref_matrix\" from cadet preferences\n    self.convert_utilities_to_preferences(cadets_as_well=True)\n\n    # Generate AFSC preferences for this problem instance\n    self.generate_fake_afsc_preferences()\n\n    # Generate rated data (Separate datasets for each SOC)\n    self.generate_rated_data()\n\n    # Update qualification matrix from AFSC preferences (treating CFM lists as \"gospel\" except for Rated/USSF)\n    self.update_qualification_matrix_from_afsc_preferences()\n\n    # Removes ineligible cadets from all 3 matrices: degree qualifications, cadet preferences, AFSC preferences\n    self.remove_ineligible_choices(printing=printing)\n\n    # Take the preferences dictionaries and update the matrices from them (using cadet/AFSC indices)\n    self.update_preference_matrices()  # 1, 2, 4, 6, 7 -&gt; 1, 2, 3, 4, 5 (preference lists need to omit gaps)\n\n    # Force first choice utility values to be 100%\n    self.update_first_choice_cadet_utility_to_one(printing=printing)\n\n    # Convert AFSC preferences to percentiles (0 to 1)\n    self.convert_afsc_preferences_to_percentiles()  # 1, 2, 3, 4, 5 -&gt; 1, 0.8, 0.6, 0.4, 0.2\n\n    # The \"cadet columns\" are located in Cadets.csv and contain the utilities/preferences in order of preference\n    self.update_cadet_columns_from_matrices()  # We haven't touched \"c_preferences\" and \"c_utilities\" until now\n\n    # Update utility matrix from columns (and create final cadet utility matrix)\n    self.update_cadet_utility_matrices_from_cadets_data(printing=printing)\n\n    # Modify rated eligibility by SOC, removing cadets that are on \"Rated Cadets\" list...\n    self.modify_rated_cadet_lists_based_on_eligibility(printing=printing)  # ...but not eligible for any rated AFSC\n\n    # Generate fake (random) set of value parameters\n    self.generate_random_value_parameters()\n\n    # Sanity check the parameters to make sure it all looks good! (No issues found.)\n    self.parameter_sanity_check()\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.convert_utilities_to_preferences","title":"<code>convert_utilities_to_preferences(cadets_as_well=False)</code>","text":"<p>Converts utility matrices to ordinal preference matrices.</p> <p>This method transforms the continuous utility values stored in the model's parameters into discrete ordinal preferences used in assignment algorithms. By default, it converts only the AFSC utility matrix (<code>afsc_utility</code>) into the <code>a_pref_matrix</code>. If specified, it also converts the cadet utility matrix (<code>cadet_utility</code>) into the <code>c_pref_matrix</code>.</p>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.convert_utilities_to_preferences--parameters","title":"Parameters","text":"<p>cadets_as_well : bool, optional     If <code>True</code>, both cadet and AFSC utility matrices are converted to preference matrices.     If <code>False</code> (default), only AFSC utilities are converted.</p>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.convert_utilities_to_preferences--returns","title":"Returns","text":"<p>None     This method updates the instance\u2019s <code>parameters</code> attribute in-place.</p> <p>Note</p> <ul> <li>The resulting <code>a_pref_matrix</code> ranks cadets for each AFSC from most to least preferred.</li> <li>The optional <code>c_pref_matrix</code> ranks AFSCs for each cadet, using 1-based indexing.</li> </ul>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.convert_utilities_to_preferences--examples","title":"Examples","text":"<pre><code># Convert only AFSC utility matrix\ninstance.convert_utilities_to_preferences()\n\n# Convert both AFSC and cadet utility matrices\ninstance.convert_utilities_to_preferences(cadets_as_well=True)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.convert_utilities_to_preferences--see-also","title":"See Also","text":"<ul> <li><code>convert_utility_matrices_preferences</code>:   Underlying function that performs the actual matrix transformation.</li> <li><code>parameter_sets_additions</code>:   Updates parameter subsets after modifying the preference matrices.</li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def convert_utilities_to_preferences(self, cadets_as_well=False):\n    \"\"\"\n    Converts utility matrices to ordinal preference matrices.\n\n    This method transforms the continuous utility values stored in the model's parameters\n    into discrete ordinal preferences used in assignment algorithms. By default, it converts\n    only the AFSC utility matrix (`afsc_utility`) into the `a_pref_matrix`. If specified, it\n    also converts the cadet utility matrix (`cadet_utility`) into the `c_pref_matrix`.\n\n    Parameters\n    ----------\n    cadets_as_well : bool, optional\n        If `True`, both cadet and AFSC utility matrices are converted to preference matrices.\n        If `False` (default), only AFSC utilities are converted.\n\n    Returns\n    -------\n    None\n        This method updates the instance\u2019s `parameters` attribute in-place.\n\n    !!! note\n        - The resulting `a_pref_matrix` ranks cadets for each AFSC from most to least preferred.\n        - The optional `c_pref_matrix` ranks AFSCs for each cadet, using 1-based indexing.\n\n    Examples\n    --------\n    ```python\n    # Convert only AFSC utility matrix\n    instance.convert_utilities_to_preferences()\n\n    # Convert both AFSC and cadet utility matrices\n    instance.convert_utilities_to_preferences(cadets_as_well=True)\n    ```\n\n    See Also\n    --------\n    - [`convert_utility_matrices_preferences`](../../../../afccp/reference/data/preferences/#data.preferences.convert_utility_matrices_preferences):\n      Underlying function that performs the actual matrix transformation.\n    - [`parameter_sets_additions`](../../../../afccp/reference/data/adjustments/#data.adjustments.parameter_sets_additions):\n      Updates parameter subsets after modifying the preference matrices.\n    \"\"\"\n\n    # Rest of your method code here\n    self.parameters = afccp.data.preferences.convert_utility_matrices_preferences(self.parameters,\n                                                                                  cadets_as_well)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_fake_afsc_preferences","title":"<code>generate_fake_afsc_preferences(fix_cadet_eligibility=False)</code>","text":"<p>Generate Simulated AFSC Preferences using certain known parameters.</p> <p>This method simulates AFSC (Air Force Specialty Code) preferences for cadets using weighted scores derived from merit, tier objectives, and other cadet/AFSC attributes. It supports scenarios where cadet eligibility should be strictly enforced before generating preferences.</p>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_fake_afsc_preferences--parameters","title":"Parameters","text":"<p>fix_cadet_eligibility : bool, optional If True, cadet preferences are regenerated to strictly respect eligibility constraints. If False (default), original eligibility is used as-is when computing preferences.</p>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_fake_afsc_preferences--returns","title":"Returns","text":"<p>None Updates the <code>parameters</code> attribute of the current <code>CadetCareerProblem</code> instance with:</p> <ul> <li><code>afsc_utility</code>: N x M utility matrix</li> <li><code>a_pref_matrix</code>: AFSCs' ranked preferences over cadets</li> <li><code>c_pref_matrix</code>: Cadets' ranked preferences over AFSCs</li> <li><code>afsc_preferences</code>, <code>cadet_preferences</code>: Index-based ranking dictionaries</li> </ul>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_fake_afsc_preferences--see-also","title":"See Also","text":"<ul> <li><code>generate_fake_afsc_preferences</code>:   Underlying utility simulation and preference generation function.</li> <li><code>parameter_sets_additions</code>:   Updates parameter subsets and mappings based on the new preference structure.</li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def generate_fake_afsc_preferences(self, fix_cadet_eligibility=False):\n    \"\"\"\n    Generate Simulated AFSC Preferences using certain known parameters.\n\n    This method simulates AFSC (Air Force Specialty Code) preferences for cadets using weighted scores\n    derived from merit, tier objectives, and other cadet/AFSC attributes. It supports scenarios where cadet eligibility\n    should be strictly enforced before generating preferences.\n\n    Parameters\n    ----------\n    fix_cadet_eligibility : bool, optional\n    If True, cadet preferences are regenerated to strictly respect eligibility constraints.\n    If False (default), original eligibility is used as-is when computing preferences.\n\n    Returns\n    -------\n    None\n    Updates the `parameters` attribute of the current `CadetCareerProblem` instance with:\n\n    - `afsc_utility`: N x M utility matrix\n    - `a_pref_matrix`: AFSCs' ranked preferences over cadets\n    - `c_pref_matrix`: Cadets' ranked preferences over AFSCs\n    - `afsc_preferences`, `cadet_preferences`: Index-based ranking dictionaries\n\n    See Also\n    --------\n    - [`generate_fake_afsc_preferences`](../../../../afccp/reference/data/preferences/#data.preferences.generate_fake_afsc_preferences):\n      Underlying utility simulation and preference generation function.\n    - [`parameter_sets_additions`](../../../../afccp/reference/data/adjustments/#data.adjustments.parameter_sets_additions):\n      Updates parameter subsets and mappings based on the new preference structure.\n    \"\"\"\n    self.parameters = afccp.data.preferences.generate_fake_afsc_preferences(\n        self.parameters, self.value_parameters, fix_cadet_eligibility=fix_cadet_eligibility)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_rated_data","title":"<code>generate_rated_data()</code>","text":"<p>Generate Simulated Rated Board Data for USAFA and ROTC Cadets.</p> <p>This method generates Order of Merit (OM) data and interest levels for cadets eligible for Rated AFSCs (e.g., Pilot, CSO, RPA, ABM) for each commissioning source. It only generates data if it does not already exist.</p> <p>Rated OM and interest data (legacy ROTC Rated Board Data) is essential (not the interest matrix, though) for modeling the Air Force\u2019s Rated board process, allowing simulation and evaluation of Rated cadet assignments.</p>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_rated_data--parameters","title":"Parameters","text":"<p>None</p>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_rated_data--returns","title":"Returns","text":"<p>None The method updates the internal <code>self.parameters</code> dictionary in-place by adding:</p> <ul> <li>ROTC-rated interest matrix (<code>rr_interest_matrix</code>)</li> <li>OM matrices for each Source of Commission (SOC), e.g., <code>ur_om_matrix</code>, <code>rr_om_matrix</code></li> </ul>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_rated_data--examples","title":"Examples","text":"<pre><code>instance = CadetCareerProblem(\"Random\", N=30, M=6, P=6)\ninstance.generate_rated_data()  # Adds Rated OM and interest matrices\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_rated_data--see-also","title":"See Also","text":"<ul> <li><code>generate_rated_data</code>:   Underlying function that constructs the rated OM and interest matrices.</li> <li><code>parameter_sets_additions</code>:   Updates relevant parameter sets derived from new OM data.</li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def generate_rated_data(self):\n    \"\"\"\n    Generate Simulated Rated Board Data for USAFA and ROTC Cadets.\n\n    This method generates Order of Merit (OM) data and interest levels for cadets eligible for Rated AFSCs\n    (e.g., Pilot, CSO, RPA, ABM) for each commissioning source. It only generates data if it does not already exist.\n\n    Rated OM and interest data (legacy ROTC Rated Board Data) is essential (not the interest matrix, though) for\n    modeling the Air Force\u2019s Rated board process, allowing simulation and evaluation of Rated cadet assignments.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    None\n    The method updates the internal `self.parameters` dictionary in-place by adding:\n\n    - ROTC-rated interest matrix (`rr_interest_matrix`)\n    - OM matrices for each Source of Commission (SOC), e.g., `ur_om_matrix`, `rr_om_matrix`\n\n    Examples\n    --------\n    ```python\n    instance = CadetCareerProblem(\"Random\", N=30, M=6, P=6)\n    instance.generate_rated_data()  # Adds Rated OM and interest matrices\n    ```\n\n    See Also\n    --------\n    - [`generate_rated_data`](../../../../afccp/reference/data/preferences/#data.preferences.generate_rated_data):\n      Underlying function that constructs the rated OM and interest matrices.\n    - [`parameter_sets_additions`](../../../../afccp/reference/data/adjustments/#data.adjustments.parameter_sets_additions):\n      Updates relevant parameter sets derived from new OM data.\n    \"\"\"\n\n    # Generate Rated Data\n    self.parameters = afccp.data.preferences.generate_rated_data(self.parameters)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_random_value_parameters","title":"<code>generate_random_value_parameters(num_breakpoints=24, vp_weight=100, printing=None)</code>","text":"<p>Generate Random Value Parameters for Assignment Problem.</p> <p>This method initializes a new set of randomly generated value-focused thinking (VFT) parameters for a cadet-AFSC matching problem instance. The generated value parameters include random weights, value functions, and AFSC/cadet preferences, making this method ideal for testing and experimentation.</p>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_random_value_parameters--parameters","title":"Parameters:","text":"<p>num_breakpoints (int, optional): Number of breakpoints to use for linearizing value functions.     Defaults to 24. vp_weight (int, optional): Scalar weight applied to the overall value parameter set.     Defaults to 100. printing (bool, optional): Whether to print progress information. Defaults to the instance attribute.</p>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_random_value_parameters--returns","title":"Returns:","text":"<p>dict: A complete dictionary of randomly generated value parameters for the instance.</p>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_random_value_parameters--example","title":"Example:","text":"<pre><code># Generate and assign a new set of value parameters using 30 breakpoints\nvp = instance.generate_random_value_parameters(num_breakpoints=30, vp_weight=80)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_random_value_parameters--see-also","title":"See Also:","text":"<ul> <li><code>generate_random_value_parameters</code>:   Initializes a value parameter dictionary from scratch with random objective weights and targets.</li> <li><code>condense_value_functions</code>:   Cleans and optimizes value function definitions by removing unused entries.</li> <li><code>value_parameters_sets_additions</code>:   Adds structured sets and subsets to the value parameter dictionary for optimization logic.</li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def generate_random_value_parameters(self, num_breakpoints=24, vp_weight=100, printing=None):\n    \"\"\"\n    Generate Random Value Parameters for Assignment Problem.\n\n    This method initializes a new set of randomly generated value-focused thinking (VFT) parameters\n    for a cadet-AFSC matching problem instance. The generated value parameters include random weights,\n    value functions, and AFSC/cadet preferences, making this method ideal for testing and experimentation.\n\n    Parameters:\n    --------\n    num_breakpoints (int, optional): Number of breakpoints to use for linearizing value functions.\n        Defaults to 24.\n    vp_weight (int, optional): Scalar weight applied to the overall value parameter set.\n        Defaults to 100.\n    printing (bool, optional): Whether to print progress information. Defaults to the instance attribute.\n\n    Returns:\n    --------\n    dict: A complete dictionary of randomly generated value parameters for the instance.\n\n    Example:\n    --------\n    ```python\n    # Generate and assign a new set of value parameters using 30 breakpoints\n    vp = instance.generate_random_value_parameters(num_breakpoints=30, vp_weight=80)\n    ```\n\n    See Also:\n    --------\n    - [`generate_random_value_parameters`](../../../../afccp/reference/data/generation/#data.generation.generate_random_value_parameters):\n      Initializes a value parameter dictionary from scratch with random objective weights and targets.\n    - [`condense_value_functions`](../../../../afccp/reference/data/values/#data.values.condense_value_functions):\n      Cleans and optimizes value function definitions by removing unused entries.\n    - [`value_parameters_sets_additions`](../../../../afccp/reference/data/values/#data.values.value_parameters_sets_additions):\n      Adds structured sets and subsets to the value parameter dictionary for optimization logic.\n    \"\"\"\n\n    # Print Statement\n    if printing is None:\n        printing = self.printing\n\n    # Generate random set of value parameters\n    value_parameters = afccp.data.generation.generate_random_value_parameters(\n        self.parameters, num_breakpoints=num_breakpoints)\n\n    # Module shorthand\n    afccp_vp = afccp.data.values\n\n    # \"Condense\" the value functions by removing unnecessary zeros\n    value_parameters = afccp_vp.condense_value_functions(self.parameters, value_parameters)\n\n    # Add indexed sets and subsets of AFSCs and AFSC objectives\n    value_parameters = afccp_vp.value_parameters_sets_additions(self.parameters, value_parameters)\n\n    # Weight of the value parameters as a whole\n    value_parameters['vp_weight'] = vp_weight\n\n    # Set value parameters to instance attribute\n    if self.mdl_p[\"set_to_instance\"]:\n        self.value_parameters = value_parameters\n\n    # Save new set of value parameters to dictionary\n    if self.mdl_p[\"add_to_dict\"]:\n        self._save_new_value_parameters_to_dict(value_parameters)\n\n    return value_parameters\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_example_castle_value_curves","title":"<code>generate_example_castle_value_curves(num_breakpoints: int = 10)</code>","text":"<p>Generate and Store Example CASTLE Value Curves.</p> <p>This method creates example concave value curves for each CASTLE-level AFSC and stores the breakpoint information in the instance's <code>parameters</code> dictionary under the key <code>'castle_q'</code>.</p> <p>These curves represent marginal utility of inventory over a range of potential quantities for use in CASTLE sustainment simulations.</p>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_example_castle_value_curves--parameters","title":"Parameters:","text":"<p>num_breakpoints (int, optional): Number of breakpoints to use for the concave curve.     Defaults to 10.</p>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_example_castle_value_curves--returns","title":"Returns:","text":"<p>None</p>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_example_castle_value_curves--example","title":"Example:","text":"<pre><code>instance.generate_example_castle_value_curves(num_breakpoints=15)\nq = instance.parameters['castle_q']\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_generated_data_corrections/#afccp.main.CadetCareerProblem.generate_example_castle_value_curves--see-also","title":"See Also:","text":"<ul> <li><code>generate_realistic_castle_value_curves</code>:   Generates concave breakpoint utility functions for CASTLE AFSCs.</li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def generate_example_castle_value_curves(self, num_breakpoints: int = 10):\n    \"\"\"\n    Generate and Store Example CASTLE Value Curves.\n\n    This method creates example concave value curves for each CASTLE-level AFSC and stores the breakpoint\n    information in the instance's `parameters` dictionary under the key `'castle_q'`.\n\n    These curves represent marginal utility of inventory over a range of potential quantities for use in\n    CASTLE sustainment simulations.\n\n    Parameters:\n    --------\n    num_breakpoints (int, optional): Number of breakpoints to use for the concave curve.\n        Defaults to 10.\n\n    Returns:\n    --------\n    None\n\n    Example:\n    --------\n    ```python\n    instance.generate_example_castle_value_curves(num_breakpoints=15)\n    q = instance.parameters['castle_q']\n    ```\n\n    See Also:\n    --------\n    - [`generate_realistic_castle_value_curves`](../../../../afccp/reference/data/generation/#data.generation.generate_realistic_castle_value_curves):\n      Generates concave breakpoint utility functions for CASTLE AFSCs.\n    \"\"\"\n\n    # Create \"q\" dictionary containing breakpoint information for castle value curves\n    q = afccp.data.generation.generate_realistic_castle_value_curves(\n        self.parameters, num_breakpoints=num_breakpoints)\n\n    # Save \"q\" dictionary for castle to parameters\n    self.parameters['castle_q'] = q\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/","title":"CadetCareerProblem \u2013 Main Data Corrections Methods","text":""},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.make_all_initial_real_instance_modifications","title":"<code>make_all_initial_real_instance_modifications(printing=None, vp_defaults_filename=None)</code>","text":"<p>Perform All Initial Modifications for Real Data Instances.</p> <p>This method runs the full preprocessing pipeline to prepare a real cadet\u2013AFSC instance for modeling. It imports default value parameters, constructs rated preferences, updates qualification matrices, and fills in missing data. It also normalizes preferences and utilities and ensures that rated cadets meet eligibility criteria.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.make_all_initial_real_instance_modifications--parameters","title":"Parameters","text":"<p>printing : bool, optional     If True, print progress updates for each major processing step. Defaults to the instance's <code>self.printing</code>.</p> <p>vp_defaults_filename : str, optional     Path to the default value parameter file. If not provided, uses the standard fallback.</p> Source code in <code>afccp/main.py</code> <pre><code>def make_all_initial_real_instance_modifications(self, printing=None, vp_defaults_filename=None):\n    \"\"\"\n    Perform All Initial Modifications for Real Data Instances.\n\n    This method runs the full preprocessing pipeline to prepare a real cadet\u2013AFSC instance for modeling.\n    It imports default value parameters, constructs rated preferences, updates qualification matrices,\n    and fills in missing data. It also normalizes preferences and utilities and ensures that rated\n    cadets meet eligibility criteria.\n\n    Parameters\n    ----------\n    printing : bool, optional\n        If True, print progress updates for each major processing step. Defaults to the instance's `self.printing`.\n\n    vp_defaults_filename : str, optional\n        Path to the default value parameter file. If not provided, uses the standard fallback.\n    \"\"\"\n\n    # Should we print updates?\n    if printing is None:\n        printing = self.printing\n\n    # Import default value parameters\n    self.import_default_value_parameters(printing=printing, vp_defaults_filename=vp_defaults_filename)\n\n    # Takes the two Rated OM datasets and re-calculates the AFSC rankings for Rated AFSCs for both SOCs\n    self.construct_rated_preferences_from_om_by_soc(printing=printing)\n\n    # Update qualification matrix from AFSC preferences (treating CFM lists as \"gospel\" except for Rated/USSF)\n    self.update_qualification_matrix_from_afsc_preferences(printing=printing)\n\n    # Fill in remaining choices\n    self.fill_remaining_afsc_choices(printing=printing)\n\n    # Removes ineligible cadets from all 3 matrices: degree qualifications, cadet preferences, AFSC preferences\n    self.remove_ineligible_choices(printing=printing)\n\n    # Take the preferences dictionaries and update the matrices from them (using cadet/AFSC indices)\n    self.update_preference_matrices(printing=printing)  # 1, 2, 4, 6, 7 -&gt; 1, 2, 3, 4, 5 (preferences omit gaps)\n\n    # Force first choice utility values to be 100%\n    self.update_first_choice_cadet_utility_to_one(printing=printing)\n\n    # Convert AFSC preferences to percentiles (0 to 1)\n    self.convert_afsc_preferences_to_percentiles(printing=printing)  # 1, 2, 3, 4, 5 -&gt; 1, 0.8, 0.6, 0.4, 0.2\n\n    # The \"cadet columns\" are located in Cadets.csv and contain the utilities/preferences in order of preference\n    self.update_cadet_columns_from_matrices(\n        printing=printing)  # We haven't touched \"c_preferences\" and \"c_utilities\" until now\n\n    # Update utility matrix from columns (and create final cadet utility matrix)\n    self.update_cadet_utility_matrices_from_cadets_data(printing=printing)\n\n    # Modify rated eligibility by SOC, removing cadets that are on \"Rated Cadets\" list...\n    self.modify_rated_cadet_lists_based_on_eligibility(printing=printing)  # ...but not eligible for any rated AFSC\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.import_default_value_parameters","title":"<code>import_default_value_parameters(no_constraints=False, num_breakpoints=24, generate_afsc_weights=True, vp_weight=100, printing=None, vp_defaults_filename=None)</code>","text":"<p>Import default value parameter settings from Excel and generate instance-specific value parameters.</p> <p>This method loads predefined \"factory defaults\" for the value-focused model from Excel and transforms them into a usable set of value parameters for this problem instance. These parameters govern how objectives are weighted, what targets and constraints exist, and how utility functions are shaped.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.import_default_value_parameters--parameters","title":"Parameters","text":"<p>no_constraints : bool, optional If True, disables all value-based constraints by zeroing out the <code>constraint_type</code> matrix.</p> <p>num_breakpoints : int, optional Number of piecewise breakpoints used when linearizing nonlinear value functions. Defaults to 24.</p> <p>generate_afsc_weights : bool, optional Whether to generate AFSC weights using the configured weight function, or use defaults. Defaults to True.</p> <p>vp_weight : float, optional Overall weight assigned to this value parameter configuration (used in ensemble models). Defaults to 100.</p> <p>printing : bool, optional Whether to print status updates during import and evaluation. Uses the instance default if None. vp_defaults_filename : str, optional</p> <p>Optional filename for the Excel workbook to load defaults from. If not specified, uses an intelligent default based on <code>self.data_name</code>.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.import_default_value_parameters--returns","title":"Returns","text":"<p>dict A dictionary of <code>value_parameters</code> customized for this instance. Keys include:</p> <ul> <li><code>objective_weight</code>, <code>objective_target</code>, <code>constraint_type</code></li> <li><code>value_functions</code>, <code>afsc_weight</code>, <code>cadet_weight</code></li> <li><code>a</code>, <code>f^hat</code> (linearized value functions), and other modeling sets like <code>K^A</code>, <code>J^A</code>, etc.</li> </ul>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.import_default_value_parameters--notes","title":"Notes","text":"<ul> <li> <p>The value parameter defaults are imported from one of the following:</p> <ul> <li><code>\"Value_Parameters_Defaults_&lt;data_name&gt;.xlsx\"</code></li> <li><code>\"Value_Parameters_Defaults_Perfect.xlsx\"</code></li> <li><code>\"Value_Parameters_Defaults_Generated.xlsx\"</code></li> </ul> </li> <li> <p>If <code>self.mdl_p[\"set_to_instance\"]</code> is True, the generated parameters are assigned to <code>self.value_parameters</code>.</p> </li> <li>If a solution already exists, it will be re-evaluated using the new value parameters.</li> <li>If <code>self.mdl_p[\"add_to_dict\"]</code> is True, the parameters are stored in <code>self.vp_dict</code>.</li> </ul>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.import_default_value_parameters--example","title":"Example","text":"<pre><code>instance = CadetCareerProblem(data_name=\"Random\")\ninstance.import_default_value_parameters()\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.import_default_value_parameters--see-also","title":"See Also","text":"<ul> <li><code>default_value_parameters_from_excel()</code></li> <li><code>generate_value_parameters_from_defaults()</code></li> <li><code>value_parameters_sets_additions()</code></li> <li><code>evaluate_solution()</code></li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def import_default_value_parameters(self, no_constraints=False, num_breakpoints=24,\n                                    generate_afsc_weights=True, vp_weight=100, printing=None,\n                                    vp_defaults_filename=None):\n    \"\"\"\n    Import default value parameter settings from Excel and generate instance-specific value parameters.\n\n    This method loads predefined \"factory defaults\" for the value-focused model from Excel and transforms them\n    into a usable set of value parameters for this problem instance. These parameters govern how objectives are\n    weighted, what targets and constraints exist, and how utility functions are shaped.\n\n    Parameters\n    ----------\n    no_constraints : bool, optional\n    If True, disables all value-based constraints by zeroing out the `constraint_type` matrix.\n\n    num_breakpoints : int, optional\n    Number of piecewise breakpoints used when linearizing nonlinear value functions. Defaults to 24.\n\n    generate_afsc_weights : bool, optional\n    Whether to generate AFSC weights using the configured weight function, or use defaults. Defaults to True.\n\n    vp_weight : float, optional\n    Overall weight assigned to this value parameter configuration (used in ensemble models). Defaults to 100.\n\n    printing : bool, optional\n    Whether to print status updates during import and evaluation. Uses the instance default if None.\n    vp_defaults_filename : str, optional\n\n    Optional filename for the Excel workbook to load defaults from. If not specified, uses an intelligent default\n    based on `self.data_name`.\n\n    Returns\n    -------\n    dict\n    A dictionary of `value_parameters` customized for this instance. Keys include:\n\n    - `objective_weight`, `objective_target`, `constraint_type`\n    - `value_functions`, `afsc_weight`, `cadet_weight`\n    - `a`, `f^hat` (linearized value functions), and other modeling sets like `K^A`, `J^A`, etc.\n\n    Notes\n    -----\n    - The value parameter defaults are imported from one of the following:\n\n        - `\"Value_Parameters_Defaults_&lt;data_name&gt;.xlsx\"`\n        - `\"Value_Parameters_Defaults_Perfect.xlsx\"`\n        - `\"Value_Parameters_Defaults_Generated.xlsx\"`\n\n    - If `self.mdl_p[\"set_to_instance\"]` is True, the generated parameters are assigned to `self.value_parameters`.\n    - If a solution already exists, it will be re-evaluated using the new value parameters.\n    - If `self.mdl_p[\"add_to_dict\"]` is True, the parameters are stored in `self.vp_dict`.\n\n    Example\n    -------\n    ```python\n    instance = CadetCareerProblem(data_name=\"Random\")\n    instance.import_default_value_parameters()\n    ```\n\n    See Also\n    --------\n    - [`default_value_parameters_from_excel()`](../../../../afccp/reference/data/values/#data.values.default_value_parameters_from_excel)\n    - [`generate_value_parameters_from_defaults()`](../../../../afccp/reference/data/values/#data.values.generate_value_parameters_from_defaults)\n    - [`value_parameters_sets_additions()`](../../../../afccp/reference/data/values/#data.values.value_parameters_sets_additions)\n    - [`evaluate_solution()`](../../../../afccp/reference/solutions/handling/#solutions.handlling.evaluate_solution)\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Folder/Files information\n    folder_path = afccp.globals.paths[\"support\"] + \"value parameters defaults/\"\n    vp_defaults_folder = os.listdir(folder_path)\n\n    if vp_defaults_filename is None:\n        vp_defaults_filename = \"Value_Parameters_Defaults_\" + self.data_name + \".xlsx\"\n\n    # Determine the path to the default value parameters we need to import\n    if vp_defaults_filename in vp_defaults_folder:\n        filename = vp_defaults_filename\n    elif len(self.data_name) == 4:\n        filename = \"Value_Parameters_Defaults.xlsx\"\n    elif \"Perfect\" in self.data_name:\n        filename = \"Value_Parameters_Defaults_Perfect.xlsx\"\n    else:\n        filename = \"Value_Parameters_Defaults_Generated.xlsx\"\n    filepath = folder_path + filename\n\n    # Module shorthand\n    afccp_vp = afccp.data.values\n\n    # Import \"default value parameters\" from excel\n    dvp = afccp_vp.default_value_parameters_from_excel(filepath, num_breakpoints=num_breakpoints, printing=printing)\n\n    # Generate this instance's value parameters from the defaults\n    value_parameters = afccp_vp.generate_value_parameters_from_defaults(\n        self.parameters, generate_afsc_weights=generate_afsc_weights, default_value_parameters=dvp)\n\n    # Add some additional components to the value parameters\n    if no_constraints:\n        value_parameters['constraint_type'] = np.zeros([self.parameters['M'], value_parameters['O']])\n\n    # \"Condense\" the value functions by removing unnecessary zeros\n    value_parameters = afccp_vp.condense_value_functions(self.parameters, value_parameters)\n\n    # Add indexed sets and subsets of AFSCs and AFSC objectives\n    value_parameters = afccp_vp.value_parameters_sets_additions(self.parameters, value_parameters)\n\n    # Weight of the value parameters as a whole\n    value_parameters['vp_weight'] = vp_weight\n\n    # Set value parameters to instance attribute\n    if self.mdl_p[\"set_to_instance\"]:\n        self.value_parameters = value_parameters\n        if self.solution is not None:\n            self.solution = afccp.solutions.handling.evaluate_solution(\n                self.solution, self.parameters, self.value_parameters, printing=printing)\n\n    # Save new set of value parameters to dictionary\n    if self.mdl_p[\"add_to_dict\"]:\n        self._save_new_value_parameters_to_dict(value_parameters)\n\n    if self.printing:\n        print('Imported.')\n\n    return value_parameters\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.construct_rated_preferences_from_om_by_soc","title":"<code>construct_rated_preferences_from_om_by_soc(printing=None)</code>","text":"<p>Construct Combined Rated AFSC Preferences Using Ordered Merit (OM) Data.</p> <p>This method processes and merges the OM matrices from each Source of Commissioning (SOC) (e.g., USAFA, ROTC) to construct a unified \"1-N\" preference list for all Rated AFSCs. It updates both the AFSC preference lists (<code>afsc_preferences</code>) and the AFSC preference matrix (<code>a_pref_matrix</code>) in the <code>parameters</code> dictionary.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.construct_rated_preferences_from_om_by_soc--parameters","title":"Parameters:","text":"<p>printing (bool, optional): If True, prints a log statement indicating the preference integration process.     Defaults to <code>self.printing</code>.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.construct_rated_preferences_from_om_by_soc--returns","title":"Returns:","text":"<p>None</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.construct_rated_preferences_from_om_by_soc--example","title":"Example:","text":"<pre><code>instance.construct_rated_preferences_from_om_by_soc(printing=True)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.construct_rated_preferences_from_om_by_soc--see-also","title":"See Also:","text":"<ul> <li><code>construct_rated_preferences_from_om_by_soc</code>:   Underlying function that consolidates SOC-specific OM matrices into ranked preferences.</li> <li><code>parameter_sets_additions</code>:   Updates indexed subsets after modifying AFSC preferences.</li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def construct_rated_preferences_from_om_by_soc(self, printing=None):\n    \"\"\"\n    Construct Combined Rated AFSC Preferences Using Ordered Merit (OM) Data.\n\n    This method processes and merges the OM matrices from each Source of Commissioning (SOC) (e.g., USAFA, ROTC)\n    to construct a unified \"1-N\" preference list for all Rated AFSCs. It updates both the AFSC preference lists\n    (`afsc_preferences`) and the AFSC preference matrix (`a_pref_matrix`) in the `parameters` dictionary.\n\n    Parameters:\n    --------\n    printing (bool, optional): If True, prints a log statement indicating the preference integration process.\n        Defaults to `self.printing`.\n\n    Returns:\n    --------\n    None\n\n    Example:\n    --------\n    ```python\n    instance.construct_rated_preferences_from_om_by_soc(printing=True)\n    ```\n\n    See Also:\n    --------\n    - [`construct_rated_preferences_from_om_by_soc`](../../../../afccp/reference/data/preferences/#data.preferences.construct_rated_preferences_from_om_by_soc):\n      Underlying function that consolidates SOC-specific OM matrices into ranked preferences.\n    - [`parameter_sets_additions`](../../../../afccp/reference/data/adjustments/#data.adjustments.parameter_sets_additions):\n      Updates indexed subsets after modifying AFSC preferences.\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Integrating rated preferences from OM matrices for each SOC...\")\n\n    # Generate Rated Preferences\n    self.parameters = afccp.data.preferences.construct_rated_preferences_from_om_by_soc(self.parameters)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_qualification_matrix_from_afsc_preferences","title":"<code>update_qualification_matrix_from_afsc_preferences(printing=None)</code>","text":"<p>This method updates the qualification matrix to reflect cadet eligibility for AFSCs based on their preferences.</p> <p>It performs the following steps:</p> <ol> <li>Checks if there is an AFSC preference matrix ('a_pref_matrix') in the parameters. If not, it raises a ValueError.</li> <li>Iterates through each AFSC ('afscs') in the parameters.</li> <li>Determines cadet eligibility and ineligibility for each AFSC based on both AFSC preferences and degree qualifications.</li> <li>If cadet eligibility differs between preference and qualification lists, it prints a message indicating the mismatch.</li> <li>For Rated or USSF AFSCs, it updates the qualification matrix, making more cadets ineligible based on CFM lists.</li> <li>For NRL AFSCs, it handles cadets eligible based on CFM lists but not the AFOCD by giving them exceptions.</li> <li>For NRL AFSCs, it also handles cadets eligible based on the AFOCD but not the CFM lists by marking them as a warning.</li> <li>Updates the qualification matrix with these changes and updates additional sets and subsets in the parameters.</li> </ol> <p>This method helps ensure that the qualification matrix aligns with cadet preferences and the AFOCD.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_qualification_matrix_from_afsc_preferences--args","title":"Args:","text":"<p>self: The class instance containing the qualification matrix and parameters.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_qualification_matrix_from_afsc_preferences--returns","title":"Returns:","text":"<p>None</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_qualification_matrix_from_afsc_preferences--raises","title":"Raises:","text":"<p>ValueError: If there is no AFSC preference matrix ('a_pref_matrix') in the parameters.</p> <p>Parameters:</p> Name Type Description Default <code>printing</code> <p>print status updates</p> <code>None</code> Source code in <code>afccp/main.py</code> <pre><code>def update_qualification_matrix_from_afsc_preferences(self, printing=None):\n    \"\"\"\n    This method updates the qualification matrix to reflect cadet eligibility for AFSCs based on their preferences.\n\n    It performs the following steps:\n\n    1. Checks if there is an AFSC preference matrix ('a_pref_matrix') in the parameters. If not, it raises a ValueError.\n    2. Iterates through each AFSC ('afscs') in the parameters.\n    3. Determines cadet eligibility and ineligibility for each AFSC based on both AFSC preferences and degree qualifications.\n    4. If cadet eligibility differs between preference and qualification lists, it prints a message indicating the mismatch.\n    5. For Rated or USSF AFSCs, it updates the qualification matrix, making more cadets ineligible based on CFM lists.\n    6. For NRL AFSCs, it handles cadets eligible based on CFM lists but not the AFOCD by giving them exceptions.\n    7. For NRL AFSCs, it also handles cadets eligible based on the AFOCD but not the CFM lists by marking them as a warning.\n    8. Updates the qualification matrix with these changes and updates additional sets and subsets in the parameters.\n\n    This method helps ensure that the qualification matrix aligns with cadet preferences and the AFOCD.\n\n    Args:\n    --------\n    self: The class instance containing the qualification matrix and parameters.\n\n    Returns:\n    --------\n    None\n\n    Raises:\n    --------\n    ValueError: If there is no AFSC preference matrix ('a_pref_matrix') in the parameters.\n    :param printing: print status updates\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Shorthand\n    p = self.parameters\n\n    if 'a_pref_matrix' not in p:\n        raise ValueError(\"No AFSC preference matrix.\")\n\n    # Loop through each AFSC\n    for j, afsc in enumerate(p['afscs'][:p['M']]):\n\n        # Eligible &amp; Ineligible cadets based on the CFM preference lists\n        preference_eligible_cadets = np.where(p['a_pref_matrix'][:, j] &gt; 0)[0]\n        preference_ineligible_cadets = np.where(p['a_pref_matrix'][:, j] == 0)[0]\n\n        # Eligible cadets based on their degree qualifications (and later using exceptions)\n        qual_eligible_cadets = np.where(p['eligible'][:, j])[0]\n\n        # There's a difference between the two\n        if len(preference_eligible_cadets) != len(qual_eligible_cadets) and printing:\n            print(j, \"AFSC '\" + afsc + \"' has\", len(preference_eligible_cadets),\n                  \"eligible cadets according to the AFSC preference matrix but\",\n                  len(qual_eligible_cadets), \"according to the qual matrix.\")\n\n        # If this is a Rated or USSF AFSC, we have to make more cadets ineligible based on CFM lists\n        if p['acc_grp'][j] in ['Rated', 'USSF']:\n\n            # Only do this if we have ineligible cadets here\n            if len(preference_ineligible_cadets) &gt; 0:\n\n                # If there's already an ineligible tier in this AFSC, we use it\n                if \"I = 0\" in p['Deg Tiers'][j]:\n                    val = \"I\" + str(p['t_count'][j])\n                else:\n                    val = \"I\" + str(p['t_count'][j] + 1)\n                    if printing:\n                        print(j, \"AFSC '\" + afsc + \"' doesn't have an ineligible tier in the Deg Tiers section\"\n                                                \" of the AFSCs.csv file. Please add one.\")\n\n                # Update qual matrix if needed\n                if len(preference_ineligible_cadets) &gt; 0 and printing:\n                    print(j, \"Making\", len(preference_ineligible_cadets), \"cadets ineligible for '\" + afsc +\n                          \"' by altering their qualification to '\" + val + \"'. \")\n                    self.parameters['qual'][preference_ineligible_cadets, j] = val\n\n        # NRL AFSC\n        else:\n\n            # Cadets that are \"eligible\" for the AFSC based on the CFM lists but not the AFOCD\n            exception_cadets = np.array([i for i in preference_eligible_cadets if i not in qual_eligible_cadets])\n\n            # Only do this if we have exception cadets here\n            if len(exception_cadets) &gt; 0:\n\n                # If there's an ineligible tier, we use this tier for the cadets with the exception\n                if \"I = 0\" in p['Deg Tiers'][j]:\n                    val = \"E\" + str(p['t_count'][j])\n                else:\n                    val = \"E\" + str(p['t_count'][j] + 1)\n\n                # Update qual matrix\n                if printing:\n                    print(j, \"Giving\", len(exception_cadets), \"cadets an exception for '\" + afsc +\n                          \"' by altering their qualification to '\" + val + \"'. \")\n                self.parameters['qual'][exception_cadets, j] = val\n\n            # Cadets that are eligible for the AFSC based on the AFOCD but not the CFM lists\n            mistake_cadets = np.array([i for i in qual_eligible_cadets if i not in preference_eligible_cadets])\n\n            if len(mistake_cadets) &gt; 0 and printing:\n                print(j, 'WARNING. There are', len(mistake_cadets), 'cadets that are eligible for AFSC', afsc,\n                      ' according to the AFOCD but not the CFM lists. These are the cadets at indices',\n                      mistake_cadets)\n\n    # Update qual stuff\n    self.parameters[\"ineligible\"] = (np.core.defchararray.find(self.parameters['qual'], \"I\") != -1) * 1\n    self.parameters[\"eligible\"] = (self.parameters[\"ineligible\"] == 0) * 1\n    self.parameters[\"exception\"] = (np.core.defchararray.find(self.parameters['qual'], \"E\") != -1) * 1\n\n    # Update the additional sets and subsets for the parameters\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.fill_remaining_afsc_choices","title":"<code>fill_remaining_afsc_choices(printing=None)</code>","text":"<p>Fill Remaining Cadet Preferences to Complete the Preference Matrix.</p> <p>This method ensures that each cadet has a complete and ordered set of AFSC preferences by arbitrarily filling in any missing AFSC choices. The method preserves explicitly defined bottom choices (second-to-last and last) and appends any remaining eligible AFSCs not yet ranked by each cadet.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.fill_remaining_afsc_choices--parameters","title":"Parameters:","text":"<p>printing (bool, optional): If True, prints a status update. If None, defaults to the instance\u2019s <code>self.printing</code>.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.fill_remaining_afsc_choices--returns","title":"Returns:","text":"<p>None: Updates <code>self.parameters</code> in-place with a complete preference matrix.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.fill_remaining_afsc_choices--example","title":"Example:","text":"<pre><code>instance.fill_remaining_afsc_choices()\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.fill_remaining_afsc_choices--see-also","title":"See Also:","text":"<ul> <li><code>fill_remaining_preferences</code>:   Underlying function that assigns missing cadet AFSC preferences.</li> <li><code>parameter_sets_additions</code>:   Updates parameter subsets after modifying the preference matrix.</li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def fill_remaining_afsc_choices(self, printing=None):\n    \"\"\"\n    Fill Remaining Cadet Preferences to Complete the Preference Matrix.\n\n    This method ensures that each cadet has a complete and ordered set of AFSC preferences by arbitrarily filling in\n    any missing AFSC choices. The method preserves explicitly defined bottom choices (second-to-last and last) and\n    appends any remaining eligible AFSCs not yet ranked by each cadet.\n\n    Parameters:\n    --------\n    printing (bool, optional): If True, prints a status update. If None, defaults to the instance\u2019s `self.printing`.\n\n    Returns:\n    --------\n    None: Updates `self.parameters` in-place with a complete preference matrix.\n\n    Example:\n    --------\n    ```python\n    instance.fill_remaining_afsc_choices()\n    ```\n\n    See Also:\n    --------\n    - [`fill_remaining_preferences`](../../../../afccp/reference/data/preferences/#data.preferences.fill_remaining_preferences):\n      Underlying function that assigns missing cadet AFSC preferences.\n    - [`parameter_sets_additions`](../../../../afccp/reference/data/adjustments/#data.adjustments.parameter_sets_additions):\n      Updates parameter subsets after modifying the preference matrix.\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Filling remaining cadet preferences arbitrarily with the exception of the bottom choices\")\n\n    # Update parameters\n    self.parameters = afccp.data.preferences.fill_remaining_preferences(self.parameters)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.remove_ineligible_choices","title":"<code>remove_ineligible_choices(printing=None)</code>","text":"<p>Remove Ineligible Cadet-AFSC Pairings Based on Qualification Criteria.</p> <p>This method scans both the cadet and AFSC preference matrices (<code>c_pref_matrix</code> and <code>a_pref_matrix</code>) and removes pairings that violate the qualification constraints defined in the <code>qual</code> matrix. It ensures that cadets are only considered for AFSCs for which they are qualified, and updates all three matrices to sync them all on eligibility (<code>c_pref_matrix</code>, <code>a_pref_matrix</code>, <code>qual</code>).</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.remove_ineligible_choices--parameters","title":"Parameters:","text":"<p>printing (bool, optional): If True, prints progress and debug information. If None (default), it uses the instance-level <code>self.printing</code> attribute.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.remove_ineligible_choices--returns","title":"Returns:","text":"<p>None: The method modifies the <code>parameters</code> attribute in-place.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.remove_ineligible_choices--examples","title":"Examples:","text":"<pre><code>instance.remove_ineligible_choices(printing=True)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.remove_ineligible_choices--see-also","title":"See Also:","text":"<ul> <li><code>remove_ineligible_cadet_choices</code>:   Underlying function that performs the actual validation and cleanup of preference matrices.</li> <li><code>parameter_sets_additions</code>:   Rebuilds indexed sets and eligibility structures after editing cadet-AFSC pairings.</li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def remove_ineligible_choices(self, printing=None):\n    \"\"\"\n    Remove Ineligible Cadet-AFSC Pairings Based on Qualification Criteria.\n\n    This method scans both the cadet and AFSC preference matrices (`c_pref_matrix` and `a_pref_matrix`)\n    and removes pairings that violate the qualification constraints defined in the `qual` matrix. It ensures\n    that cadets are only considered for AFSCs for which they are qualified, and updates all three matrices to sync\n    them all on eligibility (`c_pref_matrix`, `a_pref_matrix`, `qual`).\n\n    Parameters:\n    --------\n    printing (bool, optional): If True, prints progress and debug information. If None (default),\n    it uses the instance-level `self.printing` attribute.\n\n    Returns:\n    --------\n    None: The method modifies the `parameters` attribute in-place.\n\n    Examples:\n    --------\n    ```python\n    instance.remove_ineligible_choices(printing=True)\n    ```\n\n    See Also:\n    --------\n    - [`remove_ineligible_cadet_choices`](../../../../afccp/reference/data/preferences/#data.preferences.remove_ineligible_cadet_choices):\n      Underlying function that performs the actual validation and cleanup of preference matrices.\n    - [`parameter_sets_additions`](../../../../afccp/reference/data/adjustments/#data.adjustments.parameter_sets_additions):\n      Rebuilds indexed sets and eligibility structures after editing cadet-AFSC pairings.\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Removing ineligible cadets based on any of the three eligibility sources \"\n              \"(c_pref_matrix, a_pref_matrix, qual)...\")\n\n    self.parameters = afccp.data.preferences.remove_ineligible_cadet_choices(self.parameters, printing=printing)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_preference_matrices","title":"<code>update_preference_matrices(printing=None)</code>","text":"<p>Update preference matrices from cadet and AFSC preference arrays.</p> <p>This method reconstructs the cadet and AFSC preference matrices (<code>c_pref_matrix</code> and <code>a_pref_matrix</code>) by transforming indexed preference arrays into complete, gapless matrices. Any gaps in the ranking (e.g., preferences like 1, 2, 4, 6, 7) are renumbered to ensure a continuous ranking (1, 2, 3, 4, 5), which is required for consistent model input.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_preference_matrices--parameters","title":"Parameters","text":"<p>printing : bool, optional Whether to print status updates during execution. Defaults to <code>self.printing</code>.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_preference_matrices--returns","title":"Returns","text":"<p>None This method updates the internal <code>parameters</code> attribute of the instance in place.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_preference_matrices--examples","title":"Examples","text":"<pre><code>instance = CadetCareerProblem(parameters)\ninstance.update_preference_matrices(printing=True)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_preference_matrices--see-also","title":"See Also","text":"<p><code>afccp.data.preferences.update_preference_matrices</code>     Underlying function that reconstructs preference matrices from dictionary of lists</p> Source code in <code>afccp/main.py</code> <pre><code>def update_preference_matrices(self, printing=None):\n    \"\"\"\n    Update preference matrices from cadet and AFSC preference arrays.\n\n    This method reconstructs the cadet and AFSC preference matrices (`c_pref_matrix` and `a_pref_matrix`)\n    by transforming indexed preference arrays into complete, gapless matrices. Any gaps in the ranking (e.g.,\n    preferences like 1, 2, 4, 6, 7) are renumbered to ensure a continuous ranking (1, 2, 3, 4, 5), which is\n    required for consistent model input.\n\n    Parameters\n    ----------\n    printing : bool, optional\n    Whether to print status updates during execution. Defaults to `self.printing`.\n\n    Returns\n    -------\n    None\n    This method updates the internal `parameters` attribute of the instance in place.\n\n    Examples\n    --------\n    ```python\n    instance = CadetCareerProblem(parameters)\n    instance.update_preference_matrices(printing=True)\n    ```\n\n    See Also\n    --------\n    [`afccp.data.preferences.update_preference_matrices`](../../../../afccp/reference/data/preferences/#data.preferences.update_preference_matrices)\n        Underlying function that reconstructs preference matrices from dictionary of lists\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Updating cadet preference matrices from the preference dictionaries. \"\n              \"ie. 1, 2, 4, 6, 7 -&gt; 1, 2, 3, 4, 5 (preference lists need to omit gaps)\")\n\n    # Update parameters\n    self.parameters = afccp.data.preferences.update_preference_matrices(self.parameters)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_first_choice_cadet_utility_to_one","title":"<code>update_first_choice_cadet_utility_to_one(printing=None)</code>","text":"<p>Fix Cadet First-Choice Utility to 100%.</p> <p>This method updates the <code>utility</code> matrix so that each cadet's top-ranked AFSC is assigned a utility value of 1. This normalization ensures that the first choice always represents the maximum utility (100%) for that cadet.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_first_choice_cadet_utility_to_one--parameters","title":"Parameters","text":"<p>printing : bool, optional If True, prints the number and indices of cadets whose utilities were updated. Defaults to <code>self.printing</code> if not explicitly provided.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_first_choice_cadet_utility_to_one--returns","title":"Returns","text":"<p>None Updates <code>self.parameters['utility']</code> in-place.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_first_choice_cadet_utility_to_one--examples","title":"Examples","text":"<pre><code>instance.update_first_choice_cadet_utility_to_one()\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_first_choice_cadet_utility_to_one--see-also","title":"See Also","text":"<p><code>update_first_choice_cadet_utility_to_one</code></p> Source code in <code>afccp/main.py</code> <pre><code>def update_first_choice_cadet_utility_to_one(self, printing=None):\n    \"\"\"\n    Fix Cadet First-Choice Utility to 100%.\n\n    This method updates the `utility` matrix so that each cadet's top-ranked AFSC is assigned a utility value of 1.\n    This normalization ensures that the first choice always represents the maximum utility (100%) for that cadet.\n\n    Parameters\n    ----------\n    printing : bool, optional\n    If True, prints the number and indices of cadets whose utilities were updated.\n    Defaults to `self.printing` if not explicitly provided.\n\n    Returns\n    -------\n    None\n    Updates `self.parameters['utility']` in-place.\n\n    Examples\n    --------\n    ```python\n    instance.update_first_choice_cadet_utility_to_one()\n    ```\n\n    See Also\n    --------\n    [`update_first_choice_cadet_utility_to_one`](../../../../afccp/reference/data/preferences/#data.preferences.update_first_choice_cadet_utility_to_one)\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print('Updating cadet first choice utility value to 100%...')\n\n    # Update \"utility\" matrix\n    self.parameters['utility'] = afccp.data.preferences.update_first_choice_cadet_utility_to_one(\n        self.parameters, printing=printing)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.convert_afsc_preferences_to_percentiles","title":"<code>convert_afsc_preferences_to_percentiles(printing=None)</code>","text":"<p>Convert AFSC Preference Lists to Normalized Percentiles.</p> <p>This method takes the AFSC preference lists (<code>a_pref_matrix</code>) and converts them into normalized percentiles representing how strongly each AFSC prefers each cadet relative to others. Higher-ranked cadets receive values closer to 1.0, while lower-ranked cadets receive values closer to 0.0.</p> <p>The result is stored in <code>afsc_utility</code> and can be used for further utility-based calculations or optimization models. Results are also saved under \"AFSCs Utility.csv\".</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.convert_afsc_preferences_to_percentiles--parameters","title":"Parameters","text":"<p>printing : bool, optional If True, prints a message about the conversion process. If None, defaults to the object's <code>self.printing</code> attribute.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.convert_afsc_preferences_to_percentiles--returns","title":"Returns","text":"<p>None This method updates <code>self.parameters</code> in place with a new <code>afsc_utility</code> matrix.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.convert_afsc_preferences_to_percentiles--examples","title":"Examples","text":"<pre><code>instance.convert_afsc_preferences_to_percentiles(printing=True)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.convert_afsc_preferences_to_percentiles--see-also","title":"See Also","text":"<ul> <li><code>convert_afsc_preferences_to_percentiles()</code></li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def convert_afsc_preferences_to_percentiles(self, printing=None):\n    \"\"\"\n    Convert AFSC Preference Lists to Normalized Percentiles.\n\n    This method takes the AFSC preference lists (`a_pref_matrix`) and converts them into normalized\n    percentiles representing how strongly each AFSC prefers each cadet relative to others.\n    Higher-ranked cadets receive values closer to 1.0, while lower-ranked cadets receive values closer to 0.0.\n\n    The result is stored in `afsc_utility` and can be used for further utility-based calculations or\n    optimization models. Results are also saved under \"AFSCs Utility.csv\".\n\n    Parameters\n    ----------\n    printing : bool, optional\n    If True, prints a message about the conversion process.\n    If None, defaults to the object's `self.printing` attribute.\n\n    Returns\n    -------\n    None\n    This method updates `self.parameters` in place with a new `afsc_utility` matrix.\n\n    Examples\n    --------\n    ```python\n    instance.convert_afsc_preferences_to_percentiles(printing=True)\n    ```\n\n    See Also\n    --------\n    - [`convert_afsc_preferences_to_percentiles()`](../../../../afccp/reference/data/preferences/#data.preferences.convert_afsc_preferences_to_percentiles)\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Converting AFSC preferences (a_pref_matrix) into percentiles (afsc_utility on AFSCs Utility.csv)...\")\n    self.parameters = afccp.data.preferences.convert_afsc_preferences_to_percentiles(self.parameters)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_cadet_columns_from_matrices","title":"<code>update_cadet_columns_from_matrices(printing=None)</code>","text":"<p>Update Cadet Columns from Preference Matrix.</p> <p>This method updates cadet-level columns (<code>c_preferences</code>, <code>c_utilities</code>) by extracting them from the cadet preference matrix (<code>c_pref_matrix</code>). Each cadet's ranked AFSCs are transformed into a compact preference list, and the associated utility values are retrieved.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_cadet_columns_from_matrices--parameters","title":"Parameters","text":"<p>printing : bool, optional If True, prints a message about the conversion process. If None, defaults to the object's <code>self.printing</code> attribute.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_cadet_columns_from_matrices--returns","title":"Returns","text":"<p>None: This method updates <code>self.parameters</code> in place with:</p> <ul> <li><code>c_preferences</code> : dict of lists     Ranked AFSCs for each cadet (non-zero entries from <code>c_pref_matrix</code>)</li> <li><code>c_utilities</code> : dict of lists     Corresponding utility values for each cadet\u2019s preference list</li> </ul>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_cadet_columns_from_matrices--examples","title":"Examples","text":"<pre><code>instance.update_cadet_columns_from_matrices(printing=True)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_cadet_columns_from_matrices--see-also","title":"See Also","text":"<ul> <li><code>update_cadet_columns_from_matrices</code></li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def update_cadet_columns_from_matrices(self, printing=None):\n    \"\"\"\n    Update Cadet Columns from Preference Matrix.\n\n    This method updates cadet-level columns (`c_preferences`, `c_utilities`) by extracting them\n    from the cadet preference matrix (`c_pref_matrix`). Each cadet's ranked AFSCs are transformed\n    into a compact preference list, and the associated utility values are retrieved.\n\n    Parameters\n    ----------\n    printing : bool, optional\n    If True, prints a message about the conversion process.\n    If None, defaults to the object's `self.printing` attribute.\n\n    Returns\n    -------\n    None: This method updates `self.parameters` in place with:\n\n    - `c_preferences` : dict of lists\n        Ranked AFSCs for each cadet (non-zero entries from `c_pref_matrix`)\n    - `c_utilities` : dict of lists\n        Corresponding utility values for each cadet\u2019s preference list\n\n    Examples\n    --------\n    ```python\n    instance.update_cadet_columns_from_matrices(printing=True)\n    ```\n\n    See Also\n    --------\n    - [`update_cadet_columns_from_matrices`](../../../../afccp/reference/data/preferences/#data.preferences.update_cadet_columns_from_matrices)\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print('Updating cadet columns (Cadets.csv...c_utilities, c_preferences) from the preference matrix '\n              '(c_pref_matrix)...')\n\n    # Update parameters\n    self.parameters['c_preferences'], self.parameters['c_utilities'] = \\\n        afccp.data.preferences.update_cadet_columns_from_matrices(self.parameters)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_cadet_utility_matrices_from_cadets_data","title":"<code>update_cadet_utility_matrices_from_cadets_data(printing=None)</code>","text":"<p>Update Cadet Utility Matrices from Cadets Data.</p> <p>This method updates the <code>utility</code> and <code>cadet_utility</code> matrices using the cadet-reported utility values stored in the <code>\"Util_1\"</code> through <code>\"Util_P\"</code> columns of <code>Cadets.csv</code>. It first populates the raw utility matrix (<code>utility</code>) and then normalizes these values to construct the final <code>cadet_utility</code> matrix based on either ordinal rankings or a value-based transformation if the <code>last_afsc</code> parameter is provided.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_cadet_utility_matrices_from_cadets_data--parameters","title":"Parameters","text":"<p>printing : bool, optional     Whether to print progress information. Defaults to the instance's <code>self.printing</code> setting.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_cadet_utility_matrices_from_cadets_data--returns","title":"Returns","text":"<p>None: Updates the following attributes in-place:</p> <ul> <li><code>self.parameters['utility']</code> : ndarray, cadet-reported utilities with an unmatched column</li> <li><code>self.parameters['cadet_utility']</code> : ndarray, normalized utility matrix</li> </ul>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_cadet_utility_matrices_from_cadets_data--examples","title":"Examples","text":"<pre><code>instance.update_cadet_utility_matrices_from_cadets_data()\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.update_cadet_utility_matrices_from_cadets_data--see-also","title":"See Also","text":"<ul> <li><code>update_cadet_utility_matrices</code></li> <li><code>create_final_cadet_utility_matrix_from_new_formula</code></li> <li><code>create_final_cadet_utility_matrix</code></li> <li><code>parameter_sets_additions</code></li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def update_cadet_utility_matrices_from_cadets_data(self, printing=None):\n    \"\"\"\n    Update Cadet Utility Matrices from Cadets Data.\n\n    This method updates the `utility` and `cadet_utility` matrices using the cadet-reported utility values stored in the\n    `\"Util_1\"` through `\"Util_P\"` columns of `Cadets.csv`. It first populates the raw utility matrix (`utility`) and then\n    normalizes these values to construct the final `cadet_utility` matrix based on either ordinal rankings or a value-based\n    transformation if the `last_afsc` parameter is provided.\n\n    Parameters\n    ----------\n    printing : bool, optional\n        Whether to print progress information. Defaults to the instance's `self.printing` setting.\n\n    Returns\n    -------\n    None: Updates the following attributes in-place:\n\n    - `self.parameters['utility']` : ndarray, cadet-reported utilities with an unmatched column\n    - `self.parameters['cadet_utility']` : ndarray, normalized utility matrix\n\n    Examples\n    --------\n    ```python\n    instance.update_cadet_utility_matrices_from_cadets_data()\n    ```\n\n    See Also\n    --------\n    - [`update_cadet_utility_matrices`](../../../../afccp/reference/data/preferences/#data.preferences.update_cadet_utility_matrices)\n    - [`create_final_cadet_utility_matrix_from_new_formula`](../../../../afccp/reference/data/preferences/#data.preferences.create_final_cadet_utility_matrix_from_new_formula)\n    - [`create_final_cadet_utility_matrix`](../../../../afccp/reference/data/preferences/#data.preferences.create_final_cadet_utility_matrix)\n    - [`parameter_sets_additions`](../../../../afccp/reference/data/adjustments/#data.adjustments.parameter_sets_additions)\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Updating cadet utility matrices ('utility' and 'cadet_utility') from the 'c_utilities' matrix\")\n\n    # Update parameters\n    self.parameters = afccp.data.preferences.update_cadet_utility_matrices(self.parameters)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.modify_rated_cadet_lists_based_on_eligibility","title":"<code>modify_rated_cadet_lists_based_on_eligibility(printing=None)</code>","text":"<p>Modify Rated Eligibility Lists and Matrices by SOC.</p> <p>This method removes cadets from each Source of Commissioning (SOC)'s rated cadet list if they lack any rated AFSC preferences. It also updates the corresponding rated order-of-merit matrix (e.g., 'rr_om_matrix') by removing the appropriate cadet rows.</p> <p>This ensures that rated eligibility lists and matrices only contain cadets who actually have at least one rated AFSC preference, which is essential for valid downstream rated matching logic.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.modify_rated_cadet_lists_based_on_eligibility--parameters","title":"Parameters","text":"<p>printing : bool, optional     If True (default is <code>self.printing</code>), prints a summary of removed cadets and updated matrices.</p>"},{"location":"reference/main/cadetcareerproblem_main_data_corrections/#afccp.main.CadetCareerProblem.modify_rated_cadet_lists_based_on_eligibility--see-also","title":"See Also","text":"<ul> <li><code>modify_rated_cadet_lists_based_on_eligibility</code></li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def modify_rated_cadet_lists_based_on_eligibility(self, printing=None):\n    \"\"\"\n    Modify Rated Eligibility Lists and Matrices by SOC.\n\n    This method removes cadets from each Source of Commissioning (SOC)'s rated cadet list if they lack any rated AFSC\n    preferences. It also updates the corresponding rated order-of-merit matrix (e.g., 'rr_om_matrix') by removing the\n    appropriate cadet rows.\n\n    This ensures that rated eligibility lists and matrices only contain cadets who actually have at least one rated AFSC\n    preference, which is essential for valid downstream rated matching logic.\n\n    Parameters\n    ----------\n    printing : bool, optional\n        If True (default is `self.printing`), prints a summary of removed cadets and updated matrices.\n\n    See Also\n    --------\n    - [`modify_rated_cadet_lists_based_on_eligibility`](../../../../afccp/reference/data/preferences/#data.preferences.modify_rated_cadet_lists_based_on_eligibility)\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print('Modifying rated eligibiity lists/matrices by SOC... \\n'\n              '(Removing cadets that are on the lists but not eligible for any rated AFSC)')\n\n    # Update rated eligibility lists\n    self.parameters = afccp.data.preferences.modify_rated_cadet_lists_based_on_eligibility(\n        self.parameters, printing=printing)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_optimization_models_%26_meta-heuristics/","title":"CadetCareerProblem \u2013 Optimization Models &amp; Meta-Heuristics Methods","text":""},{"location":"reference/main/cadetcareerproblem_optimization_models_%26_meta-heuristics/#afccp.main.CadetCareerProblem.solve_vft_pyomo_model","title":"<code>solve_vft_pyomo_model(p_dict={}, printing=None)</code>","text":"<p>Solve the VFT model using Pyomo, an optimization modeling library.</p> <p>This method is responsible for solving the Value Focussed Thinking (VFT) model using Pyomo. The VFT model is a specific type of optimization model. It conducts the necessary preparation, builds the model, solves it, and handles the resulting solution. The goal is to find optimal solutions for the VFT problem.</p> <p>Args:     p_dict (dict): A dictionary of parameters used for the model. It allows for customization of the model's         input parameters.     printing (bool, None): A flag to control whether to print information during the model-solving process. If set to         True, the method will print progress and debugging information. If set to False, it will suppress printing.         If None, the method will use the default printing setting from the class instance.</p> <p>Returns:     solution: The solution of the VFT model, which contains the optimal values for the decision variables and other         relevant information.</p> <p>Notes: - Before using this method, it's important to ensure that the class instance contains valid and appropriate data. - This method uses external functions for building and solving the Pyomo model, and the specifics of those functions   are located in the 'afccp.solutions.optimization' module.</p> Source code in <code>afccp/main.py</code> <pre><code>def solve_vft_pyomo_model(self, p_dict={}, printing=None):\n    \"\"\"\n    Solve the VFT model using Pyomo, an optimization modeling library.\n\n    This method is responsible for solving the Value Focussed Thinking (VFT) model using Pyomo. The VFT model is a specific\n    type of optimization model. It conducts the necessary preparation, builds the model, solves it, and handles the\n    resulting solution. The goal is to find optimal solutions for the VFT problem.\n\n    Args:\n        p_dict (dict): A dictionary of parameters used for the model. It allows for customization of the model's\n            input parameters.\n        printing (bool, None): A flag to control whether to print information during the model-solving process. If set to\n            True, the method will print progress and debugging information. If set to False, it will suppress printing.\n            If None, the method will use the default printing setting from the class instance.\n\n    Returns:\n        solution: The solution of the VFT model, which contains the optimal values for the decision variables and other\n            relevant information.\n\n    Notes:\n    - Before using this method, it's important to ensure that the class instance contains valid and appropriate data.\n    - This method uses external functions for building and solving the Pyomo model, and the specifics of those functions\n      are located in the 'afccp.solutions.optimization' module.\n    \"\"\"\n    self._error_checking(\"Pyomo Model\")\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self._reset_functional_parameters(p_dict)\n\n    # Build the model and then solve it\n    model, q = afccp.solutions.optimization.vft_model_build(self, printing=printing)\n    solution = afccp.solutions.optimization.solve_pyomo_model(self, model, \"VFT\", q=q, printing=printing)\n\n    # Determine what to do with the solution\n    self._solution_handling(solution)\n\n    # Return the solution\n    return solution\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_optimization_models_%26_meta-heuristics/#afccp.main.CadetCareerProblem.solve_original_pyomo_model","title":"<code>solve_original_pyomo_model(p_dict={}, printing=None)</code>","text":"<p>Solve the original AFPC model using pyomo</p> Source code in <code>afccp/main.py</code> <pre><code>def solve_original_pyomo_model(self, p_dict={}, printing=None):\n    \"\"\"\n    Solve the original AFPC model using pyomo\n    \"\"\"\n    self._error_checking(\"Pyomo Model\")\n    if printing is None:\n        printing = self.printing\n\n    # One little \"switch\" to get the original model objective function\n    p_dict['assignment_model_obj'] = \"Original Utility\"\n\n    # Reset instance model parameters\n    self._reset_functional_parameters(p_dict)\n\n    # Build the model and then solve it\n    model = afccp.solutions.optimization.assignment_model_build(self, printing=printing)\n    solution = afccp.solutions.optimization.solve_pyomo_model(self, model, \"Original\", printing=printing)\n\n    # Determine what to do with the solution\n    self._solution_handling(solution)\n\n    # Return the solution\n    return solution\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_optimization_models_%26_meta-heuristics/#afccp.main.CadetCareerProblem.solve_guo_pyomo_model","title":"<code>solve_guo_pyomo_model(p_dict={}, printing=None)</code>","text":"<p>Solve the \"generalized assignment problem\" model with the new global utility matrix constructed from the AFSC and Cadet Utility matrices. This is the \"GUO\" model.</p> Source code in <code>afccp/main.py</code> <pre><code>def solve_guo_pyomo_model(self, p_dict={}, printing=None):\n    \"\"\"\n    Solve the \"generalized assignment problem\" model with the new global utility matrix constructed\n    from the AFSC and Cadet Utility matrices. This is the \"GUO\" model.\n    \"\"\"\n    # One little \"switch\" to get the new assignment model objective function\n    p_dict['assignment_model_obj'] = \"Global Utility\"\n\n    # Reset instance model parameters\n    self._reset_functional_parameters(p_dict)\n\n    # Error handling\n    self._error_checking(\"Pyomo Model\")\n    if printing is None:\n        printing = self.printing\n\n    # Determine solution method\n    if self.mdl_p['solution_method'] is None:\n        solution_method = 'GUO'\n    else:\n        solution_method = self.mdl_p['solution_method']\n\n    # Build the model and then solve it\n    model = afccp.solutions.optimization.assignment_model_build(self, printing=printing)\n    solution = afccp.solutions.optimization.solve_pyomo_model(self, model, solution_method, printing=printing)\n\n    # Determine what to do with the solution\n    self._solution_handling(solution)\n\n    # Return the solution\n    return solution\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_optimization_models_%26_meta-heuristics/#afccp.main.CadetCareerProblem.solve_gp_pyomo_model","title":"<code>solve_gp_pyomo_model(p_dict={}, printing=None)</code>","text":"<p>Solve the Goal Programming Model (Created by Lt. Reynolds)</p> Source code in <code>afccp/main.py</code> <pre><code>def solve_gp_pyomo_model(self, p_dict={}, printing=None):\n    \"\"\"\n    Solve the Goal Programming Model (Created by Lt. Reynolds)\n    \"\"\"\n    self._error_checking(\"Pyomo Model\")\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self._reset_functional_parameters(p_dict)\n\n    # Convert VFT parameters to Goal Programming (\"gp\") parameters\n    if self.gp_parameters is None:\n        self.vft_to_gp_parameters(self.mdl_p)\n\n    # Build the model and then solve it\n    model = afccp.solutions.optimization.gp_model_build(self, printing=printing)\n    solution = afccp.solutions.optimization.solve_pyomo_model(self, model, \"GP\", printing=printing)\n\n    # Determine what to do with the solution\n    self._solution_handling(solution)\n\n    # Return the solution\n    return solution\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_optimization_models_%26_meta-heuristics/#afccp.main.CadetCareerProblem.solve_vft_main_methodology","title":"<code>solve_vft_main_methodology(p_dict={}, printing=None)</code>","text":"<p>This is the main method to solve the problem instance. We first determine an initial population of solutions. We then evolve the solutions further using the GA.</p> Source code in <code>afccp/main.py</code> <pre><code>def solve_vft_main_methodology(self, p_dict={}, printing=None):\n    \"\"\"\n    This is the main method to solve the problem instance. We first determine an initial population of solutions.\n    We then evolve the solutions further using the GA.\n    \"\"\"\n    self._error_checking(\"Pyomo Model\")\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self._reset_functional_parameters(p_dict)\n\n    # Determine population for the genetic algorithm\n    if self.mdl_p['population_generation_model'] == 'Assignment':\n        self.mdl_p[\"initial_solutions\"] = \\\n            afccp.solutions.sensitivity.populate_initial_ga_solutions_from_assignment_model(self, printing)\n    else:\n        self.mdl_p[\"initial_solutions\"] = \\\n            afccp.solutions.sensitivity.populate_initial_ga_solutions_from_vft_model(self, printing)\n\n    # Add additional solutions if necessary\n    if self.mdl_p[\"solution_names\"] is not None:\n\n        # In case the user specifies \"Solution\" instead of [\"Solution\"]\n        if type(self.mdl_p[\"solution_names\"]) == str:\n            self.mdl_p[\"solution_names\"] = [self.mdl_p[\"solution_names\"]]\n\n        # Add additional solutions\n        for solution_name in self.mdl_p[\"solution_names\"]:\n            solution = self.solutions[solution_name]\n            self.mdl_p[\"initial_solutions\"] = np.vstack((self.mdl_p[\"initial_solutions\"], solution))\n\n    self.mdl_p[\"initialize\"] = True  # Force the initialize parameter to be true\n\n    if printing:\n        now = datetime.datetime.now()\n        print('Solving Genetic Algorithm for ' + str(self.mdl_p[\"ga_max_time\"]) + ' seconds at ' +\n              now.strftime('%H:%M:%S') + '...')\n    self.vft_genetic_algorithm(self.mdl_p, printing=self.mdl_p[\"ga_printing\"])\n    if printing:\n        print('Solution value of ' + str(round(self.solution['z'], 4)) + ' obtained.')\n\n    # Return solution\n    return self.solution\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_optimization_models_%26_meta-heuristics/#afccp.main.CadetCareerProblem.vft_genetic_algorithm","title":"<code>vft_genetic_algorithm(p_dict={}, printing=None)</code>","text":"<p>This is the genetic algorithm. The hyper-parameters to the algorithm can be tuned, and this is meant to be solved in conjunction with the pyomo model solution. Use that as the initial solution, and then we evolve from there</p> Source code in <code>afccp/main.py</code> <pre><code>def vft_genetic_algorithm(self, p_dict={}, printing=None):\n    \"\"\"\n    This is the genetic algorithm. The hyper-parameters to the algorithm can be tuned, and this is meant to be\n    solved in conjunction with the pyomo model solution. Use that as the initial solution, and then we evolve\n    from there\n    \"\"\"\n    self._error_checking(\"Value Parameters\")\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self._reset_functional_parameters(p_dict)\n\n    # Dictionary of failed constraints across all solutions (phased out since we're using APM as initial population)\n    con_fail_dict = None\n\n    # Get a starting population of solutions if applicable!\n    if self.mdl_p[\"initialize\"]:\n\n        if self.mdl_p[\"initial_solutions\"] is None:\n\n            if self.solutions is None:\n                raise ValueError(\"Error. No solutions in dictionary.\")\n\n            else:\n                if self.mdl_p[\"solution_names\"] is None:\n\n                    # Get list of initial solutions\n                    initial_solutions = np.array(\n                        [self.solutions[solution_name]['j_array'] for solution_name in self.solutions])\n                    solution_names = list(self.solutions.keys())\n\n                else:\n\n                    # If we just pass \"Solution\" instead of [\"Solution\"]\n                    if type(self.mdl_p[\"solution_names\"]) == str:\n                        self.mdl_p[\"solution_names\"] = [self.mdl_p[\"solution_names\"]]\n\n                    # Get list of initial solutions\n                    initial_solutions = np.array(\n                        [self.solutions[solution_name]['j_array'] for solution_name in self.mdl_p[\"solution_names\"]])\n                    solution_names = self.mdl_p[\"solution_names\"]\n\n                if printing:\n                    print(\"Running Genetic Algorithm with initial solutions:\", solution_names)\n\n        else:\n\n            # Get list of initial solutions\n            initial_solutions = self.mdl_p[\"initial_solutions\"]\n            if printing:\n                print(\"Running Genetic Algorithm with\", len(initial_solutions), \"initial solutions...\")\n\n    else:\n\n        if printing:\n            print(\"Running Genetic Algorithm with no initial solutions (not advised!)...\")\n        initial_solutions = None\n\n    # Generate the solution\n    solution, time_eval_df = afccp.solutions.algorithms.vft_genetic_algorithm(\n        self, initial_solutions, con_fail_dict, printing=printing)\n\n    # Determine what to do with the solution\n    self._solution_handling(solution)\n\n    # Return the final solution and maybe the time evaluation dataframe if needed\n    if self.mdl_p[\"time_eval\"]:\n        return time_eval_df, solution\n    else:\n        return solution\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_optimization_models_%26_meta-heuristics/#afccp.main.CadetCareerProblem.genetic_matching_algorithm","title":"<code>genetic_matching_algorithm(p_dict={}, printing=None)</code>","text":"<p>This method solves the problem instance using \"Genetic Matching Algorithm\"</p> Source code in <code>afccp/main.py</code> <pre><code>def genetic_matching_algorithm(self, p_dict={}, printing=None):\n    \"\"\"\n    This method solves the problem instance using \"Genetic Matching Algorithm\"\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self._reset_functional_parameters(p_dict)\n\n    # Force solution iteration collection to be turned off\n    self.mdl_p['collect_solution_iterations'] = False\n\n    # Get the capacities\n    capacities = afccp.solutions.algorithms.genetic_matching_algorithm(self, printing=printing)\n\n    # Update capacities in parameters (quota_max or quota_min)\n    self.parameters[self.mdl_p['capacity_parameter']] = capacities\n\n    # Run the matching algorithm with these capacities\n    solution = afccp.solutions.algorithms.classic_hr(self, printing=printing)\n\n    # Determine what to do with the solution\n    self._solution_handling(solution)\n\n    return solution\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/","title":"CadetCareerProblem \u2013 Other Adjustments Methods","text":""},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.parameter_sanity_check","title":"<code>parameter_sanity_check()</code>","text":"<p>Perform a Full Sanity Check on the Instance Parameters and Value Parameters.</p> <p>This method serves as a high-level entry point for validating the integrity and feasibility of all input data used in the AFSC cadet-career field assignment model. It ensures that parameters (<code>self.parameters</code>) and value parameters (<code>self.value_parameters</code>) are properly defined, logically consistent, and free of structural or numerical issues prior to model execution.</p> <p>The method internally delegates the actual check logic to <code>afccp.data.adjustments.parameter_sanity_check(self)</code>, which audits everything from AFSC quotas, cadet eligibility, objective constraints, preference matrices, tier distributions, and utility monotonicity.</p>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.parameter_sanity_check--parameters","title":"Parameters:","text":"<ul> <li>self: <code>CadetCareerProblem</code>     The instance of the assignment problem containing the full dataset and modeling structure.</li> </ul>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.parameter_sanity_check--returns","title":"Returns:","text":"<ul> <li>None: This method prints a summary of all issues detected but does not return any value. It may raise a   <code>ValueError</code> if the <code>value_parameters</code> are missing or invalid.</li> </ul>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.parameter_sanity_check--examples","title":"Examples:","text":"<pre><code># Run a full input audit before solving\ninstance.parameter_sanity_check()\n</code></pre> <p>Example output (truncated for brevity): <pre><code>3 ISSUE: AFSC '15A' quota_min (15) &gt; number of eligible cadets (13)\n4 ISSUE: Cadet 41 has no preferences and is therefore eligible for nothing.\n5 ISSUE: Objective 'Tier 2' has value function with unsorted breakpoints.\n</code></pre></p>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.parameter_sanity_check--see-also","title":"See Also:","text":"<ul> <li><code>parameter_sanity_check</code>:   Full implementation of the internal logic performing the data validation. ```</li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def parameter_sanity_check(self):\n    \"\"\"\n    Perform a Full Sanity Check on the Instance Parameters and Value Parameters.\n\n    This method serves as a high-level entry point for validating the integrity and feasibility of all input data\n    used in the AFSC cadet-career field assignment model. It ensures that parameters (`self.parameters`) and value\n    parameters (`self.value_parameters`) are properly defined, logically consistent, and free of structural or\n    numerical issues prior to model execution.\n\n    The method internally delegates the actual check logic to\n    `afccp.data.adjustments.parameter_sanity_check(self)`, which audits everything from AFSC quotas, cadet eligibility,\n    objective constraints, preference matrices, tier distributions, and utility monotonicity.\n\n    Parameters:\n    --------\n    - self: `CadetCareerProblem`\n        The instance of the assignment problem containing the full dataset and modeling structure.\n\n    Returns:\n    --------\n    - None: This method prints a summary of all issues detected but does not return any value. It may raise a\n      `ValueError` if the `value_parameters` are missing or invalid.\n\n    Examples:\n    --------\n    ```python\n    # Run a full input audit before solving\n    instance.parameter_sanity_check()\n    ```\n\n    Example output (truncated for brevity):\n    ```\n    3 ISSUE: AFSC '15A' quota_min (15) &gt; number of eligible cadets (13)\n    4 ISSUE: Cadet 41 has no preferences and is therefore eligible for nothing.\n    5 ISSUE: Objective 'Tier 2' has value function with unsorted breakpoints.\n    ```\n\n    See Also:\n    --------\n    - [`parameter_sanity_check`](../../../../afccp/reference/data/adjustments/#data.adjustments.parameter_sanity_check):\n      Full implementation of the internal logic performing the data validation.\n    ```\n    \"\"\"\n\n    # Call the function\n    afccp.data.adjustments.parameter_sanity_check(self)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.create_final_utility_matrix_from_new_formula","title":"<code>create_final_utility_matrix_from_new_formula(printing=None)</code>","text":"<p>Construct the Final Cadet Utility Matrix Using a New Weighted Formula.</p> <p>This method builds the <code>cadet_utility</code> matrix by applying a new utility scoring formula that combines:</p> <ul> <li>Ranked ordinal preferences</li> <li>Cadet-specified utility values</li> <li>Boolean least desired AFSC logic (e.g., last choice, bottom 2, etc.)</li> </ul> <p>The scoring function is applied to each cadet-AFSC pairing based on a normalized mix of ranking and utility to capture more nuanced decision-making behavior. This method is essential for creating the input data used in optimization.</p> <p>After computing the new utility values, the method also updates the internal parameter sets to ensure consistency between derived structures (e.g., eligibility dictionaries and matrix representations).</p>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.create_final_utility_matrix_from_new_formula--parameters","title":"Parameters:","text":"<ul> <li>printing (bool, optional): Whether to print progress messages. If None, defaults to <code>self.printing</code>.</li> </ul>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.create_final_utility_matrix_from_new_formula--returns","title":"Returns:","text":"<ul> <li>None: This method modifies <code>self.parameters</code> in-place with updated cadet utility values and updated   preference-derived sets.</li> </ul>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.create_final_utility_matrix_from_new_formula--examples","title":"Examples:","text":"<pre><code># Run the transformation step to produce cadet utilities from ranked inputs\ninstance.create_final_utility_matrix_from_new_formula(printing=True)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.create_final_utility_matrix_from_new_formula--see-also","title":"See Also:","text":"<ul> <li><code>create_final_cadet_utility_matrix_from_new_formula</code>:   Core function that applies the new weighted formula to calculate cadet utilities.</li> <li><code>parameter_sets_additions</code>:   Ensures derived sets such as <code>I^E</code> and <code>J^E</code> are regenerated after utility/preference updates. ```</li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def create_final_utility_matrix_from_new_formula(self, printing=None):\n    \"\"\"\n    Construct the Final Cadet Utility Matrix Using a New Weighted Formula.\n\n    This method builds the `cadet_utility` matrix by applying a new utility scoring formula that combines:\n\n    - Ranked ordinal preferences\n    - Cadet-specified utility values\n    - Boolean least desired AFSC logic (e.g., last choice, bottom 2, etc.)\n\n    The scoring function is applied to each cadet-AFSC pairing based on a normalized mix of ranking and utility\n    to capture more nuanced decision-making behavior. This method is essential for creating the input data used\n    in optimization.\n\n    After computing the new utility values, the method also updates the internal parameter sets to ensure consistency\n    between derived structures (e.g., eligibility dictionaries and matrix representations).\n\n    Parameters:\n    --------\n    - printing (bool, optional): Whether to print progress messages. If None, defaults to `self.printing`.\n\n    Returns:\n    --------\n    - None: This method modifies `self.parameters` in-place with updated cadet utility values and updated\n      preference-derived sets.\n\n    Examples:\n    --------\n    ```python\n    # Run the transformation step to produce cadet utilities from ranked inputs\n    instance.create_final_utility_matrix_from_new_formula(printing=True)\n    ```\n\n    See Also:\n    --------\n    - [`create_final_cadet_utility_matrix_from_new_formula`](../../../../afccp/reference/data/preferences/#data.preferences.create_final_cadet_utility_matrix_from_new_formula):\n      Core function that applies the new weighted formula to calculate cadet utilities.\n    - [`parameter_sets_additions`](../../../../afccp/reference/data/adjustments/#data.adjustments.parameter_sets_additions):\n      Ensures derived sets such as `I^E` and `J^E` are regenerated after utility/preference updates.\n    ```\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Creating 'Final' cadet utility matrix from the new formula with different conditions...\")\n\n    # Update parameters\n    self.parameters = afccp.data.preferences.create_final_cadet_utility_matrix_from_new_formula(self.parameters)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.set_ots_must_matches","title":"<code>set_ots_must_matches(printing=None)</code>","text":"<p>Set OTS Cadet Must-Match Constraints Based on Order of Merit.</p> <p>This method determines which Officer Training School (OTS) cadets must be assigned an AFSC by evaluating their Order of Merit (OM) scores. It sorts the eligible OTS cadets by merit and selects the top <code>ots_accessions</code> (rounded to 99.5%) to be marked as \"must match\" within the optimization model.</p> <p>The method modifies the <code>must_match</code> vector and updates the <code>I^Must_Match</code> set accordingly. These constraints are used to enforce that high-ranking OTS cadets must be matched during the assignment process.</p> <p>If the instance does not include OTS cadets (i.e., 'ots' not in <code>SOCs</code>), the function exits early without making any changes.</p>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.set_ots_must_matches--parameters","title":"Parameters:","text":"<ul> <li>printing (bool, optional): If True, prints logging information about the matching process.   If None (default), uses the instance's <code>self.printing</code> attribute.</li> </ul>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.set_ots_must_matches--returns","title":"Returns:","text":"<ul> <li>None: This method updates the instance's <code>parameters</code> attribute in place.</li> </ul>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.set_ots_must_matches--examples","title":"Examples:","text":"<pre><code>instance.set_ots_must_matches(printing=True)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.set_ots_must_matches--see-also","title":"See Also:","text":"<ul> <li><code>set_ots_must_matches</code>:   Underlying function that applies the must-match logic to the parameter dictionary.</li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def set_ots_must_matches(self, printing=None):\n    \"\"\"\n    Set OTS Cadet Must-Match Constraints Based on Order of Merit.\n\n    This method determines which Officer Training School (OTS) cadets must be assigned an AFSC\n    by evaluating their Order of Merit (OM) scores. It sorts the eligible OTS cadets by merit and\n    selects the top `ots_accessions` (rounded to 99.5%) to be marked as \"must match\" within the\n    optimization model.\n\n    The method modifies the `must_match` vector and updates the `I^Must_Match` set accordingly.\n    These constraints are used to enforce that high-ranking OTS cadets must be matched during the\n    assignment process.\n\n    If the instance does not include OTS cadets (i.e., 'ots' not in `SOCs`), the function exits early\n    without making any changes.\n\n    Parameters:\n    --------\n    - printing (bool, optional): If True, prints logging information about the matching process.\n      If None (default), uses the instance's `self.printing` attribute.\n\n    Returns:\n    --------\n    - None: This method updates the instance's `parameters` attribute in place.\n\n    Examples:\n    --------\n    ```python\n    instance.set_ots_must_matches(printing=True)\n    ```\n\n    See Also:\n    --------\n    - [`set_ots_must_matches`](../../../../afccp/reference/data/adjustments/#data.adjustments.set_ots_must_matches):\n      Underlying function that applies the must-match logic to the parameter dictionary.\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(f\"Setting OTS 'must-matches' by sorting OM and selecting top {self.parameters['ots_accessions']} OTS\")\n\n    # Set OTS must matches  (No need to adjust parameter sets- I adjust \"I^Must_Match\" in this function too\n    self.parameters = afccp.data.adjustments.set_ots_must_matches(self.parameters)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.calculate_qualification_matrix","title":"<code>calculate_qualification_matrix(printing=None)</code>","text":"<p>Generate or Update the Qualification Matrix Based on CIP Codes.</p> <p>This method regenerates the degree qualification matrix (<code>qual</code>) using CIP codes (<code>cip1</code>, and optionally <code>cip2</code>) mapped to AFSCs via a tiered system. The qualification matrix determines which cadets are eligible for which AFSCs and tags them accordingly as mandatory, desired, permitted, ineligible, or exceptional. It is useful when switching qualification logic or refreshing the matrix after modifying degree information.</p>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.calculate_qualification_matrix--parameters","title":"Parameters:","text":"<ul> <li>printing (bool, optional): If True, print progress messages to the console.   Defaults to the instance's <code>self.printing</code> attribute.</li> </ul>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.calculate_qualification_matrix--returns","title":"Returns:","text":"<ul> <li>None: The function updates the <code>self.parameters</code> attribute in-place.</li> </ul>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.calculate_qualification_matrix--examples","title":"Examples:","text":"<pre><code>instance.calculate_qualification_matrix(printing=True)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_other_adjustments/#afccp.main.CadetCareerProblem.calculate_qualification_matrix--see-also","title":"See Also:","text":"<ul> <li><code>cip_to_qual_tiers</code>:   Generates the tiered qualification matrix based on CIP-to-AFSC logic.</li> <li><code>parameter_sets_additions</code>:   Rebuilds internal indexed parameter sets and flags after matrix updates.</li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def calculate_qualification_matrix(self, printing=None):\n    \"\"\"\n    Generate or Update the Qualification Matrix Based on CIP Codes.\n\n    This method regenerates the degree qualification matrix (`qual`) using CIP codes\n    (`cip1`, and optionally `cip2`) mapped to AFSCs via a tiered system. The qualification matrix\n    determines which cadets are eligible for which AFSCs and tags them accordingly as mandatory,\n    desired, permitted, ineligible, or exceptional. It is useful when switching qualification logic\n    or refreshing the matrix after modifying degree information.\n\n    Parameters:\n    --------\n    - printing (bool, optional): If True, print progress messages to the console.\n      Defaults to the instance's `self.printing` attribute.\n\n    Returns:\n    --------\n    - None: The function updates the `self.parameters` attribute in-place.\n\n    Examples:\n    --------\n    ```python\n    instance.calculate_qualification_matrix(printing=True)\n    ```\n\n    See Also:\n    --------\n    - [`cip_to_qual_tiers`](../../../../afccp/reference/data/support/#data.support.cip_to_qual_tiers):\n      Generates the tiered qualification matrix based on CIP-to-AFSC logic.\n    - [`parameter_sets_additions`](../../../../afccp/reference/data/adjustments/#data.adjustments.parameter_sets_additions):\n      Rebuilds internal indexed parameter sets and flags after matrix updates.\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print('Adjusting qualification matrix...')\n    parameters = copy.deepcopy(self.parameters)\n\n    # Generate new matrix\n    if \"cip1\" in parameters:\n        if \"cip2\" in parameters:\n            qual_matrix = afccp.data.support.cip_to_qual_tiers(\n                parameters[\"afscs\"][:parameters[\"M\"]], parameters['cip1'], cip2=parameters['cip2'])\n        else:\n            qual_matrix = afccp.data.support.cip_to_qual_tiers(\n                parameters[\"afscs\"][:parameters[\"M\"]], parameters['cip1'])\n    else:\n        raise ValueError(\"Error. Need to update the degree tier qualification matrix to include tiers \"\n                         \"('M1' instead of 'M' for example) but don't have CIP codes. Please incorporate this.\")\n\n    # Load data back into parameters\n    parameters[\"qual\"] = qual_matrix\n    parameters[\"qual_type\"] = \"Tiers\"\n    parameters[\"ineligible\"] = (np.core.defchararray.find(qual_matrix, \"I\") != -1) * 1\n    parameters[\"eligible\"] = (parameters[\"ineligible\"] == 0) * 1\n    parameters[\"exception\"] = (np.core.defchararray.find(qual_matrix, \"E\") != -1) * 1\n    for t in [1, 2, 3, 4]:\n        parameters[\"tier \" + str(t)] = (np.core.defchararray.find(qual_matrix, str(t)) != -1) * 1\n    parameters = afccp.data.adjustments.parameter_sets_additions(parameters)\n    self.parameters = copy.deepcopy(parameters)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_overview/","title":"Overview","text":""},{"location":"reference/main/cadetcareerproblem_overview/#afccp.main.CadetCareerProblem","title":"<code>afccp.main.CadetCareerProblem(data_name='Random', data_version='Default', degree_qual_type='Consistent', num_value_function_breakpoints=None, N=1600, M=32, P=6, S=10, generate_extra_components=False, generate_only_nrl=False, ctgan_model_name='CTGAN_Full', ctgan_pilot_sampling=False, printing=True)</code>","text":"<p>\ud83d\udcbc Core Class: CadetCareerProblem</p> <p>The <code>CadetCareerProblem</code> class is the central engine behind the Air Force Cadet Career Problem (AFCCP). It enables you to load, generate, solve, and export cadet-to-AFSC matching problems with full flexibility for synthetic and historical data scenarios.</p> <p>\u2699\ufe0f Use Cases:</p> <ul> <li>Load existing instances from the <code>/instances</code> folder (e.g. <code>\"2022b\"</code>).</li> <li>Generate new problem instances using <code>\"Random\"</code> or <code>\"CTGAN\"</code> data.</li> <li>Solve matching problems using classical or advanced optimization methods (e.g. VFT, GUO, GP).</li> <li>Visualize and export solution results for further analysis.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>data_name</code> <code>str</code> <p>Name of the instance. Can be: - Existing instance name (e.g., <code>\"2022b\"</code>) - <code>\"Random\"</code> or <code>\"CTGAN\"</code> for synthetic generation</p> <code>'Random'</code> <code>data_version</code> <code>str</code> <p>Sub-version of the instance (optional).</p> <code>'Default'</code> <code>degree_qual_type</code> <code>str</code> <p>Qualification structure; one of <code>\"Binary\"</code>, <code>\"Tiers\"</code>, <code>\"Relaxed\"</code>, <code>\"Consistent\"</code>.</p> <code>'Consistent'</code> <code>num_value_function_breakpoints</code> <code>int | None</code> <p>Optional number of breakpoints to override existing value function definitions.</p> <code>None</code> <code>N</code> <code>int</code> <p>Number of cadets to generate (synthetic only).</p> <code>1600</code> <code>M</code> <code>int</code> <p>Number of AFSCs to generate.</p> <code>32</code> <code>P</code> <code>int</code> <p>Number of preferences per cadet.</p> <code>6</code> <code>S</code> <code>int</code> <p>Number of bases to generate.</p> <code>10</code> <code>generate_extra_components</code> <code>bool</code> <p>Whether to include bases and extra data.</p> <code>False</code> <code>generate_only_nrl</code> <code>bool</code> <p>Restrict AFSCs to NRLs only.</p> <code>False</code> <code>ctgan_model_name</code> <code>str</code> <p>Model to use for CTGAN generation.</p> <code>'CTGAN_Full'</code> <code>ctgan_pilot_sampling</code> <code>bool</code> <p>Condition sampling on pilot preferences in CTGAN.</p> <code>False</code> <code>printing</code> <code>bool  ---</code> <p>Whether to print status updates.</p> <code>True</code>"},{"location":"reference/main/cadetcareerproblem_overview/#afccp.main.CadetCareerProblem--attributes","title":"\ud83d\udce6 Attributes","text":"<ul> <li><code>parameters (dict)</code>: Core cadet, AFSC, and preference data</li> <li><code>value_parameters (dict)</code>: Active value function weights and breakpoints</li> <li><code>solutions (dict)</code>: Stored solutions by name</li> <li><code>solution (dict)</code>: Currently active solution</li> <li><code>mdl_p (dict)</code>: Modeling parameters (for optimization)</li> <li><code>gp_df (pd.DataFrame)</code>: Goal Programming dataframe (if applicable)</li> </ul>"},{"location":"reference/main/cadetcareerproblem_overview/#afccp.main.CadetCareerProblem--example","title":"\ud83d\udca1 Example","text":"<pre><code># Generate a synthetic problem instance\ninstance = CadetCareerProblem(data_name=\"Random\", N=300, M=12, P=5)\n\n# Fix generated data by adding &amp; correcting parameters, value parameters\ninstance.fix_generated_data()\n\n# Solve using VFT optimization\ninstance.solve_vft_pyomo_model()\n\n# Export results to Excel\ninstance.export_solution_results()\n</code></pre> <p>Automatic Import Behavior</p> <p>If <code>data_name</code> matches a folder in <code>/instances</code>, the problem will auto-load that instance's data. Otherwise, it will generate a synthetic instance.</p> <p>Need Quick Test Data?</p> <p>Use <code>data_name=\"Random\"</code> and <code>N=50</code> to generate a fast demo instance for rapid prototyping.</p> <p>For a tailored guide on the use of this object, please refer to Tutorial 1.</p>"},{"location":"reference/main/cadetcareerproblem_overview/#afccp.main.CadetCareerProblem--see-also","title":"\ud83d\udee0 See Also","text":"<ul> <li><code>solve_vft_pyomo_model</code>, <code>solve_guo_pyomo_model</code>, <code>solve_gp_pyomo_model</code></li> <li><code>reset_functional_parameters</code>, <code>export_data</code>, <code>measure_solution</code></li> <li>Module: <code>afccp.data.processing</code> for import/export logic</li> </ul> Source code in <code>afccp/main.py</code> <pre><code>def __init__(self, data_name=\"Random\", data_version=\"Default\", degree_qual_type=\"Consistent\",\n             num_value_function_breakpoints=None, N=1600, M=32, P=6, S=10, generate_extra_components=False,\n             generate_only_nrl=False, ctgan_model_name='CTGAN_Full', ctgan_pilot_sampling=False, printing=True):\n    \"\"\"\n    ___\n    ### \ud83d\udce6 Attributes\n\n    - `parameters (dict)`: Core cadet, AFSC, and preference data\n    - `value_parameters (dict)`: Active value function weights and breakpoints\n    - `solutions (dict)`: Stored solutions by name\n    - `solution (dict)`: Currently active solution\n    - `mdl_p (dict)`: Modeling parameters (for optimization)\n    - `gp_df (pd.DataFrame)`: Goal Programming dataframe (if applicable)\n\n    ---\n\n    ### \ud83d\udca1 Example\n\n    ```python\n    # Generate a synthetic problem instance\n    instance = CadetCareerProblem(data_name=\"Random\", N=300, M=12, P=5)\n\n    # Fix generated data by adding &amp; correcting parameters, value parameters\n    instance.fix_generated_data()\n\n    # Solve using VFT optimization\n    instance.solve_vft_pyomo_model()\n\n    # Export results to Excel\n    instance.export_solution_results()\n    ```\n\n    ---\n\n    !!! note \"Automatic Import Behavior\"\n        If `data_name` matches a folder in `/instances`, the problem will auto-load that instance's data.\n        Otherwise, it will generate a synthetic instance.\n\n    !!! tip \"Need Quick Test Data?\"\n        Use `data_name=\"Random\"` and `N=50` to generate a fast demo instance for rapid prototyping.\n\n    ---\n\n    For a tailored guide on the use of this object, please refer to [Tutorial 1](../../../../../afccp/user-guide/tutorial_1).\n\n    ### \ud83d\udee0 See Also\n    - `solve_vft_pyomo_model`, `solve_guo_pyomo_model`, `solve_gp_pyomo_model`\n    - `reset_functional_parameters`, `export_data`, `measure_solution`\n    - Module: `afccp.data.processing` for import/export logic\n    \"\"\"\n\n    # Shorten the module name so everything fits better\n    afccp_dp = afccp.data.processing\n\n    # Data attributes\n    self.data_version = data_version  # Version of instance (in parentheses of the instance sub-folders)\n    self.import_paths, self.export_paths = None, None  # We initialize these attributes to 'None'\n    self.printing = printing\n\n    # The data variant helps inform how the charts should be constructed\n    if len(data_name) == 1:  # \"A\", \"B\", \"C\", ...\n        self.data_variant = \"Scrubbed\"\n    elif data_name[:4].isdigit():  # \"2016\", \"2017\", \"2018\", ...\n        self.data_variant = \"Year\"\n    else:  # \"Random_1\", \"Random_2\", ...\n        self.data_variant = \"Generated\"\n\n    # Additional instance components (value parameters and solutions)\n    self.value_parameters, self.vp_name = None, None  # Set of weight and value parameters (and the name)\n    self.vp_dict = None  # Dictionary of value_parameters (set of sets)\n    self.solution, self.solution_name = None, None  # Dictionary of solution elements (and the name)\n    self.solutions = None  # Dictionary of solutions and their main attributes (x, j_array, afsc_array, etc.)\n\n    # Parameters from *former* Lt Rebecca Reynold's thesis\n    self.gp_parameters, self.gp_df = None, None\n\n    # Update instances available (for importing)\n    afccp.globals.instances_available = []\n    for other_data_name in os.listdir(afccp.globals.paths[\"instances\"]):\n        if os.path.isdir(afccp.globals.paths[\"instances\"] + other_data_name):\n            afccp.globals.instances_available.append(other_data_name)\n\n    # If we have an instance folder already for the specified instance (we're importing it)\n    if data_name in afccp.globals.instances_available:\n\n        # Gather information about the files we're importing and eventually exporting\n        self.data_name = data_name\n        self.import_paths, self.export_paths = afccp_dp.initialize_file_information(self.data_name,\n                                                                                    self.data_version)\n\n        # Print statement\n        if self.printing:\n            print(\"Importing '\" + data_name + \"' instance...\")\n\n        # Initialize dictionary of instance parameters (Information pertaining to cadets and AFSCs)\n        self.parameters = {\"Qual Type\": degree_qual_type}\n\n        # Import the \"fixed\" parameters (the information about cadets/AFSCs that, for the most part, doesn't change)\n        import_data_functions = [afccp_dp.import_afscs_data, afccp_dp.import_cadets_data,\n                                 afccp_dp.import_afsc_cadet_matrices_data, afccp_dp.import_additional_data]\n        for import_function in import_data_functions:  # Here we're looping through a list of functions!\n            self.parameters = import_function(self.import_paths, self.parameters)  # Python is nice like that...\n\n        # Additional sets and subsets of cadets/AFSCs need to be loaded into the instance parameters\n        self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n\n        # Import the \"Goal Programming\" dataframe (from Lt Rebecca Reynold's thesis)\n        if \"Goal Programming\" in self.import_paths:\n            self.gp_df = afccp.globals.import_csv_data(self.import_paths[\"Goal Programming\"])\n        else:  # Default \"GP\" file\n            self.gp_df = afccp.globals.import_data(\n                afccp.globals.paths[\"files\"] + \"gp_parameters.xlsx\")\n\n        # Import the \"Value Parameters\" data dictionary\n        self.vp_dict = afccp_dp.import_value_parameters_data(self.import_paths, self.parameters,\n                                                             num_value_function_breakpoints)\n\n        # Import the \"Solutions\" data dictionary\n        self.solutions = afccp_dp.import_solutions_data(self.import_paths, self.parameters)\n\n    # This is a new problem instance that we're generating (Should be \"Random\", \"Perfect\", or \"Realistic\")\n    else:\n\n        # Error Handling (Must be valid data generation parameter)\n        if data_name not in [\"Random\", \"CTGAN\"]:\n            raise ValueError(\n                \"Error. Instance name '\" + data_name + \"' is not a valid instance name. Instances must \"\n                                                       \"be either generated or imported. \"\n                                                       \"(Instance not found in folder).\")\n\n        # Determine the name of this instance (Random_1, Random_2, etc.)\n        for data_variant in [\"Random\", \"CTGAN\"]:\n            if data_name == data_variant:\n\n                # Determine name of data based on what instances are already in our \"instances\" folder\n                variant_counter = 1\n                name_determined = False\n                while not name_determined:\n                    check_name = data_variant + \"_\" + str(variant_counter)\n                    if check_name not in afccp.globals.instances_available:\n                        self.data_name = check_name\n                        name_determined = True\n                    else:\n                        variant_counter += 1\n\n        # Print statement\n        if self.printing:\n            print(\"Generating '\" + self.data_name + \"' instance...\")\n\n        # Want to generate a \"valid\" problem instance that meets the conditions below\n        invalid = True\n        while invalid:\n            invalid = False  # \"Innocent until proven guilty\"\n\n            # Generate a \"Random\" problem instance\n            if data_name == 'Random':\n                self.parameters = afccp.data.generation.generate_random_instance(\n                    N, M, P, S, generate_only_nrl=generate_only_nrl, generate_extra=generate_extra_components)\n\n                # Every cadet needs to be eligible for at least one AFSC\n                for i in range(self.parameters['N']):\n                    if np.sum(self.parameters['eligible'][i, :]) == 0:\n                        invalid = True  # Guilty!\n                        break\n\n                # Every AFSC needs to have at least one cadet eligible for it\n                for j in range(self.parameters['M']):\n                    if np.sum(self.parameters['eligible'][:, j]) == 0:\n                        invalid = True  # Guilty!\n                        break\n\n                # Too few positions or too many positions to fill\n                if (np.sum(self.parameters['quota_max']) &lt; self.parameters['N']) or \\\n                    (np.sum(self.parameters['quota_min']) &gt; self.parameters['N']):\n                    invalid = True  # Guilty!\n\n            # Generate a \"CTGAN\" problem instance\n            elif data_name == \"CTGAN\":\n                self.parameters = afccp.data.generation.generate_ctgan_instance(\n                    N, name=ctgan_model_name, pilot_condition=ctgan_pilot_sampling)\n\n            # We don't have that type of data available to generate\n            else:\n                raise ValueError(\"Data type '\" + data_name + \"' currently not a valid method of generating\"\n                                                             \" data.\")\n\n        # Additional sets and subsets of cadets/AFSCs need to be loaded into the instance parameters\n        self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n\n    # Initialize more \"functional\" parameters\n    self.mdl_p = afccp.data.support.initialize_instance_functional_parameters(\n        self.parameters[\"N\"])\n    self._reset_functional_parameters()\n\n    if self.printing:\n        print(\"Instance '\" + self.data_name + \"' initialized.\")\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_results_visualizations/","title":"CadetCareerProblem \u2013 Results Visualizations Methods","text":""},{"location":"reference/main/cadetcareerproblem_results_visualizations/#afccp.main.CadetCareerProblem.display_all_results_graphs","title":"<code>display_all_results_graphs(p_dict={}, printing=None)</code>","text":"<p>Saves all charts for the current solution and for the solutions in the solution names list if specified</p> Source code in <code>afccp/main.py</code> <pre><code>def display_all_results_graphs(self, p_dict={}, printing=None):\n    \"\"\"\n    Saves all charts for the current solution and for the solutions in the solution names list if specified\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Create solution folder if necessary\n    self._manage_solution_folder()\n\n    # Determine what kind of results charts we're creating\n    if 'solution_names' not in p_dict:  # Regular Solution Charts\n        desired_charts = 'desired_charts'\n        if printing:\n            print(\"Saving all solution results charts to the corresponding folder...\")\n\n    else:  # Solution Comparison Charts\n        desired_charts = 'desired_comparison_charts'\n        p_dict['results_graph'] = 'Solution Comparison'\n        if printing:\n            print(\"Saving all solution comparison charts to the corresponding folder...\")\n\n        # Evaluate the solutions to get metrics\n        self._evaluate_all_solutions(p_dict['solution_names'])\n\n    # Loop through the subset of AFSC charts that I actually care about\n    charts = []\n    for obj, version in self.mdl_p[desired_charts]:\n        if printing:\n            print(\"&lt;Objective '\" + obj + \"' version '\" + version + \"'&gt;\")\n\n        # Build the figure\n        if obj in self.value_parameters['objectives'] or obj == 'Extra':\n            p_dict[\"objective\"] = obj\n            p_dict[\"version\"] = version\n            p_dict['macro_chart_kind'] = 'AFSC Chart'\n            charts.append(self.display_results_graph(p_dict))\n        else:\n            if printing:\n                print(\"Objective '\" + obj + \"' passed since it isn't in our set of objectives.\")\n\n    # Loop through the subset of \"other charts\" that I care about\n    if self.mdl_p['results_graph'] != \"Solution Comparison\":  # Only for a solution-specific chart\n        for kind, version in self.mdl_p['desired_other_charts']:\n            if printing:\n                print(\"&lt;Other Charts '\" + kind + \"' version '\" + version + \"'&gt;\")\n\n            # Build the figure\n            p_dict['objective'] = \"Extra\"\n            p_dict[\"version\"] = version\n            p_dict['macro_chart_kind'] = 'Accessions Group'\n            charts.append(self.display_results_graph(p_dict))\n\n\n    return charts\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_results_visualizations/#afccp.main.CadetCareerProblem.display_cadet_individual_utility_graph","title":"<code>display_cadet_individual_utility_graph(p_dict={}, printing=None)</code>","text":"<p>Builds the cadet utility graph for a particular cadet</p> Source code in <code>afccp/main.py</code> <pre><code>def display_cadet_individual_utility_graph(self, p_dict={}, printing=None):\n    \"\"\"\n    Builds the cadet utility graph for a particular cadet\n    \"\"\"\n\n    # Print statement\n    if printing is None:\n        printing = self.printing\n\n    # Adjust instance plot parameters\n    self._reset_functional_parameters(p_dict)\n\n    # Build the chart\n    afccp.visualizations.charts.CadetUtilityGraph(self)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_results_visualizations/#afccp.main.CadetCareerProblem.display_results_graph","title":"<code>display_results_graph(p_dict={}, printing=None)</code>","text":"<p>Builds the AFSC Results graphs</p> Source code in <code>afccp/main.py</code> <pre><code>def display_results_graph(self, p_dict={}, printing=None):\n    \"\"\"\n    Builds the AFSC Results graphs\n    \"\"\"\n\n    # Print statement\n    if printing is None:\n        printing = self.printing\n\n    # Adjust instance plot parameters\n    self._reset_functional_parameters(p_dict)\n    self.mdl_p = afccp.data.support.determine_afsc_plot_details(self, results_chart=True)\n\n    # Error handling\n    if self.mdl_p['results_graph'] == 'Solution Comparison':\n        self._error_checking('Solutions')\n        chart_type = 'Comparison'\n    else:\n        self._error_checking('Solution')\n        chart_type = 'Solution'\n\n    # Determine which chart to create\n    if self.mdl_p[\"macro_chart_kind\"] == \"AFSC Chart\":\n\n        # Initialize the AFSC Chart object\n        afsc_chart = afccp.visualizations.charts.AFSCsChart(self)\n\n        # Construct the specific chart\n        return afsc_chart.build(chart_type=chart_type, printing=printing)\n\n    elif self.mdl_p[\"macro_chart_kind\"] == \"Accessions Group\":\n\n        # Initialize the AFSC Chart object\n        acc_chart = afccp.visualizations.charts.AccessionsGroupChart(self)\n\n        # Construct the specific chart\n        return acc_chart.build(chart_type=chart_type, printing=printing)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_results_visualizations/#afccp.main.CadetCareerProblem.generate_results_slides","title":"<code>generate_results_slides(p_dict={}, printing=None)</code>","text":"<p>Method to generate the results slides for a particular problem instance with solution</p> Source code in <code>afccp/main.py</code> <pre><code>def generate_results_slides(self, p_dict={}, printing=None):\n    \"\"\"\n    Method to generate the results slides for a particular problem instance with solution\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Generating results slides...\")\n\n    # Adjust instance plot parameters\n    self._reset_functional_parameters(p_dict)\n    self._error_checking('Solution')\n\n    # Call the function to generate the slides\n    if afccp.globals.use_pptx:\n        afccp.visualizations.slides.generate_results_slides(self)\n    else:\n        print('PPTX library not installed.')\n\n    if printing:\n        print('Done.')\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_results_visualizations/#afccp.main.CadetCareerProblem.generate_comparison_slides","title":"<code>generate_comparison_slides(p_dict={}, printing=None)</code>","text":"<p>Method to generate the results slides for a particular problem instance with solution</p> Source code in <code>afccp/main.py</code> <pre><code>def generate_comparison_slides(self, p_dict={}, printing=None):\n    \"\"\"\n    Method to generate the results slides for a particular problem instance with solution\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Generating comparison slides...\")\n\n    if 'Comparison Charts' not in os.listdir(self.export_paths['Analysis &amp; Results']):\n        raise ValueError(\"Error. No 'Comparison Charts' folder found in the 'Analysis &amp; Results' folder. You need to\"\n                         \" put all charts you'd like to compile into a slide-deck in this folder.\")\n\n    # Adjust instance plot parameters\n    self._reset_functional_parameters(p_dict)\n    self._error_checking('Solutions')\n\n    # Call the function to generate the slides\n    if afccp.globals.use_pptx:\n        afccp.visualizations.slides.generate_comparison_slides(self)\n    else:\n        print('PPTX library not installed.')\n\n    if printing:\n        print('Done.')\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_results_visualizations/#afccp.main.CadetCareerProblem.generate_animation_slides","title":"<code>generate_animation_slides(p_dict={}, printing=None)</code>","text":"<p>Method to generate the animation slides for a particular problem instance and solution iterations</p> Source code in <code>afccp/main.py</code> <pre><code>def generate_animation_slides(self, p_dict={}, printing=None):\n    \"\"\"\n    Method to generate the animation slides for a particular problem instance and solution iterations\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Generating animation slides...\")\n\n    # Manage the solution iterations\n    self._manage_bubbles_parameters(p_dict)\n\n    # Call the function to generate the slides\n    if afccp.globals.use_pptx:\n        # afccp.visualizations.slides.create_animation_slides(self)\n        afccp.visualizations.slides.create_animated_presentation(self, num_intro_slides=5)\n    else:\n        print('PPTX library not installed.')\n\n    if printing:\n        print('Done.')\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_results_visualizations/#afccp.main.CadetCareerProblem.generate_comparison_slide_components","title":"<code>generate_comparison_slide_components(p_dict={}, printing=None)</code>","text":"<p>Method to do all the steps of generating the specific solution comparison charts I want</p> Source code in <code>afccp/main.py</code> <pre><code>def generate_comparison_slide_components(self, p_dict={}, printing=None):\n    \"\"\"\n    Method to do all the steps of generating the specific solution comparison charts I want\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if \"solution_names\" not in p_dict:\n        raise ValueError(\"Error. In order to run this comparison method, the argument 'solution_names' must be \"\n                         \"passed within 'p_dict'. This needs to be a list of solution names.\")\n\n    if printing:\n        print(\"Generating comparison charts for the solutions:\", p_dict['solution_names'])\n\n    # Create the comparison charts folder if necessary\n    if 'Comparison Charts' not in os.listdir(self.export_paths['Analysis &amp; Results']):\n        os.mkdir(self.export_paths['Analysis &amp; Results'] + 'Comparison Charts')\n\n    # Adjust instance plot parameters\n    self._reset_functional_parameters(p_dict)\n    self._error_checking('Solutions')\n\n    # Save all solution comparison charts to the \"Comparison Charts\" folder\n    self.display_all_results_graphs(p_dict, printing)\n\n    # Cadet Utility Histogram\n    self.display_utility_histogram(p_dict, folder='Comparison Charts')\n\n    # Create pareto frontier plots\n    self.show_pareto_chart(folder='Comparison Charts')  # without solutions\n    self.show_pareto_chart(p_dict, folder='Comparison Charts',\n                           solution_names=p_dict['solution_names'])  # with solutions\n\n    # Compute similarity matrix and then calculate the similarity plot between all the solutions\n    self.compute_similarity_matrix(solution_names=p_dict['solution_names'])\n    self.similarity_plot(p_dict, folder='Comparison Charts')\n\n    if printing:\n        print('Done.')\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_results_visualizations/#afccp.main.CadetCareerProblem.display_utility_histogram","title":"<code>display_utility_histogram(p_dict={}, printing=None, folder='Results Charts')</code>","text":"<p>This method plots the cadet utility histogram</p> Source code in <code>afccp/main.py</code> <pre><code>def display_utility_histogram(self, p_dict={}, printing=None, folder=\"Results Charts\"):\n    \"\"\"\n    This method plots the cadet utility histogram\n    \"\"\"\n\n    # Print statement\n    if printing is None:\n        printing = self.printing\n    if printing:\n        print(\"Creating cadet utility histogram...\")\n\n    # Adjust instance plot parameters\n    self._reset_functional_parameters(p_dict)\n    self.mdl_p = afccp.data.support.determine_afsc_plot_details(self, results_chart=True)\n\n    # Evaluate the solutions to get metrics\n    if self.mdl_p['solution_names'] is not None:\n        self._evaluate_all_solutions(self.mdl_p['solution_names'])\n\n    # Filepath for plot\n    filepath = self.export_paths['Analysis &amp; Results'] + folder + \"/\"\n\n    # Construct the chart\n    return afccp.visualizations.charts.cadet_utility_histogram(self, filepath=filepath)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_results_visualizations/#afccp.main.CadetCareerProblem.generate_bubbles_chart","title":"<code>generate_bubbles_chart(p_dict={}, printing=None)</code>","text":"<p>Method to generate the \"BubbleChart\" figure by calling the BubbleChart class and applying the parameters as specified in the ccp helping functions.</p> Source code in <code>afccp/main.py</code> <pre><code>def generate_bubbles_chart(self, p_dict={}, printing=None):\n    \"\"\"\n    Method to generate the \"BubbleChart\" figure by calling the BubbleChart class and applying the parameters\n    as specified in the ccp helping functions.\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Manage the solution iterations\n    self._manage_bubbles_parameters(p_dict)\n\n    # Print updates\n    if printing:\n        print('Creating Bubbles Chart...')\n\n    # Call the figure object\n    bubble_chart = afccp.visualizations.bubbles.BubbleChart(self, printing=printing)\n    bubble_chart.main()\n\n    # Only build the animation slides if we're saving iteration frames\n    if self.mdl_p['save_iteration_frames']:\n\n        # Generate the slides to go with this\n        self.generate_animation_slides(p_dict, printing)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_solution_generation_%26_algorithms/","title":"CadetCareerProblem \u2013 Solution Generation &amp; Algorithms Methods","text":""},{"location":"reference/main/cadetcareerproblem_solution_generation_%26_algorithms/#afccp.main.CadetCareerProblem.generate_random_solution","title":"<code>generate_random_solution(p_dict={}, printing=None)</code>","text":"<p>Generate random solution by assigning cadets to AFSCs that they're eligible for</p> Source code in <code>afccp/main.py</code> <pre><code>def generate_random_solution(self, p_dict={}, printing=None):\n    \"\"\"\n    Generate random solution by assigning cadets to AFSCs that they're eligible for\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print('Generating random solution...')\n\n    # Reset instance model parameters\n    self._reset_functional_parameters(p_dict)\n\n    # Generate solution\n    solution = {'method': 'Random',\n        'j_array': np.array([np.random.choice(self.parameters['J^E'][i]) for i in self.parameters['I']])}\n\n    # Determine what to do with the solution\n    self._solution_handling(solution)\n\n    return solution\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_solution_generation_%26_algorithms/#afccp.main.CadetCareerProblem.rotc_rated_board_original","title":"<code>rotc_rated_board_original(p_dict={}, printing=None)</code>","text":"Source code in <code>afccp/main.py</code> <pre><code>def rotc_rated_board_original(self, p_dict={}, printing=None):\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self._reset_functional_parameters(p_dict)\n\n    # Get the solution we need\n    solution = afccp.solutions.algorithms.rotc_rated_board_original(self, printing=printing)\n\n    # Determine what to do with the solution\n    self._solution_handling(solution)\n\n    return solution\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_solution_generation_%26_algorithms/#afccp.main.CadetCareerProblem.allocate_ots_candidates_original_method","title":"<code>allocate_ots_candidates_original_method(p_dict={}, printing=None)</code>","text":"Source code in <code>afccp/main.py</code> <pre><code>def allocate_ots_candidates_original_method(self, p_dict={}, printing=None):\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self._reset_functional_parameters(p_dict)\n\n    # Get the solution we need\n    solution = afccp.solutions.algorithms.allocate_ots_candidates_original_method(self, printing=printing)\n\n    # Determine what to do with the solution\n    self._solution_handling(solution)\n\n    return solution\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_solution_generation_%26_algorithms/#afccp.main.CadetCareerProblem.soc_rated_matching_algorithm","title":"<code>soc_rated_matching_algorithm(p_dict={}, printing=None)</code>","text":"<p>This is the Hospitals/Residents algorithm that matches or reserves cadets to their Rated AFSCs depending on the source of commissioning (SOCs).</p> Source code in <code>afccp/main.py</code> <pre><code>def soc_rated_matching_algorithm(self, p_dict={}, printing=None):\n    \"\"\"\n    This is the Hospitals/Residents algorithm that matches or reserves cadets to their Rated AFSCs depending on the\n    source of commissioning (SOCs).\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self._reset_functional_parameters(p_dict)\n\n    # Get the solution and solution iterations we need\n    combined, reserves, matches = afccp.solutions.algorithms.soc_rated_matching_algorithm(\n        self, soc=self.mdl_p['soc'], printing=printing)\n\n    # Determine what to do with the solution(s)\n    for solution in [reserves, matches, combined]:\n        self._solution_handling(solution, printing=False)  # Don't want print updates for this\n\n    return solution\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_solution_generation_%26_algorithms/#afccp.main.CadetCareerProblem.classic_hr","title":"<code>classic_hr(p_dict={}, printing=None)</code>","text":"<p>This method solves the problem instance using the classical \"Hospital/Residents\" algorithm</p> Source code in <code>afccp/main.py</code> <pre><code>def classic_hr(self, p_dict={}, printing=None):\n    \"\"\"\n    This method solves the problem instance using the classical \"Hospital/Residents\" algorithm\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self._reset_functional_parameters(p_dict)\n\n    # Get the solution we need\n    solution = afccp.solutions.algorithms.classic_hr(self, printing=printing)\n\n    # Determine what to do with the solution\n    self._solution_handling(solution)\n\n    return solution\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_solution_handling/","title":"CadetCareerProblem \u2013 Solution Handling Methods","text":""},{"location":"reference/main/cadetcareerproblem_solution_handling/#afccp.main.CadetCareerProblem.measure_solution","title":"<code>measure_solution(approximate=False, printing=None)</code>","text":"<p>Evaluate a solution using the VFT objective hierarchy</p> Source code in <code>afccp/main.py</code> <pre><code>def measure_solution(self, approximate=False, printing=None):\n    \"\"\"\n    Evaluate a solution using the VFT objective hierarchy\n    \"\"\"\n    # Error checking, solution setting\n    if self.solution is None or self.value_parameters is None:\n        raise ValueError(\"Error. Solution and value parameters needed to evaluate solution.\")\n\n    # Print statement\n    if printing is None:\n        printing = self.printing\n\n    # Copy weight on GUO solution (relative to CASTLE) from \"mdl_p\" to \"parameters\"\n    self.parameters['w^G'] = self.mdl_p['w^G']\n\n    # Calculate solution metrics\n    self.solution = afccp.solutions.handling.evaluate_solution(\n        self.solution, self.parameters, self.value_parameters, approximate=approximate, printing=printing,\n        re_calculate_x=self.mdl_p['re-calculate x'])\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_solution_handling/#afccp.main.CadetCareerProblem.measure_fitness","title":"<code>measure_fitness(printing=None)</code>","text":"<p>This is the fitness function method (could be slightly different depending on how the constraints are handled)</p> <p>Returns:</p> Type Description <p>fitness score</p> Source code in <code>afccp/main.py</code> <pre><code>def measure_fitness(self, printing=None):\n    \"\"\"\n    This is the fitness function method (could be slightly different depending on how the constraints are handled)\n    :return: fitness score\n    \"\"\"\n    # Error checking, solution setting\n    if self.solution is None or self.value_parameters is None:\n        raise ValueError(\"Error. Solution and value parameters needed to evaluate solution.\")\n\n    # Printing statement\n    if printing is None:\n        printing = self.printing\n\n    # Get the solution metrics if necessary\n    if \"z\" not in self.solution:\n        self.solution = self.measure_solution(printing=False)\n\n    # Calculate fitness value\n    z = afccp.solutions.handling.fitness_function(self.solution['j_array'], self.parameters,\n                                                  self.value_parameters, self.mdl_p,\n                                                  con_fail_dict=self.solution['con_fail_dict'])\n\n    # Print and return fitness value\n    if printing:\n        print(\"Fitness value calculated to be\", round(z, 4))\n    return z\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_solution_handling/#afccp.main.CadetCareerProblem.set_solution","title":"<code>set_solution(solution_name=None, printing=None)</code>","text":"<p>Set the current instance object's solution to a solution from the dictionary</p> Source code in <code>afccp/main.py</code> <pre><code>def set_solution(self, solution_name=None, printing=None):\n    \"\"\"\n    Set the current instance object's solution to a solution from the dictionary\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if self.solutions is None:\n        raise ValueError('No solution dictionary initialized')\n    else:\n        if solution_name is None:\n            solution_name = list(self.solutions.keys())[0]\n        else:\n            if solution_name not in self.solutions:\n                raise ValueError('Solution ' + solution_name + ' not in solution dictionary')\n\n        self.solution = self.solutions[solution_name]\n        self.solution_name = solution_name\n        if self.value_parameters is not None:\n            self.measure_solution(printing=printing)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_solution_handling/#afccp.main.CadetCareerProblem.add_solution","title":"<code>add_solution(j_array: np.ndarray = None, afsc_array: np.ndarray = None, method: str = None)</code>","text":"<p>Takes a numpy array of AFSCs and adds this new solution into the solution dictionary</p> Source code in <code>afccp/main.py</code> <pre><code>def add_solution(self, j_array: np.ndarray = None, afsc_array: np.ndarray = None, method: str = None):\n    \"\"\"\n    Takes a numpy array of AFSCs and adds this new solution into the solution dictionary\n    \"\"\"\n\n    # Determine AFSC solution information\n    if j_array is not None:\n        afsc_array = np.array([self.parameters['afscs'][j] for j in j_array])\n    elif afsc_array is not None:\n        j_array = np.array([np.where(self.parameters['afscs'] == afsc)[0][0] for afsc in afsc_array])\n    else:\n        raise ValueError(f'Error. No AFSC solution array specified')\n    if method is None:\n        method = 'Added'\n\n    # Create solution dictionary\n    solution = {'j_array': j_array, 'method': method, 'afsc_array': afsc_array}\n\n    # Determine what to do with the solution\n    self._solution_handling(solution)\n\n    # Return the solution\n    return solution\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_solution_handling/#afccp.main.CadetCareerProblem.incorporate_rated_algorithm_results","title":"<code>incorporate_rated_algorithm_results(p_dict={}, printing=None)</code>","text":"<p>Takes the two sets of Rated Matches and Reserves and adds that into the parameters (J^Fixed and J^Reserved)</p> Source code in <code>afccp/main.py</code> <pre><code>def incorporate_rated_algorithm_results(self, p_dict={}, printing=None):\n    \"\"\"\n    Takes the two sets of Rated Matches and Reserves and adds that into the parameters (J^Fixed and J^Reserved)\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self._reset_functional_parameters(p_dict)\n\n    self.parameters = afccp.solutions.handling.incorporate_rated_results_in_parameters(\n        self, printing=printing)\n\n    # Shorthand\n    p = self.parameters\n\n    # Temporary stuff\n    if self.mdl_p['create_new_rated_solutions']:\n\n        name_dict = {'Rated Matches': 'J^Fixed', 'Rated Reserves': 'J^Reserved',\n                     'Rated Alternates (Hard)': 'J^Alternates (Hard)',\n                     'Rated Alternates (Soft)': 'J^Alternates (Soft)'}\n        new_solutions = {}\n        for s_name, s_param in name_dict.items():\n            new_solutions[s_name] = {'method': s_name,\n                                     'j_array': np.array([p['M'] for _ in p['I']]),\n                                     'afsc_array': np.array(['*' for _ in p['I']])}\n\n            # Create this solution array\n            for i in p['I']:\n                if i in p[s_param]:\n                    if s_param == 'J^Reserved':\n                        j = p['J^Reserved'][i][len(p['J^Reserved'][i]) - 1]\n                    else:\n                        j = p[s_param][i]\n                    new_solutions[s_name]['j_array'][i] = j\n                    new_solutions[s_name]['afsc_array'][i] = p['afscs'][j]\n\n            # Integrate this solution\n            self._solution_handling(new_solutions[s_name], printing=False)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_solution_handling/#afccp.main.CadetCareerProblem.find_ineligible_cadets","title":"<code>find_ineligible_cadets(solution_name=None, fix_it=True)</code>","text":"<p>Prints out the ID's of ineligible pairs of cadets/AFSCs</p> Source code in <code>afccp/main.py</code> <pre><code>def find_ineligible_cadets(self, solution_name=None, fix_it=True):\n    \"\"\"\n    Prints out the ID's of ineligible pairs of cadets/AFSCs\n    \"\"\"\n\n    if solution_name is None:\n        if self.solution is None:\n            raise ValueError(\"No solution activated.\")\n        else:\n            solution = self.solution['j_array']\n    else:\n        solution = self.solutions[solution_name]['j_array']\n\n    # Loop through each cadet to see if they're ineligible for the AFSC they're assigned to\n    total_ineligible = 0\n    for i, j in enumerate(solution):\n        cadet, afsc = self.parameters['cadets'][i], self.parameters['afscs'][j]\n\n        # Unmatched AFSC\n        if j == self.parameters['M']:\n            continue\n\n        # Cadet is not in the set of eligible cadets for this AFSC\n        if i not in self.parameters['I^E'][j]:\n            total_ineligible += 1\n\n            # Do we do anything about it yet?\n            if fix_it:\n                print('Cadet', cadet, 'assigned to AFSC', afsc, 'but is ineligible for it. Adjusting qual matrix to'\n                                                                ' allow this exception.')\n\n                # Add exception in different parameters\n                self.parameters['qual'][i, j] = \"E\" + str(self.parameters['t_count'][j])\n                self.parameters['ineligible'][i, j] = 0\n                self.parameters['eligible'][i, j] = 1\n\n            else:\n                print('Cadet', cadet, 'assigned to AFSC', afsc, 'but is ineligible for it.')\n\n    # Printing statement\n    if total_ineligible == 0:\n        print(\"No cadets assigned to AFSCs that they're ineligible for in the current solution.\")\n    else:\n        print(total_ineligible, \"total cadets assigned to AFSCs that they're ineligible for in the current solution.\")\n\n    # Adjust sets and subsets of cadets to reflect change\n    if fix_it and total_ineligible &gt; 0:\n        self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_value_parameter_specifications/","title":"CadetCareerProblem \u2013 Value Parameter Specifications Methods","text":""},{"location":"reference/main/cadetcareerproblem_value_parameter_specifications/#afccp.main.CadetCareerProblem.set_value_parameters","title":"<code>set_value_parameters(vp_name=None)</code>","text":"<p>Set the Active Value Parameters for the Current Problem Instance.</p> <p>This method assigns the current working set of value parameters (<code>self.value_parameters</code>) based on a given name from the value parameter dictionary (<code>self.vp_dict</code>). These value parameters determine cadet-level utilities, preferences, or constraints and are essential inputs to various components of the AFCCP model (e.g., CAVE, ALERT, MARKET).</p> <p>If no <code>vp_name</code> is specified, the method defaults to the first entry in the dictionary.</p>"},{"location":"reference/main/cadetcareerproblem_value_parameter_specifications/#afccp.main.CadetCareerProblem.set_value_parameters--parameters","title":"Parameters:","text":"<ul> <li>vp_name (str, optional): Name of the value parameter set to activate. If None, defaults to the first available set.</li> </ul>"},{"location":"reference/main/cadetcareerproblem_value_parameter_specifications/#afccp.main.CadetCareerProblem.set_value_parameters--returns","title":"Returns:","text":"<p>None: Updates <code>self.vp_name</code> and <code>self.value_parameters</code> in-place.</p>"},{"location":"reference/main/cadetcareerproblem_value_parameter_specifications/#afccp.main.CadetCareerProblem.set_value_parameters--examples","title":"Examples:","text":"<pre><code>instance.set_value_parameters()  # Automatically select the first available VP set\n</code></pre> Source code in <code>afccp/main.py</code> <pre><code>def set_value_parameters(self, vp_name=None):\n    \"\"\"\n    Set the Active Value Parameters for the Current Problem Instance.\n\n    This method assigns the current working set of value parameters (`self.value_parameters`) based on\n    a given name from the value parameter dictionary (`self.vp_dict`). These value parameters determine\n    cadet-level utilities, preferences, or constraints and are essential inputs to various components\n    of the AFCCP model (e.g., CAVE, ALERT, MARKET).\n\n    If no `vp_name` is specified, the method defaults to the first entry in the dictionary.\n\n    Parameters:\n    --------\n    - vp_name (str, optional): Name of the value parameter set to activate. If None, defaults to the first available set.\n\n    Returns:\n    --------\n    None: Updates `self.vp_name` and `self.value_parameters` in-place.\n\n    Examples:\n    --------\n    ```python\n    instance.set_value_parameters()  # Automatically select the first available VP set\n    ```\n    \"\"\"\n    if self.vp_dict is None:\n        raise ValueError(\"Error. No sets of value parameters (vp_dict) detected. You need to import the \"\n                         \"defaults first by using 'instance.import_default_value_parameters()'.\")\n    else:\n        if vp_name is None:  # Name not specified\n            self.vp_name = list(self.vp_dict.keys())[0]  # Take the first set in the dictionary\n            self.value_parameters = copy.deepcopy(self.vp_dict[self.vp_name])\n        else:  # Name specified\n            if vp_name not in self.vp_dict:\n                raise ValueError(vp_name + ' set not in value parameter dictionary. Available sets are:',\n                                 self.vp_dict.keys())\n            else:\n                self.value_parameters = copy.deepcopy(self.vp_dict[vp_name])\n                self.vp_name = vp_name\n\n        if self.solution is not None:\n            self.measure_solution()\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_value_parameter_specifications/#afccp.main.CadetCareerProblem.update_value_parameters","title":"<code>update_value_parameters(num_breakpoints=24)</code>","text":"<p>Simple method to take the current set of value parameters and update their sets and subsets and all that. This method also updates the set of value parameters in the dictionary</p> <p>Parameters:</p> Name Type Description Default <code>num_breakpoints</code> <p>Number of breakpoints to use when building the value functions</p> <code>24</code> Source code in <code>afccp/main.py</code> <pre><code>def update_value_parameters(self, num_breakpoints=24):\n    \"\"\"\n    Simple method to take the current set of value parameters and update their sets and subsets and all that.\n    This method also updates the set of value parameters in the dictionary\n    :param num_breakpoints: Number of breakpoints to use when building the value functions\n    \"\"\"\n\n    # Update the value functions and cadet/AFSC weights\n    self.value_parameters = afccp.data.values.update_value_and_weight_functions(self, num_breakpoints)\n\n    # \"Condense\" the value functions by removing unnecessary zeros in the breakpoints\n    self.value_parameters = afccp.data.values.condense_value_functions(self.parameters, self.value_parameters)\n\n    # Add indexed sets and subsets of AFSCs and AFSC objectives\n    self.value_parameters = afccp.data.values.value_parameters_sets_additions(\n        self.parameters, self.value_parameters)\n\n    # Update the set of value parameters in the dictionary (vp_dict attribute)\n    self._update_value_parameters_in_dict()\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_value_parameter_specifications/#afccp.main.CadetCareerProblem.calculate_afocd_value_parameters","title":"<code>calculate_afocd_value_parameters()</code>","text":"<p>This method calculates the AFOCD value parameters using my own methodology on determining the weights and uses the AFSCs.csv dataset for the targets and constraints.</p> Source code in <code>afccp/main.py</code> <pre><code>def calculate_afocd_value_parameters(self):\n    \"\"\"\n    This method calculates the AFOCD value parameters using my own methodology on determining the\n    weights and uses the AFSCs.csv dataset for the targets and constraints.\n    \"\"\"\n\n    # Determine the AFOCD value parameters\n    self.value_parameters = afccp.data.values.generate_afocd_value_parameters(\n        self.parameters, self.value_parameters)\n\n    # Update the value parameters\n    self.update_value_parameters()\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_value_parameter_specifications/#afccp.main.CadetCareerProblem.export_value_parameters_as_defaults","title":"<code>export_value_parameters_as_defaults(filename=None, printing=None)</code>","text":"<p>This method exports the current set of instance value parameters to a new excel file in the \"default\" value parameter format</p> Source code in <code>afccp/main.py</code> <pre><code>def export_value_parameters_as_defaults(self, filename=None, printing=None):\n    \"\"\"\n    This method exports the current set of instance value parameters to a new excel file in the \"default\"\n    value parameter format\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if self.value_parameters is None:\n        raise ValueError('No instance value parameters detected.')\n\n    # Export value parameters\n    if filename is None:  # I add the \"_New\" just so we make sure we don't accidentally overwrite the old one\n        filename = \"Value_Parameters_Defaults_\" + self.data_name + \"_New.xlsx\"\n    filepath = afccp.globals.paths[\"support\"] + \"value parameters defaults/\" + filename\n    afccp.data.values.model_value_parameters_to_defaults(self, filepath=filepath, printing=printing)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_value_parameter_specifications/#afccp.main.CadetCareerProblem.change_weight_function","title":"<code>change_weight_function(cadets=True, function=None)</code>","text":"<p>Changes the weight function on either cadets or AFSCs</p> <p>Parameters:</p> Name Type Description Default <code>cadets</code> <p>if this is for cadets (True) or AFSCs (False)</p> <code>True</code> <code>function</code> <p>new weight function to use</p> <code>None</code> Source code in <code>afccp/main.py</code> <pre><code>def change_weight_function(self, cadets=True, function=None):\n    \"\"\"\n    Changes the weight function on either cadets or AFSCs\n    :param cadets: if this is for cadets (True) or AFSCs (False)\n    :param function: new weight function to use\n    \"\"\"\n\n    if cadets:\n        if function is None:\n            function = 'Linear'\n\n        if \"merit_all\" in self.parameters:  # The cadets' real order of merit\n            merit = self.parameters[\"merit_all\"]\n        else:  # The cadets' scaled order of merit (based solely on Non-Rated cadets)\n            merit = self.parameters[\"merit\"]\n\n        # Update weight function\n        self.value_parameters['cadet_weight_function'] = function\n\n        # Update weights\n        self.value_parameters[\"cadet_weight\"] = \\\n            afccp.data.values.cadet_weight_function(merit, function)\n\n    else:\n        if function is None:\n            function = \"Curve_2\"\n\n        if \"pgl\" in self.parameters:  # The actual PGL target\n            quota = self.parameters[\"pgl\"]\n        else:  # The \"Real\" Target based on surplus and such\n            quota = self.parameters[\"quota\"]\n\n        # Update weight function\n        self.value_parameters['afsc_weight_function'] = function\n\n        # Update weights\n        self.value_parameters[\"afsc_weight\"] = \\\n            afccp.data.values.afsc_weight_function(quota, function)\n</code></pre>"},{"location":"reference/main/cadetcareerproblem_value_parameter_specifications/#afccp.main.CadetCareerProblem.vft_to_gp_parameters","title":"<code>vft_to_gp_parameters(p_dict={}, printing=None)</code>","text":"<p>Translate VFT Model Parameters to former Lt Rebecca Reynold's Goal Programming Model Parameters.</p> <p>This method is responsible for translating various parameters and settings used in the Value Focussed Thinking (VFT) model into parameters suitable for the Goal Programming (GP) model. It facilitates the conversion between different modeling frameworks.</p> <p>Args:     p_dict (dict, optional): A dictionary of additional parameters that can be provided to fine-tune the translation process.         These parameters may include specific weights or settings required for the GP model. Defaults to an empty dictionary.</p> <pre><code>printing (bool, optional): A flag to control whether to print progress information during the translation process.\n    If True, it will print status updates; if False, it will run silently. Defaults to None.\n</code></pre> <p>Returns:     None</p> <p>The method updates the internal representation of parameters and settings in the instance to match the requirements of the Goal Programming (GP) model. It translates preference scores, rewards, and penalties according to the GP model's specifications, making the instance ready for goal-based optimization.</p> <p>Note: - The method may apply normalization to ensure that rewards and penalties are consistent with the GP model's expectations. - If the 'get_new_rewards_penalties' flag is set to True in the model parameters, the method may compute new rewards   and penalties based on the instance data and preferences, creating a fresh set of values for optimization.</p> Source code in <code>afccp/main.py</code> <pre><code>def vft_to_gp_parameters(self, p_dict={}, printing=None):\n    \"\"\"\n    Translate VFT Model Parameters to *former* Lt Rebecca Reynold's Goal Programming Model Parameters.\n\n    This method is responsible for translating various parameters and settings used in the Value Focussed Thinking (VFT) model\n    into parameters suitable for the Goal Programming (GP) model. It facilitates the conversion between different modeling\n    frameworks.\n\n    Args:\n        p_dict (dict, optional): A dictionary of additional parameters that can be provided to fine-tune the translation process.\n            These parameters may include specific weights or settings required for the GP model. Defaults to an empty dictionary.\n\n        printing (bool, optional): A flag to control whether to print progress information during the translation process.\n            If True, it will print status updates; if False, it will run silently. Defaults to None.\n\n    Returns:\n        None\n\n    The method updates the internal representation of parameters and settings in the instance to match the requirements\n    of the Goal Programming (GP) model. It translates preference scores, rewards, and penalties according to the GP model's\n    specifications, making the instance ready for goal-based optimization.\n\n    Note:\n    - The method may apply normalization to ensure that rewards and penalties are consistent with the GP model's expectations.\n    - If the 'get_new_rewards_penalties' flag is set to True in the model parameters, the method may compute new rewards\n      and penalties based on the instance data and preferences, creating a fresh set of values for optimization.\n\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Print statement\n    if printing:\n        print('Translating VFT model parameters to Goal Programming Model parameters...')\n\n    # Reset instance model parameters\n    self._reset_functional_parameters(p_dict)\n\n    # Get basic parameters (May or may not include penalty/reward parameters\n    self.gp_parameters = afccp.data.values.translate_vft_to_gp_parameters(self)\n\n    # Get list of constraints\n    con_list = copy.deepcopy(self.gp_parameters['con'])\n    con_list.append(\"S\")\n    num_constraints = len(con_list)\n\n    # Convert gp_df to dictionary of numpy arrays (\"gc\" = \"gp_df columns\")\n    gc = {col: np.array(self.gp_df[col]) for col in self.gp_df}\n\n    # Do we want to create new rewards/penalties for this problem instance by iterating with the model?\n    if self.mdl_p[\"get_new_rewards_penalties\"]:\n\n        gc[\"Raw Reward\"], gc[\"Raw Penalty\"] = afccp.solutions.optimization.calculate_rewards_penalties(\n            self, printing=printing)\n        min_p = min([penalty for penalty in gc[\"Raw Penalty\"] if penalty != 0])\n        min_r = min(gc[\"Raw Reward\"])\n        gc[\"Normalized Penalty\"] = np.array([min_p / penalty if penalty != 0 else 0 for penalty in gc[\"Raw Penalty\"]])\n        gc[\"Normalized Reward\"] = np.array([min_r / reward for reward in gc[\"Raw Reward\"]])\n\n    # Rewards/Penalties used in the model \"run\"\n    gc[\"Run Penalty\"] = np.array(\n        [gc[\"Penalty Weight\"][c] /\n         gc[\"Normalized Penalty\"][c] if gc[\"Normalized Penalty\"][c] != 0 else 0 for c in range(num_constraints)])\n    gc[\"Run Reward\"] = np.array([gc[\"Reward Weight\"][c] / gc[\"Normalized Reward\"][c] for c in range(num_constraints)])\n\n    # Convert back to pandas dataframe using numpy array dictionary\n    self.gp_df = pd.DataFrame(gc)\n\n    # Update the \"mu\" and \"lam\" parameters with our new Reward/Penalty terms\n    self.gp_parameters = afccp.data.values.translate_vft_to_gp_parameters(self)\n</code></pre>"},{"location":"reference/research/ots_cadet_additions/","title":"Ots cadet additions","text":""},{"location":"reference/research/ots_cadet_additions/#research.ots_cadet_additions","title":"<code>research.ots_cadet_additions</code>","text":""},{"location":"reference/research/rotc_rated/","title":"Rotc rated","text":""},{"location":"reference/research/rotc_rated/#research.rotc_rated","title":"<code>research.rotc_rated</code>","text":""},{"location":"reference/research/rotc_rated/#research.rotc_rated.process_data_in_parameters","title":"<code>process_data_in_parameters(df, parameters, autofix=False)</code>","text":"<p>This function takes in a dataframe (must be of the \"ROTC Rated Data\" format), processes it, and loads it into the appropriate \"parameters\" data dictionary. The \"parameters\" dictionary is then returned</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>dataframe in \"ROTC Rated Data\" format</p> required <code>parameters</code> <p>initialized parameters dictionary</p> required <p>Returns:</p> Type Description <p>parameters dictionary</p> Source code in <code>afccp/research/rotc_rated.py</code> <pre><code>def process_data_in_parameters(df, parameters, autofix=False):\n    \"\"\"\n    This function takes in a dataframe (must be of the \"ROTC Rated Data\" format), processes it,\n    and loads it into the appropriate \"parameters\" data dictionary. The \"parameters\" dictionary is then returned\n    :param df: dataframe in \"ROTC Rated Data\" format\n    :param parameters: initialized parameters dictionary\n    :return: parameters dictionary\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Collect AFSC preferences\n    p['rr_om_matrix'] = np.array(df.loc[:, p['rated_afscs'][0]: p['rated_afscs'][len(p['rated_afscs']) - 1]])\n    p['afscs_preferences'] = {}\n    for idx, j in enumerate(p['J^Rated']):\n        sorted_cadets = np.argsort(p['rr_om_matrix'][:, idx])[::-1]\n        zero_cadets = np.where(p['rr_om_matrix'][:, idx] == 0)[0]\n        num_zero = len(zero_cadets)\n        p['afscs_preferences'][j] = sorted_cadets[:p['N'] - num_zero]\n\n    # Cadets to remove\n    removals = []\n\n    # Collect Cadet preferences\n    p['c_preferences'] = np.array(df.loc[:, 'Pref_1':])\n    p['cadets_preferences'] = {}\n    p['rated_only_preferences'] = {}\n    p['cadet_first_choice'] = {}\n    p['num_eligible'] = {}\n    for i in p['I']:\n\n        # \"Real\" first choice AFSC\n        p['cadet_first_choice'][i] = p['c_preferences'][i, 0]\n\n        # Ordered list of AFSC indices\n        p['rated_only_preferences'][i] = np.array(\n            [np.where(p['afscs'] == afsc)[0][0] for afsc in p['c_preferences'][i] if afsc in p['rated_afscs']])\n        p['cadets_preferences'][i] = np.array(\n            [np.where(p['afscs'] == afsc)[0][0] for afsc in p['c_preferences'][i] if afsc in p['afscs']])\n\n        # Make sure cadet is on each of their desired AFSCs' lists\n        cadet_not_on_afsc_lists = []\n        for j in p['rated_only_preferences'][i]:\n            if i not in p['afscs_preferences'][j]:\n                cadet_not_on_afsc_lists.append(p['afscs'][j])\n\n                # We remove this AFSC from this cadet's preferences\n                idx = np.where(p['rated_only_preferences'][i] == j)[0][0]\n                p['rated_only_preferences'][i] = np.delete(p['rated_only_preferences'][i], idx)\n\n                # We remove this AFSC from this cadet's preferences\n                idx = np.where(p['cadets_preferences'][i] == j)[0][0]\n                p['cadets_preferences'][i] = np.delete(p['cadets_preferences'][i], idx)\n\n        # Print update\n        if len(cadet_not_on_afsc_lists) &gt; 0:\n            print_afscs = \", \".join(cadet_not_on_afsc_lists)\n            print(\"[\" + str(i) + \"] Cadet '\" + str(p['cadets'][i]) + \"' not eligible for \" + print_afscs +\n                  \". AFSC(s) have been removed from the cadet's preferences.\")\n\n        # See if this cadet is on the AFSC's list but the AFSC is not in their preferences\n        afsc_not_on_cadet_list = []\n        for j in [j for j in p['J^Rated'] if j not in p['rated_only_preferences'][i]]:\n            if i in p['afscs_preferences'][j]:\n                afsc_not_on_cadet_list.append(p['afscs'][j])\n\n                # We remove this cadet from this AFSC's preferences\n                idx = np.where(p['afscs_preferences'][j] == i)[0][0]\n                p['afscs_preferences'][j] = np.delete(p['afscs_preferences'][j], idx)\n\n        # Print update\n        if len(afsc_not_on_cadet_list) &gt; 0:\n            print_afscs = \", \".join(afsc_not_on_cadet_list)\n            print(\"[\" + str(i) + \"] Cadet '\" + str(p['cadets'][i]) + \"' on preferences lists for \" + print_afscs +\n                  \". AFSC(s) not in cadet's list. Cadet has been removed from the AFSCs' preferences.\")\n\n        # Number of eligible AFSCs for this cadet\n        p['num_eligible'][i] = len(p['rated_only_preferences'][i])\n\n        # Make sure this cadet is eligible for at least one rated AFSC\n        if p['num_eligible'][i] == 0:\n\n            if autofix:\n                print(\"Error at index '\" + str(i) + \"'. Cadet '\" + str(p['cadets'][i]) +\n                             \"' not eligible for any rated AFSCs but is in the dataset. Cadet will be removed\")\n                removals.append(p['cadets'][i])\n            else:\n                raise ValueError(\"Error at index '\" + str(i) + \"'. Cadet '\" + str(p['cadets'][i]) +\n                                 \"' not eligible for any rated AFSCs but is in the dataset. Please adjust.\")\n\n    # Return parameters and removals\n    return p, removals\n</code></pre>"},{"location":"reference/research/rotc_rated/#research.rotc_rated.rotc_rated_hr_algorithm","title":"<code>rotc_rated_hr_algorithm(parameters, printing=True)</code>","text":"<p>This function performs the classic hospital/residents algorithm to match ROTC rated cadets. The ideas of reserved/fixed AFSCs is also imposed here.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <p>dictionary of model parameters pertaining to the ROTC rated matching process</p> required <code>printing</code> <p>whether to print status updates</p> <code>True</code> <p>Returns:</p> Type Description <p>solution augmented parameters</p> Source code in <code>afccp/research/rotc_rated.py</code> <pre><code>def rotc_rated_hr_algorithm(parameters, printing=True):\n    \"\"\"\n    This function performs the classic hospital/residents algorithm to match ROTC rated cadets. The ideas of\n    reserved/fixed AFSCs is also imposed here.\n    :param parameters: dictionary of model parameters pertaining to the ROTC rated matching process\n    :param printing: whether to print status updates\n    :return: solution augmented parameters\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Dictionary to keep track of what AFSC choice in their list the cadets are proposing to\n    cadet_proposal_choice = {i: 0 for i in p['I']} # Initially all propose to their top Rated preference!\n\n    # Begin the simple Hospital/Residents Algorithm\n    total_rejections = {j: 0 for j in p['J^Rated']}  # Number of rejections for each rated AFSC\n    total_matched = {j: 0 for j in p['J^Rated']}  # Number of accepted cadets for each rated AFSC\n    exhausted_cadets = []  # Will contain the cadets that have exhausted (been rejected by) all of their preferences\n    iteration = 1 # First iteration of the algorithm\n    while sum([total_matched[j] for j in p['J^Rated']]) + len(exhausted_cadets) &lt; p['N']:  # Stopping conditions\n\n        # Cadets propose to their top choice that hasn't been rejected\n        proposals = {i: p['rated_only_preferences'][i][\n            cadet_proposal_choice[i]] if i not in exhausted_cadets else p['M'] for i in p['I']}\n        proposal_array = np.array([proposals[i] if i in p['I'] else p['M'] for i in p['I']])\n        counts = {p['afscs'][j]: len(np.where(proposal_array == j)[0]) for j in p['J^Rated']}\n\n        # Initialize matches information for this iteration\n        total_matched = {j: 0 for j in p['J^Rated']}\n\n        # AFSCs accept their best cadets and reject the others\n        for j in p['J^Rated']:\n\n            # Loop through their preferred cadets from top to bottom\n            iteration_rejections = 0\n            for i in p['afscs_preferences'][j]:\n\n                # If the cadet is proposing to this AFSC, we have two options\n                if proposals[i] == j:\n\n                    # We haven't hit capacity, so we accept this cadet\n                    if total_matched[j] &lt; p['total_slots'][j]:\n                        total_matched[j] += 1\n\n                    # We're at capacity, so we reject this cadet\n                    else:\n\n                        # Essentially \"delete\" the preference from the cadet's list\n                        cadet_proposal_choice[i] += 1\n                        proposals[i] = p['M']  # index of the unmatched AFSC (*)\n\n                        # Collect additional information\n                        if printing:\n                            iteration_rejections += 1\n                            total_rejections[j] += 1\n\n        # Check exhausted cadets\n        exhausted_cadets = []\n        for i in p['I']:\n            if cadet_proposal_choice[i] &gt;= p['num_eligible'][i]:\n                exhausted_cadets.append(i)\n\n        # Print statement\n        if printing:\n            print(\"\\nIteration\", iteration)\n            print('Proposals:', counts)\n            print('Matched', {p['afscs'][j]: total_matched[j] for j in p['J^Rated']})\n            print('Rejected', {p['afscs'][j]: total_rejections[j] for j in p['J^Rated']})\n            total_matched_sum = sum([total_matched[j] for j in p['J^Rated']])\n            exhausted_sum = len(exhausted_cadets)\n            print(\"Total Exhausted (\" + str(exhausted_sum) + \") + Total Matched (\" + str(total_matched_sum)\n                  + \") = Total Accounted (\" + str(exhausted_sum + total_matched_sum) + \") || N: \" + str(p['N']) + \".\")\n\n        iteration += 1  # Next iteration!\n\n    # Create \"Matched\" and \"Reserved\" solution arrays\n    p['matches'], p['reserves'] = np.array([p['M'] for _ in p['I']]), np.array([p['M'] for _ in p['I']])\n    p['J^Fixed'], p['J^Reserved'] = {}, {}\n    for i in p['I']:\n        j = proposal_array[i]\n        if j in p['J^Rated']:\n            if p['cadet_first_choice'][i] == p['afscs'][j]:\n                p['matches'][i] = j\n                p['J^Fixed'][i] = j\n            else:\n                p['reserves'][i] = j\n                choice = np.where(p['cadets_preferences'][i] == j)[0][0]\n                p['J^Reserved'][i] = p['cadets_preferences'][i][:choice + 1]\n\n\n\n\n    return p\n</code></pre>"},{"location":"reference/research/rotc_rated/#research.rotc_rated.rotc_rated_alternates_algorithm","title":"<code>rotc_rated_alternates_algorithm(parameters, printing=True)</code>","text":"<p>This function takes in the results from the ROTC Rated HR algorithm and then augments it with the alternate list logic</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <p>dictionary of model parameters pertaining to the ROTC rated matching process</p> required <code>printing</code> <p>whether to print status updates</p> <code>True</code> <p>Returns:</p> Type Description <p>augmented parameters containing the solution w/alternates</p> Source code in <code>afccp/research/rotc_rated.py</code> <pre><code>def rotc_rated_alternates_algorithm(parameters, printing=True):\n    \"\"\"\n    This function takes in the results from the ROTC Rated HR algorithm and then augments it with the\n    alternate list logic\n    :param parameters: dictionary of model parameters pertaining to the ROTC rated matching process\n    :param printing: whether to print status updates\n    :return: augmented parameters containing the solution w/alternates\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Start with a full list of cadets eligible for each AFSC\n    possible_cadets = {j: list(p['afscs_preferences'][j]) for j in p['J^Rated']}\n\n    # Used for stopping conditions\n    last_reserves, last_matches, last_alternates_h = np.array([1000 for _ in p['J^Rated']]), \\\n                                                     np.array([1000 for _ in p['J^Rated']]), \\\n                                                     np.array([1000 for _ in p['J^Rated']])\n\n    # Main algorithm\n    iteration, iterating = 0, True\n    while iterating:\n\n        # Set of cadets reserved or matched to each rated AFSC\n        p['I^Reserved'] = {j: np.array([i for i in p['J^Reserved'] if p['reserves'][i] == j]) for j in p['J^Rated']}\n        p['I^Matched'] = {j: np.array([i for i in p['J^Fixed'] if p['matches'][i] == j]) for j in p['J^Rated']}\n\n        # Number of alternates (number of reserved slots)\n        num_reserved = {j: len(p['I^Reserved'][j]) for j in p['J^Rated']}\n\n        # Need to determine who falls into each category of alternates\n        hard_alternates = {j: [] for j in p['J^Rated']}\n        soft_alternates = {j: [] for j in p['J^Rated']}\n        alternates = {j: [] for j in p['J^Rated']}  # all the cadets ordered here\n\n        # Loop through each rated AFSC to determine alternates\n        for j in p['J^Rated']:\n\n            # Loop through each cadet in order of the AFSC's preference\n            for i in p['afscs_preferences'][j]:\n\n                # Assume this cadet is \"next in line\" until proven otherwise\n                next_in_line = True\n\n                # Is the cadet already fixed to something else?\n                if i in p['J^Fixed']:\n                    next_in_line = False\n                    if i in possible_cadets[j]:\n                        possible_cadets[j].remove(i)\n\n                # Is this cadet reserved for something?\n                if i in p['J^Reserved']:\n\n                    # Where did the cadet rank their reserved AFSC?\n                    reserved_choice = np.where(p['rated_only_preferences'][i] == p['reserves'][i])[0][0]\n\n                    # Where did the cadet rank this rated AFSC?\n                    this_choice = np.where(p['rated_only_preferences'][i] == j)[0][0]\n\n                    # If they're already reserved for this rated AFSC or something better, they're not considered\n                    if reserved_choice &lt;= this_choice:\n                        next_in_line = False\n                        if i in possible_cadets[j]:\n                            possible_cadets[j].remove(i)\n\n                # If this cadet is next in line (and we still have alternates to assign)\n                if next_in_line and len(hard_alternates[j]) &lt; num_reserved[j]:\n                    alternates[j].append(i)\n\n                    # Loop through the cadet's preferences:\n                    for j_c in p['cadets_preferences'][i]:\n\n                        # Determine what kind of alternate this cadet is\n                        if j_c == j:  # Hard Rated Alternate\n                            hard_alternates[j].append(i)\n                            break\n                        elif j_c in p['J^Rated']:\n                            if i in possible_cadets[j_c]:  # Soft Rated Alternate\n                                soft_alternates[j].append(i)\n                                break\n                            else:  # Can't be matched, go to next preference\n                                continue\n                        else:  # Soft Non-Rated Alternate\n                            soft_alternates[j].append(i)\n                            break\n\n                # We've run out of hard alternates to assign (thus, we're done assigning alternates)\n                elif len(hard_alternates[j]) &gt;= num_reserved[j]:\n                    if i in possible_cadets[j]:\n                        possible_cadets[j].remove(i)\n\n        # Loop through each AFSC to potentially turn \"reserved\" slots into \"matched\" slots\n        for j in p['J^Rated']:\n\n            # Loop through each cadet in order of the AFSC's preference\n            for i in p['afscs_preferences'][j]:\n\n                # Does this cadet have a reserved slot for something?\n                if i in p['J^Reserved']:\n\n                    # Is this cadet reserved for this AFSC?\n                    if p['reserves'][i] == j:\n\n                        # Determine if there's any possible way this cadet might not be matched to this AFSC\n                        inevitable_match = True\n                        for j_c in p['J^Reserved'][i][:-1]:  # Loop through all more preferred AFSCs than this one\n                            if j_c not in p['J^Rated']:  # Non-Rated\n                                inevitable_match = False\n                            else:  # Rated\n                                if i in alternates[j_c]:  # They're an alternate for something more preferred\n                                    inevitable_match = False\n                                else:  # They're not an alternate for that more preferred AFSC...\n                                    if i in possible_cadets[j_c]:  # ...they cannot be matched to that AFSC\n                                        possible_cadets[j_c].remove(i)  # Remove this cadet as a possibility!\n\n                        # If still inevitable, change from reserved to fixed\n                        if inevitable_match:\n                            p['J^Fixed'][i], p['matches'][i], p['reserves'][i] = j, j, p['M']\n                            p['J^Reserved'].pop(i)\n\n                # This cadet cannot receive this AFSC\n                if i not in alternates[j] and i in possible_cadets[j]:\n                    possible_cadets[j].remove(i)\n\n        # Print Statement\n        if printing:\n            print(\"\\nIteration\", iteration)\n            print(\"Possible\", {p['afscs'][j]: len(possible_cadets[j]) for j in p['J^Rated']})\n            print(\"Matched\", {p['afscs'][j]: len(p['I^Matched'][j]) for j in p['J^Rated']})\n            print(\"Reserved\", {p['afscs'][j]: len(p['I^Reserved'][j]) for j in p['J^Rated']})\n            print(\"Alternates (Hard)\", {p['afscs'][j]: len(hard_alternates[j]) for j in p['J^Rated']})\n            print(\"Alternates (Soft)\", {p['afscs'][j]: len(soft_alternates[j]) for j in p['J^Rated']})\n\n        # Once we stop changing from the algorithm, we're done!\n        current_matched = np.array([len(p['I^Matched'][j]) for j in p['J^Rated']])\n        current_reserved = np.array([len(p['I^Reserved'][j]) for j in p['J^Rated']])\n        current_alternates_h = np.array([len(hard_alternates[j]) for j in p['J^Rated']])\n        if np.sum(current_matched - last_matches + current_reserved -\n                  last_reserves + current_alternates_h - last_alternates_h) == 0:\n            iterating = False\n        else:\n            last_matches, last_reserves, last_alternates_h = current_matched, current_reserved, current_alternates_h\n\n        # Next iteration\n        iteration += 1\n\n    # Incorporate alternate lists (broken down by Hard/Soft)\n    p['alternates_hard'] = np.array([p['M'] for _ in p['I']])\n    p['alternates_soft'] = np.array([p['M'] for _ in p['I']])\n    for i in p['I']:  # Loop through all rated cadets\n        for j in p['rated_only_preferences'][i]:  # Loop through rated preferences in order\n            if i in hard_alternates[j]:\n                p['alternates_hard'][i] = j\n            elif i in soft_alternates[j]:\n                p['alternates_soft'][i] = j\n                break  # Next cadet\n\n    # Return updated parameters (and alternate lists)\n    return p\n</code></pre>"},{"location":"reference/research/rotc_rated/#research.rotc_rated.rotc_rated_match","title":"<code>rotc_rated_match(filename, afsc_quotas, afscs, auto_fix_eligibility=False, printing=True)</code>","text":"<p>This is the main function to match ROTC rated cadets to their AFSCs prior to the main \"One Market\" model match. It calls all necessary functions to process the information and export it back to excel</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <p>name/path to file</p> required <code>afsc_quotas</code> <p>dictionary of ROTC capacities for the rated AFSCs</p> required <code>printing</code> <p>if we should print status updates</p> <code>True</code> <p>Returns:</p> Type Description <p>None. Export results to excel</p> Source code in <code>afccp/research/rotc_rated.py</code> <pre><code>def rotc_rated_match(filename, afsc_quotas, afscs, auto_fix_eligibility=False, printing=True):\n    \"\"\"\n    This is the main function to match ROTC rated cadets to their AFSCs prior to the main \"One Market\" model\n    match. It calls all necessary functions to process the information and export it back to excel\n    :param filename: name/path to file\n    :param afsc_quotas: dictionary of ROTC capacities for the rated AFSCs\n    :param printing: if we should print status updates\n    :return: None. Export results to excel\n    \"\"\"\n\n    # Load in data\n    df = afccp.globals.import_csv_data(filename)\n\n    # Process data twice, first to remove Rated ineligible cadets and then once more to finish\n    for iteration in [1, 2]:\n\n        # Initialize parameter dictionary\n        parameters = {'rated_afscs': np.array([afsc for afsc in afsc_quotas]), 'cadets': np.array(df['Cadet']),\n                      'afscs': afscs}\n\n        # Additional information\n        parameters['N'], parameters['M'] = len(parameters['cadets']), len(parameters['afscs'])\n        parameters['I'], parameters['J'] = np.arange(parameters['N']), np.arange(parameters['M'])\n        parameters['J^Rated'] = np.array([np.where(afsc == parameters['afscs'])[0][0] for afsc in parameters['rated_afscs']])\n        parameters['total_slots'] = {j: afsc_quotas[parameters['afscs'][j]] for j in parameters['J^Rated']}\n\n        if printing:\n            print(\"\\nProcessing Data...Iteration \" + str(iteration) + \"\\n\")\n\n        # Process data\n        parameters, removals = process_data_in_parameters(df, parameters, autofix=auto_fix_eligibility)\n\n        # Drop the cadets we don't want\n        df = df.set_index('Cadet')\n        df = df.drop(removals)\n        df = df.reset_index()\n\n    if printing:\n        print(\"\\nROTC Rated Board Algorithm...\")\n\n    # Run the rated board algorithm\n    parameters = rotc_rated_hr_algorithm(parameters, printing)\n\n    if printing:\n        print(\"\\nROTC Rated Alternates Algorithm...\\n\")\n\n    # Run the rated alternates algorithm\n    parameters = rotc_rated_alternates_algorithm(parameters, printing)\n\n    # Adjust solution arrays and add them into dataframe\n    df['Matches'] = [parameters['afscs'][j] if j in parameters['J'] else '' for j in parameters['matches']]\n    df['Reserves'] = [parameters['afscs'][j] if j in parameters['J'] else '' for j in parameters['reserves']]\n    df['Alternates (H)'] = [parameters['afscs'][j] if j in parameters['J'] else '' for j in\n                            parameters['alternates_hard']]\n    df['Alternates (S)'] = [parameters['afscs'][j] if j in parameters['J'] else '' for j in\n                            parameters['alternates_soft']]\n\n    # Export back to csv\n    df.to_csv(filename, index=False)\n</code></pre>"},{"location":"reference/research/testing/","title":"Testing","text":""},{"location":"reference/research/testing/#research.testing","title":"<code>research.testing</code>","text":""},{"location":"reference/research/testing/#research.testing.test_solve_times","title":"<code>test_solve_times()</code>","text":"<p>Tests solve times</p> Source code in <code>afccp/research/testing.py</code> <pre><code>def test_solve_times():\n    \"\"\"\n    Tests solve times\n    \"\"\"\n\n    # size_list = [(100, 6, 0), (200, 6, 0), (1200, 6, 0), (2500, 16, 0)]\n    size_list = [(500, 10, 6), (1500, 14, 6), (3000, 14, 10)]\n    # model_solver_list = [('GUO', 'cbc'), ('A-VFT', 'cbc'), ('E-VFT', 'ipopt')]\n    model_solver_list = [('GUO', 'cbc')]\n    instances_per_size = 5\n    max_solve_time = 60\n\n    df_columns = {'Iteration': [], 'Size (NxMxS)': [], 'Instance': [], 'Model': [], 'Solver': [], 'Result': [],\n                  'Solve Time (s)': [], 'Pyomo Z': [], 'Real X Exact VFT Z': [], 'Real X Approx VFT Z': [],\n                  'Rounded X Exact VFT Z': [], 'Real X GUO Z': [], 'Rounded X GUO Z': [], 'Integer X': [],\n                  'Integer Y': [], 'Integer V': [], 'Integer Q': [], 'Fixed, Reserved, Alternates': []}\n\n    # Loop through each problem size in the list\n    iteration = 0\n    for size in size_list:\n\n        N, M, S = size[0], size[1], size[2]\n        size_name = str(N) + 'x' + str(M) + 'x' + str(S)\n\n        print('\\nSize', size_name)\n\n        # Loop through each iteration of this problem size\n        for i in range(instances_per_size):\n\n            print('\\nInstance', i + 1)\n\n            # Create the problem instance\n            if S == 0:\n                instance = CadetCareerProblem('Random', N=N, M=M, P=M, printing=False)\n            else:\n                instance = CadetCareerProblem('Random', N=N, M=M, P=M, S=S, generate_extra_components=True,\n                                              printing=False)\n            instance.fix_generated_data(printing=False)\n            instance.set_value_parameters()\n            instance.soc_rated_matching_algorithm({'soc': 'usafa'})\n            instance.soc_rated_matching_algorithm({'soc': 'rotc'})\n            instance.incorporate_rated_algorithm_results()\n\n            # Loop through each model &amp; solver name in the list\n            for model_name, solver_name in model_solver_list:\n                iteration += 1\n\n                # Initialize \"p_dict\" for model controls\n                p_dict = {'solver_name': solver_name, 'pyomo_max_time': max_solve_time, 're-calculate x': False}\n\n                # Change dictionary based on certain features\n                if solver_name == 'couenne':\n                    p_dict['provide_executable'] = True\n                if S != 0:\n                    p_dict['solve_extra_components'] = True\n\n                # Add standard values\n                df_columns['Iteration'].append(iteration), df_columns['Instance'].append(i + 1)\n                df_columns['Size (NxMxS)'].append(size_name), df_columns['Model'].append(model_name),\n                df_columns['Solver'].append(solver_name)\n\n                print(model_name, solver_name, 'solving at', datetime.datetime.now().strftime(\"%H:%M:%S\"))\n\n                # Solve the model\n                try:\n                    if model_name == 'GUO':\n                        instance.solve_guo_pyomo_model(p_dict)\n                    elif model_name == 'A-VFT':\n                        p_dict['approximate'] = True\n                        instance.solve_vft_pyomo_model(p_dict)\n                    elif model_name == 'E-VFT':\n                        p_dict['approximate'] = False\n                        instance.solve_vft_pyomo_model(p_dict)\n\n                    # Solve Time\n                    if instance.solution['solve_time'] &gt;= max_solve_time:\n                        df_columns['Result'].append('Time Limit Reached')\n                    else:\n                        df_columns['Result'].append('Solved')\n\n                    # Add values\n                    df_columns['Solve Time (s)'].append(instance.solution['solve_time'])\n                    df_columns['Pyomo Z'].append(instance.solution['pyomo_obj_value'])\n                    df_columns['Fixed, Reserved, Alternates'].append(\n                        instance.solution['cadets_fixed_correctly'] + ', ' +\n                        instance.solution['cadets_reserved_correctly'] + ', ' + instance.solution['alternate_list_metric'])\n\n                    # Check if we have integer values\n                    df_columns['Integer X'].append(str(instance.solution['x_integer']))\n                    if model_name != 'GUO':\n                        df_columns['Integer Y'].append(str(instance.solution['y_integer']))\n                    else:\n                        df_columns['Integer Y'].append('N/A')\n                    if S != 0:\n                        df_columns['Integer V'].append(str(instance.solution['v_integer']))\n                        df_columns['Integer Q'].append(str(instance.solution['q_integer']))\n                    else:\n                        df_columns['Integer V'].append('N/A')\n                        df_columns['Integer Q'].append('N/A')\n\n                    # Get objective values\n                    df_columns['Real X GUO Z'].append(round(instance.solution['z^gu'], 4))\n                    df_columns['Real X Exact VFT Z'].append(round(instance.solution['z'], 4))\n\n                    # Get approximate VFT Z\n                    instance.measure_solution(approximate=True)\n                    df_columns['Real X Approx VFT Z'].append(round(instance.solution['z'], 4))\n\n                    # Get rounded X matrix objective values\n                    instance.mdl_p['re-calculate x'] = True\n                    instance.measure_solution()\n                    df_columns['Rounded X Exact VFT Z'].append(round(instance.solution['z'], 4))\n                    df_columns['Rounded X GUO Z'].append(round(instance.solution['z^gu'], 4))\n                    print(model_name, solver_name, 'solved in', instance.solution['solve_time'], 'seconds.')\n\n                    print_str = df_columns['Result'][iteration - 1]\n                    for element in ['Real X GUO Z', 'Real X Exact VFT Z', 'Real X Approx VFT Z', 'Rounded X Exact VFT Z',\n                                    'Rounded X GUO Z']:\n                        print_str += ', ' + element + ': ' + str(df_columns[element][iteration - 1])\n                    print(model_name, solver_name, print_str)\n\n                # Solver failed!\n                except:\n\n                    # Add values\n                    df_columns['Result'].append('Failed'), df_columns['Real X Approx VFT Z'].append(0)\n                    df_columns['Solve Time (s)'].append(0), df_columns['Rounded X GUO Z'].append(0)\n                    df_columns['Pyomo Z'].append(0), df_columns['Rounded X Exact VFT Z'].append(0)\n                    df_columns['Real X Exact VFT Z'].append(0), df_columns['Real X GUO Z'].append(0)\n                    df_columns['Integer X'].append('N/A'), df_columns['Integer Y'].append('N/A'), \\\n                    df_columns['Integer V'].append('N/A'), df_columns['Integer Q'].append('N/A')\n                    df_columns['Fixed, Reserved, Alternates'].append('N/A')\n                    print(model_name, solver_name, 'Failed')\n\n    # Put dataframe together\n    df = pd.DataFrame(df_columns)\n\n    # Export to csv\n    df.to_csv('Solve Time Test.csv', index=False)\n</code></pre>"},{"location":"reference/solutions/algorithms/","title":"Algorithms","text":""},{"location":"reference/solutions/algorithms/#solutions.algorithms","title":"<code>solutions.algorithms</code>","text":""},{"location":"reference/solutions/algorithms/#solutions.algorithms.classic_hr","title":"<code>classic_hr(instance, capacities=None, printing=True)</code>","text":"<p>Matches cadets and AFSCs across all rated, space, and NRL positions using the Hospitals/Residents algorithm.</p> <p>Parameters:     instance (CadetCareerProblem): The instance of the CadetCareerProblem class.     capacities (numpy.ndarray or None): The capacities of AFSCs. If None, the capacities are taken from the         instance parameters. Default is None.     printing (bool): Whether to print status updates or not. Default is True.</p> <p>Returns:     dict: The solution dictionary containing the assigned AFSCs for each cadet.</p> <p>This function implements the Hospitals/Residents algorithm to match cadets and AFSCs across all rated, space, and NRL positions. It takes an instance of the CadetCareerProblem class as input and an optional parameter <code>capacities</code> to specify the capacities of AFSCs. If <code>capacities</code> is None, the capacities are taken from the instance parameters. By default, the function prints status updates during the matching process.</p> <p>The algorithm initializes the necessary variables and dictionaries. It then proceeds with the Hospitals/Residents algorithm by having cadets propose to their top choices and AFSCs accept or reject cadets based on their preferences and capacities. The matching process continues until all cadets are matched or have exhausted their preferences. The function updates the matches and rejections for each AFSC and tracks the progress through iterations.</p> <p>The function returns a solution dictionary containing the assigned AFSCs for each cadet.</p> <p>Example usage:     solution = classic_hr(instance, capacities=capacities, printing=True)</p> Source code in <code>afccp/solutions/algorithms.py</code> <pre><code>def classic_hr(instance, capacities=None, printing=True):\n    \"\"\"\n    Matches cadets and AFSCs across all rated, space, and NRL positions using the Hospitals/Residents algorithm.\n\n    Parameters:\n        instance (CadetCareerProblem): The instance of the CadetCareerProblem class.\n        capacities (numpy.ndarray or None): The capacities of AFSCs. If None, the capacities are taken from the\n            instance parameters. Default is None.\n        printing (bool): Whether to print status updates or not. Default is True.\n\n    Returns:\n        dict: The solution dictionary containing the assigned AFSCs for each cadet.\n\n    This function implements the Hospitals/Residents algorithm to match cadets and AFSCs across all rated, space,\n    and NRL positions. It takes an instance of the CadetCareerProblem class as input and an optional parameter\n    `capacities` to specify the capacities of AFSCs. If `capacities` is None, the capacities are taken from the\n    instance parameters. By default, the function prints status updates during the matching process.\n\n    The algorithm initializes the necessary variables and dictionaries. It then proceeds with the Hospitals/Residents\n    algorithm by having cadets propose to their top choices and AFSCs accept or reject cadets based on their preferences\n    and capacities. The matching process continues until all cadets are matched or have exhausted their preferences.\n    The function updates the matches and rejections for each AFSC and tracks the progress through iterations.\n\n    The function returns a solution dictionary containing the assigned AFSCs for each cadet.\n\n    Example usage:\n        solution = classic_hr(instance, capacities=capacities, printing=True)\n    \"\"\"\n\n    if printing:\n        print(\"Modeling this as an H/R problem and solving with DAA...\")\n\n    # Shorthand\n    p, vp, mdl_p = instance.parameters, instance.value_parameters, instance.mdl_p\n\n    # Algorithm initialization\n    if capacities is None:\n        total_slots = p[mdl_p['capacity_parameter']]\n    else:  # In case this is used in a genetic algorithm\n        total_slots = capacities\n\n    # Array to keep track of what AFSC choice in their list the cadets are proposing to (python index at 0)\n    cadet_proposal_choice = np.zeros(p['N']).astype(int)  # Everyone proposes to their first choice initially\n\n    # Initialize solution dictionary\n    solution = {'method': 'HR'}\n\n    # Dictionary of parameters used for the \"BubbleChart\" object (animation)\n    if mdl_p['collect_solution_iterations']:\n        solution['iterations'] = {'type': 'HR'}\n        for key in ['proposals', 'matches', 'names']:\n            solution['iterations'][key] = {}\n\n    # Begin the simple Hospital/Residents Algorithm\n    total_rejections = np.zeros(p['M'])  # Number of rejections for each AFSC\n    total_matched = np.zeros(p['M'])  # Number of accepted cadets for each AFSC\n    exhausted_cadets = []  # Will contain the cadets that have exhausted (been rejected by) all of their preferences\n    iteration = 0  # First iteration of the algorithm\n    while np.sum(total_matched) + len(exhausted_cadets) &lt; p['N']:  # Stopping conditions\n\n        # Cadets propose to their top choice that hasn't been rejected\n        exhausted_cadets = np.where(cadet_proposal_choice &gt;= p['num_cadet_choices'])[0]\n        proposals = np.array([p['cadet_preferences'][i][cadet_proposal_choice[i]] if i not in exhausted_cadets\n                              else p['M'] for i in p['I']])\n\n        # Solution Iteration components (Proposals) and print statement\n        if mdl_p['collect_solution_iterations']:\n            solution['iterations']['proposals'][iteration] = copy.deepcopy(proposals)\n        if mdl_p['ma_printing']:\n            print(\"\\nIteration\", iteration + 1)\n            counts = {p['afscs'][j]: len(np.where(proposals == j)[0]) for j in p['J']}\n\n        # Initialize matches information for this iteration\n        total_matched = np.zeros(p['M'])\n\n        # AFSCs accept their best cadets and reject the others\n        for j in p['J']:\n\n            # Loop through their preferred cadets from top to bottom\n            iteration_rejections = 0\n            for i in p['afsc_preferences'][j]:\n\n                # If the cadet is proposing to this AFSC, we have two options\n                if proposals[i] == j:\n\n                    # We haven't hit capacity, so we accept this cadet\n                    if total_matched[j] &lt; total_slots[j]:\n                        total_matched[j] += 1\n\n                    # We're at capacity, so we reject this cadet\n                    else:\n\n                        # Essentially \"delete\" the preference from the cadet's list\n                        cadet_proposal_choice[i] += 1\n                        proposals[i] = p['M']  # index of the unmatched AFSC (*)\n\n                        # Collect additional information\n                        if mdl_p['ma_printing']:\n                            iteration_rejections += 1\n                            total_rejections[j] += 1\n\n        # Solution Iteration components\n        if mdl_p['collect_solution_iterations']:\n            solution['iterations']['matches'][iteration] = copy.deepcopy(proposals)\n            solution['iterations']['names'][iteration] = 'Round ' + str(iteration + 1)\n\n        # Specific matching algorithm print statement\n        if mdl_p['ma_printing']:\n            print('Proposals:', counts)\n            print('Matched', {p['afscs'][j]: total_matched[j] for j in p['J']})\n            print('Rejected', {p['afscs'][j]: total_rejections[j] for j in p['J']})\n\n        iteration += 1 # Next iteration!\n\n    # Last solution iteration\n    if mdl_p['collect_solution_iterations']:\n        solution['iterations']['last_s'] = iteration - 1\n\n    # Return solution\n    solution['j_array'] = proposals\n    solution['afsc_array'] = np.array([p['afscs'][j] for j in solution['j_array']])\n    return solution\n</code></pre>"},{"location":"reference/solutions/algorithms/#solutions.algorithms.rotc_rated_board_original","title":"<code>rotc_rated_board_original(instance, printing=False)</code>","text":"<p>Assigns Rated AFSCs to ROTC cadets based on their preferences and the existing quotas for each AFSC using the current rated board algorithm.</p> <p>Parameters:     instance (CadetCareerProblem): The instance of the CadetCareerProblem class.     printing (bool): Whether to print status updates or not. Default is False.</p> <p>Returns:     dict: The solution dictionary containing the assigned AFSCs for each cadet.</p> <p>This function assigns Rated AFSCs to ROTC cadets based on their preferences and the existing quotas for each AFSC. It follows the current rated board algorithm. The function takes an instance of the CadetCareerProblem class as input and an optional parameter <code>printing</code> to specify whether to print status updates. By default, <code>printing</code> is set to False. The function initializes the necessary variables and dictionaries for the algorithm. It then goes through each phase of the rated board algorithm, considering cadets' order of merit and interest levels for each AFSC. Cadets are assigned AFSCs based on availability and eligibility. The function updates the assigned AFSCs for each cadet and tracks the number of matched cadets for each AFSC. Finally, it converts the assigned AFSCs into a solution dictionary and returns it.</p> <p>Example usage:     solution = rotc_rated_board_original(instance, printing=True)</p> Source code in <code>afccp/solutions/algorithms.py</code> <pre><code>def rotc_rated_board_original(instance, printing=False):\n    \"\"\"\n    Assigns Rated AFSCs to ROTC cadets based on their preferences and the existing quotas for each AFSC using the\n    current rated board algorithm.\n\n    Parameters:\n        instance (CadetCareerProblem): The instance of the CadetCareerProblem class.\n        printing (bool): Whether to print status updates or not. Default is False.\n\n    Returns:\n        dict: The solution dictionary containing the assigned AFSCs for each cadet.\n\n    This function assigns Rated AFSCs to ROTC cadets based on their preferences and the existing quotas for each AFSC.\n    It follows the current rated board algorithm. The function takes an instance of the CadetCareerProblem class as\n    input and an optional parameter `printing` to specify whether to print status updates. By default, `printing` is\n    set to False. The function initializes the necessary variables and dictionaries for the algorithm. It then goes\n    through each phase of the rated board algorithm, considering cadets' order of merit and interest levels for each\n    AFSC. Cadets are assigned AFSCs based on availability and eligibility. The function updates the assigned AFSCs\n    for each cadet and tracks the number of matched cadets for each AFSC. Finally, it converts the assigned AFSCs into\n    a solution dictionary and returns it.\n\n    Example usage:\n        solution = rotc_rated_board_original(instance, printing=True)\n    \"\"\"\n\n\n    if printing:\n        print(\"Running status quo ROTC rated algorithm...\")\n\n    # Shorthand\n    p, mdl_p = instance.parameters, instance.mdl_p\n\n    # Cadets/AFSCs and their preferences\n    cadet_indices = p['Rated Cadets']['rotc']  # indices of the cadets in the full set of cadets\n    cadets, N = np.arange(len(cadet_indices)), len(cadet_indices)\n    rated_J = np.array([j for j in p['J^Rated'] if '_U' not in p['afscs'][j]])\n    afscs, M = p['afscs'][rated_J], len(rated_J)\n    afsc_indices = np.array([np.where(p['afscs'] == afsc)[0][0] for afsc in afscs])\n    afsc_om = {afscs[j]: p['rr_om_matrix'][:, j] for j in range(M)}  # list of OM percentiles for each AFSC\n    afsc_interest = {afscs[j]: p['rr_interest_matrix'][:, j] for j in range(M)}  # list of Rated interest from cadets\n    eligible = {afscs[j]: p['rr_om_matrix'][:, j] &gt; 0 for j in range(M)}  # binary eligibility column for each AFSC\n\n    # Dictionary of dictionaries of cadets within each order of merit \"level\" for each AFSC\n    om_cl = {\"High\": (0.4, 1), \"Med\": (0.2, 0.4), \"Low\": (0.1, 0.2)}\n    om = {afsc: {level: np.where((afsc_om[afsc] &gt;= om_cl[level][0]) &amp;\n                                 (afsc_om[afsc] &lt; om_cl[level][1]))[0] for level in om_cl} for afsc in afscs}\n\n    # Dictionary of dictionaries of cadets with each interest \"level\" for each AFSC\n    interest_levels = [\"High\", \"Med\", \"Low\", \"None\"]\n    interest = {afsc: {level: np.where(afsc_interest[afsc] == level)[0] for level in interest_levels} for afsc in afscs}\n\n    # Algorithm initialization\n    total_slots = {afscs[idx]: p['rotc_quota'][j] for idx, j in enumerate(afsc_indices)}\n    total_matched = {afsc: 0 for afsc in afscs}  # Number of matched cadets for each AFSC\n    matching = {afsc: True for afsc in afscs}  # Used in stopping conditions\n    assigned_afscs = {cadet: \"\" for cadet in cadets}\n\n    # Initialize solution dictionary\n    solution = {'cadets_solved_for': 'ROTC Rated', 'afscs_solved_for': 'Rated', 'method': 'ROTCRatedBoard'}\n\n    # Dictionary of parameters used for the \"BubbleChart\" object (animation)\n    if mdl_p['collect_solution_iterations']:\n        solution['iterations'] = {'type': 'ROTC Rated Board'}\n        for key in ['matches', 'names']:\n            solution['iterations'][key] = {}\n\n    # Re-order AFSCs if necessary\n    if instance.mdl_p['rotc_rated_board_afsc_order'] is not None:\n        afscs = instance.mdl_p['rotc_rated_board_afsc_order']  # Need to be ordered list of ROTC Rated AFSCs\n\n    # Phases of the Rated board where each tuple represents the level for (OM, Interest)\n    phases = [(\"High\", \"High\"), (\"High\", \"Med\"), (\"Med\", \"High\"), (\"Med\", \"Med\"), (\"Low\", \"High\"), (\"High\", \"Low\"),\n              (\"Low\", \"Med\"), (\"Med\", \"Low\"), (\"Low\", \"Low\"), (\"High\", \"None\"), (\"Med\", \"None\"), (\"Low\", \"None\")]\n    phase_num = 0\n    s = 0  # for solution iterations\n    while any(matching.values()) and phase_num &lt; len(phases):\n        phase = phases[phase_num]\n        om_level, interest_level = phase[0], phase[1]\n        phase_num += 1\n        if printing:\n            print(\"\\nPhase\", phase_num, om_level, \"OM\", \"&amp;\", interest_level, \"Interest\")\n\n        # Loop through each Rated AFSC\n        for afsc in afscs:\n\n            # Get the ordered list of cadets we're considering in this phase\n            phase_cadets = np.intersect1d(om[afsc][om_level], interest[afsc][interest_level])\n            om_phase_cadets = afsc_om[afsc][phase_cadets]\n            indices = np.argsort(om_phase_cadets)[::-1]\n            ordered_cadets = phase_cadets[indices]\n\n            # Loop through each eligible cadet to assign them this AFSC if applicable\n            eligible_cadets = np.where(eligible[afsc])[0]\n            counter = 0\n            for cadet in ordered_cadets:\n\n                # The cadet has to be eligible for the AFSC to be considered\n                if cadet not in eligible_cadets:\n                    continue\n\n                # If we didn't already assign them an AFSC, and we've still got open slots left, the cadet gets matched\n                if assigned_afscs[cadet] == \"\" and total_matched[afsc] &lt; total_slots[afsc]:\n                    assigned_afscs[cadet] = afsc\n                    total_matched[afsc] += 1\n                    counter += 1\n\n                # We've reached capacity for this AFSC\n                if total_matched[afsc] == total_slots[afsc]:\n                    matching[afsc] = False\n                    break\n\n            if counter != 0 and printing:\n                print(afsc, \"Phase Matched:\", counter, \"  ---&gt;   Total Matched:\", total_matched[afsc], \"/\",\n                      total_slots[afsc])\n\n            # Solution Iteration components\n            s += 1\n            if mdl_p['collect_solution_iterations']:\n                afsc_solution = np.array([\" \" * 10 for _ in p['I']])\n                for cadet, i in enumerate(cadet_indices):\n                    if assigned_afscs[cadet] in afscs:\n                        afsc_solution[i] = assigned_afscs[cadet]\n                indices = np.where(afsc_solution == \" \" * 10)[0]\n                afsc_solution[indices] = \"*\"\n                solution['iterations']['matches'][s] = \\\n                    np.array([np.where(p['afscs'] == afsc)[0][0] for afsc in afsc_solution])\n                solution['iterations']['names'][s] = \\\n                    \"Phase \" + str(phase_num) + \" (\" + om_level + \", \" + interest_level + \") [\" + afsc + \"]\"\n\n    # Solution Iteration components\n    if mdl_p['collect_solution_iterations']:\n        solution['iterations']['last_s'] = s - 1\n\n    # Convert it back to a full solution with all cadets (anyone not matched to a Rated AFSC is unmatched)\n    afsc_solution = np.array([\" \" * 10 for _ in p['I']])\n    for cadet, i in enumerate(cadet_indices):\n        if assigned_afscs[cadet] in afscs:\n            afsc_solution[i] = assigned_afscs[cadet]\n    indices = np.where(afsc_solution == \" \" * 10)[0]\n    afsc_solution[indices] = \"*\"\n    solution['j_array'] = np.array([np.where(p['afscs'] == afsc)[0][0] for afsc in afsc_solution])\n    return solution\n</code></pre>"},{"location":"reference/solutions/algorithms/#solutions.algorithms.soc_rated_matching_algorithm","title":"<code>soc_rated_matching_algorithm(instance, soc='usafa', printing=True)</code>","text":"<p>Matches or reserves cadets to their Rated AFSCs based on the Source of Commissioning (SOC) using the Hospitals/Residents algorithm.</p> <p>Parameters:     instance (CadetCareerProblem): The instance of the CadetCareerProblem class.     soc (str): The SOC for which to perform the matching algorithm. Options are 'usafa' (United States Air Force Academy)                or 'rotc' (Reserve Officer Training Corps). Default is 'usafa'.     printing (bool): Whether to print status updates or not. Default is True.</p> <p>Returns:     tuple: A tuple containing three solution dictionaries: the overall solution, the reserves solution,         and the matches solution.</p> <p>This function implements the Hospitals/Residents algorithm to match or reserve cadets to their Rated AFSCs based on the Source of Commissioning (SOC). It takes an instance of the CadetCareerProblem class as input and an optional parameter <code>soc</code> to specify the SOC for which the matching algorithm should be performed. The available options for <code>soc</code> are 'usafa' (United States Air Force Academy) and 'rotc' (Reserve Officer Training Corps). By default, the SOC is set to 'usafa'. The function also takes an optional parameter <code>printing</code> to control whether status updates are printed during the matching process.</p> <p>The algorithm initializes the necessary variables and dictionaries. It then proceeds with the Hospitals/Residents algorithm by having cadets propose to their top choices and AFSCs accept or reject cadets based on their preferences and capacities. The matching process continues until all cadets are matched or have exhausted their preferences. The function tracks the progress through iterations and collects information on both reserved and matched AFSCs.</p> <p>The function returns a tuple containing three solution dictionaries: the overall solution, the reserves solution, and the matches solution. Each solution dictionary contains the assigned AFSCs for each cadet. The reserves solution only includes cadets with reserved slots, the matches solution only includes cadets with matched slots, and the overall solution includes both cadets with reserved and matched slots.</p> <p>Example usage:     solution, reserves, matches = soc_rated_matching_algorithm(instance, soc='usafa', printing=True)</p> Source code in <code>afccp/solutions/algorithms.py</code> <pre><code>def soc_rated_matching_algorithm(instance, soc='usafa', printing=True):\n    \"\"\"\n    Matches or reserves cadets to their Rated AFSCs based on the Source of Commissioning (SOC) using the Hospitals/Residents algorithm.\n\n    Parameters:\n        instance (CadetCareerProblem): The instance of the CadetCareerProblem class.\n        soc (str): The SOC for which to perform the matching algorithm. Options are 'usafa' (United States Air Force Academy)\n                   or 'rotc' (Reserve Officer Training Corps). Default is 'usafa'.\n        printing (bool): Whether to print status updates or not. Default is True.\n\n    Returns:\n        tuple: A tuple containing three solution dictionaries: the overall solution, the reserves solution,\n            and the matches solution.\n\n    This function implements the Hospitals/Residents algorithm to match or reserve cadets to their Rated AFSCs\n    based on the Source of Commissioning (SOC). It takes an instance of the CadetCareerProblem class as input and\n    an optional parameter `soc` to specify the SOC for which the matching algorithm should be performed. The available\n    options for `soc` are 'usafa' (United States Air Force Academy) and 'rotc' (Reserve Officer Training Corps). By\n    default, the SOC is set to 'usafa'. The function also takes an optional parameter `printing` to control whether\n    status updates are printed during the matching process.\n\n    The algorithm initializes the necessary variables and dictionaries. It then proceeds with the Hospitals/Residents\n    algorithm by having cadets propose to their top choices and AFSCs accept or reject cadets based on their preferences\n    and capacities. The matching process continues until all cadets are matched or have exhausted their preferences.\n    The function tracks the progress through iterations and collects information on both reserved and matched AFSCs.\n\n    The function returns a tuple containing three solution dictionaries: the overall solution, the reserves solution,\n    and the matches solution. Each solution dictionary contains the assigned AFSCs for each cadet. The reserves\n    solution only includes cadets with reserved slots, the matches solution only includes cadets with matched slots,\n    and the overall solution includes both cadets with reserved and matched slots.\n\n    Example usage:\n        solution, reserves, matches = soc_rated_matching_algorithm(instance, soc='usafa', printing=True)\n    \"\"\"\n\n    if printing:\n        print(\"Solving the rated matching algorithm for \" + soc.upper() + \" cadets...\")\n\n    # Shorthand\n    p, mdl_p = instance.parameters, instance.mdl_p\n\n    # Slight change to Rated AFSCs (Remove SOC specific slots)\n    rated_afscs = determine_soc_rated_afscs(soc, all_rated_afscs=p['afscs_acc_grp'][\"Rated\"])\n    rated_J = np.array([np.where(p['afscs'] == afsc)[0][0] for afsc in rated_afscs])\n\n    # Algorithm initialization\n    total_slots = {j: p[soc + \"_quota\"][j] for j in rated_J}\n    cadets = p['Rated Cadets'][soc]\n    N = len(cadets)\n\n    # \"REAL\" first choice of the cadet\n    first_choice = {i: p['cadet_preferences'][i][0] for i in cadets}\n\n    # Dictionary to keep track of what AFSC choice in their list the cadets are proposing to\n    cadet_proposal_choice = {i: 0 for i in cadets}  # Initially all propose to their top Rated preference!\n\n    # Initialize solution dictionary for all 3 solutions (reserves, matches, combined)\n    solution_reserves = {'cadets_solved_for': soc.upper() + ' Rated', 'afscs_solved_for': 'Rated',\n                         'method': 'Rated ' + soc.upper() + ' HR (Reserves)'}\n    solution_matches = {'cadets_solved_for': soc.upper() + ' Rated', 'afscs_solved_for': 'Rated',\n                        'method': 'Rated ' + soc.upper() + ' HR (Matches)'}\n    solution = {'cadets_solved_for': soc.upper() + ' Rated', 'afscs_solved_for': 'Rated',  # Combined Solution\n                'method': 'Rated ' + soc.upper() + ' HR'}\n\n    # Dictionary of parameters used for the \"BubbleChart\" object (animation)\n    if mdl_p['collect_solution_iterations']:\n        solution['iterations'] = {'type': 'Rated SOC HR'}\n        for key in ['proposals', 'matches', 'reserves', 'matched', 'names']:\n            solution['iterations'][key] = {}\n\n    # Begin the simple Hospital/Residents Algorithm\n    total_rejections = {j: 0 for j in rated_J}  # Number of rejections for each AFSC\n    total_matched = {j: 0 for j in rated_J}  # Number of accepted cadets for each AFSC\n    exhausted_cadets = []  # Will contain the cadets that have exhausted (been rejected by) all of their preferences\n    iteration = 0  # First iteration of the algorithm\n    while sum([total_matched[j] for j in rated_J]) + len(exhausted_cadets) &lt; N:  # Stopping conditions\n\n        # Cadets propose to their top choice that hasn't been rejected\n        proposals = {i: p['Rated Choices'][\n            soc][i][cadet_proposal_choice[i]] if i not in exhausted_cadets else p['M'] for i in cadets}\n        proposal_array = np.array([proposals[i] if i in cadets else p['M'] for i in p['I']])\n        counts = {p['afscs'][j]: len(np.where(proposal_array == j)[0]) for j in rated_J}\n\n        # Solution Iteration components (Proposals) and print statement\n        if mdl_p['collect_solution_iterations']:\n            solution['iterations']['proposals'][iteration] = proposal_array\n        if mdl_p['ma_printing']:\n            print(\"\\nIteration\", iteration + 1)\n\n        # Initialize matches information for this iteration\n        total_matched = {j: 0 for j in rated_J}\n\n        # AFSCs accept their best cadets and reject the others\n        for j in rated_J:\n\n            # Loop through their preferred cadets from top to bottom\n            iteration_rejections = 0\n            for i in p['afsc_preferences'][j]:\n                if i not in cadets:\n                    continue  # Other SOC (we don't care about them right now)\n\n                # If the cadet is proposing to this AFSC, we have two options\n                if proposals[i] == j:\n\n                    # We haven't hit capacity, so we accept this cadet\n                    if total_matched[j] &lt; total_slots[j]:\n                        total_matched[j] += 1\n\n                    # We're at capacity, so we reject this cadet\n                    else:\n\n                        # Essentially \"delete\" the preference from the cadet's list\n                        cadet_proposal_choice[i] += 1\n                        proposals[i] = p['M']  # index of the unmatched AFSC (*)\n\n                        # Collect additional information\n                        if mdl_p['ma_printing']:\n                            iteration_rejections += 1\n                            total_rejections[j] += 1\n\n        # Solution Iteration components\n        if mdl_p['collect_solution_iterations']:\n\n            # Rated matches from this iteration\n            solution['iterations']['matches'][iteration] = \\\n                np.array([proposals[i] if i in cadets else p['M'] for i in p['I']])\n            solution['iterations']['names'][iteration] = 'Iteration ' + str(iteration + 1)\n\n            # Collect information on this iteration's reserved slots and actual matched slots\n            reserves = np.zeros(p['N']).astype(int)\n            matches = np.zeros(p['N']).astype(int)\n            for i in p['I']:\n\n                # Default to unmatched\n                reserves[i], matches[i] = p['M'], p['M']\n                if i in cadets:\n                    if proposals[i] in rated_J:\n                        if first_choice[i] == proposals[i]:\n                            matches[i] = proposals[i]\n                        else:\n                            reserves[i] = proposals[i]\n\n            # Set of cadets with reserved or matched slots\n            solution['iterations']['matched'][iteration] = np.where(matches != p['M'])[0]\n            solution['iterations']['reserves'][iteration] = np.where(reserves != p['M'])[0]\n\n        # Specific matching algorithm print statement\n        if mdl_p['ma_printing']:\n            print('Proposals:', counts)\n            print('Matched', {p['afscs'][j]: total_matched[j] for j in rated_J})\n            print('Rejected', {p['afscs'][j]: total_rejections[j] for j in rated_J})\n\n        # Check exhausted cadets\n        exhausted_cadets = []\n        for i in cadets:\n            if cadet_proposal_choice[i] &gt;= p['Num Rated Choices'][soc][i]:\n                exhausted_cadets.append(i)\n\n        iteration += 1 # Next iteration!\n\n    # Last solution iteration\n    if mdl_p['collect_solution_iterations']:\n        solution['iterations']['last_s'] = iteration - 1\n\n    # Collect information on all 3 solutions: reserves, matches, and combined\n    solution_reserves['j_array'] = np.zeros(p['N']).astype(int)\n    solution_matches['j_array'] = np.zeros(p['N']).astype(int)\n    solution['j_array'] = np.zeros(p['N']).astype(int)\n    for i in p['I']:\n\n        # Default to unmatched\n        solution_matches['j_array'][i], solution_reserves['j_array'][i] = p['M'], p['M']\n        solution['j_array'][i] = p['M']\n        if i in cadets:\n            if proposals[i] in rated_J:\n                solution['j_array'][i] = proposals[i]\n                if first_choice[i] == proposals[i]:\n                    solution_matches['j_array'][i] = proposals[i]\n                else:\n                    solution_reserves['j_array'][i] = proposals[i]\n\n    # Add information to the solution matches and reserves components\n    solution['matches'] = np.where(solution_matches['j_array'] != p['M'])[0]\n    solution['reserves'] = np.where(solution_reserves['j_array'] != p['M'])[0]\n\n    # Return solution, reserved array, and solution iterations\n    return solution, solution_reserves, solution_matches\n</code></pre>"},{"location":"reference/solutions/algorithms/#solutions.algorithms.vft_genetic_algorithm","title":"<code>vft_genetic_algorithm(instance, initial_solutions=None, con_fail_dict=None, printing=False)</code>","text":"<p>Solves the optimization problem using a genetic algorithm.</p> <p>Parameters:     instance (CadetCareerProblem): An instance of the CadetCareerProblem class representing the optimization problem.     initial_solutions (ndarray or None): An optional array of initial solutions in the population. If provided, it         should be a numpy ndarray of shape (pop_size, N) where pop_size is the size of the population and N is the         number of cadets. Default is None.     con_fail_dict (dict or None): An optional dictionary containing information about constraints that failed for         the initial solutions. It should be a dictionary where the keys are the indices of the initial solutions         (0-based) and the values are lists of constraint indices that failed for that solution. Default is None.     printing (bool): A flag indicating whether to print status updates during the genetic algorithm execution.         Default is False.</p> <p>Returns:     tuple: A tuple containing the best solution and the time evaluation dataframe (if time evaluation is enabled).</p> <p>This function implements a genetic algorithm to solve the optimization problem defined by the CadetCareerProblem instance. The genetic algorithm works by iteratively evolving a population of candidate solutions through selection, crossover, and mutation operations. The fitness of each solution is evaluated using the Value-Focused Thinking (VFT) objective function.</p> <p>The genetic algorithm operates as follows: 1. Initialize the population: If initial_solutions are provided, they are used as the initial population. Otherwise,    a random population is generated. 2. Evaluate the fitness of each solution in the population using the VFT objective function. 3. Sort the population based on the fitness scores in descending order. 4. Create the next generation of solutions:    - The top two solutions (best fitness) from the current population are automatically included in the next generation.    - For the remaining solutions, select two parents based on their fitness scores using rank selection.    - Apply multi-point crossover to generate two offspring solutions from the selected parents.    - Perform mutation on the offspring solutions to introduce small random changes.    - Add the offspring solutions to the next generation. 5. Repeat steps 2-4 until the termination condition is met (e.g., maximum time limit).</p> <p>The best solution found during the genetic algorithm execution is returned as the output. If time evaluation is enabled, a time evaluation dataframe is also returned, containing the objective values at different time points during the algorithm execution.</p> <p>Example usage:     solution, time_eval_df = vft_genetic_algorithm(instance, initial_solutions, con_fail_dict, printing=True)</p> Source code in <code>afccp/solutions/algorithms.py</code> <pre><code>def vft_genetic_algorithm(instance, initial_solutions=None, con_fail_dict=None, printing=False):\n    \"\"\"\n    Solves the optimization problem using a genetic algorithm.\n\n    Parameters:\n        instance (CadetCareerProblem): An instance of the CadetCareerProblem class representing the optimization problem.\n        initial_solutions (ndarray or None): An optional array of initial solutions in the population. If provided, it\n            should be a numpy ndarray of shape (pop_size, N) where pop_size is the size of the population and N is the\n            number of cadets. Default is None.\n        con_fail_dict (dict or None): An optional dictionary containing information about constraints that failed for\n            the initial solutions. It should be a dictionary where the keys are the indices of the initial solutions\n            (0-based) and the values are lists of constraint indices that failed for that solution. Default is None.\n        printing (bool): A flag indicating whether to print status updates during the genetic algorithm execution.\n            Default is False.\n\n    Returns:\n        tuple: A tuple containing the best solution and the time evaluation dataframe (if time evaluation is enabled).\n\n    This function implements a genetic algorithm to solve the optimization problem defined by the CadetCareerProblem\n    instance. The genetic algorithm works by iteratively evolving a population of candidate solutions through selection,\n    crossover, and mutation operations. The fitness of each solution is evaluated using the Value-Focused Thinking (VFT)\n    objective function.\n\n    The genetic algorithm operates as follows:\n    1. Initialize the population: If initial_solutions are provided, they are used as the initial population. Otherwise,\n       a random population is generated.\n    2. Evaluate the fitness of each solution in the population using the VFT objective function.\n    3. Sort the population based on the fitness scores in descending order.\n    4. Create the next generation of solutions:\n       - The top two solutions (best fitness) from the current population are automatically included in the next generation.\n       - For the remaining solutions, select two parents based on their fitness scores using rank selection.\n       - Apply multi-point crossover to generate two offspring solutions from the selected parents.\n       - Perform mutation on the offspring solutions to introduce small random changes.\n       - Add the offspring solutions to the next generation.\n    5. Repeat steps 2-4 until the termination condition is met (e.g., maximum time limit).\n\n    The best solution found during the genetic algorithm execution is returned as the output. If time evaluation is\n    enabled, a time evaluation dataframe is also returned, containing the objective values at different time points\n    during the algorithm execution.\n\n    Example usage:\n        solution, time_eval_df = vft_genetic_algorithm(instance, initial_solutions, con_fail_dict, printing=True)\n    \"\"\"\n\n\n    def multi_point_crossover(genome1, genome2):\n        \"\"\"\n        Take two parent genomes, crossover the genes at multiple points and return two offspring solutions\n        :param genome1: first parent genome\n        :param genome2: second parent genome\n        :return: offspring\n        \"\"\"\n        points = np.sort(np.random.choice(crossover_positions, size=mp[\"num_crossover_points\"], replace=False))\n        start_points = np.append(0, points)\n        stop_points = np.append(points, p['N'] - 1)\n        child1 = np.zeros(p['N']).astype(int)\n        child2 = np.zeros(p['N']).astype(int)\n        flip = 1\n        for i in range(len(start_points)):\n            if flip == 1:\n                child1[start_points[i]:stop_points[i] + 1] = genome2[start_points[i]:stop_points[i] + 1]\n                child2[start_points[i]:stop_points[i] + 1] = genome1[start_points[i]:stop_points[i] + 1]\n            else:\n                child1[start_points[i]:stop_points[i] + 1] = genome1[start_points[i]:stop_points[i] + 1]\n                child2[start_points[i]:stop_points[i] + 1] = genome2[start_points[i]:stop_points[i] + 1]\n\n            flip = flip * -1\n\n        return child1, child2\n\n    def mutation(genome):\n        \"\"\"\n        Takes a genome, and picks a random cadet index to mutate with some probability.\n        This means we can swap an AFSC for one cadet individually\n        :param genome: solution vector\n        :return: mutated genome\n        \"\"\"\n        for _ in range(mp[\"num_mutations\"]):\n            i = np.random.choice(p['I^Variable'])  # Pick a random cadet that doesn't have a \"fixed\" AFSC\n\n            if mp['mutation_function'] == 'cadet_choice':\n\n                # Determine what set of AFSCs we can choose from (Coin flip on if we're going to select more preferred ones)\n                if np.random.uniform() &gt; mp['preference_mutation_rate']:\n\n                    # Current preference that the cadet received\n                    current_choice = p['c_pref_matrix'][i, genome[i]]\n\n                    # All AFSCs that are at least as preferred as current assigned\n                    possible_afscs = p['cadet_preferences'][i][:current_choice]\n\n                else:\n\n                    # All AFSCs that the cadet is eligible for\n                    possible_afscs = p['J^E'][i]\n            else:\n\n                # All AFSCs that the cadet is eligible for\n                possible_afscs = p['J^E'][i]\n\n            # Fix the possible AFSCs to select from if this cadet has a reserved Rated slot\n            if i in p['J^Reserved']:\n                possible_afscs = p['J^Reserved'][i]\n\n            # Pick a random AFSC\n            j = np.random.choice(possible_afscs)\n\n            # Mutate if applicable\n            genome[i] = j if (np.random.uniform() &lt; mp[\"mutation_rate\"]) else genome[i]\n\n        return genome\n\n    # Shorthand\n    p = instance.parameters\n    vp = instance.value_parameters\n    mp = instance.mdl_p\n\n    # Cadets that aren't \"fixed\" in the solution\n    p['I^Variable'] = np.array([i for i in p['I'] if i not in p['J^Fixed']])\n\n    # Rank Selection Parameters\n    rank_weights = (np.arange(1, mp[\"pop_size\"] + 1)[::-1]) ** 1.2\n    rank_weights = rank_weights / sum(rank_weights)\n    rank_choices = np.arange(mp[\"pop_size\"])\n\n    # Multi-Point Crossover Parameters\n    crossover_positions = np.arange(1, p['N'] - 1)\n\n    # Initialize Population\n    population = np.array([[np.random.choice(p['J^E'][i]) for i in p['I']] for _ in range(mp[\"pop_size\"])]).astype(int)\n    if initial_solutions is not None:\n\n        # Get fitness of initial_solutions in case there are feasibility issues or there are too many initial solutions\n        num_initial = len(initial_solutions)\n        fitness = np.zeros(num_initial)\n        for s, chromosome in enumerate(initial_solutions):\n            fitness[s] = afccp.solutions.handling.fitness_function(chromosome, p, vp, mp, con_fail_dict)\n\n        # Sort Initial solutions by Fitness\n        sorted_indices = fitness.argsort()[::-1]\n        initial_solutions = initial_solutions[sorted_indices]\n\n        # Insert these solutions into the population\n        for s, chromosome in enumerate(initial_solutions):\n\n            # Make sure there aren't too many initial solutions\n            if s &lt; mp[\"pop_size\"]:\n                population[s] = chromosome\n\n    # Initialize Fitness Scores\n    fitness = np.zeros(mp[\"pop_size\"])\n    for s, chromosome in enumerate(population):\n        fitness[s] = afccp.solutions.handling.fitness_function(chromosome, p, vp, mp, con_fail_dict)\n\n    # Sort Population by Fitness\n    sorted_indices = fitness.argsort()[::-1]\n    fitness = fitness[sorted_indices]\n    population = population[sorted_indices]\n\n    # Print updates\n    if mp[\"ga_printing\"]:\n        step = mp[\"ga_max_time\"] / (100 / mp[\"percent_step\"])\n        checkpoint = step\n        completed = 0\n        print('Initial Fitness Scores', fitness)\n\n    # Time Evaluation Initialization\n    if mp[\"time_eval\"]:\n        time_step = mp[\"ga_max_time\"] / mp[\"num_time_points\"]\n        step_num = 1\n        times = [0]\n        scores = [fitness[0]]\n\n    # Main Loop\n    start_time = time.perf_counter()\n    eval_times = []\n    gen_times = []\n    generating = True\n    generation = 1\n    while generating:\n\n        # Start time\n        gen_start_time = time.perf_counter()\n\n        # Evaluate Population\n        for index in range(2, mp[\"pop_size\"]):\n            fitness[index] = afccp.solutions.handling.fitness_function(population[index], p, vp, mp, con_fail_dict)\n        eval_times.append(time.perf_counter() - gen_start_time)\n\n        # Sort Population by Fitness\n        sorted_indices = fitness.argsort()[::-1]\n        fitness = fitness[sorted_indices]\n        population = population[sorted_indices]\n        best_score = fitness[0]\n\n        # Printing updates\n        if mp[\"ga_printing\"]:\n            if (time.perf_counter() - start_time) &gt; checkpoint:\n                completed += mp[\"percent_step\"]\n                checkpoint += step\n                print(str(completed) + \"% complete. Best solution value: \" + str(round(best_score, 4)))\n                avg_eval_time = np.mean(np.array(eval_times[0:generation]))\n                print('Average evaluation time for ' + str(mp[\"pop_size\"]) + ' solutions: ' +\n                      str(round(avg_eval_time, 4)) + ' seconds.')\n                avg_gen_time = np.mean(np.array(gen_times[0:generation]))\n                print('Average generation time: ' + str(round(avg_gen_time, 4)) + ' seconds.')\n\n        # Create next generation\n        next_generation = population[0:2]  # the best two solutions are kept for the next generation\n        for twins in range(int((mp[\"pop_size\"] / 2) - 1)):  # create the offspring\n\n            # Select parents for mating\n            index_1, index_2 = np.random.choice(rank_choices, size=2, replace=False, p=rank_weights)\n            parent_1, parent_2 = population[index_1], population[index_2]\n\n            # Apply crossover function\n            offspring_1, offspring_2 = multi_point_crossover(parent_1, parent_2)\n\n            # Mutate genomes of offspring\n            offspring_1 = mutation(offspring_1)\n            offspring_2 = mutation(offspring_2)\n\n            # Add this pair to the next generation\n            offsprings = np.vstack((offspring_1, offspring_2))\n            next_generation = np.vstack((next_generation, offsprings))\n\n        # Time Eval\n        if mp[\"time_eval\"]:\n            if (time.perf_counter() - start_time) &gt; (time_step * step_num):\n                times.append(time.perf_counter() - start_time)\n                scores.append(best_score)\n                step_num += 1\n\n        # Check stopping criteria\n        if (time.perf_counter() - start_time) &gt; mp[\"ga_max_time\"]:\n            if mp[\"ga_printing\"]:\n                end_time = round(time.perf_counter() - start_time, 2)\n                print('End time reached in ' + str(end_time) + ' seconds.')\n            generating = False\n\n        # Next Generation\n        population = next_generation\n        gen_times.append(time.perf_counter() - gen_start_time)\n        generation += 1\n\n    # Acquire solution dictionary for the top chromosome in the population\n    solution = {'method': 'VFT_Genetic', 'j_array': population[0]}\n\n    # Time Eval\n    if mp[\"time_eval\"]:\n\n        # Create time_eval_df\n        time_eval_df = pd.DataFrame({'Time': times, 'Objective Value': scores})\n\n        if printing:\n            print(time_eval_df)\n        return solution, time_eval_df\n\n    else:\n\n        # Return best solution\n        return solution, None\n</code></pre>"},{"location":"reference/solutions/algorithms/#solutions.algorithms.genetic_matching_algorithm","title":"<code>genetic_matching_algorithm(instance, printing=False)</code>","text":"<p>Genetic algorithm that determines optimal capacities to the classic deferred acceptance algorithm to minimize blocking pairs</p> <p>Parameters:     instance (CadetCareerProblem): An instance of the CadetCareerProblem class representing the optimization problem.     printing (bool): A flag indicating whether to print additional information during the algorithm execution.         Default is False.</p> <p>Returns:     ndarray: An array representing the optimal capacities determined by the genetic algorithm.</p> <p>This function implements a genetic algorithm to determine the optimal capacities for the classic deferred acceptance algorithm. The goal is to minimize the number of blocking pairs in the matching process.</p> <p>The genetic algorithm works as follows: 1. Initialize the population of capacities randomly. Each capacity is selected within the valid range for the    corresponding AFSC. 2. Evaluate the fitness of each capacity configuration using the classic deferred acceptance algorithm with the    given capacities. The fitness is determined by the number of blocking pairs in the resulting matching. 3. Sort the population based on fitness scores in descending order. 4. Create the next generation of capacities:    - The two best capacities (lowest fitness) from the current population are automatically included in the next      generation.    - For the remaining capacities, select two parents based on their fitness scores using rank selection.    - Apply multi-point crossover to generate two offspring capacities from the selected parents.    - Perform mutation on the offspring capacities to introduce small random changes.    - Add the offspring capacities to the next generation. 5. Repeat steps 2-4 until a termination condition is met (e.g., maximum time or number of generations).</p> <p>The best capacity configuration found during the genetic algorithm execution is returned as the output.</p> <p>Example usage:     optimal_capacities = genetic_matching_algorithm(instance, printing=True)</p> Source code in <code>afccp/solutions/algorithms.py</code> <pre><code>def genetic_matching_algorithm(instance, printing=False):\n    \"\"\"\n    Genetic algorithm that determines optimal capacities to the classic deferred acceptance algorithm to minimize\n    blocking pairs\n\n    Parameters:\n        instance (CadetCareerProblem): An instance of the CadetCareerProblem class representing the optimization problem.\n        printing (bool): A flag indicating whether to print additional information during the algorithm execution.\n            Default is False.\n\n    Returns:\n        ndarray: An array representing the optimal capacities determined by the genetic algorithm.\n\n    This function implements a genetic algorithm to determine the optimal capacities for the classic deferred acceptance\n    algorithm. The goal is to minimize the number of blocking pairs in the matching process.\n\n    The genetic algorithm works as follows:\n    1. Initialize the population of capacities randomly. Each capacity is selected within the valid range for the\n       corresponding AFSC.\n    2. Evaluate the fitness of each capacity configuration using the classic deferred acceptance algorithm with the\n       given capacities. The fitness is determined by the number of blocking pairs in the resulting matching.\n    3. Sort the population based on fitness scores in descending order.\n    4. Create the next generation of capacities:\n       - The two best capacities (lowest fitness) from the current population are automatically included in the next\n         generation.\n       - For the remaining capacities, select two parents based on their fitness scores using rank selection.\n       - Apply multi-point crossover to generate two offspring capacities from the selected parents.\n       - Perform mutation on the offspring capacities to introduce small random changes.\n       - Add the offspring capacities to the next generation.\n    5. Repeat steps 2-4 until a termination condition is met (e.g., maximum time or number of generations).\n\n    The best capacity configuration found during the genetic algorithm execution is returned as the output.\n\n    Example usage:\n        optimal_capacities = genetic_matching_algorithm(instance, printing=True)\n    \"\"\"\n\n\n    # Shorthand\n    p, vp, mdl_p = instance.parameters, instance.value_parameters, instance.mdl_p\n\n    # Define functions\n    def initialize_population():\n        \"\"\"\n        Function to initialize all the \"chromosomes\" for this GA\n        \"\"\"\n        population = np.array([np.zeros(p['M']) for _ in range(mdl_p['gma_pop_size'])])\n        for c in range(mdl_p['gma_pop_size']):\n            for j in p['J']:\n                capacity = int(random.choice(capacity_options[j]))\n                population[c, j] = capacity\n\n        return population\n\n    def fitness_function(chromosome):\n        \"\"\"\n        Evaluates the chromosome (capacities for HR)\n        \"\"\"\n\n        # Run the algorithm using these capacities\n        solution = classic_hr(instance, capacities=chromosome, printing=False)\n\n        # Evaluate blocking pairs\n        return afccp.solutions.handling.calculate_blocking_pairs(p, solution, only_return_count=True)\n\n    def multi_point_crossover(genome1, genome2):\n        \"\"\"\n        Take two parent genomes, crossover the genes at multiple points and return two offspring solutions\n        :param genome1: first parent genome\n        :param genome2: second parent genome\n        :return: offspring\n        \"\"\"\n        points = np.sort(np.random.choice(crossover_positions, size=mdl_p[\"gma_num_crossover_points\"], replace=False))\n        start_points = np.append(0, points)\n        stop_points = np.append(points, p['M'] - 1)\n        child1 = np.zeros(p['M']).astype(int)\n        child2 = np.zeros(p['M']).astype(int)\n        flip = 1\n        for i in range(len(start_points)):\n            if flip == 1:\n                child1[start_points[i]:stop_points[i] + 1] = genome2[start_points[i]:stop_points[i] + 1]\n                child2[start_points[i]:stop_points[i] + 1] = genome1[start_points[i]:stop_points[i] + 1]\n            else:\n                child1[start_points[i]:stop_points[i] + 1] = genome1[start_points[i]:stop_points[i] + 1]\n                child2[start_points[i]:stop_points[i] + 1] = genome2[start_points[i]:stop_points[i] + 1]\n\n            flip = flip * -1\n\n        return child1, child2\n\n    def mutation(genome):\n        \"\"\"\n        Takes a genome, and picks a random cadet index to mutate with some probability.\n        This means we can swap an AFSC for one cadet individually\n        :param genome: solution vector\n        :return: mutated genome\n        \"\"\"\n        for _ in range(mdl_p[\"gma_mutations\"]):\n            j = np.random.choice(p['J'])  # Random AFSC\n\n            # Pick random new capacity for AFSC j\n            min, max = p['quota_min'][j], p['quota_max'][j]\n            capacity_options = np.arange(min, max + 1).astype(int)\n            capacity = int(random.choice(capacity_options))\n            genome[j] = capacity if (np.random.uniform() &lt; mdl_p[\"gma_mutation_rate\"]) else genome[j]\n\n        return genome\n\n    # Determine range of capacities for all AFSCs\n    capacity_options = {}\n    for j in p['J']:\n        min, max = p['quota_min'][j], p['quota_max'][j]\n        capacity_options[j] = np.arange(min, max + 1).astype(int)\n\n    # Rank Selection Parameters\n    rank_weights = (np.arange(1, mdl_p[\"gma_pop_size\"] + 1)[::-1]) ** 1.2\n    rank_weights = rank_weights / sum(rank_weights)\n    rank_choices = np.arange(mdl_p[\"gma_pop_size\"])\n\n    # Multi-Point Crossover Parameters\n    crossover_positions = np.arange(1, p['M'] - 1)\n\n    # Initialize population\n    population = initialize_population()\n\n    # Initialize fitness scores\n    fitness = np.zeros(mdl_p['gma_pop_size'])\n    for c in range(mdl_p['gma_pop_size']):\n        fitness[c] = fitness_function(population[c])\n\n    # Sort Population by Fitness\n    sorted_indices = fitness.argsort()\n    fitness = fitness[sorted_indices]\n    population = population[sorted_indices]\n\n    # Main Loop\n    start_time = time.perf_counter()\n    generation = 0\n    generating = True\n    while generating:\n\n        # Evaluate population\n        for c in range(2, mdl_p['gma_pop_size']):\n            fitness[c] = fitness_function(population[c])\n\n        # Sort Population by Fitness\n        sorted_indices = fitness.argsort()\n        fitness = fitness[sorted_indices]\n        population = population[sorted_indices]\n\n        # Print statements\n        if mdl_p['gma_printing']:\n            print('Generation', generation, 'Fitness', fitness)\n\n        # Create next generation\n        next_generation = population[:2]  # the best two solutions are kept for the next generation\n        for twins in range(int((mdl_p[\"gma_pop_size\"] / 2) - 1)):  # create the offspring\n\n            # Select parents for mating\n            c1, c2 = np.random.choice(rank_choices, size=2, replace=False, p=rank_weights)\n            parent_1, parent_2 = population[c1], population[c2]\n\n            # Apply crossover function\n            offspring_1, offspring_2 = multi_point_crossover(parent_1, parent_2)\n\n            # Mutate genomes of offspring\n            offspring_1 = mutation(offspring_1)\n            offspring_2 = mutation(offspring_2)\n\n            # Add this pair to the next generation\n            offsprings = np.vstack((offspring_1, offspring_2))\n            next_generation = np.vstack((next_generation, offsprings))\n\n        # Next Generation\n        population = next_generation\n        generation += 1\n\n        # Stopping conditions\n        if mdl_p['stopping_conditions'] == 'Time':\n            if (time.perf_counter() - start_time) &gt; mdl_p['gma_max_time']:\n                generating = False\n        elif mdl_p['stopping_conditions'] == 'Generations':\n            if generation &gt;= mdl_p['gma_num_generations']:\n                generating = False\n\n        # We have no blocking pairs!\n        if fitness[0] == 0:\n            generating = False\n\n    if printing:\n        print(\"Final capacities:\", population[0])\n\n    # Return the capacities\n    return population[0]\n</code></pre>"},{"location":"reference/solutions/handling/","title":"Handling","text":""},{"location":"reference/solutions/handling/#solutions.handling","title":"<code>solutions.handling</code>","text":""},{"location":"reference/solutions/handling/#solutions.handling.evaluate_solution","title":"<code>evaluate_solution(solution, parameters, value_parameters, approximate=False, re_calculate_x=True, printing=False)</code>","text":"<p>Evaluate a solution (either a vector or a matrix) by calculating various metrics.</p> <p>Parameters:     solution (numpy.ndarray): The solution to evaluate, represented as a vector or a matrix.     parameters (dict): The fixed cadet/AFSC model parameters.     value_parameters (dict): The weight/value parameters.     approximate (bool, optional): Whether the solution is approximate or exact. Defaults to False.     re_calculate_x (bool, optional): If we want to force re-calculation of x as integer matrix. Defaults to True.     printing (bool, optional): Whether to print the evaluated metrics. Defaults to False.</p> <p>Returns:     solution (dict): A dictionary containing the solution core elements and evaluated metrics.</p> <p>Note:     This function evaluates a solution by calculating various metrics, including objective measures, objective values,     AFSC values, cadet values, constraint failures, overall values, and additional useful metrics.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def evaluate_solution(solution, parameters, value_parameters, approximate=False, re_calculate_x=True, printing=False):\n    \"\"\"\n    Evaluate a solution (either a vector or a matrix) by calculating various metrics.\n\n    Parameters:\n        solution (numpy.ndarray): The solution to evaluate, represented as a vector or a matrix.\n        parameters (dict): The fixed cadet/AFSC model parameters.\n        value_parameters (dict): The weight/value parameters.\n        approximate (bool, optional): Whether the solution is approximate or exact. Defaults to False.\n        re_calculate_x (bool, optional): If we want to force re-calculation of x as integer matrix. Defaults to True.\n        printing (bool, optional): Whether to print the evaluated metrics. Defaults to False.\n\n    Returns:\n        solution (dict): A dictionary containing the solution core elements and evaluated metrics.\n\n    Note:\n        This function evaluates a solution by calculating various metrics, including objective measures, objective values,\n        AFSC values, cadet values, constraint failures, overall values, and additional useful metrics.\n    \"\"\"\n\n    # Shorthand\n    p, vp = parameters, value_parameters\n\n    # Get X matrix\n    if 'x' not in solution or re_calculate_x:\n        solution['x'] = np.array([[1 if solution['j_array'][i] == j else 0 for j in p['J']] for i in p['I']])\n    x = solution['x']\n\n    # Initialize solution metrics to be added to solution dictionary\n    metrics = {'objective_measure': np.zeros([p['M'], vp['O']]),  # AFSC objective \"raw\" measure\n               'objective_value': np.ones([p['M'], vp['O']]),  # AFSC objective value determined through value function\n               'afsc_value': np.zeros(p['M']), 'cadet_value': np.zeros(p['N']),  # AFSC/Cadet Individual values\n               'cadet_constraint_fail': np.zeros(p['N']),  # 1-N binary array indicating cadet constraint failures\n               'afsc_constraint_fail': np.zeros(p['M']),  # 1-M binary array indicating AFSC constraint failures\n               'objective_score': np.zeros(vp['O']),  # \"Flipped\" score for the AFSC objective\n\n               # Constraint data metrics\n               'total_failed_constraints': 0, \"failed_constraints\": [],\n               'objective_constraint_fail': np.array([[\" \" * 30 for _ in range(vp['O'])] for _ in range(p['M'])]),\n               'con_fail_dict': {}  # Dictionary containing the new minimum/maximum value we need to adhere to\n               }\n    for key in metrics:\n        solution[key] = metrics[key]\n\n    # Loop through all AFSCs to assign their \"individual\" values\n    for j in p['J']:\n        afsc = p[\"afscs\"][j]\n\n        # Loop through all AFSC objectives\n        for k, objective in enumerate(vp[\"objectives\"]):\n\n            # Calculate AFSC objective measure\n            solution['objective_measure'][j, k], _ = calculate_objective_measure_matrix(\n                solution['x'], j, objective, p, vp, approximate=approximate)\n\n            # Calculate AFSC objective value\n            if k in vp[\"K^A\"][j]:\n                solution['objective_value'][j, k] = value_function(\n                    vp['a'][j][k], vp['f^hat'][j][k], vp['r'][j][k], solution['objective_measure'][j, k])\n\n            # Update metrics dictionary with failed AFSC objective constraint information\n            if k in vp['K^C'][j]:\n                solution = calculate_failed_constraint_metrics(j, k, solution, p, vp)\n\n        # AFSC individual value\n        solution['afsc_value'][j] = np.dot(vp['objective_weight'][j, :], solution['objective_value'][j, :])\n        if solution['afsc_value'][j] &lt; vp['afsc_value_min'][j]:\n            solution['afsc_constraint_fail'][j] = 1\n            solution['total_failed_constraints'] += 1\n            solution[\"failed_constraints\"].append(afsc + \" Value\")\n\n    # Set of cadets that have been matched to AFSCs\n    solution['I^Match'] = np.where(solution['j_array'] != p['M'])[0]\n    solution['Num Matched'] = len(solution['I^Match'])\n\n    # Loop through all cadets to assign their values\n    for i in p['I']:\n        solution['cadet_value'][i] = np.sum(x[i, j] * p['cadet_utility'][i, j] for j in p['J^E'][i])\n        if solution['cadet_value'][i] &lt; vp['cadet_value_min'][i]:\n            solution['cadet_constraint_fail'][i] = 1\n            solution['total_failed_constraints'] += 1\n            solution[\"failed_constraints\"].append(\"Cadet \" + str(p['cadets'][i]) + \" Value\")\n\n    # Variables used to help verify that cadets are receiving the AFSCs they need to if specified\n    num_fixed_correctly = 0\n    num_reserved_correctly = 0\n\n    # Get the AFSC solution (Modified to support \"unmatched\" cadets)\n    solution[\"num_unmatched\"] = 0\n    solution['afsc_array'] = np.array([\" \" * 10 for _ in p['I']])\n    for i in p['I']:\n        j = np.where(x[i, :])[0]\n        if len(j) != 0:\n            j = int(j[0])\n        else:\n            solution[\"num_unmatched\"] += 1\n            j = p['M']  # Last index (*)\n        solution['afsc_array'][i] = p['afscs'][j]\n\n        # Check if this AFSC was \"fixed\" for this cadet\n        if i in p['J^Fixed']:\n            if j == p['J^Fixed'][i]:\n                num_fixed_correctly += 1\n\n        # Check if this AFSC was reserved for this cadet\n        if i in p['J^Reserved']:\n            if j in p['J^Reserved'][i]:\n                num_reserved_correctly += 1\n\n    # Alternate list situation\n    if 'J^Preferred [usafa]' in p:\n        solution['num_alternates_allowed'] = 0  # Number of cadets on alternate lists\n        solution['num_successful_alternates'] = 0  # Number of cadets on alternate lists that don't form blocking pairs\n\n        # Loop through each SOC and rated AFSC\n        for soc in p['SOCs']:\n\n            # Did we not run the algorithm for this specific SOC?\n            if f'J^Preferred [{soc}]' not in p:\n                continue\n\n            # Loop through each rated AFSC\n            for j in p['J^Rated']:\n\n                # Loop through each cadet on this SOC's rated AFSC's list\n                for i in p['I^Alternate [' + soc + ']'][j]:\n                    solution['num_alternates_allowed'] += 1\n\n                    # Check the blocking pair constraint for this rated AFSC and cadet pair\n                    not_blocking_pair = p[soc + '_quota'][j] * (1 - np.sum(\n                        x[i, j_p] for j_p in p['J^Preferred [' + soc + ']'][j][i])) &lt;= np.sum(\n                        x[i_p, j] for i_p in p['I^Preferred [' + soc + ']'][j][i])\n                    if not_blocking_pair:\n                        solution['num_successful_alternates'] += 1\n\n        solution['alternate_list_metric'] = str(solution['num_successful_alternates']) + \" / \" + \\\n                                            str(solution['num_alternates_allowed'])\n\n    else:\n        solution['alternate_list_metric'] = \"0 / 0\"  # Not applicable here\n\n    # Verification that AFSCs are being assigned properly to work with J^Fixed and J^Reserved\n    num_fixed_needed = len(p['J^Fixed'].keys())\n    num_reserved_needed = len(p['J^Reserved'].keys())\n    solution['cadets_fixed_correctly'] = str(num_fixed_needed) + ' / ' + str(num_fixed_needed)\n    solution['cadets_reserved_correctly'] = str(num_reserved_correctly) + ' / ' + str(num_reserved_needed)\n\n    # Define overall metrics\n    solution['cadets_overall_value'] = np.dot(vp['cadet_weight'][solution['I^Match']],\n                                              solution['cadet_value'][solution['I^Match']])\n    solution['afscs_overall_value'] = np.dot(vp['afsc_weight'], solution['afsc_value'])\n    solution['z'] = vp['cadets_overall_weight'] * solution['cadets_overall_value'] + \\\n                   vp['afscs_overall_weight'] * solution['afscs_overall_value']\n    solution['num_ineligible'] = np.sum(x[i, j] * p['ineligible'][i, j] for j in p['J'] for i in solution['I^Match'])\n\n    # Add additional metrics components (Non-VFT stuff)\n    solution = calculate_additional_useful_metrics(solution, p, vp)\n\n    # Add base/training components if applicable\n    if 'base_array' in solution:\n        solution = calculate_base_training_metrics(solution, p, vp)\n\n    # Add Castle solution metrics\n    if 'castle_q' in p:\n        solution = calculate_castle_solution_metrics(solution, p)\n\n    if 'ots' in p['SOCs']:\n        solution = calculate_ots_specific_metrics(solution, p)\n\n    # Calculate blocking pairs\n    if 'a_pref_matrix' in p:\n        solution['blocking_pairs'] = calculate_blocking_pairs(p, solution)\n        solution['num_blocking_pairs'] = len(solution['blocking_pairs'])\n\n    # Print statement\n    if printing:\n        if approximate:\n            model_type = 'approximate'\n        else:\n            model_type = 'exact'\n        if 'name' in solution:\n            print_str = \"Solution Evaluated: \" + solution['name'] + \".\"\n        else:\n            print_str = \"New Solution Evaluated.\"\n        print_str += \"\\nMeasured \" + model_type + \" VFT objective value: \" + str(round(solution['z'], 4))\n        if 'z^gu' in solution:\n            print_str += \".\\nGlobal Utility Score: \" + str(round(solution['z^gu'], 4))\n        print_str += \". \" + solution['cadets_fixed_correctly'] + ' AFSCs fixed. ' + \\\n                     solution['cadets_reserved_correctly'] + ' AFSCs reserved'\n        print_str += \". \" + solution['alternate_list_metric'] + ' alternate list scenarios respected'\n        if 'z^CASTLE' in solution:\n            print_str += f\".\\nCASTLE GUO Score: {solution['z^CASTLE']}. \" \\\n                         f\"Value Curve Score: {solution['z^CASTLE (Values)']}\"\n        if 'num_blocking_pairs' in solution:\n            print_str += \".\\nBlocking pairs: \" + str(solution['num_blocking_pairs'])\n        print_str += \". Unmatched cadets: \" + str(solution[\"num_unmatched\"])\n        print_str += f\".\\nMatched cadets: {solution['Num Matched']}/{p['N']}. N^Match: {p['N^Match']}\"\n        print_str += \". Ineligible cadets: \" + str(solution['num_ineligible']) + \".\\n\"\n        if 'matched_out_of_must_match' in solution:\n            print_str += f'{solution[\"matched_out_of_must_match\"]} OTS \"must-matches\" accessed.\\n'\n        if 'ots' in p['SOCs']:\n            print_str += f'OTS Average Merit: {solution[\"OTS Average Merit\"]}. ' \\\n                         f'{solution[\"OTS Selected Pref Count\"]} / {len(solution[\"I^Match-OTS\"])} ' \\\n                         f'OTS candidates received AFSC they selected.'\n        print(print_str)\n\n    # Return the solution/metrics\n    return solution\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.fitness_function","title":"<code>fitness_function(chromosome, p, vp, mp, con_fail_dict=None)</code>","text":"<p>Evaluates a chromosome (solution vector) and returns its fitness score.</p> <p>Parameters:     chromosome (array-like): The chromosome representing the solution vector.     p (dict): Parameters used in the calculations.     vp (dict): Value parameters used in the calculations.     mp (dict): Model parameters.     con_fail_dict (dict, optional): Dictionary to store failed constraints for efficient evaluation.                                     Defaults to None.</p> <p>Returns:     fitness_score (float): The fitness score of the chromosome.</p> <p>Note:     This function is relatively time-consuming and should be as efficient as possible.     The fitness score is calculated based on the provided chromosome and parameters.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def fitness_function(chromosome, p, vp, mp, con_fail_dict=None):\n    \"\"\"\n    Evaluates a chromosome (solution vector) and returns its fitness score.\n\n    Parameters:\n        chromosome (array-like): The chromosome representing the solution vector.\n        p (dict): Parameters used in the calculations.\n        vp (dict): Value parameters used in the calculations.\n        mp (dict): Model parameters.\n        con_fail_dict (dict, optional): Dictionary to store failed constraints for efficient evaluation.\n                                        Defaults to None.\n\n    Returns:\n        fitness_score (float): The fitness score of the chromosome.\n\n    Note:\n        This function is relatively time-consuming and should be as efficient as possible.\n        The fitness score is calculated based on the provided chromosome and parameters.\n    \"\"\"\n\n    # 5% cap on total percentage of USAFA cadets allowed into certain AFSCs\n    if vp[\"J^USAFA\"] is not None:\n\n        # This is a pretty arbitrary constraint and will only be used for real class years (but has since been removed)\n        cap = 0.05 * mp[\"real_usafa_n\"]\n        u_count = 0\n        for j in vp[\"J^USAFA\"]:\n            cadets = np.where(chromosome == j)[0]\n            usafa_cadets = np.intersect1d(p['I^D']['USAFA Proportion'][j], cadets)\n            u_count += len(usafa_cadets)\n\n        # If we fail this constraint, we return an objective value of 0\n        if u_count &gt; int(cap + 1):\n            return 0\n\n    # Calculate AFSC individual values\n    afsc_value = np.zeros(p['M'])\n    for j in p['J']:\n\n        # Initialize objective measures and values\n        measure = np.zeros(vp['O'])\n        value = np.zeros(vp['O'])\n\n        # Indices of cadets assigned to this AFSC\n        cadets = np.where(chromosome == j)[0]\n\n        # Only calculate measures for AFSCs with at least one cadet\n        count = len(cadets)\n        if count &gt; 0:\n\n            # Loop through all AFSC objectives\n            for k in vp[\"K\"]:\n\n                # If this AFSC is constraining this objective or only has it in the objective function\n                if k in vp[\"K^A\"][j]:\n\n                    # Calculate AFSC objective measure\n                    measure[k] = calculate_objective_measure_chromosome(cadets, j, vp['objectives'][k], p, vp, count)\n\n                    # Assign AFSC objective value\n                    value[k] = value_function(vp['a'][j][k], vp['f^hat'][j][k], vp['r'][j][k], measure[k])\n\n                    # Check failed AFSC objective\n                    if k in vp['K^C'][j]:\n                        if check_failed_constraint_chromosome(j, k, measure[k], count, p, vp, con_fail_dict):\n                            return 0\n\n            # Calculate AFSC value\n            afsc_value[j] = np.dot(vp['objective_weight'][j, :], value)\n            if j in vp['J^C']:\n\n                # If we fail this constraint, we return an objective value of 0\n                if afsc_value[j] &lt; vp['afsc_value_min'][j]:\n                    return 0\n\n        # No cadets assigned to the AFSC means it failed\n        else:\n            return 0\n\n    # Calculate Cadet Value\n    cadet_value = np.array([p['cadet_utility'][i, int(chromosome[i])] for i in p['I']])\n    for i in vp['I^C']:\n\n        # If we fail this constraint, we return an objective value of 0\n        if cadet_value[i] &lt; vp['cadet_value_min'][i]:\n            return 0\n\n    # Return fitness value\n    return vp['cadets_overall_weight'] * np.dot(vp['cadet_weight'], cadet_value) + \\\n           vp['afscs_overall_weight'] * np.dot(vp['afsc_weight'], afsc_value)\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_blocking_pairs","title":"<code>calculate_blocking_pairs(parameters, solution, only_return_count=False)</code>","text":"<p>Calculate blocking pairs in a given solution.</p> <p>Parameters: - parameters (dict): The parameters of the matching problem. - solution (dict): The current matching solution. - only_return_count (bool): If True, return the count of blocking pairs; if False,   return the list of blocking pairs.</p> <p>Returns: - blocking_pairs (list or int): A list of blocking pairs (or count of blocking pairs).</p> <p>Description: This function calculates the blocking pairs in a given matching solution based on the stable matching community's definition. A blocking pair consists of an unmatched cadet and a more preferred AFSC that is also unmatched or assigned to a cadet with lower preference.</p> <p>Parameters Dictionary Structure: - 'cadet_preferences': An array representing cadet preferences. - 'a_pref_matrix': A matrix of AFSC preferences. - 'J': The set of all AFSCs. - 'M': A special symbol representing an unmatched cadet.</p> <p>Solution Dictionary Structure: - 'j_array': An array representing the assignment of AFSCs to cadets.</p> <p>Dependencies: - NumPy</p> <p>Reference: - Gale, D., &amp; Shapley, L. S. (1962). College Admissions and the Stability of   Marriage. American Mathematical Monthly, 69(1), 9-15.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_blocking_pairs(parameters, solution, only_return_count=False):\n    \"\"\"\n    Calculate blocking pairs in a given solution.\n\n    Parameters:\n    - parameters (dict): The parameters of the matching problem.\n    - solution (dict): The current matching solution.\n    - only_return_count (bool): If True, return the count of blocking pairs; if False,\n      return the list of blocking pairs.\n\n    Returns:\n    - blocking_pairs (list or int): A list of blocking pairs (or count of blocking pairs).\n\n    Description:\n    This function calculates the blocking pairs in a given matching solution based on\n    the stable matching community's definition. A blocking pair consists of an unmatched\n    cadet and a more preferred AFSC that is also unmatched or assigned to a cadet with\n    lower preference.\n\n    Parameters Dictionary Structure:\n    - 'cadet_preferences': An array representing cadet preferences.\n    - 'a_pref_matrix': A matrix of AFSC preferences.\n    - 'J': The set of all AFSCs.\n    - 'M': A special symbol representing an unmatched cadet.\n\n    Solution Dictionary Structure:\n    - 'j_array': An array representing the assignment of AFSCs to cadets.\n\n    Dependencies:\n    - NumPy\n\n    Reference:\n    - Gale, D., &amp; Shapley, L. S. (1962). College Admissions and the Stability of\n      Marriage. American Mathematical Monthly, 69(1), 9-15.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Dictionary of cadets matched to each AFSC in this solution\n    cadets_matched = {j: np.where(solution['j_array'] == j)[0] for j in p['J']}\n\n    # Loop through all cadets and their assigned AFSCs\n    blocking_pairs = []\n    blocking_pair_count = 0\n\n    # Loop through each cadet, AFSC pair\n    for i, j in enumerate(solution['j_array']):\n\n        # Unmatched cadets are blocking pairs by definition\n        if j == p['M']:\n            if only_return_count:\n                blocking_pair_count += 1\n            else:\n                blocking_pairs.append((i, j))\n                blocking_pair_count += 1\n\n        # Matched cadets need to be calculated\n        else:\n            cadet_choice = np.where(p['cadet_preferences'][i] == j)[0][0]\n\n            # Loop through more desirable AFSCs than current matched\n            for j_compare in p['cadet_preferences'][i][:cadet_choice]:\n\n                # Where is this cadet ranked in the AFSC list?\n                afsc_choice_of_this_cadet = p['a_pref_matrix'][i, j_compare]\n                matched_cadet_ranks = p['a_pref_matrix'][cadets_matched[j_compare], j_compare]\n\n                # No one has been assigned to this more desirable AFSC (another blocking pair situation)\n                if len(matched_cadet_ranks) == 0:\n                    if only_return_count:\n                        blocking_pair_count += 1\n                    else:\n                        blocking_pairs.append((i, j_compare))\n                        blocking_pair_count += 1\n                    break\n\n                # The lowest rank of the assigned cadet\n                afsc_choice_of_worst_cadet = np.max(matched_cadet_ranks)\n\n                # Check for blocking pairs\n                if afsc_choice_of_this_cadet &lt; afsc_choice_of_worst_cadet:\n                    if only_return_count:\n                        blocking_pair_count += 1\n                    else:\n                        blocking_pairs.append((i, j_compare))\n                        blocking_pair_count += 1\n                    break\n\n    if only_return_count:\n        return blocking_pair_count\n    else:\n        return blocking_pairs\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.value_function","title":"<code>value_function(a, f_a, r, x)</code>","text":"<p>Calculates the AFSC objective value based on the provided parameters.</p> <p>Parameters:     a (array-like): Measure at each breakpoint.     f_a (array-like): Value at each breakpoint.     r (int): Number of breakpoints.     x (float): Actual AFSC objective measure.</p> <p>Returns:     value (float): AFSC objective value.</p> <p>Note:     This function finds the appropriate breakpoint based on the measure and calculates the objective value     using linear interpolation.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def value_function(a, f_a, r, x):\n    \"\"\"\n    Calculates the AFSC objective value based on the provided parameters.\n\n    Parameters:\n        a (array-like): Measure at each breakpoint.\n        f_a (array-like): Value at each breakpoint.\n        r (int): Number of breakpoints.\n        x (float): Actual AFSC objective measure.\n\n    Returns:\n        value (float): AFSC objective value.\n\n    Note:\n        This function finds the appropriate breakpoint based on the measure and calculates the objective value\n        using linear interpolation.\n    \"\"\"\n    # Find which breakpoint is immediately before this measure\n    indices = np.array([a[l] &lt;= x &lt;= a[l + 1] for l in range(r - 1)]) * 1\n    l = np.where(indices)[0]\n\n    # Obtain value\n    if len(l) == 0:\n        l = r - 1\n        val = f_a[l]\n    else:\n        l = l[0]\n        val = f_a[l + 1] - ((f_a[l + 1] - f_a[l]) / (a[l + 1] - a[l])) * (a[l + 1] - x)\n\n    # Return value\n    return val\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.value_function_points","title":"<code>value_function_points(a, fhat)</code>","text":"<p>Takes the linear function parameters and returns the approximately non-linear coordinates</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <p>function breakpoints</p> required <code>fhat</code> <p>function breakpoint values</p> required <p>Returns:</p> Type Description <p>x, y</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def value_function_points(a, fhat):\n    \"\"\"\n    Takes the linear function parameters and returns the approximately non-linear coordinates\n    :param a: function breakpoints\n    :param fhat: function breakpoint values\n    :return: x, y\n    \"\"\"\n    x = (np.arange(1001) / 1000) * a[len(a) - 1]\n    y = np.array([value_function(a, fhat, len(a), i) for i in x])\n    return x, y\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_afsc_norm_score","title":"<code>calculate_afsc_norm_score(cadets, j, p, count=None)</code>","text":"<p>Calculate the Normalized Score for an AFSC assignment.</p> <p>Parameters: - cadets (list or numpy.ndarray): A list of cadets assigned to the AFSC. - j (int): The index of the AFSC for which the score is calculated. - p (dict): The problem parameters including preferences and AFSC data. - count (int, optional): The number of cadets assigned to the AFSC. If not provided,   it is calculated from the length of the 'cadets' list.</p> <p>Returns: - norm_score (float): The normalized score for the AFSC assignment, ranging from 0 to 1.</p> <p>Description: This function calculates the normalized score for an assignment of cadets to an AFSC. The score reflects how well the cadets are matched to their preferences for the given AFSC. A higher score indicates a better match, while a lower score suggests a less favorable assignment.</p> <p>The calculation involves comparing the achieved score (sum of cadet preferences) to the best and worst possible scores for the AFSC assignment. The result is then normalized to a range between 0 and 1, with 1 being the best possible score and 0 being the worst.</p> <p>Parameters Dictionary Structure: - 'a_pref_matrix': A matrix of AFSC preferences. - 'num_eligible': A dictionary with the number of eligible cadets for each AFSC.</p> <p>Dependencies: - NumPy</p> <p>Returns: - norm_score (float): The normalized score for the AFSC assignment, ranging from 0 to 1.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_afsc_norm_score(cadets, j, p, count=None):\n    \"\"\"\n    Calculate the Normalized Score for an AFSC assignment.\n\n    Parameters:\n    - cadets (list or numpy.ndarray): A list of cadets assigned to the AFSC.\n    - j (int): The index of the AFSC for which the score is calculated.\n    - p (dict): The problem parameters including preferences and AFSC data.\n    - count (int, optional): The number of cadets assigned to the AFSC. If not provided,\n      it is calculated from the length of the 'cadets' list.\n\n    Returns:\n    - norm_score (float): The normalized score for the AFSC assignment, ranging from 0 to 1.\n\n    Description:\n    This function calculates the normalized score for an assignment of cadets to an AFSC.\n    The score reflects how well the cadets are matched to their preferences for the given AFSC.\n    A higher score indicates a better match, while a lower score suggests a less favorable assignment.\n\n    The calculation involves comparing the achieved score (sum of cadet preferences) to the\n    best and worst possible scores for the AFSC assignment. The result is then normalized to\n    a range between 0 and 1, with 1 being the best possible score and 0 being the worst.\n\n    Parameters Dictionary Structure:\n    - 'a_pref_matrix': A matrix of AFSC preferences.\n    - 'num_eligible': A dictionary with the number of eligible cadets for each AFSC.\n\n    Dependencies:\n    - NumPy\n\n    Returns:\n    - norm_score (float): The normalized score for the AFSC assignment, ranging from 0 to 1.\n    \"\"\"\n\n    # Re-calculate count if necessary\n    if count is None:\n        count = len(cadets)\n\n    # Best score sum we could achieve\n    best_sum = np.sum(c for c in range(count))\n\n    # Worst score sum we could receive\n    worst_range = range(p[\"num_eligible\"][j] - count, p[\"num_eligible\"][j])\n    worst_sum = np.sum(c for c in worst_range)\n\n    # Score sum we did receive\n    achieved_sum = np.sum(p[\"a_pref_matrix\"][cadets, j])\n\n    # Normalize this score and return it\n    return 1 - (achieved_sum - best_sum) / (worst_sum - best_sum)\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_afsc_norm_score_general","title":"<code>calculate_afsc_norm_score_general(ranks, achieved_ranks)</code>","text":"<p>Calculate the Normalized Score for an AFSC assignment using custom ranks.</p> <p>Parameters: - ranks (numpy.ndarray): An array containing the preference ranks for eligible cadets   for the specific AFSC. - achieved_ranks (numpy.ndarray): An array of achieved ranks, indicating the ranks   at which cadets were assigned to the AFSC.</p> <p>Returns: - norm_score (float): The normalized score for the AFSC assignment, ranging from 0 to 1.</p> <p>Description: This function calculates the normalized score for an assignment of cadets to an AFSC. The score reflects how well the cadets are matched to their preferences for the given AFSC. A higher score indicates a better match, while a lower score suggests a less favorable assignment.</p> <p>The calculation involves comparing the achieved ranks of cadets to the best and worst possible ranks for the AFSC assignment. The result is then normalized to a range between 0 and 1, with 1 being the best possible score and 0 being the worst.</p> <p>Dependencies: - NumPy</p> <p>Returns: - norm_score (float): The normalized score for the AFSC assignment, ranging from 0 to 1.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_afsc_norm_score_general(ranks, achieved_ranks):\n    \"\"\"\n    Calculate the Normalized Score for an AFSC assignment using custom ranks.\n\n    Parameters:\n    - ranks (numpy.ndarray): An array containing the preference ranks for eligible cadets\n      for the specific AFSC.\n    - achieved_ranks (numpy.ndarray): An array of achieved ranks, indicating the ranks\n      at which cadets were assigned to the AFSC.\n\n    Returns:\n    - norm_score (float): The normalized score for the AFSC assignment, ranging from 0 to 1.\n\n    Description:\n    This function calculates the normalized score for an assignment of cadets to an AFSC.\n    The score reflects how well the cadets are matched to their preferences for the given AFSC.\n    A higher score indicates a better match, while a lower score suggests a less favorable assignment.\n\n    The calculation involves comparing the achieved ranks of cadets to the best and worst possible ranks\n    for the AFSC assignment. The result is then normalized to a range between 0 and 1, with 1 being the\n    best possible score and 0 being the worst.\n\n    Dependencies:\n    - NumPy\n\n    Returns:\n    - norm_score (float): The normalized score for the AFSC assignment, ranging from 0 to 1.\n    \"\"\"\n    # Number of cadets assigned here\n    count = len(achieved_ranks)\n\n    # Only consider eligible cadets\n    eligible_indices = np.where(ranks != 0)[0]\n    eligible_ranks = ranks[eligible_indices]\n\n    # Determine the best and worst set of rankings in this list\n    worst_indices = np.argsort(eligible_ranks)[-count:][::-1]\n    worst_ranks = eligible_ranks[worst_indices]\n    best_indices = np.argsort(eligible_ranks)[:count]\n    best_ranks = eligible_ranks[best_indices]\n\n    # Calculate the sums\n    best_sum, achieved_sum, worst_sum = np.sum(best_ranks), np.sum(achieved_ranks), np.sum(worst_ranks)\n\n    # Normalize this score and return it\n    return 1 - (achieved_sum - best_sum) / (worst_sum - best_sum)\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_additional_useful_metrics","title":"<code>calculate_additional_useful_metrics(solution, p, vp)</code>","text":"<p>Add additional components to the \"metrics\" dictionary based on the parameters and value parameters.</p> <p>Parameters:     solution (dict): The dictionary containing the existing metrics.     p (dict): The parameters dictionary.     vp (dict): The value parameters dictionary.</p> <p>Returns:     solution (dict): The updated metrics dictionary.</p> <p>Note:     This function adds additional components to the \"solution\" dictionary based on the provided parameters     and value parameters. The purpose is to enhance the information and analysis of the solution/metrics.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_additional_useful_metrics(solution, p, vp):\n    \"\"\"\n    Add additional components to the \"metrics\" dictionary based on the parameters and value parameters.\n\n    Parameters:\n        solution (dict): The dictionary containing the existing metrics.\n        p (dict): The parameters dictionary.\n        vp (dict): The value parameters dictionary.\n\n    Returns:\n        solution (dict): The updated metrics dictionary.\n\n    Note:\n        This function adds additional components to the \"solution\" dictionary based on the provided parameters\n        and value parameters. The purpose is to enhance the information and analysis of the solution/metrics.\n    \"\"\"\n\n    # Only calculate these metrics if we have the right parameters\n    if 'c_pref_matrix' in p and 'a_pref_matrix' in p:\n\n        # Calculate various metrics achieved\n        solution['cadet_choice'] = np.zeros(p[\"N\"]).astype(int)\n        solution['afsc_choice'] = np.zeros(p['N']).astype(int)\n        solution['cadet_utility_achieved'] = np.zeros(p['N'])\n        solution['afsc_utility_achieved'] = np.zeros(p['N'])\n        solution['global_utility_achieved'] = np.zeros(p['N'])\n        for i, j in enumerate(solution['j_array']):\n            if j in p['J']:\n                solution['cadet_choice'][i] = p['c_pref_matrix'][i, j]  # Assigned cadet choice\n\n                # Cadet is not in the AFSC's preferences\n                if i not in p['afsc_preferences'][j]:\n                    print('Cadet', i, 'not in ' + p['afscs'][j] + \"'s preferences. This will cause an error.\")\n                    continue\n                solution['afsc_choice'][i] = np.where(p['afsc_preferences'][j] == i)[0][0] + 1  # Where is the cadet ranked\n                solution['cadet_utility_achieved'][i] = p['cadet_utility'][i, j]\n                solution['afsc_utility_achieved'][i] = p['afsc_utility'][i, j]\n                solution['global_utility_achieved'][i] = vp['global_utility'][i, j]\n            else:\n                solution['cadet_choice'][i] = np.max(p['c_pref_matrix'][i, :]) + 1  # Unassigned cadet choice\n        solution['average_cadet_choice'] = round(np.mean(solution['cadet_choice'][solution['I^Match']]), 2)\n\n        # Calculate average cadet choice for each AFSC individually\n        solution['afsc_average_cadet_choice'] = np.zeros(p['M'])\n        for j in p['J']:\n            cadets = np.where(solution['j_array'] == j)[0]\n            solution['afsc_average_cadet_choice'][j] = np.mean(p['c_pref_matrix'][cadets, j])\n\n        # Calculate overall utility scores\n        solution['z^gu'] = round(np.mean(solution['global_utility_achieved'][solution['I^Match']]), 4)\n        solution['cadet_utility_overall'] = round(np.mean(solution['cadet_utility_achieved'][solution['I^Match']]), 4)\n        solution['afsc_utility_overall'] = round(np.mean(solution['afsc_utility_achieved'][solution['I^Match']]), 4)\n\n        # Calculate cadet utility based on SOC\n        for soc in p['SOCs']:\n            solution[f'{soc}_cadet_utility'] = round(np.mean(solution['cadet_utility_achieved'][p[f'{soc}_cadets']]), 4)\n\n    # Cadet Choice Counts (For exporting solution file to excel)\n    solution['cadet_choice_counts'] = {}\n    for choice in np.arange(1, 11):  # Just looking at top 10\n        choice_cadets = np.where(solution['cadet_choice'] == choice)[0]\n        solution['cadet_choice_counts'][choice] = len(np.intersect1d(choice_cadets, solution['I^Match']))\n    solution['cadet_choice_counts']['All Others'] = int(solution['Num Matched'] - sum(\n        [solution['cadet_choice_counts'][choice] for choice in np.arange(1, 11)]))\n\n    # Save the counts for each AFSC separately from the objective_measure matrix\n    quota_k = np.where(vp['objectives'] == 'Combined Quota')[0][0]\n    solution['count'] = solution['objective_measure'][:, quota_k]\n\n    # Assigned cadets\n    solution['cadets_assigned'] = {j: np.where(solution['j_array'] == j)[0] for j in p['J']}\n\n    # Cadets assigned to each accession group\n    con_acc_grp_numerator = 0\n    con_acc_grp_denominator = 0\n    for acc_grp in p['afscs_acc_grp']:\n        solution['I^' + acc_grp] = np.array([i for i in p['I'] if solution['j_array'][i] in p['J^' + acc_grp]])\n\n        # Determine if we constrained Accessions groups properly\n        if \"I^\" + acc_grp in p:\n            acc_grp_constrained = len(p['I^' + acc_grp])\n\n            # Calculate metrics if we actually constrained some people from this group\n            if acc_grp_constrained &gt; 0:\n                acc_grp_correct = len(np.intersect1d(p['I^' + acc_grp], solution['I^' + acc_grp]))\n                con_acc_grp_numerator += acc_grp_correct\n                con_acc_grp_denominator += acc_grp_constrained\n    solution['constrained_acc_grp_target'] = str(con_acc_grp_numerator) + \" / \" + str(con_acc_grp_denominator)\n\n    # Air Force Cadets\n    if 'USSF' in p['afscs_acc_grp']:\n        solution['I^USAF'] = np.array([i for i in p['I'] if i not in solution['I^USSF']])\n\n    # Calculate USSF Merit Distribution\n    solution['ussf_om'] = 0  # Just to have something to show\n    if 'USSF' in p['afscs_acc_grp']:\n\n        # Necessary variables to calculate\n        ussf_merit_sum = np.sum(np.sum(p['merit'][i] * solution['x'][i, j] for i in p['I^E'][j]) for j in p['J^USSF'])\n        ussf_sum = np.sum(np.sum(solution['x'][i, j] for i in p['I^E'][j]) for j in p['J^USSF'])\n\n        # Calculate metric\n        solution['ussf_om'] = round(ussf_merit_sum / ussf_sum, 3)\n\n        # USSF/USAF cadet distinctions\n        solution['ussf_cadets'] = np.array([i for i in p['I'] if solution['j_array'][i] in p['J^USSF']])\n        solution['usaf_cadets'] = np.array([i for i in p['I'] if solution['j_array'][i] not in p['J^USSF']])\n\n        # Calculate cadet/AFSC utility relative to USSF/USAF cadets\n        for service in ['ussf', 'usaf']:\n            for entity in ['cadet', 'afsc']:\n\n                if len(solution[service + '_cadets']) &gt; 0:\n                    solution[service + '_' + entity + '_utility'] = round(\n                        np.mean(solution[entity + '_utility_achieved'][solution[service + '_cadets']]), 4)\n                else:\n                    solution[service + '_' + entity + '_utility'] = 0\n\n        # USSF SOC Breakout\n        solution['ussf_usafa_cadets'] = np.intersect1d(solution['ussf_cadets'], p['usafa_cadets'])\n        solution['ussf_rotc_cadets'] = np.intersect1d(solution['ussf_cadets'], p['rotc_cadets'])\n        solution['ussf_usafa_cadets_count'] = len(solution['ussf_usafa_cadets'])\n        solution['ussf_rotc_cadets_count'] = len(solution['ussf_rotc_cadets'])\n\n        # Metrics that will be printed to excel\n        solution['ussf_usafa_pgl_target'] = str(solution['ussf_usafa_cadets_count']) + \" / \" + str(p['ussf_usafa_pgl'])\n        solution['ussf_rotc_pgl_target'] = str(solution['ussf_rotc_cadets_count']) + \" / \" + str(p['ussf_rotc_pgl'])\n\n    # Calculate weighted average AFSC choice (based on Norm Score)\n    if 'Norm Score' in vp['objectives']:\n        k = np.where(vp['objectives'] == 'Norm Score')[0][0]\n\n        # Individual norm scores for each AFSC\n        solution['afsc_norm_score'] = solution['objective_measure'][:, k]\n\n        # Weighted average AFSC choice\n        weights = solution['count'] / np.sum(solution['count'])\n        solution['weighted_average_afsc_score'] = np.dot(weights, solution['afsc_norm_score'])\n        solution['weighted_average_nrl_afsc_score'] = np.dot(weights[p['J^NRL']] / np.sum(weights[p['J^NRL']]),\n                                                             solution['afsc_norm_score'][p['J^NRL']])\n\n        # Space Force and Air Force differences\n        if 'USSF' in p['afscs_acc_grp']:\n\n            # Weighted average AFSC choice for USSF AFSCs (SFSCs)\n            weights = solution['count'][p['J^USSF']] / np.sum(solution['count'][p['J^USSF']])\n            solution['weighted_average_ussf_afsc_score'] = np.dot(weights, solution['afsc_norm_score'][p['J^USSF']])\n\n            # Weighted average AFSC choice for USAF AFSCs (AFSCs)\n            weights = solution['count'][p['J^USAF']] / np.sum(solution['count'][p['J^USAF']])\n            solution['weighted_average_usaf_afsc_score'] = np.dot(weights, solution['afsc_norm_score'][p['J^USAF']])\n\n    # Generate objective scores for each objective\n    for k in vp['K']:\n        new_weights = vp['afsc_weight'] * vp['objective_weight'][:, k]\n        new_weights = new_weights / sum(new_weights)\n        solution['objective_score'][k] = np.dot(new_weights, solution['objective_value'][:, k])\n\n    # SOC/Gender proportions across AFSCs\n    solution['usafa_proportion_afscs'] = np.array(\n        [round(np.mean(p['usafa'][solution['cadets_assigned'][j]]), 2) for j in p['J']])\n    if 'male' in p:\n        solution['male_proportion_afscs'] = np.array(\n            [round(np.mean(p['male'][solution['cadets_assigned'][j]]), 2) for j in p['J']])\n\n    # SOC/Gender proportions across each Accession group\n    for acc_grp in p['afscs_acc_grp']:\n        if len(solution['I^' + acc_grp]) &gt; 0:\n            solution['usafa_proportion_' + acc_grp] = np.around(np.mean(p['usafa'][solution['I^' + acc_grp]]), 2)\n            if 'male' in p:\n                solution['male_proportion_' + acc_grp] = np.around(np.mean(p['male'][solution['I^' + acc_grp]]), 2)\n\n    # Simpson index\n    if 'race' in p:\n        races = p['race_categories']  # Shorthand (easier to type)\n\n        # Calculate Simpson diversity index for each AFSC\n        solution['simpson_index'] = np.zeros(p['M'])  # Initialize index array for all the AFSCs\n        for j in p['J']:\n            n = solution['count'][j]  # Just grabbing \"n\" as the number of cadets assigned to this AFSC\n\n            # \"AFSC Cadets Race\" dictionary of the number of cadets that were assigned to this AFSC from each race\n            acr = {race: len(np.intersect1d(p['I^' + race], solution['cadets_assigned'][j])) for race in races}\n\n            # Calculate simpson diversity index for this AFSC\n            solution['simpson_index'][j] = round(1 - np.sum([(acr[r] * (acr[r] - 1)) / (n * (n - 1)) for r in races]), 2)\n\n        # Calculate Simpson diversity index for each Accessions Group\n        for acc_grp in p['afscs_acc_grp']:\n            n = len(solution['I^' + acc_grp])  # Just grabbing \"n\" as the number of cadets assigned to this acc group\n\n            # \"Accessions Cadets Race\" dictionary of the number of cadets that were assigned to this grp from each race\n            acr = {race: len(np.intersect1d(p['I^' + race], solution['I^' + acc_grp])) for race in races}\n\n            # Calculate simpson diversity index for this accessions group\n            try:\n                solution['simpson_index_' + acc_grp] = round(1 - np.sum(\n                    [(acr[r] * (acr[r] - 1)) / (n * (n - 1)) for r in races]), 2)\n            except:\n                solution['simpson_index_' + acc_grp] = 0\n\n    # Simpson index (Ethnicity)\n    if 'ethnicity' in p:\n        eths = p['ethnicity_categories']  # Shorthand (easier to type)\n\n        # Calculate Simpson diversity index for each AFSC\n        solution['simpson_index_eth'] = np.zeros(p['M'])  # Initialize index array for all the AFSCs\n        for j in p['J']:\n            n = solution['count'][j]  # Just grabbing \"n\" as the number of cadets assigned to this AFSC\n\n            # \"AFSC Cadets Ethnicity\" dictionary of the number of cadets that were assigned to this AFSC from each eth\n            ace = {eth: len(np.intersect1d(p['I^' + eth], solution['cadets_assigned'][j])) for eth in eths}\n\n            # Calculate simpson diversity index for this AFSC\n            solution['simpson_index_eth'][j] = round(\n                1 - np.sum([(ace[eth] * (ace[eth] - 1)) / (n * (n - 1)) for eth in eths]), 2)\n\n        # Calculate Simpson diversity index for each Accessions Group\n        for acc_grp in p['afscs_acc_grp']:\n            n = len(\n                solution['I^' + acc_grp])  # Just grabbing \"n\" as the number of cadets assigned to this acc group\n\n            # \"Accessions Cadets Ethnicity\" dictionary of the number of cadets that were assigned to this grp/from eth\n            ace = {eth: len(np.intersect1d(p['I^' + eth], solution['I^' + acc_grp])) for eth in eths}\n\n            # Calculate simpson diversity index for this accessions group\n            try:\n                solution['simpson_index_eth_' + acc_grp] = round(1 - np.sum(\n                    [(ace[eth] * (ace[eth] - 1)) / (n * (n - 1)) for eth in eths]), 2)\n            except:\n                solution['simpson_index_eth_' + acc_grp] = 0\n\n    # Calculate STEM proportions in each AFSC\n    if 'stem' in p:\n        pass\n\n    # Initialize dictionaries for cadet choice based on demographics\n    dd = {\"usafa\": [soc.upper() for soc in p['SOCs']], \"male\": [\"Male\", \"Female\"]}  # Demographic Dictionary\n    demographic_dict = {cat: [dd[cat][0], dd[cat][1]] for cat in dd if cat in p}  # Demographic Dictionary (For this instance)\n    solution[\"choice_counts\"] = {\"TOTAL\": {}}  # Everyone\n    for cat in demographic_dict:\n        for dem in demographic_dict[cat]:\n            solution[\"choice_counts\"][dem] = {}\n\n    # Top 3 Choices from USSF and USAF (and ROTC/USAFA)\n    if 'USSF' in p['afscs_acc_grp']:\n        for cat in ['USSF', 'USAF']:\n\n            # Might not have anyone assigned from this group\n            if len(solution['I^' + cat]) == 0:\n                solution['top_3_' + cat.lower() + '_count'] = 0\n                continue\n\n            # Calculate actual top 3 count\n            arr = np.array([i for i in solution['I^' + cat] if solution['j_array'][i] in p['cadet_preferences'][i][:3]])\n            solution['top_3_' + cat.lower() + '_count'] = round(len(arr) / len(solution['I^' + cat]), 4)\n    for cat in dd['usafa']:\n        arr = np.array([i for i in p['I^' + cat] if solution['j_array'][i] in p['cadet_preferences'][i][:3]])\n        solution['top_3_' + cat.lower() + '_count'] = round(len(arr) / len(p['I^' + cat]), 4)\n\n    # Initialize arrays within the choice dictionaries for the AFSCs\n    choice_categories = [\"Top 3\", \"Next 3\", \"All Others\", \"Total\"]\n    for dem in solution[\"choice_counts\"]:\n        for c_cat in choice_categories:\n            solution[\"choice_counts\"][dem][c_cat] = np.zeros(p[\"M\"]).astype(int)\n        for afsc in p[\"afscs\"]:\n            solution[\"choice_counts\"][dem][afsc] = np.zeros(p[\"P\"]).astype(int)\n\n    # AFSC choice\n    solution['afsc_choice_counts'] = {}\n\n    cat_bound_dict = {'90-100%': 0.9, '80-89%': 0.8, '70-79%': 0.7, '60-69%': 0.6, '50-59%': 0.5,\n                      '40-49%': 0.4, '30-39%': 0.3, '20-29%': 0.2, '10-19%': 0.1, '0-10%': 0}\n\n    # Loop through each AFSC\n    for j, afsc in enumerate(p[\"afscs\"][:p['M']]):  # Skip unmatched AFSC\n\n        # The cadets that were assigned to this AFSC\n        dem_cadets = {\"TOTAL\": np.where(solution[\"afsc_array\"] == afsc)[0]}\n\n        # The cadets with the demographic that were assigned to this AFSC\n        for cat in demographic_dict:\n            dem_1, dem_2 = demographic_dict[cat][0], demographic_dict[cat][1]\n            dem_cadets[dem_1] = np.intersect1d(np.where(p[cat] == 1)[0], dem_cadets[\"TOTAL\"])\n            dem_cadets[dem_2] = np.intersect1d(np.where(p[cat] == 0)[0], dem_cadets[\"TOTAL\"])\n\n        afsc_utilities = p['afsc_utility'][dem_cadets['TOTAL'], j]\n        solution['afsc_choice_counts'][afsc] = {}\n        for cat, bound in cat_bound_dict.items():\n\n            if cat == '90-100%':\n                condition = (afsc_utilities &gt;= bound) &amp; (afsc_utilities &lt;= bound + 0.1)\n            else:\n                condition = (afsc_utilities &gt;= bound) &amp; (afsc_utilities &lt; bound + 0.1)\n            cadets = np.where(condition)[0]\n            solution['afsc_choice_counts'][afsc][cat] = len(cadets)\n\n        # Loop through each choice and calculate the metric\n        for choice in range(p[\"P\"]):\n\n            # The cadets that were assigned to this AFSC and placed it in their Pth choice\n            assigned_choice_cadets = np.intersect1d(p[\"I^Choice\"][choice][j], dem_cadets[\"TOTAL\"])\n\n            # The cadets that were assigned to this AFSC, placed it in their Pth choice, and had the demographic\n            for dem in solution[\"choice_counts\"]:\n                solution[\"choice_counts\"][dem][afsc][choice] = len(\n                    np.intersect1d(assigned_choice_cadets, dem_cadets[dem]))\n\n        # Loop through each demographic\n        for dem in solution[\"choice_counts\"]:\n            solution[\"choice_counts\"][dem][\"Total\"][j] = int(len(dem_cadets[dem]))\n            solution[\"choice_counts\"][dem][\"Top 3\"][j] = int(np.sum(solution[\"choice_counts\"][dem][afsc][:3]))\n            solution[\"choice_counts\"][dem][\"Next 3\"][j] = int(np.sum(solution[\"choice_counts\"][dem][afsc][3:6]))\n            solution[\"choice_counts\"][dem][\"All Others\"][j] = int(len(\n                dem_cadets[dem]) - solution[\"choice_counts\"][dem][\"Top 3\"][j] - solution[\"choice_counts\"][dem][\"Next 3\"][j])\n\n    # Top 3 Choice Percentage\n    solution['top_3_choice_percent'] = np.around(\n        np.sum([1 &lt;= solution['cadet_choice'][i] &lt;= 3 for i in solution['I^Match']]) / solution['Num Matched'], 3)\n    return solution\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_base_training_metrics","title":"<code>calculate_base_training_metrics(solution, p, vp)</code>","text":"<p>Add additional base/training components to the \"solution\" dictionary based on the parameters and value parameters.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_base_training_metrics(solution, p, vp):\n    \"\"\"\n    Add additional base/training components to the \"solution\" dictionary based on the parameters and value parameters.\n    \"\"\"\n\n    # Initialize arrays\n    solution['base_choice'] = np.zeros(p['N']).astype(int)\n    solution['base_utility_achieved'] = np.zeros(p['N'])\n    solution['course_utility_achieved'] = np.zeros(p['N'])\n    solution['cadet_state_achieved'] = np.zeros(p['N']).astype(int)\n    solution['cadet_value_achieved'] = np.zeros(p['N'])\n\n    # Weights Implemented\n    solution['afsc_weight_used'] = np.zeros(p['N'])\n    solution['base_weight_used'] = np.zeros(p['N'])\n    solution['course_weight_used'] = np.zeros(p['N'])\n    solution['state_utility_used'] = np.zeros(p['N'])\n\n    # Loop through each cadet to load in their values to each of the above\n    for i, j in enumerate(solution['j_array']):\n        b, c = solution['b_array'][i], solution['c_array'][i][1]\n\n        # Determine what state this cadet achieved\n        d = [d for d in p['D'][i] if j in p['J^State'][i][d]][0]\n        solution['cadet_state_achieved'][i] = d\n\n        # Base-components depend on base outcome\n        if b != p['S']:\n            solution['base_choice'][i] = p['b_pref_matrix'][i, b]\n            solution['base_utility_achieved'][i] = p['base_utility'][i, b]\n            solution['base_weight_used'][i] = p['w^B'][i][d]\n        else:\n            solution['base_choice'][i] = 0\n            solution['base_utility_achieved'][i] = 0\n            solution['base_weight_used'][i] = 0\n\n        # Load other components\n        solution['course_utility_achieved'][i] = p['course_utility'][i][j][c]\n        solution['afsc_weight_used'][i] = p['w^A'][i][d]\n        solution['course_weight_used'][i] = p['w^C'][i][d]\n        solution['state_utility_used'][i] = p['u^S'][i][d]\n\n        # Calculate Cadet Value\n        solution['cadet_value_achieved'][i] = p['u^S'][i][d] * (\n                p['w^A'][i][d] * (p['cadet_utility'][i, j] / p['u^S'][i][d]) +\n                solution['base_weight_used'][i] * solution['base_utility_achieved'][i] +\n                p['w^C'][i][d] * solution['course_utility_achieved'][i])\n\n    # Calculate adjusted Z value (VFT) and associated metrics\n    solution['cadet_value'] = solution['cadet_value_achieved']\n    solution['cadets_overall_value'] = np.dot(vp['cadet_weight'], solution['cadet_value'])\n    solution['z'] = vp['cadets_overall_weight'] * solution['cadets_overall_value'] + \\\n                    vp['afscs_overall_weight'] * solution['afscs_overall_value']\n\n    # Calculate adjusted Z value (GUO)\n    solution['z^gu'] = (1 / p['N']) * vp['afscs_overall_weight'] * np.sum(solution['afsc_utility_achieved']) + \\\n                       vp['cadets_overall_weight'] * solution['cadets_overall_value']\n\n    return solution\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_castle_solution_metrics","title":"<code>calculate_castle_solution_metrics(solution, p)</code>","text":"<p>Add CASTLE-specific solution metrics</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_castle_solution_metrics(solution, p):\n    \"\"\"\n    Add CASTLE-specific solution metrics\n    \"\"\"\n\n    # Shorthand\n    x, q = solution['x'], p['castle_q']\n\n    # Loop through each CASTLE AFSC to calculate the numbers of people assigned\n    solution['castle_counts'], solution['castle_v'] = {}, {}\n    afscs = [afsc for afsc, _ in p['J^CASTLE'].items()]\n    for afsc, j_indices in p['J^CASTLE'].items():\n\n        # Get the number of people assigned to each AFSC under this \"CASTLE\" AFSC umbrella\n        measure = np.sum(np.sum(x[i, j] for i in p['I^E'][j]) for j in j_indices)\n\n        # (+ ADD OTS if they're not being matched!!)\n        if 'ots' not in p['SOCs']:\n            measure += p['ots_counts'][afsc]\n\n        # Save the measure\n        solution['castle_counts'][afsc] = measure\n\n        # Get the value from this AFSC's curve\n        v = value_function(q['a'][afsc], q['f^hat'][afsc], q['r'][afsc], measure)\n        solution['castle_v'][afsc] = v\n\n    # Calculate \"z^CASTLE\"\n    solution['z^CASTLE (Values)'] = round(np.sum(solution['castle_v'][afsc] for afsc in afscs), 4)\n    solution['z^CASTLE'] = round(p['w^G'] * solution['z^gu'] + (1 - p['w^G']) * solution['z^CASTLE (Values)'], 4)\n    return solution\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_objective_measure_chromosome","title":"<code>calculate_objective_measure_chromosome(cadets, j, objective, p, vp, count)</code>","text":"<p>Calculates the AFSC objective measure based on the provided parameters.</p> <p>Parameters:     cadets (list): List of cadets.     j (int): AFSC index.     objective (str): Objective for which to calculate the measure.     p (dict): Parameters used in the calculations.     vp (dict): Value parameters used in the calculations.     count (int): Number of cadets.</p> <p>Returns:     measure (float): The calculated AFSC objective measure.</p> <p>Note:     The function assumes an \"exact\" model since it's used in the fitness function.     The measure is calculated based on the objective and the provided inputs.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_objective_measure_chromosome(cadets, j, objective, p, vp, count):\n    \"\"\"\n    Calculates the AFSC objective measure based on the provided parameters.\n\n    Parameters:\n        cadets (list): List of cadets.\n        j (int): AFSC index.\n        objective (str): Objective for which to calculate the measure.\n        p (dict): Parameters used in the calculations.\n        vp (dict): Value parameters used in the calculations.\n        count (int): Number of cadets.\n\n    Returns:\n        measure (float): The calculated AFSC objective measure.\n\n    Note:\n        The function assumes an \"exact\" model since it's used in the fitness function.\n        The measure is calculated based on the objective and the provided inputs.\n\n    \"\"\"\n\n    # Objective to balance some demographic of the cadets (binary indicator)\n    if objective in vp['K^D']:\n        return len(np.intersect1d(p['I^D'][objective][j], cadets)) / count\n\n    # Balancing Merit\n    elif objective == 'Merit':\n        return np.mean(p['merit'][cadets])\n\n    # \"Number of Cadets\" Objectives\n    elif objective == 'Combined Quota':\n        return count\n    elif objective == 'USAFA Quota':\n        return len(np.intersect1d(p['usafa_cadets'], cadets))\n    elif objective == 'ROTC Quota':\n        return len(np.intersect1d(p['rotc_cadets'], cadets))\n    elif objective == 'OTS Quota':\n        return len(np.intersect1d(p['ots_cadets'], cadets))\n\n    # Maximize cadet utility\n    elif objective == 'Utility':\n        return np.mean(p['cadet_utility'][cadets, j])\n\n    # New objective to evaluate CFM preference lists\n    elif objective == \"Norm Score\":\n        return calculate_afsc_norm_score(cadets, j, p, count=count)\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_objective_measure_matrix","title":"<code>calculate_objective_measure_matrix(x, j, objective, p, vp, approximate=True)</code>","text":"<p>Calculates the AFSC objective measure based on the provided parameters.</p> <p>Parameters:     x (ndarray): Matrix representing the assignment of cadets to AFSCs.     j (int): AFSC index.     objective (str): Objective for which to calculate the measure.     p (dict): Parameters used in the calculations.     vp (dict): Value parameters used in the calculations.     approximate (bool, optional): Flag indicating whether to use an approximate measure (divide by estimated number         of cadets, not the REAL number af cadets assigned to the AFSC. Defaults to True.</p> <p>Returns:     measure (float): The calculated AFSC objective measure.     numerator (float or None): The numerator used in the calculation of the measure.         It is None for certain objectives.</p> <p>Raises:     ValueError: If the provided objective does not have a means of calculation in the VFT model.</p> <p>Note:     The measure and numerator are calculated based on the objective and the provided inputs.     The numerator is the value used in the calculation of the measure (sum of cadets with some feature over the     \"num_cadets\" variable which is either the actual number of cadets assigned (count) or estimated (quota_e).</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_objective_measure_matrix(x, j, objective, p, vp, approximate=True):\n    \"\"\"\n    Calculates the AFSC objective measure based on the provided parameters.\n\n    Parameters:\n        x (ndarray): Matrix representing the assignment of cadets to AFSCs.\n        j (int): AFSC index.\n        objective (str): Objective for which to calculate the measure.\n        p (dict): Parameters used in the calculations.\n        vp (dict): Value parameters used in the calculations.\n        approximate (bool, optional): Flag indicating whether to use an approximate measure (divide by estimated number\n            of cadets, not the REAL number af cadets assigned to the AFSC. Defaults to True.\n\n    Returns:\n        measure (float): The calculated AFSC objective measure.\n        numerator (float or None): The numerator used in the calculation of the measure.\n            It is None for certain objectives.\n\n    Raises:\n        ValueError: If the provided objective does not have a means of calculation in the VFT model.\n\n    Note:\n        The measure and numerator are calculated based on the objective and the provided inputs.\n        The numerator is the value used in the calculation of the measure (sum of cadets with some feature over the\n        \"num_cadets\" variable which is either the actual number of cadets assigned (count) or estimated (quota_e).\n\n    \"\"\"\n\n    # Get count variables for this AFSC\n    count = np.sum(x[i, j] for i in p['I^E'][j])\n    if approximate:\n        num_cadets = int(p['quota_e'][j])  # estimated number of cadets\n    else:\n        num_cadets = count  # actual number of cadets\n\n    # Objective to balance some demographic of the cadets (binary indicator)\n    if objective in vp['K^D']:\n        numerator = np.sum(x[i, j] for i in p['I^D'][objective][j])\n        return numerator / num_cadets, numerator # Measure, Numerator\n\n    # Balancing Merit\n    elif objective == \"Merit\":\n        numerator = np.sum(p['merit'][i] * x[i, j] for i in p['I^E'][j])\n        return numerator / num_cadets, numerator # Measure, Numerator\n\n    # \"Number of Cadets\" Objectives\n    elif objective == \"Combined Quota\":\n        return count, None # Measure, Numerator\n    elif objective == \"USAFA Quota\":\n        return np.sum(x[i, j] for i in np.intersect1d(p['usafa_cadets'], p['I^E'][j])), None # Measure, Numerator\n    elif objective == \"ROTC Quota\":\n        return np.sum(x[i, j] for i in np.intersect1d(p['rotc_cadets'], p['I^E'][j])), None  # Measure, Numerator\n    elif objective == \"OTS Quota\":\n        return np.sum(x[i, j] for i in np.intersect1d(p['ots_cadets'], p['I^E'][j])), None  # Measure, Numerator\n\n    # Maximize cadet utility\n    elif objective == \"Utility\":\n        numerator = np.sum(p['cadet_utility'][i, j] * x[i, j] for i in p['I^E'][j])\n        return numerator / num_cadets, numerator  # Measure, Numerator\n\n    # New objective to evaluate CFM preference lists\n    elif objective == \"Norm Score\":\n\n        # Proxy for constraint purposes\n        numerator = np.sum(p['afsc_utility'][i, j] * x[i, j] for i in p['I^E'][j])\n\n        # Temporary placeholder- need better methodology for calculating Norm Score in \"Exact Model\"!\n        if type(num_cadets) not in [int, np.int64]:\n            num_cadets = int(p['quota_e'][j])\n\n        # Actual objective measure\n        best_range = range(num_cadets)\n        best_sum = np.sum(c for c in best_range)\n        worst_range = range(p[\"num_eligible\"][j] - num_cadets, p[\"num_eligible\"][j])\n        worst_sum = np.sum(c for c in worst_range)\n        achieved_sum = np.sum(p[\"a_pref_matrix\"][i, j] * x[i, j] for i in p[\"I^E\"][j])\n        return 1 - (achieved_sum - best_sum) / (worst_sum - best_sum), numerator  # Measure, Numerator\n\n    # Unrecognized objective\n    else:\n        raise ValueError(\"Error. Objective '\" + objective + \"' does not have a means of calculation in the\"\n                                                            \" VFT model. Please adjust.\")\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_failed_constraint_metrics","title":"<code>calculate_failed_constraint_metrics(j, k, solution, p, vp)</code>","text":"<p>Calculate failed constraint metrics for an AFSC objective and return the updated metrics dictionary.</p> <p>Parameters:     j (int): Index of the AFSC objective.     k (int): Index of the objective measure.     solution (dict): The solution/metrics dictionary.     p (dict): The fixed cadet/AFSC model parameters.     vp (dict): The weight/value parameters.</p> <p>Returns:     solution (dict): The updated solution/metrics dictionary.</p> <p>Note:     This function calculates the failed constraint metrics for an AFSC objective and updates the metrics dictionary     with the newly calculated values.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_failed_constraint_metrics(j, k, solution, p, vp):\n    \"\"\"\n    Calculate failed constraint metrics for an AFSC objective and return the updated metrics dictionary.\n\n    Parameters:\n        j (int): Index of the AFSC objective.\n        k (int): Index of the objective measure.\n        solution (dict): The solution/metrics dictionary.\n        p (dict): The fixed cadet/AFSC model parameters.\n        vp (dict): The weight/value parameters.\n\n    Returns:\n        solution (dict): The updated solution/metrics dictionary.\n\n    Note:\n        This function calculates the failed constraint metrics for an AFSC objective and updates the metrics dictionary\n        with the newly calculated values.\n    \"\"\"\n\n    # Constrained Approximate Measure (Only meant for degree tier constraints)\n    if vp[\"constraint_type\"][j, k] == 1:  # Should be an \"at least constraint\"\n\n        # Get count variable\n        count = np.sum(solution['x'][i, j] for i in p['I^E'][j])\n        constrained_measure = (solution['objective_measure'][j, k] * count) / min(p['quota_min'][j], p['pgl'][j])\n\n    # Constrained Exact Measure\n    elif vp[\"constraint_type\"][j, k] == 2:  # Should be either an \"at most constraint\" or simple valid range (0.2, 0.4)\n        constrained_measure = solution['objective_measure'][j, k]\n\n    else:\n        pass\n\n    # Measure is below the range\n    if constrained_measure &lt; vp['objective_min'][j, k]:\n        solution['objective_constraint_fail'][j, k] = \\\n            str(round(constrained_measure, 2)) + ' &lt; ' + str(vp['objective_min'][j, k]) + '. ' + \\\n            str(round(100 * constrained_measure / vp['objective_min'][j, k], 2)) + '% Met.'\n        solution['total_failed_constraints'] += 1\n        solution[\"failed_constraints\"].append(p['afscs'][j] + \" \" + vp['objectives'][k])\n        solution[\"con_fail_dict\"][(j, k)] = '&gt; ' + str(round(constrained_measure, 4))\n\n    # Measure is above the range\n    elif constrained_measure &gt; vp['objective_max'][j, k]:\n        solution['objective_constraint_fail'][j, k] = \\\n            str(round(constrained_measure, 2)) + ' &gt; ' + str(vp['objective_max'][j, k]) + '. ' + \\\n            str(round(100 * vp['objective_max'][j, k] / constrained_measure, 2)) + '% Met.'\n        solution['total_failed_constraints'] += 1\n        solution[\"failed_constraints\"].append(p['afscs'][j] + \" \" + vp['objectives'][k])\n        solution[\"con_fail_dict\"][(j, k)] = '&lt; ' + str(round(constrained_measure, 4))\n\n    return solution  # Return *updated* solution/metrics\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.check_failed_constraint_chromosome","title":"<code>check_failed_constraint_chromosome(j, k, measure, count, p, vp, con_fail_dict)</code>","text":"<p>This function takes in the AFSC index, objective index, AFSC objective measure, number of cadets assigned (count), parameters, value parameters, and the constraint fail dictionary and determines if we've failed the constraint or not.</p> <p>Parameters:</p> Name Type Description Default <code>j</code> <p>Index of the AFSC (Air Force Specialty Code).</p> required <code>k</code> <p>Index of the objective.</p> required <code>measure</code> <p>Measure of the AFSC objective.</p> required <code>count</code> <p>Number of cadets assigned.</p> required <code>p</code> <p>Dictionary of parameters. - 'quota_min': Array of minimum quotas for each AFSC. - 'pgl': Array of Program Guidance Letter (PGL) targets for each AFSC.</p> required <code>vp</code> <p>Dictionary of value parameters. - 'constraint_type': Array representing the constraint type for each AFSC and objective. - 1 represents Constrained Approximate Measure. - 2 represents Constrained Exact Measure. - 'objective_min': Array representing the minimum objective value for each AFSC and objective. - 'objective_max': Array representing the maximum objective value for each AFSC and objective.</p> required <code>con_fail_dict</code> <p>Dictionary containing information about failed constraints (optional). - Keys are tuples (j, k) representing AFSC and objective indices. - Values are strings representing adjusted min/max values for the failed constraint. - If the string starts with '&gt;', it means the minimum value needed should be lowered. - Otherwise, it means the maximum value allowed should be raised.</p> required <p>Returns:</p> Type Description <p>A boolean indicating whether the constraint is failed or not. - True if the measure is outside the constrained range (constraint failed). - False if the measure is within the constrained range (constraint passed).</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def check_failed_constraint_chromosome(j, k, measure, count, p, vp, con_fail_dict):\n    \"\"\"\n    This function takes in the AFSC index, objective index, AFSC objective measure, number of cadets assigned (count),\n    parameters, value parameters, and the constraint fail dictionary and determines if we've failed the constraint or not.\n\n    :param j: Index of the AFSC (Air Force Specialty Code).\n    :param k: Index of the objective.\n    :param measure: Measure of the AFSC objective.\n    :param count: Number of cadets assigned.\n    :param p: Dictionary of parameters.\n        - 'quota_min': Array of minimum quotas for each AFSC.\n        - 'pgl': Array of Program Guidance Letter (PGL) targets for each AFSC.\n    :param vp: Dictionary of value parameters.\n        - 'constraint_type': Array representing the constraint type for each AFSC and objective.\n            - 1 represents Constrained Approximate Measure.\n            - 2 represents Constrained Exact Measure.\n        - 'objective_min': Array representing the minimum objective value for each AFSC and objective.\n        - 'objective_max': Array representing the maximum objective value for each AFSC and objective.\n    :param con_fail_dict: Dictionary containing information about failed constraints (optional).\n        - Keys are tuples (j, k) representing AFSC and objective indices.\n        - Values are strings representing adjusted min/max values for the failed constraint.\n            - If the string starts with '&gt;', it means the minimum value needed should be lowered.\n            - Otherwise, it means the maximum value allowed should be raised.\n\n    :return: A boolean indicating whether the constraint is failed or not.\n        - True if the measure is outside the constrained range (constraint failed).\n        - False if the measure is within the constrained range (constraint passed).\n    \"\"\"\n\n    # Constrained Approximate Measure (Only meant for degree tier constraints)\n    if vp[\"constraint_type\"][j, k] == 1:  # Should be an \"at least constraint\"\n        constrained_measure = (measure * count) / min(p['quota_min'][j], p['pgl'][j])\n\n    # Constrained Exact Measure\n    elif vp[\"constraint_type\"][j, k] == 2:  # Should be either an \"at most constraint\" or simple valid range (0.2, 0.4)\n        constrained_measure = measure\n\n    # The constrained min and max values as specified by the value parameters\n    constrained_min, constrained_max = vp[\"objective_min\"][j, k], vp[\"objective_max\"][j, k]\n\n    # We adjust the constrained min and max based on the pyomo solution since it could be a little off due to rounding\n    if con_fail_dict is not None:\n        if (j, k) in con_fail_dict:\n\n            # Split up the value in the dictionary to get the new min and max\n            split_list = con_fail_dict[(j, k)].split(' ')\n            if split_list[0] == '&gt;':  # We lower the minimum value needed\n                constrained_min = float(split_list[1])\n            else:  # We raise the maximum value allowed\n                constrained_max = float(split_list[1])\n\n    # Round everything to stay consistent\n    constrained_min, constrained_measure, constrained_max = round(constrained_min, 4), round(constrained_measure, 4), \\\n                                                            round(constrained_max, 4)\n\n    # Check if we failed the constraint, and return a boolean\n    if constrained_min &lt;= constrained_measure &lt;= constrained_max:\n        return False  # Measure is in the range, we DID NOT fail the constraint (failed = False)\n    else:\n        return True  # Measure is outside the range, we DID fail the constraint (failed = True)\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.compare_solutions","title":"<code>compare_solutions(baseline, compared, printing=False)</code>","text":"<p>Compare two solutions (in vector form) to the same problem and determine the similarity between them based on the AFSCs assigned to cadets.</p> <p>Parameters:     baseline (numpy.ndarray): The first solution (baseline) to compare.     compared (numpy.ndarray): The second solution to compare against the baseline.     printing (bool, optional): Whether to print the similarity percentage. Defaults to False.</p> <p>Returns:     percent_similar (float): The percentage of the compared solution that is the same as the baseline solution.</p> <p>Note:     This function compares two solutions represented as vectors and calculates the percentage of similarity     between them in terms of the AFSCs assigned to cadets. The solutions must be for the same set of cadets     and AFSCs.</p> <p>Example:     baseline = np.array([0, 1, 2, 1, 0])     compared = np.array([1, 0, 2, 1, 0])     similarity = compare_solutions(baseline, compared, printing=True)     # Output: The two solutions are 60.0% the same (3/5).</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def compare_solutions(baseline, compared, printing=False):\n    \"\"\"\n    Compare two solutions (in vector form) to the same problem and determine the similarity between them based on the\n    AFSCs assigned to cadets.\n\n    Parameters:\n        baseline (numpy.ndarray): The first solution (baseline) to compare.\n        compared (numpy.ndarray): The second solution to compare against the baseline.\n        printing (bool, optional): Whether to print the similarity percentage. Defaults to False.\n\n    Returns:\n        percent_similar (float): The percentage of the compared solution that is the same as the baseline solution.\n\n    Note:\n        This function compares two solutions represented as vectors and calculates the percentage of similarity\n        between them in terms of the AFSCs assigned to cadets. The solutions must be for the same set of cadets\n        and AFSCs.\n\n    Example:\n        baseline = np.array([0, 1, 2, 1, 0])\n        compared = np.array([1, 0, 2, 1, 0])\n        similarity = compare_solutions(baseline, compared, printing=True)\n        # Output: The two solutions are 60.0% the same (3/5).\n    \"\"\"\n\n    percent_similar = (sum(baseline == compared * 1) / len(baseline))\n    if printing:\n        print(\"The two solutions are \" + str(percent_similar) + \"% the same.\")\n    return percent_similar\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.similarity_coordinates","title":"<code>similarity_coordinates(similarity_matrix)</code>","text":"<p>Perform Multidimensional Scaling (MDS) on a similarity matrix to obtain coordinates representing the solutions' similarity relationships.</p> <p>Parameters: - similarity_matrix (numpy.ndarray): A square similarity matrix where each element   (i, j) measures the similarity between solutions i and j.</p> <p>Returns: - coordinates (numpy.ndarray): An array of 2D coordinates representing the solutions   in a space where the distance between solutions reflects their similarity.</p> <p>Description: This function takes in a similarity matrix and performs Multidimensional Scaling (MDS) to obtain coordinates representing the solutions in a lower-dimensional space. The purpose of MDS is to transform similarity data into distances. In the resulting 2D space, solutions that are similar to each other will be closer together, while dissimilar solutions will be farther apart.</p> <p>MDS is particularly useful for visualizing the similarity relationships among solutions. These coordinates can be used for plotting or further analysis to gain insights into how solutions relate to each other based on their similarities.</p> <p>Note: Ensure that you have the required libraries, such as NumPy and Scikit-learn, installed.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def similarity_coordinates(similarity_matrix):\n    \"\"\"\n    Perform Multidimensional Scaling (MDS) on a similarity matrix to obtain coordinates\n    representing the solutions' similarity relationships.\n\n    Parameters:\n    - similarity_matrix (numpy.ndarray): A square similarity matrix where each element\n      (i, j) measures the similarity between solutions i and j.\n\n    Returns:\n    - coordinates (numpy.ndarray): An array of 2D coordinates representing the solutions\n      in a space where the distance between solutions reflects their similarity.\n\n    Description:\n    This function takes in a similarity matrix and performs Multidimensional Scaling (MDS)\n    to obtain coordinates representing the solutions in a lower-dimensional space. The\n    purpose of MDS is to transform similarity data into distances. In the resulting 2D\n    space, solutions that are similar to each other will be closer together, while\n    dissimilar solutions will be farther apart.\n\n    MDS is particularly useful for visualizing the similarity relationships among solutions.\n    These coordinates can be used for plotting or further analysis to gain insights into\n    how solutions relate to each other based on their similarities.\n\n    Note: Ensure that you have the required libraries, such as NumPy and Scikit-learn, installed.\n    \"\"\"\n\n    # Change similarity matrix into distance matrix\n    distances = 1 - similarity_matrix\n\n    # Get coordinates\n    if afccp.globals.use_manifold:\n        mds = manifold.MDS(n_components=2, dissimilarity='precomputed', random_state=10)\n        results = mds.fit(distances)\n        coordinates = results.embedding_\n    else:\n        coordinates = np.zeros([len(distances), 2])\n        print('Sklearn manifold not available')\n\n    return coordinates\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.incorporate_rated_results_in_parameters","title":"<code>incorporate_rated_results_in_parameters(instance, printing=True)</code>","text":"<p>This function extracts the results from the two Rated solutions (for both USAFA &amp; ROTC) and incorporates them into the problem's parameters. It fixes cadets who were \"matched\" by the algorithm to specific AFSCs and constrains individuals who had \"reserved\" slots.</p> <p>Parameters: - instance: An instance of the problem, containing parameters and algorithm results. - printing (bool, optional): A flag to control whether to print information during execution.   Set to True to enable printing, and False to suppress it. Default is True.</p> <p>Returns: - parameters (dict): The updated parameters dictionary reflecting the rated algorithm results.</p> <p>Description: This function is used to integrate the outcomes of the Rated SOC (Source of Commissioning) algorithm into the problem's parameters. It processes the results for both USAFA (United States Air Force Academy) and ROTC (Reserve Officers' Training Corps) categories.</p> <ul> <li> <p>The \"Matched\" cadets are assigned to specific AFSCs based on the algorithm results. These assignments   are recorded in the 'J^Fixed' array within the parameters.</p> </li> <li> <p>The \"Reserved\" cadets have their AFSC selections constrained based on their reserved slots. The   'J^Reserved' dictionary is updated to enforce these constraints.</p> </li> <li> <p>Special treatment is provided for AFSCs with an \"alternate list\" concept. Cadets who did not receive   one of their top preferences but are next in line for a particular AFSC are assigned to the \"alternate list.\"   Cadets on this list may be given preferences or reserved slots, depending on availability.</p> </li> </ul> <p>This function aims to ensure that the problem's parameters align with the Rated SOC algorithm's results, facilitating further decision-making and analysis.</p> <p>Note: Detailed information on the Rated SOC algorithm results is assumed to be available within the 'instance.'</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def incorporate_rated_results_in_parameters(instance, printing=True):\n    \"\"\"\n    This function extracts the results from the two Rated solutions (for both USAFA &amp; ROTC)\n    and incorporates them into the problem's parameters. It fixes cadets who were \"matched\" by the algorithm\n    to specific AFSCs and constrains individuals who had \"reserved\" slots.\n\n    Parameters:\n    - instance: An instance of the problem, containing parameters and algorithm results.\n    - printing (bool, optional): A flag to control whether to print information during execution.\n      Set to True to enable printing, and False to suppress it. Default is True.\n\n    Returns:\n    - parameters (dict): The updated parameters dictionary reflecting the rated algorithm results.\n\n    Description:\n    This function is used to integrate the outcomes of the Rated SOC (Source of Commissioning) algorithm into\n    the problem's parameters. It processes the results for both USAFA (United States Air Force Academy)\n    and ROTC (Reserve Officers' Training Corps) categories.\n\n    - The \"Matched\" cadets are assigned to specific AFSCs based on the algorithm results. These assignments\n      are recorded in the 'J^Fixed' array within the parameters.\n\n    - The \"Reserved\" cadets have their AFSC selections constrained based on their reserved slots. The\n      'J^Reserved' dictionary is updated to enforce these constraints.\n\n    - Special treatment is provided for AFSCs with an \"alternate list\" concept. Cadets who did not receive\n      one of their top preferences but are next in line for a particular AFSC are assigned to the \"alternate list.\"\n      Cadets on this list may be given preferences or reserved slots, depending on availability.\n\n    This function aims to ensure that the problem's parameters align with the Rated SOC algorithm's results,\n    facilitating further decision-making and analysis.\n\n    Note: Detailed information on the Rated SOC algorithm results is assumed to be available within the 'instance.'\n    \"\"\"\n\n    if printing:\n        print(\"Incorporating rated algorithm results...\")\n\n    # Shorthand\n    p, vp, solutions = instance.parameters, instance.value_parameters, instance.solutions\n    mdl_p = instance.mdl_p\n    if mdl_p['socs_to_use'] is None:\n        socs_to_use = p['SOCs']\n    else:\n        socs_to_use = mdl_p['socs_to_use']\n    upper_socs = [soc.upper() for soc in socs_to_use]\n\n    # Make sure we have the solutions from both SOCs with matches and reserves\n    for soc in upper_socs:\n        for kind in ['Reserves', 'Matches']:\n            solution_name = \"Rated \" + soc.upper() + \" HR (\" + kind + \")\"\n            if solution_name not in solutions:\n                return p  # We don't have the required solutions!\n\n    # Matched cadets get fixed in the solution!\n    for soc in upper_socs:\n        solution = solutions[\"Rated \" + soc.upper() + \" HR (Matches)\"]\n        matched_cadets = np.where(solution['j_array'] != p['M'])[0]\n        for i in matched_cadets:\n            p['J^Fixed'][i] = solution['j_array'][i]\n\n    # Reserved cadets AFSC selection is constrained to be AT LEAST their reserved Rated slot\n    p['J^Reserved'] = {}\n    for soc in upper_socs:\n        solution = solutions[\"Rated \" + soc.upper() + \" HR (Reserves)\"]\n        reserved_cadets = np.where(solution['j_array'] != p['M'])[0]\n        for i in reserved_cadets:\n            j = solution['j_array'][i]\n            choice = np.where(p['cadet_preferences'][i] == j)[0][0]\n            p['J^Reserved'][i] = p['cadet_preferences'][i][:choice + 1]\n\n    # Calculate additional rated algorithm result information for both SOCs\n    for soc in socs_to_use:\n\n        # Do we want to potentially allow ROTC to fill USAFA pilot slots?\n        if mdl_p['usafa_soc_pilot_cross_in'] and soc == 'rotc':\n\n            # If we want to allow cross-flow, we need to add USAFA reserved pilot slots to be potentially filled\n            j_pilot_u = np.where(p['afscs'] == '11XX_U')[0][0]  # by ROTC (increase their alternate list)\n\n            # First we calculate the number of reserved USAFA pilot slots there are\n            u_reserved_pilot = \\\n                [i for i in p['J^Reserved'] if\n                 p['cadet_preferences'][i][len(p['J^Reserved'][i]) - 1] == j_pilot_u and p['usafa'][i]]\n            num_reserved_u_pilot = len(u_reserved_pilot)\n\n            # We also need the number of hard alternates for USAFA pilot\n            u_hard_alternates_pilot = [i for i, j in p['J^Alternates (Hard)'].items() if j == j_pilot_u]\n            num_hard_alternates_u_pilot = len(u_hard_alternates_pilot)\n\n            # The number of potential additions for ROTC pilot is going to be the total number of resered USAFA slots\n            num_additions_rotc_pilot = num_reserved_u_pilot - num_hard_alternates_u_pilot  # minus hard alternates\n\n        else:\n            num_additions_rotc_pilot = 0\n        p = augment_rated_algorithm_results(p, soc=soc, printing=instance.mdl_p['alternate_list_iterations_printing'],\n                                            num_additions_rotc_pilot=num_additions_rotc_pilot)\n\n    # Print statement\n    if printing:\n\n        # Matched/Reserved Lists\n        print_str = \"Rated SOC Algorithm Results:\\n\"\n        for soc in upper_socs:\n            for kind in [\"Fixed\", \"Reserved\"]:\n                count = str(len([i for i in p[soc.lower() + \"_cadets\"] if i in p['J^' + kind]]))\n                print_str += soc + ' ' + kind + ' Cadets: ' + count + ', '\n        print(print_str[:-2])\n\n        # Alternate Lists\n        count_u = str(int(sum([len(p['I^Alternate [usafa]'][j]) for j in p['J^Rated']])))\n        count_r = str(int(sum([len(p['I^Alternate [rotc]'][j]) for j in p['J^Rated']])))\n        print_str = \"USAFA Rated Alternates: \" + count_u + \", ROTC Rated Alternates: \" + count_r\n        if 'ots' in socs_to_use:\n            count_o = str(int(sum([len(p['I^Alternate [ots]'][j]) for j in p['J^Rated']])))\n            print_str += \", OTS Rated Alternates: \" + count_o\n        print(print_str)\n\n    return p  # Return the parameters!\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.augment_rated_algorithm_results","title":"<code>augment_rated_algorithm_results(p, soc='rotc', printing=False, num_additions_rotc_pilot: int = 0)</code>","text":"<p>Analyzes the results of the Rated SOC algorithm for a specific SOC (Source of Commissioning), such as ROTC or USAFA, and augments the system's parameters. This analysis includes identifying alternates and definitively matching additional individuals to AFSCs.</p> <p>Parameters: - p (dict): The problem's parameters containing relevant data. - soc (str, optional): The SOC to analyze and augment results for. Default is 'rotc'. - printing (bool, optional): A flag to control whether to print information during execution.   Set to True to enable printing, and False to suppress it. Default is False.</p> <p>Returns: - parameters (dict): The updated parameters dictionary reflecting the rated algorithm results,   including alternates and definitively matched individuals.</p> <p>Description: This function processes the results of the Rated SOC algorithm for a specific SOC category, identifying alternates and definitively matching additional individuals to AFSCs. The primary goal is to ensure the system's parameters accurately reflect the outcomes of the algorithm, which aids in further analysis and decision-making.</p> <ul> <li>'Reserved' cadets have their AFSC selections constrained to match their reserved slots.</li> <li>'Matched' cadets are assigned specific AFSCs based on the algorithm results.</li> <li>'Alternates' are cadets who did not receive one of their top AFSC preferences but are next in line   for specific AFSCs based on the algorithm's execution. Alternates may be given preferences or   reserved slots, depending on availability.</li> </ul> <p>Note: Detailed information on the Rated SOC algorithm results is assumed to be available within the 'parameters.'</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def augment_rated_algorithm_results(p, soc='rotc', printing=False, num_additions_rotc_pilot: int = 0):\n    \"\"\"\n    Analyzes the results of the Rated SOC algorithm for a specific SOC (Source of Commissioning),\n    such as ROTC or USAFA, and augments the system's parameters. This analysis includes identifying\n    alternates and definitively matching additional individuals to AFSCs.\n\n    Parameters:\n    - p (dict): The problem's parameters containing relevant data.\n    - soc (str, optional): The SOC to analyze and augment results for. Default is 'rotc'.\n    - printing (bool, optional): A flag to control whether to print information during execution.\n      Set to True to enable printing, and False to suppress it. Default is False.\n\n    Returns:\n    - parameters (dict): The updated parameters dictionary reflecting the rated algorithm results,\n      including alternates and definitively matched individuals.\n\n    Description:\n    This function processes the results of the Rated SOC algorithm for a specific SOC category,\n    identifying alternates and definitively matching additional individuals to AFSCs. The primary goal\n    is to ensure the system's parameters accurately reflect the outcomes of the algorithm, which\n    aids in further analysis and decision-making.\n\n    - 'Reserved' cadets have their AFSC selections constrained to match their reserved slots.\n    - 'Matched' cadets are assigned specific AFSCs based on the algorithm results.\n    - 'Alternates' are cadets who did not receive one of their top AFSC preferences but are next in line\n      for specific AFSCs based on the algorithm's execution. Alternates may be given preferences or\n      reserved slots, depending on availability.\n\n    Note: Detailed information on the Rated SOC algorithm results is assumed to be available within the 'parameters.'\n    \"\"\"\n\n    # Start with a full list of cadets eligible for each AFSC from this SOC\n    possible_cadets = {j: list(np.intersect1d(p['I^E'][j], p[soc + '_cadets'])) for j in p['J^Rated']}\n\n    # Used for stopping conditions\n    last_reserves, last_matches, last_alternates_h = np.array([1000 for _ in p['J^Rated']]), \\\n                                                     np.array([1000 for _ in p['J^Rated']]), \\\n                                                     np.array([1000 for _ in p['J^Rated']])\n\n    if printing:\n        print(\"\\nSOC:\", soc.upper())\n        print()\n\n    # Main algorithm\n    iteration, iterating = 0, True\n    while iterating:\n\n        # Set of cadets reserved or matched to each AFSC\n        p['I^Reserved'] = {j: np.array([i for i in p['J^Reserved'] if p['cadet_preferences'][i][\n            len(p['J^Reserved'][i]) - 1] == j and p[soc][i]]) for j in p['J^Rated']}\n        p['I^Matched'] = {j: np.array([\n            i for i in p['J^Fixed'] if j == p['J^Fixed'][i] and p[soc][i]]) for j in p['J^Rated']}\n\n        # Number of alternates (number of reserved slots)\n        num_reserved = {j: len(p['I^Reserved'][j]) for j in p['J^Rated']}\n\n        # Need to determine who falls into each category of alternates\n        hard_alternates = {j: [] for j in p['J^Rated']}\n        soft_r_alternates = {j: [] for j in p['J^Rated']}\n        soft_n_alternates = {j: [] for j in p['J^Rated']}\n        alternates = {j: [] for j in p['J^Rated']}  # all the cadets ordered here\n\n        # Loop through each rated AFSC to determine alternates\n        for j in p['J^Rated']:\n\n            # We may want to increase the length of ROTC pilot alternate list to account for USAFA\n            if j == '11XX_R':\n                num_additions = copy.deepcopy(num_additions_rotc_pilot)\n            else:\n                num_additions = 0\n\n            # Loop through each cadet in order of the AFSC's preference from this SOC\n            for i in p['afsc_preferences'][j]:\n                if not p[soc][i]:\n                    continue\n\n                # Assume this cadet is \"next in line\" until proven otherwise\n                next_in_line = True\n\n                # Is the cadet already fixed to something else?\n                if i in p['J^Fixed']:\n                    next_in_line = False\n                    if i in possible_cadets[j]:\n                        possible_cadets[j].remove(i)\n\n                # Is this cadet reserved for something?\n                if i in p['J^Reserved']:\n\n                    # If they're already reserved for this AFSC or something better, they're not considered\n                    if len(p['J^Reserved'][i]) &lt;= p['c_pref_matrix'][i, j]:\n                        next_in_line = False\n                        if i in possible_cadets[j]:\n                            possible_cadets[j].remove(i)\n\n                # If this cadet is next in line (and we still have alternates to assign)\n                if next_in_line and len(hard_alternates[j]) &lt; (num_reserved[j] + num_additions):\n                    alternates[j].append(i)\n\n                    # Loop through the cadet's preferences:\n                    for j_c in p['cadet_preferences'][i]:\n\n                        # Determine what kind of alternate this cadet is\n                        if j_c == j:  # Hard Rated Alternate\n                            hard_alternates[j].append(i)\n                            break\n                        elif j_c in p['J^Rated']:\n                            if i in possible_cadets[j_c]:  # Soft Rated Alternate\n                                soft_r_alternates[j].append(i)\n                                break\n                            else:  # Can't be matched, go to next preference\n                                continue\n                        else:  # Soft Non-Rated Alternate\n                            soft_n_alternates[j].append(i)\n                            break\n\n                # We've run out of hard alternates to assign (thus, we're done assigning alternates)\n                elif len(hard_alternates[j]) &gt;= (num_reserved[j] + num_additions):\n                    if i in possible_cadets[j]:\n                        possible_cadets[j].remove(i)\n\n        # Loop through each rated AFSC to potentially turn \"reserved\" slots into \"matched\" slots\n        for j in p['J^Rated']:\n\n            # Loop through each cadet in order of the AFSC's preference from this SOC\n            for i in p['afsc_preferences'][j]:\n                if not p[soc][i]:\n                    continue\n\n                # Does this cadet have a reserved slot for something?\n                if i in p['J^Reserved']:\n\n                    # Is this cadet reserved for this AFSC?\n                    if len(p['J^Reserved'][i]) == p['c_pref_matrix'][i, j]:\n\n                        # Determine if there's any possible way this cadet might not be matched to this AFSC\n                        inevitable_match = True\n                        for j_c in p['J^Reserved'][i][:-1]:\n                            if j_c not in p['J^Rated']:\n                                inevitable_match = False\n                            else:  # Rated\n                                if i in alternates[j_c]:\n                                    inevitable_match = False\n                                else:\n                                    if i in possible_cadets[j_c]:\n                                        possible_cadets[j_c].remove(i)  # Remove this cadet as a possibility!\n\n                        # If still inevitable, change from reserved to fixed\n                        if inevitable_match:\n                            p['J^Fixed'][i] = j\n                            p['J^Reserved'].pop(i)\n\n                # This cadet cannot receive this AFSC\n                if i not in alternates[j] and i in possible_cadets[j]:\n                    possible_cadets[j].remove(i)\n\n        # Print Statement\n        if printing:\n            print(\"Iteration\", iteration)\n            print(\"Possible\", {p['afscs'][j]: len(possible_cadets[j]) for j in p['J^Rated']})\n            print(\"Matched\", {p['afscs'][j]: len(p['I^Matched'][j]) for j in p['J^Rated']})\n            print(\"Reserved\", {p['afscs'][j]: len(p['I^Reserved'][j]) for j in p['J^Rated']})\n            print(\"Alternates (Hard)\", {p['afscs'][j]: len(hard_alternates[j]) for j in p['J^Rated']})\n            print(\"Alternates (Soft)\", {p['afscs'][j]: len(soft_n_alternates[j]) +\n                                                       len(soft_r_alternates[j]) for j in p['J^Rated']})\n\n        # Once we stop changing from the algorithm, we're done!\n        current_matched = np.array([len(p['I^Matched'][j]) for j in p['J^Rated']])\n        current_reserved = np.array([len(p['I^Reserved'][j]) for j in p['J^Rated']])\n        current_alternates_h = np.array([len(hard_alternates[j]) for j in p['J^Rated']])\n        if np.sum(current_matched - last_matches + current_reserved -\n                  last_reserves + current_alternates_h - last_alternates_h) == 0:\n            iterating = False\n        else:\n            last_matches, last_reserves, last_alternates_h = current_matched, current_reserved, current_alternates_h\n\n        # Next iteration\n        iteration += 1\n\n    # Incorporate alternate lists (broken down by Hard/Soft)\n    if 'J^Alternates (Hard)' not in p:\n        p['J^Alternates (Hard)'] = {}\n    if 'J^Alternates (Soft)' not in p:\n        p['J^Alternates (Soft)'] = {}\n    for i in p['Rated Cadets'][soc]:  # Loop through all rated cadets\n        for j in p['Rated Choices'][soc][i]:  # Loop through rated preferences in order\n            if i in hard_alternates[j]:\n                p['J^Alternates (Hard)'][i] = j\n            elif i in soft_r_alternates[j] or i in soft_n_alternates[j]:\n                p['J^Alternates (Soft)'][i] = j\n                break # Next cadet\n\n    # Alternate List Optimization Formulation Sets Needed\n    p['J^Preferred [' + soc + ']'], p['I^Preferred [' + soc + ']'], p['I^Alternate [' + soc + ']'] = {}, {}, {}\n    for j in p['J^Rated']:\n\n        # Empty sets for each AFSC\n        p['I^Alternate [' + soc + ']'][j] = []\n        p['I^Preferred [' + soc + ']'][j] = {}\n        p['J^Preferred [' + soc + ']'][j] = {}\n\n        # Loop through each cadet in order of the AFSC's preference\n        for i in p['afsc_preferences'][j]:\n\n            # Where this cadet ranked this AFSC\n            cadet_rank_afsc = np.where(p['cadet_preferences'][i] == j)[0][0]\n\n            # Set of more preferred AFSCs (including this AFSC too) for this cadet\n            p['J^Preferred [' + soc + ']'][j][i] = p['cadet_preferences'][i][:cadet_rank_afsc + 1]\n\n            # Where this AFSC ranked this cadet\n            afsc_rank_cadet = np.where(p['afsc_preferences'][j] == i)[0][0]\n\n            # Set of more preferred cadets (including this cadet too) for this AFSC\n            p['I^Preferred [' + soc + ']'][j][i] = np.intersect1d(\n                p['afsc_preferences'][j][:afsc_rank_cadet + 1], p[soc + '_cadets'])\n\n            # Is this cadet an alternate from this SOC?\n            if i in p[soc + '_cadets'] and (i in p['J^Alternates (Hard)'] or i in p['J^Alternates (Soft)']):\n\n                # This cadet needs to be an alternate specifically for this AFSC\n                alternate = False\n                if i in p['J^Alternates (Hard)']:\n                    if p['J^Alternates (Hard)'][i] == j:\n                        alternate = True\n                elif i in p['J^Alternates (Soft)']:\n                    if p['J^Alternates (Soft)'][i] == j:\n                        alternate = True\n                if not alternate:\n                    continue\n\n                # Add the cadet to the alternate list for this AFSC\n                p['I^Alternate [' + soc + ']'][j].append(i)\n\n        # Convert to numpy array\n        p['I^Alternate [' + soc + ']'][j] = np.array(p['I^Alternate [' + soc + ']'][j])\n\n    # Return updated parameters (and alternate lists)\n    return p\n</code></pre>"},{"location":"reference/solutions/optimization/","title":"Optimization","text":""},{"location":"reference/solutions/optimization/#solutions.optimization","title":"<code>solutions.optimization</code>","text":""},{"location":"reference/solutions/optimization/#solutions.optimization.assignment_model_build","title":"<code>assignment_model_build(instance, printing=False)</code>","text":"<p>Converts the parameters and value parameters to the pyomo data structure</p> <p>Parameters:     instance (object): Problem instance object     printing (bool, optional): Whether the procedure should print something. Default is False.</p> <p>Returns:     pyomo data: Pyomo data representing the converted model</p> <p>Description:     This function builds a Pyomo model based on the provided problem instance. It converts the parameters and value     parameters into the Pyomo data structure and constructs the objective function and constraints of the model.</p> <pre><code>The function takes a problem instance object as input, which contains the necessary parameters and value parameters\nfor building the model. The `printing` parameter controls whether the procedure should print progress information\nduring model construction.\n\nThe utility/cost matrix is computed based on the parameters and value parameters. The AFSC preferences, merit,\nand eligibility information are used to calculate the cost values for each cadet-AFSC pair in the matrix.\n\nThe model is built using the Pyomo `ConcreteModel` class. The variables, objective function, and constraints\nare defined within the model.\n\nThe objective function is defined as the sum of the cost values multiplied by the corresponding decision variable\nfor each cadet-AFSC pair.\n\nThe constraints include ensuring that each cadet is assigned to exactly one AFSC, limiting the percentage of\nUSAFA cadets in certain AFSCs, and applying AFSC objective measure constraints if specified.\n\nIf `printing` is set to True, the function prints progress information during the model construction.\n\nFinally, the constructed model is returned.\n</code></pre> <p>Example:     instance = ProblemInstance()     model = assignment_model_build(instance, printing=True)     ...</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def assignment_model_build(instance, printing=False):\n    \"\"\"\n    Converts the parameters and value parameters to the pyomo data structure\n\n    Parameters:\n        instance (object): Problem instance object\n        printing (bool, optional): Whether the procedure should print something. Default is False.\n\n    Returns:\n        pyomo data: Pyomo data representing the converted model\n\n    Description:\n        This function builds a Pyomo model based on the provided problem instance. It converts the parameters and value\n        parameters into the Pyomo data structure and constructs the objective function and constraints of the model.\n\n        The function takes a problem instance object as input, which contains the necessary parameters and value parameters\n        for building the model. The `printing` parameter controls whether the procedure should print progress information\n        during model construction.\n\n        The utility/cost matrix is computed based on the parameters and value parameters. The AFSC preferences, merit,\n        and eligibility information are used to calculate the cost values for each cadet-AFSC pair in the matrix.\n\n        The model is built using the Pyomo `ConcreteModel` class. The variables, objective function, and constraints\n        are defined within the model.\n\n        The objective function is defined as the sum of the cost values multiplied by the corresponding decision variable\n        for each cadet-AFSC pair.\n\n        The constraints include ensuring that each cadet is assigned to exactly one AFSC, limiting the percentage of\n        USAFA cadets in certain AFSCs, and applying AFSC objective measure constraints if specified.\n\n        If `printing` is set to True, the function prints progress information during the model construction.\n\n        Finally, the constructed model is returned.\n\n    Example:\n        instance = ProblemInstance()\n        model = assignment_model_build(instance, printing=True)\n        ...\n    \"\"\"\n\n    # Shorthand\n    p, vp, mdl_p = instance.parameters, instance.value_parameters, instance.mdl_p\n\n    # *New* Utility/\"Cost\" Matrix based on CFM preferences and cadet preferences (GUO model)\n    if mdl_p['assignment_model_obj'] == 'Global Utility':\n        c = vp['global_utility']\n\n        if printing:\n            print(\"Building assignment problem (GUO) model...\")\n\n    # Original Model Utility/\"Cost\" Matrix  (Original model)\n    else:  # This is the \"legacy\" AFPC model!\n        c = build_old_afpc_model_utility_matrix(p)\n\n        if printing:\n            print(\"Building original assignment problem model...\")\n\n    # Build Model\n    m = ConcreteModel()\n\n    # ___________________________________VARIABLE DEFINITION_________________________________\n    m = common_optimization_handling(m, p, vp, mdl_p)  # Define x along with additional functional constraints\n\n    # Base/Training model extra components\n    if mdl_p['solve_extra_components']:\n        m = base_training_model_handling(m, p, mdl_p)\n\n    # Initialize CASTLE value curve variables\n    if mdl_p['solve_castle_guo']:\n        m = initialize_castle_value_curve_function_variables(m, p, q=p['castle_q'])\n\n    # ___________________________________OBJECTIVE FUNCTION__________________________________\n    m.objective = assignment_model_objective_function_definition(m=m, p=p, vp=vp, mdl_p=mdl_p, c=c)\n\n    # ________________________________________CONSTRAINTS_____________________________________\n    m.measure_constraints = ConstraintList()  # AFSC Objective Measure Constraints (Optional decision-maker constraints)\n\n    # Incorporate CASTLE value curve functional constraints\n    if mdl_p['solve_castle_guo']:\n        m = initialize_value_function_constraint_lists(m)\n\n        # Loop through each CASTLE AFSC to add the constraints\n        for castle_afsc, j_indices in p['J^CASTLE'].items():\n\n            # Get the number of people assigned to each AFSC under this \"CASTLE\" AFSC umbrella (+ ADD OTS!!)\n            if 'ots' in p['SOCs']:  # If OTS is in the model, we don't have to account for them\n                measure = np.sum(np.sum(m.x[i, j] for i in p['I^E'][j]) for j in j_indices)\n            else:  # If we are not matching OTS, we have to account for them\n                measure = np.sum(np.sum(m.x[i, j] for i in p['I^E'][j]) for j in j_indices) + p['ots_counts'][\n                    castle_afsc]\n\n            # Add the value curve constraints for this \"CASTLE\" AFSC\n            m = add_castle_value_curve_function_constraints(m, measure, afsc=castle_afsc, q=p['castle_q'])\n\n    # Loop through all AFSCs to add AFSC objective measure constraints\n    for j in p['J']:\n\n        # Loop through all constrained AFSC objectives\n        for k in vp['K^C'][j]:\n            # Calculate AFSC objective measure components\n            measure, numerator = afccp.solutions.handling.calculate_objective_measure_matrix(\n                m.x, j, vp['objectives'][k], p, vp, approximate=True)\n\n            # Add AFSC objective measure constraint\n            m = add_objective_measure_constraint(m, j, k, measure, numerator, p, vp)\n\n    if printing:\n        print(\"Done. Solving model...\")\n\n    if mdl_p['usafa_soc_pilot_cross_in']:\n        j = np.where(p['afscs'] == '11XX_U')[0][0]\n        k = np.where(vp['objectives'] == 'Combined Quota')[0][0]\n        if (vp[\"objective_min\"][j, k] == vp[\"objective_max\"][j, k]) and vp['constraint_type'][j, k] != 0:\n            print(\"*****************WARNING**********************\",\n                  \"\\nModel designated to allow USAFA Pilot cross-flows but constraints are still activated that\"\n                  \" would prevent this.\\nEnsure you turn off the USAFA/ROTC pilot quota\",\n                  f\"constraints in '{instance.data_name} VP.csv'\")\n\n    return m  # Return model\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.assignment_model_objective_function_definition","title":"<code>assignment_model_objective_function_definition(m, p, vp, mdl_p, c)</code>","text":"<p>Define the objective function for the assignment model.</p> <p>This function constructs the objective function for an assignment optimization model. The objective function varies depending on whether the model includes additional components (<code>solve_extra_components</code>) or only considers AFSC-based assignments.</p> <p>If <code>solve_extra_components</code> is enabled, the objective function consists of two weighted components: - A cadet-specific value function weighted by <code>cadets_overall_weight</code> and individual   cadet weights. - An AFSC-specific utility function weighted by <code>afscs_overall_weight</code> and normalized by <code>1/N</code>.</p> <p>If <code>solve_extra_components</code> is disabled, the function simplifies to maximizing the AFSC-only utility values.</p> <p>Args:     m (ConcreteModel): The Pyomo model to which the objective function will be added.     p (dict): A dictionary containing problem parameters, including:         - 'I': Set of cadets.         - 'J^E': Set of available AFSCs for each cadet.         - 'afsc_utility': Utility values for cadet-to-AFSC assignments.         - 'N': Normalization factor for AFSC weight.     vp (dict): A dictionary containing value parameters, including:         - 'cadets_overall_weight': Overall weight for cadet value.         - 'cadet_weight': Individual weights for cadets.         - 'afscs_overall_weight': Overall weight for AFSC utility.     mdl_p (dict): Model parameters containing:         - 'solve_extra_components' (bool): Determines whether additional components           (cadet-based value) are included in the objective.     c (dict): A dictionary of AFSC-only utility values used when <code>solve_extra_components</code>         is disabled.</p> <p>Returns:     Objective: The Pyomo Objective function, maximizing either the full weighted sum     of cadet and AFSC utility (if <code>solve_extra_components</code> is True) or just AFSC utility     (if False).</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def assignment_model_objective_function_definition(m, p, vp, mdl_p, c):\n    \"\"\"\n    Define the objective function for the assignment model.\n\n    This function constructs the objective function for an assignment optimization model.\n    The objective function varies depending on whether the model includes additional components\n    (`solve_extra_components`) or only considers AFSC-based assignments.\n\n    If `solve_extra_components` is enabled, the objective function consists of two weighted\n    components:\n    - A cadet-specific value function weighted by `cadets_overall_weight` and individual\n      cadet weights.\n    - An AFSC-specific utility function weighted by `afscs_overall_weight` and normalized by `1/N`.\n\n    If `solve_extra_components` is disabled, the function simplifies to maximizing\n    the AFSC-only utility values.\n\n    Args:\n        m (ConcreteModel): The Pyomo model to which the objective function will be added.\n        p (dict): A dictionary containing problem parameters, including:\n            - 'I': Set of cadets.\n            - 'J^E': Set of available AFSCs for each cadet.\n            - 'afsc_utility': Utility values for cadet-to-AFSC assignments.\n            - 'N': Normalization factor for AFSC weight.\n        vp (dict): A dictionary containing value parameters, including:\n            - 'cadets_overall_weight': Overall weight for cadet value.\n            - 'cadet_weight': Individual weights for cadets.\n            - 'afscs_overall_weight': Overall weight for AFSC utility.\n        mdl_p (dict): Model parameters containing:\n            - 'solve_extra_components' (bool): Determines whether additional components\n              (cadet-based value) are included in the objective.\n        c (dict): A dictionary of AFSC-only utility values used when `solve_extra_components`\n            is disabled.\n\n    Returns:\n        Objective: The Pyomo Objective function, maximizing either the full weighted sum\n        of cadet and AFSC utility (if `solve_extra_components` is True) or just AFSC utility\n        (if False).\n    \"\"\"\n\n    # Do we incorporate base/training decision components to the model?\n    if mdl_p['solve_extra_components']:\n\n        # Base/Training model objective function\n        def objective_function(m):\n            return vp['cadets_overall_weight'] * np.sum(vp['cadet_weight'][i] * m.cadet_value[i] for i in p['I']) + \\\n                   1 / p['N'] * vp['afscs_overall_weight'] * np.sum(\n                np.sum(p['afsc_utility'][i, j] * m.x[i, j] for j in p['J^E'][i]) for i in p['I'])\n\n    else:  # If not, we solve the \"AFSC-only\" assignment problem model\n\n        # AFSC-only objective function (GUO) i.e. (not base/training component considerations)\n        z_guo = np.sum(np.sum(c[i, j] * m.x[i, j] for j in p[\"J^E\"][i]) for i in p[\"I\"]) / p['N^Match']\n\n        def objective_function(m):  # Standard \"GUO\" function value \"z^GUO\"\n            return z_guo\n\n        # Determine whether we want to add \"CASTLE\" modeling components or not\n        if mdl_p['solve_castle_guo']:\n            if 'castle_q' not in p:  # If we don't have castle parameters, we can't solve the model\n                print(\"CASTLE Parameters not found. We cannot solve model w/CASTLE modifications.\")\n                return Objective(rule=objective_function, sense=maximize)  # Return normal GUO function\n            afscs = [afsc for afsc, _ in p['castle_afscs'].items()]\n\n            # Define the Castle-informed objective function!\n            z_castle_values = np.sum(m.f_value[afsc] for afsc in afscs)\n            if mdl_p['w^G'] == 1:  # Weight on Castle solution is zero so we don't need to include it!\n                def objective_function(m):  # Standard \"GUO\" function value \"z^GUO\"\n                    return z_guo\n            elif mdl_p['w^G'] == 0:  # Weight on GUO solution is zero so just use Castle information\n                def objective_function(m):  # Castle-values portion of objective function\n                    return z_castle_values\n            else:\n                def objective_function(m):  # Full weighted function of GUO and Castle\n                    return mdl_p['w^G'] * z_guo + (1 - mdl_p['w^G']) * z_castle_values\n\n    # Objective function has been defined\n    return Objective(rule=objective_function, sense=maximize)\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.common_optimization_handling","title":"<code>common_optimization_handling(m, p, vp, mdl_p)</code>","text":"<p>Adds optimization model components common to main optimization models like VFT and the generalized assignment problem models.</p> <p>Parameters: m (ConcreteModel): The Pyomo ConcreteModel instance to which the optimization model components will be added. p (dict): A dictionary containing problem-specific data, including cadet, AFSC, base, course, utility, and weight          information. vp (dict): A dictionary containing value-specific parameters and information. mdl_p (dict): A dictionary containing model-specific parameters and configurations.</p> <p>Returns: ConcreteModel: The modified Pyomo ConcreteModel instance with added optimization model components.</p> <p>Notes: - This function extends the given Pyomo ConcreteModel (m) by adding optimization model components common to   various main optimization models. - The parameters include:     - m: The Pyomo ConcreteModel instance to be extended.     - p: A dictionary containing various problem-specific data, such as cadet information, AFSCs, bases, courses,          utility values, and weights.     - vp: A dictionary containing value-specific parameters and information.     - mdl_p: A dictionary containing model-specific parameters and configurations. - The added optimization model components include binary variables (x), constraints for cadet AFSC assignment,   cadet value constraints, constraints for fixed variables, reserved AFSC constraints, and constraints for   AFSC cadet percentages, among others. - Additional constraints handle special cases like alternate list rated addition, 5% cap on total percentage of   USAFA cadets allowed in certain AFSCs, USSF SOC PGL constraint, and USSF OM constraint. - The given ConcreteModel (m) is modified in-place and returned for further use.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def common_optimization_handling(m, p, vp, mdl_p):\n    \"\"\"\n    Adds optimization model components common to *main* optimization models like VFT and the generalized assignment\n    problem models.\n\n    Parameters:\n    m (ConcreteModel): The Pyomo ConcreteModel instance to which the optimization model components will be added.\n    p (dict): A dictionary containing problem-specific data, including cadet, AFSC, base, course, utility, and weight\n             information.\n    vp (dict): A dictionary containing value-specific parameters and information.\n    mdl_p (dict): A dictionary containing model-specific parameters and configurations.\n\n    Returns:\n    ConcreteModel: The modified Pyomo ConcreteModel instance with added optimization model components.\n\n    Notes:\n    - This function extends the given Pyomo ConcreteModel (m) by adding optimization model components common to\n      various main optimization models.\n    - The parameters include:\n        - m: The Pyomo ConcreteModel instance to be extended.\n        - p: A dictionary containing various problem-specific data, such as cadet information, AFSCs, bases, courses,\n             utility values, and weights.\n        - vp: A dictionary containing value-specific parameters and information.\n        - mdl_p: A dictionary containing model-specific parameters and configurations.\n    - The added optimization model components include binary variables (x), constraints for cadet AFSC assignment,\n      cadet value constraints, constraints for fixed variables, reserved AFSC constraints, and constraints for\n      AFSC cadet percentages, among others.\n    - Additional constraints handle special cases like alternate list rated addition, 5% cap on total percentage of\n      USAFA cadets allowed in certain AFSCs, USSF SOC PGL constraint, and USSF OM constraint.\n    - The given ConcreteModel (m) is modified in-place and returned for further use.\n    \"\"\"\n\n    # Define the x-variable\n    m.x = Var(((i, j) for i in p['I'] for j in p['J^E'][i]), within=Binary)\n\n    # Cadets receive one and only one AFSC (Ineligibility constraint is always met as a result of the indexed sets)\n    m.one_afsc_constraints = ConstraintList()  # ...except for OTS candidates- there is a lot of nuance there!\n    m = add_x_variable_one_afsc_constraints(m, p, mdl_p)  # Modify the \"one_afsc_constraints\" list for each cadet\n\n    # Cadets may sometimes be constrained to be part of one \"Accessions Group\" (probably just USSF)\n    m.acc_grp_constraints = ConstraintList()\n    if 'acc_grp_constraint' in p:\n        for acc_grp in p['afscs_acc_grp']:\n            for i in p['I^' + acc_grp]:\n                m.acc_grp_constraints.add(\n                    expr=np.sum(m.x[i, j] for j in p['J^' + acc_grp] if j in p['J^E'][i]) == 1)\n\n    # Cadet value constraint (Could work on any optimization model)\n    m.min_cadet_value_constraints = ConstraintList()\n    for i in vp['I^C']:  # \"J^Top_Choice is set of AFSCs at or above designated utility value (typically top 3)\n        m.min_cadet_value_constraints.add(expr=np.sum(m.x[i, j] for j in vp['J^Top_Choice'][i]) == 1)\n\n    # \"AlTERNATE LIST\" Rated Addition\n    if mdl_p['rated_alternates'] and 'J^Preferred [usafa]' in p:  # If [usafa] version is here, [rotc] will be too\n        m = add_rated_alternates_constraints(m, p, mdl_p)\n\n    # Fixing variables if necessary\n    for i in p['J^Fixed']:\n        m.x[i, p['J^Fixed'][i]].fix(1)\n\n    # Cadets with reserved AFSC slots get constrained so that the \"worst\" choice they can get is their reserved AFSC\n    m.reserved_afsc_constraints = ConstraintList()\n    for i in p['J^Reserved']:\n        m.reserved_afsc_constraints.add(expr=np.sum(m.x[i, j] for j in p['J^Reserved'][i]) == 1)\n\n    # 5% cap on total percentage of USAFA cadets allowed into certain AFSCs\n    if mdl_p[\"USAFA-Constrained AFSCs\"] is not None:\n        cap = 0.05 * mdl_p[\"real_usafa_n\"]  # Total number of graduating USAFA cadets\n\n        # Convert list of AFSC names to list of AFSC indices\n        constrained_afscs = [np.where(p['afscs'] == afsc)[0][0] for afsc in mdl_p[\"USAFA-Constrained AFSCs\"]]\n\n        # USAFA 5% Cap Constraint\n        def usafa_afscs_rule(m):\n            \"\"\"\n            This is the 5% USAFA graduating class cap constraint for certain AFSCs (support AFSCs). I will note that\n            as of Mar '23 this constraint is effectively null and void! Still here for documentation however and for any\n            potential future experiment\n            \"\"\"\n            return np.sum(np.sum(m.x[i, j] for i in p['usafa_cadets']) for j in constrained_afscs) &lt;= cap\n\n        m.usafa_afscs_constraint = Constraint(rule=usafa_afscs_rule)\n\n    # Space Force Special Constraints!\n    m = add_space_force_constraints(m, p, mdl_p)\n\n    # OTS accessions cap\n    if 'ots' in p['SOCs']:\n        # Determine the cap on OTS accessions\n        print(f\"OTS accessions capacity constraint: {p['ots_accessions']}\")\n\n        # Define and apply the constraint\n        def ots_accessions_constraint_rule(m):\n            \"\"\"\n            Constraint to ensure we stay under OTS accessions cap\n            \"\"\"\n            return np.sum(np.sum(m.x[i, j] for j in p['J^E'][i]) for i in p['I^OTS']) &lt;= p['ots_accessions']\n\n        m.ots_accessions_constraint = Constraint(rule=ots_accessions_constraint_rule)\n\n    # Return updated model\n    return m\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.log_constraint_violations_to_file","title":"<code>log_constraint_violations_to_file(model, filepath, tolerance=0.0001, max_violations=100)</code>","text":"<p>Logs violated constraints to a text file, suppressing uninitialized variable warnings.</p> <p>Args:     model (ConcreteModel): The Pyomo model to inspect.     filepath (str): Path to the log file.     tolerance (float): Numerical tolerance for feasibility.     max_violations (int): Max number of violations to report.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def log_constraint_violations_to_file(model, filepath, tolerance=1e-4, max_violations=100):\n    \"\"\"\n    Logs violated constraints to a text file, suppressing uninitialized variable warnings.\n\n    Args:\n        model (ConcreteModel): The Pyomo model to inspect.\n        filepath (str): Path to the log file.\n        tolerance (float): Numerical tolerance for feasibility.\n        max_violations (int): Max number of violations to report.\n    \"\"\"\n    def all_vars_initialized(expr):\n        \"\"\"Helper to check if all variables in an expression are initialized.\"\"\"\n        try:\n            for var in identify_variables(expr, include_fixed=False):\n                if var.value is None:\n                    return False\n            return True\n        except:\n            return False\n\n    with open(filepath, 'w') as f:\n        f.write(\"Constraint Violations Log\\n\\n\")\n        count = 0\n        for constr in model.component_objects(Constraint, active=True):\n            cdata = getattr(model, constr.name)\n            for index in cdata:\n                con = cdata[index]\n                try:\n                    if not all_vars_initialized(con.body):\n                        continue  # Skip uninitialized expressions\n\n                    lhs = value(con.body)\n                    lb = value(con.lower) if con.lower is not None else -np.inf\n                    ub = value(con.upper) if con.upper is not None else np.inf\n\n                    if not (lb - tolerance &lt;= lhs &lt;= ub + tolerance):\n                        f.write(f\"\u274c {constr.name}[{index}]\\n\")\n                        f.write(f\"    LHS = {lhs:.6f}\\n\")\n                        f.write(f\"    Bounds = [{lb:.6f}, {ub:.6f}]\\n\\n\")\n                        count += 1\n                        if count &gt;= max_violations:\n                            f.write(\"\u26a0\ufe0f Max violations reached.\\n\")\n                            return\n                except Exception as e:\n                    f.write(f\"\u26a0\ufe0f Could not evaluate {constr.name}[{index}]: {e}\\n\\n\")\n        if count == 0:\n            f.write(\"\u2705 No constraint violations detected.\\n\")\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.handle_infeasible_model","title":"<code>handle_infeasible_model(model, results, output_dir='infeasibility_logs')</code>","text":"<p>Handles an infeasible model: prints message, logs diagnostics, and raises error.</p> <p>Args:     model (ConcreteModel): The Pyomo model.     results (SolverResults): The results from solver.solve().     output_dir (str): Directory to write the LP file and violation log.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def handle_infeasible_model(model, results, output_dir=\"infeasibility_logs\"):\n    \"\"\"\n    Handles an infeasible model: prints message, logs diagnostics, and raises error.\n\n    Args:\n        model (ConcreteModel): The Pyomo model.\n        results (SolverResults): The results from solver.solve().\n        output_dir (str): Directory to write the LP file and violation log.\n    \"\"\"\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n\n    infeasible_lp_path = os.path.join(output_dir, \"infeasible_model.lp\")\n    violations_path = os.path.join(output_dir, \"constraint_violations.txt\")\n\n    print(\"\\n\ud83d\udeab Model is infeasible. Writing diagnostics...\")\n\n    # Write model to LP file for further inspection\n    model.write(infeasible_lp_path, io_options={\"symbolic_solver_labels\": True})\n    print(f\"\ud83d\udcc4 Model written to: {infeasible_lp_path}\")\n\n    # Log constraint violations\n    log_constraint_violations_to_file(model, violations_path)\n    print(f\"\ud83d\udcc4 Constraint violations written to: {violations_path}\")\n\n    # Log LP analysis\n    lp_analysis_path = os.path.join(output_dir, \"lp_analysis.txt\")\n    parse_lp_file(infeasible_lp_path, output_log=lp_analysis_path)\n    lp_analysis_debug_path = os.path.join(output_dir, \"lp_analysis_debug.txt\")\n    parse_lp_file_debug(infeasible_lp_path, output_log=lp_analysis_debug_path)\n\n    # Raise the error\n    raise ValueError(\"Model is infeasible. Diagnostics have been saved.\")\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.parse_lp_file_debug","title":"<code>parse_lp_file_debug(lp_path, output_log='lp_analysis_debug.txt')</code>","text":"<p>Parses and analyzes a .lp file to flag common infeasibility patterns.</p> <p>Args:     lp_path (str): Path to the .lp file.     output_log (str): Output file for diagnostic results.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def parse_lp_file_debug(lp_path, output_log=\"lp_analysis_debug.txt\"):\n    \"\"\"\n    Parses and analyzes a .lp file to flag common infeasibility patterns.\n\n    Args:\n        lp_path (str): Path to the .lp file.\n        output_log (str): Output file for diagnostic results.\n    \"\"\"\n    with open(lp_path, 'r') as f:\n        lines = f.readlines()\n\n    in_constraints = False\n    in_bounds = False\n    in_general = False\n\n    constraints = []\n    bounds = []\n    binary_vars = set()\n    constraint_vars = set()\n    variable_bounds = {}\n\n    for line in lines:\n        line = line.strip()\n\n        # Section headers\n        if line.startswith(\"Subject To\"):\n            in_constraints = True\n            continue\n        if line.startswith(\"Bounds\"):\n            in_constraints = False\n            in_bounds = True\n            continue\n        if line.startswith(\"General\") or line.startswith(\"Binary\"):\n            in_bounds = False\n            in_general = True\n            continue\n        if line.startswith(\"End\"):\n            in_general = False\n\n        # Constraints\n        if in_constraints:\n            constraints.append(line)\n            constraint_vars.update(re.findall(r'\\b\\w+\\b', line))\n\n        # Bounds\n        elif in_bounds:\n            bounds.append(line)\n            # Examples:\n            # 0 &lt;= x1 &lt;= 1\n            # x3 free\n            parts = re.findall(r'[\\w\\.-]+', line)\n            if \"free\" in line:\n                variable_bounds[parts[0]] = (\"-inf\", \"inf\", \"free\")\n            elif len(parts) == 5:\n                variable_bounds[parts[2]] = (parts[0], parts[4], \"bounded\")\n\n        # Binary/General\n        elif in_general:\n            binary_vars.update(re.findall(r'\\b\\w+\\b', line))\n\n    flagged_issues = []\n\n    # Analyze bounds\n    for var, (lb, ub, status) in variable_bounds.items():\n        if status == \"free\":\n            flagged_issues.append(f\"\u26a0\ufe0f Variable {var} is free \u2014 may lead to unboundedness.\")\n        else:\n            try:\n                if float(lb) &gt; float(ub):\n                    flagged_issues.append(f\"\u274c Variable {var} has inconsistent bounds: {lb} &gt; {ub}\")\n            except ValueError:\n                flagged_issues.append(f\"\u26a0\ufe0f Variable {var} has non-numeric bounds: {lb}, {ub}\")\n\n    # Analyze constraints\n    eq_constraints = [c for c in constraints if re.search(r\"= [\\d\\.-]+\", c)]\n    for c in eq_constraints:\n        flagged_issues.append(f\"\u26a0\ufe0f Hard equality constraint: {c.strip()}\")\n\n    # Check for undeclared variables\n    for var in constraint_vars:\n        if var not in variable_bounds and var not in binary_vars and not var.startswith(\"c\"):\n            flagged_issues.append(f\"\u26a0\ufe0f Variable {var} used in constraints but not declared.\")\n\n    # Check for large coefficients\n    for c in constraints:\n        coeffs = re.findall(r'[\\+\\-]?\\s*\\d+\\.\\d+', c)\n        for coeff in coeffs:\n            val = float(coeff.replace(\" \", \"\"))\n            if abs(val) &gt; 1e6 or abs(val) &lt; 1e-6:\n                flagged_issues.append(f\"\u26a0\ufe0f Extreme coefficient ({val}) in: {c.strip()}\")\n\n    # Write log\n    with open(output_log, 'w') as out:\n        out.write(\"=== LP Debug Analysis ===\\n\\n\")\n        out.write(\"\u2705 Basic stats:\\n\")\n        out.write(f\"  - Constraints: {len(constraints)}\\n\")\n        out.write(f\"  - Bounds: {len(bounds)}\\n\")\n        out.write(f\"  - Binary/General vars: {len(binary_vars)}\\n\\n\")\n\n        if flagged_issues:\n            out.write(\"\u2757 Potential Issues Found:\\n\")\n            for issue in flagged_issues:\n                out.write(\"  \" + issue + \"\\n\")\n        else:\n            out.write(\"\u2705 No obvious issues found.\\n\")\n\n        out.write(\"\\n=== Sample Constraints ===\\n\")\n        for c in constraints[:10]:\n            out.write(\"  \" + c + \"\\n\")\n\n        out.write(\"\\n=== Sample Bounds ===\\n\")\n        for b in bounds[:10]:\n            out.write(\"  \" + b + \"\\n\")\n\n    print(f\"\ud83d\udcc4 LP analysis written to: {output_log}\")\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.parse_lp_file","title":"<code>parse_lp_file(lp_path, output_log='lp_analysis.txt')</code>","text":"<p>Parses a .lp file and logs constraints and bounds for debugging.</p> <p>Args:     lp_path (str): Path to the .lp file.     output_log (str): File to write analysis log to.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def parse_lp_file(lp_path, output_log=\"lp_analysis.txt\"):\n    \"\"\"\n    Parses a .lp file and logs constraints and bounds for debugging.\n\n    Args:\n        lp_path (str): Path to the .lp file.\n        output_log (str): File to write analysis log to.\n    \"\"\"\n    with open(lp_path, 'r') as f:\n        lines = f.readlines()\n\n    in_constraints = False\n    in_bounds = False\n    in_general = False\n    constraints = []\n    bounds = []\n    binary_vars = []\n\n    for line in lines:\n        line = line.strip()\n\n        if line.startswith(\"Subject To\"):\n            in_constraints = True\n            continue\n        if line.startswith(\"Bounds\"):\n            in_constraints = False\n            in_bounds = True\n            continue\n        if line.startswith(\"General\") or line.startswith(\"Binary\"):\n            in_bounds = False\n            in_general = True\n            continue\n        if line.startswith(\"End\"):\n            in_general = False\n\n        if in_constraints:\n            constraints.append(line)\n        elif in_bounds:\n            bounds.append(line)\n        elif in_general:\n            binary_vars.append(line)\n\n    with open(output_log, 'w') as out:\n        out.write(\"=== Constraint Section ===\\n\")\n        for c in constraints[:50]:  # show only first 50 for brevity\n            out.write(c + '\\n')\n\n        out.write(\"\\n=== Bounds Section ===\\n\")\n        for b in bounds[:50]:\n            out.write(b + '\\n')\n\n        out.write(\"\\n=== Binary/General Variables ===\\n\")\n        for v in binary_vars:\n            out.write(v + '\\n')\n\n        out.write(\"\\n\u2705 Finished parsing LP file.\\n\")\n\n    print(f\"\u2714\ufe0f LP file parsed and analyzed. Results written to: {output_log}\")\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.solve_pyomo_model","title":"<code>solve_pyomo_model(instance, model, model_name, q=None, printing=False)</code>","text":"<p>Solve a Pyomo model using a specified solver.</p> <p>This function takes an instance, a Pyomo model, the model name, optional parameters (q), and a flag for printing intermediate information. It adjusts the solver settings based on the provided instance parameters, solves the model, and returns the solution.</p> <p>Args:     instance: The Pyomo instance.     model: The Pyomo model to solve.     model_name (str): The name of the model.     q (dict, optional): Optional parameters.     printing (bool, optional): Flag for printing intermediate information.</p> <p>Returns:     solution (int or tuple): The solution of the model.         - If the model name is \"GP\", returns a tuple (solution, x) where solution is an array of integers representing           the AFSCs assigned to cadets, and x is a 2D array representing the assignment matrix.         - Otherwise, returns a tuple (solution, x, warm_start), where solution is an array of integers representing           the AFSCs assigned to cadets, x is a 2D array representing the assignment matrix, and warm_start is a           dictionary containing warm start variables used for initializing the VFT Pyomo model.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def solve_pyomo_model(instance, model, model_name, q=None, printing=False):\n    \"\"\"\n    Solve a Pyomo model using a specified solver.\n\n    This function takes an instance, a Pyomo model, the model name, optional parameters (q), and a flag for printing\n    intermediate information. It adjusts the solver settings based on the provided instance parameters, solves the\n    model, and returns the solution.\n\n    Args:\n        instance: The Pyomo instance.\n        model: The Pyomo model to solve.\n        model_name (str): The name of the model.\n        q (dict, optional): Optional parameters.\n        printing (bool, optional): Flag for printing intermediate information.\n\n    Returns:\n        solution (int or tuple): The solution of the model.\n            - If the model name is \"GP\", returns a tuple (solution, x) where solution is an array of integers representing\n              the AFSCs assigned to cadets, and x is a 2D array representing the assignment matrix.\n            - Otherwise, returns a tuple (solution, x, warm_start), where solution is an array of integers representing\n              the AFSCs assigned to cadets, x is a 2D array representing the assignment matrix, and warm_start is a\n              dictionary containing warm start variables used for initializing the VFT Pyomo model.\n    \"\"\"\n\n    # Different parameters are needed based on the model\n    if model_name == 'Bubbles':\n        b, mdl_p = instance.b, instance.b  # It's weird, I know, but this works\n        mdl_p[\"solver_name\"] = b['b_solver_name']  # Change the solver\n        mdl_p[\"pyomo_max_time\"] = b['b_pyomo_max_time']  # Set the max time\n    else:\n        p, vp, gp, mdl_p = instance.parameters, instance.value_parameters, instance.gp_parameters, instance.mdl_p\n\n        # Adjust solver if necessary\n        if not mdl_p[\"approximate\"] and model_name == \"VFT\":\n            if mdl_p[\"solver_name\"] == 'cbc':\n                mdl_p[\"solver_name\"] = 'ipopt'\n\n    # Determine how the solver is called here\n    solver = build_solver(model_name, mdl_p, printing)\n\n    # Solve Model\n    start_time = time.perf_counter()\n    model = execute_solver(model, solver, mdl_p)\n    solve_time = round(time.perf_counter() - start_time, 2)\n\n    # # Log infeasibility\n    # if (results.solver.status != SolverStatus.ok) or (\n    #         results.solver.termination_condition == TerminationCondition.infeasible):\n    #     timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')\n    #     folder_path = f\"{instance.export_paths['Analysis &amp; Results']}infeasibility_logs {timestamp}\"\n    #     handle_infeasible_model(model, results, output_dir=folder_path)\n\n    # Goal Programming Model specific actions\n    if model_name == \"GP\":\n\n        # We're \"pre-process\" solving the model for a specific GP constraint\n        if mdl_p[\"con_term\"] is not None:\n            return model.objective()\n\n        # We're actually solving the model for a solution\n        else:\n\n            # Get solution\n            solution = {\"method\": \"GP\", \"j_array\": np.zeros(gp['N']).astype(int), \"x\": np.zeros((gp['N'], gp['M']))}\n            for c in gp['C']:\n                for a in gp['A^']['E'][c]:\n                    solution['x'][c, a] = model.x[c, a].value\n                    if round(solution['x'][c, a]):\n                        solution['j_array'][c] = int(a)\n\n            if printing:\n                print('Model solved.')\n\n            return solution\n\n    # \"Bubble Chart\" optimization model\n    elif model_name == 'Bubbles':\n\n        # Get the values from the model and return them\n        x, y, s = {}, {}, model.s.value\n\n        for j in b['J^translated']:\n            idx = b['J^translated'][j]\n            x[j], y[j] = model.x[idx].value, model.y[idx].value\n        return s, x, y\n\n    # VFT/Assignment Model specific actions\n    else:\n\n        # Obtain solution from the model\n        def obtain_solution():\n            \"\"\"\n            This nested function obtains the X matrix and the solution vector from the pyomo model\n            \"\"\"\n\n            # Get solution\n            solution = {\"method\": model_name, \"j_array\": np.zeros(p['N']).astype(int), \"x\": np.zeros((p['N'], p['M'])),\n                        'solve_time': solve_time, 'x_integer': True}\n\n            # Loop through each cadet to determine what AFSC they're assigned\n            for i in p['I']:\n                found = False\n                for j in p['J^E'][i]:\n                    solution['x'][i, j] = model.x[i, j].value\n                    try:\n                        if round(solution['x'][i, j]):\n                            solution['j_array'][i] = int(j)\n                            found = True\n\n                        if 0.01 &lt; solution['x'][i, j] &lt; 0.99:\n                            solution['x_integer'] = False\n                    except:\n                        raise ValueError(\"Solution didn't come out right, likely model is infeasible.\")\n\n                # For some reason we may not have assigned a cadet to an AFSC in which case we just give them to one\n                # they're eligible for and want (happens usually to only 1-3 people through VFT model)\n                if not found:\n\n                    # OTS candidates may go unmatched\n                    if 'I^OTS' in p:\n                        if i in p['I^OTS']:\n                            solution['j_array'][i] = p['M']  # Cadet assigned to \"unmatched\" AFSC!\n                            continue\n\n                    # Try to give the cadet their top choice AFSC for which they're eligible\n                    if len(p[\"J^P\"][i]) != 0:\n                        max_util = 0\n                        max_j = 0\n                        for j in p[\"J^P\"][i]:\n                            if p['cadet_utility'][i, j] &gt;= max_util:\n                                max_j = j\n                                max_util = max_util\n                        solution['j_array'][i] = int(max_j)\n\n                    # If we don't have any eligible preferences from the cadet, they get Needs of the Air Force\n                    else:\n\n                        if len(p[\"J^E\"][i]) &gt;= 2:\n                            solution['j_array'][i] = int(p[\"J^E\"][i][1])\n                        else:\n                            solution['j_array'][i] = int(p[\"J^E\"][i][0])\n\n                    afsc = p[\"afscs\"][int(solution['j_array'][i])]\n\n                    if printing:\n                        print(\"Cadet \" + str(i) + \" was not assigned by the model for some reason. \"\n                                                  \"We assigned them to\", afsc)\n\n            # Get objective value\n            solution['pyomo_obj_value'] = round(model.objective(), 4)\n            return solution\n\n        # Obtain base/training solution components from the model\n        def obtain_extra_solution_components(solution):\n            \"\"\"\n            This nested function obtains the base/training variable components from the pyomo model\n            \"\"\"\n\n            solution['b_array'] = np.zeros(p['N']).astype(int)\n            solution['c_array'] = np.array([(0, 0) for _ in p['I']])\n            solution['base_array'] = np.array([\" \" * 100 for _ in p['I']])\n            solution['course_array'] = np.array([\" \" * 100 for _ in p['I']])\n            solution['v'] = np.zeros((p['N'], p['S'])).astype(int)\n            solution['q'] = np.zeros((p['N'], p['M'], max(p['T']))).astype(int)\n            solution['cadet_value (Pyomo)'] = np.zeros(p['N'])\n            solution['v_integer'], solution['q_integer'] = True, True\n\n            # Loop through each cadet to determine what base they're assigned to\n            for i in p['I']:\n                found = False\n                for b in p['B^E'][i]:\n                    solution['v'][i, b] = model.v[i, b].value\n                    try:\n                        if round(solution['v'][i, b]):\n                            solution['b_array'][i] = int(b)\n                            found = True\n\n                        if 0.01 &lt; solution['v'][i, b] &lt; 0.99:\n                            warm_start['v_integer'] = False\n                    except:\n                        raise ValueError(\"Solution didn't come out right, likely model is infeasible.\")\n\n                if found:\n                    solution['base_array'][i] = p['bases'][solution['b_array'][i]]\n                else:  # Not matched to a base\n                    solution['base_array'][i] = \"\"\n                    solution['b_array'][i] = p['S']\n\n            # Loop through each cadet to determine what course they're assigned to\n            for i in p['I']:\n                found = False\n                for j in p['J^E'][i]:\n                    for c in p['C^E'][i][j]:\n                        solution['q'][i, j, c] = model.q[i, j, c].value\n                        try:\n                            if round(solution['q'][i, j, c]):\n                                solution['c_array'][i] = (j, c)\n                                found = True\n\n                            if 0.01 &lt; solution['q'][i, j, c] &lt; 0.99:\n                                warm_start['q_integer'] = False\n                        except:\n                            raise ValueError(\"Solution didn't come out right, likely model is infeasible.\")\n\n                if found:\n                    solution['course_array'][i] = p['courses'][solution['c_array'][i][0]][solution['c_array'][i][1]]\n                else:  # Not matched to a course\n                    print('Cadet', i, 'not matched to a course for some reason. Something went wrong.')\n\n            # Loop through each cadet to get their value from pyomo\n            for i in p['I']:\n                solution['cadet_value (Pyomo)'][i] = model.cadet_value[i].value\n\n            return solution\n\n        solution = obtain_solution()\n\n        # Base/Training Model components\n        if mdl_p['solve_extra_components']:\n            solution = obtain_extra_solution_components(solution)\n\n        # Obtain \"warm start\" variables used to initialize the VFT pyomo model\n        def obtain_warm_start_variables():\n            \"\"\"\n            This nested function obtains the variables used for the warm start (variable initialization) of the pyomo model\n            \"\"\"\n\n            # Determine maximum number of breakpoints for any particular AFSC\n            max_r = 0\n            for j in p[\"J\"]:\n                for k in vp[\"K^A\"][j]:\n                    if q[\"r\"][j][k] &gt; max_r:\n                        max_r = q[\"r\"][j][k]\n\n            # Initialize dictionary\n            warm_start = {'f(measure)': np.zeros([p['M'], vp['O']]), 'r^max': max_r + 1,\n                          'lambda': np.zeros([p['M'], vp['O'], max_r + 1]),\n                          'y': np.zeros([p['M'], vp['O'], max_r + 1]).astype(int), 'obj': model.objective(),\n                          'y_original': np.zeros([p['M'], vp['O'], max_r + 1]), 'y_integer': True}\n\n            # Load warm start variables\n            for j in p['J']:\n                for k in vp['K^A'][j]:\n                    warm_start['f(measure)'][j, k] = model.f_value[j, k].value\n                    for l in range(q['r'][j, k]):\n                        warm_start['lambda'][j, k, l] = model.lam[j, k, l].value\n                        if l &lt; q['r'][j, k] - 1:\n                            warm_start['y'][j, k, l] = round(model.y[j, k, l].value)\n                            warm_start['y_original'][j, k, l] = model.y[j, k, l].value\n                            if 0.01 &lt; warm_start['y_original'][j, k, l] &lt; 0.99:\n                                warm_start['y_integer'] = False\n\n            # Return the \"warm start\" dictionary\n            return warm_start\n\n        # Add additional components to solution dictionary\n        if mdl_p[\"obtain_warm_start_variables\"] and 'VFT' in model_name:\n            warm_start = obtain_warm_start_variables()\n            for key in warm_start:\n                solution[key] = warm_start[key]\n\n        if printing:\n            timestamp = datetime.datetime.now().strftime('%B %d %Y %r')\n            print(f\"Model solved in {solve_time} seconds at {timestamp}. Pyomo reported objective value:\",\n                  solution['pyomo_obj_value'])\n\n        # Return solution dictionary\n        return solution\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.execute_solver","title":"<code>execute_solver(model, solver, mdl_p)</code>","text":"<p>Solves the Pyomo model with a progress bar if a time limit is specified.</p> <p>Args:     model (ConcreteModel): The Pyomo model to solve.     solver (SolverFactory): The solver instance.     mdl_p (dict): Dictionary of model parameters including solver config.</p> <p>Returns:     ConcreteModel: The solved model.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def execute_solver(model, solver, mdl_p):\n    \"\"\"\n    Solves the Pyomo model with a progress bar if a time limit is specified.\n\n    Args:\n        model (ConcreteModel): The Pyomo model to solve.\n        solver (SolverFactory): The solver instance.\n        mdl_p (dict): Dictionary of model parameters including solver config.\n\n    Returns:\n        ConcreteModel: The solved model.\n    \"\"\"\n    def print_progress_bar(duration, stop_event):\n        start_time = time.time()\n        bar_length = 40\n        while not stop_event.is_set():\n            elapsed = time.time() - start_time\n            percent = min(elapsed / duration, 0.99)\n            filled_len = int(bar_length * percent)\n            bar = '\u2588' * filled_len + '-' * (bar_length - filled_len)\n            eta = int(duration - elapsed) if elapsed &lt; duration else 1\n            sys.stdout.write(f'\\r\u23f3 Solver running: |{bar}| {percent*100:5.1f}% ETA: ~{eta}s ')\n            sys.stdout.flush()\n            time.sleep(1)\n        sys.stdout.write(f'\\r\u2705 Solver complete: |{\"\u2588\" * bar_length}| 100.0%              \\n')\n        sys.stdout.flush()\n\n    # If time limit is set, start the timer bar\n    if mdl_p.get(\"pyomo_max_time\"):\n        stop_event = threading.Event()\n        target_time = int(min(mdl_p[\"pyomo_max_time\"] * 1.05, mdl_p[\"pyomo_max_time\"] + 40))\n        thread = threading.Thread(target=print_progress_bar, args=(target_time, stop_event))\n        thread.start()\n\n    # Solve Model\n    try:\n        if mdl_p[\"pyomo_max_time\"] is not None:\n            if mdl_p[\"solver_name\"] == 'mindtpy':\n                solver.solve(model, time_limit=mdl_p[\"pyomo_max_time\"], tee=mdl_p['pyomo_tee'])\n                # mip_solver='cplex_persistent', nlp_solver='ipopt')\n            elif mdl_p[\"solver_name\"] == 'gurobi':\n                solver.solve(model, options={'TimeLimit': mdl_p[\"pyomo_max_time\"],\n                                             'IntFeasTol': 0.05}, tee=mdl_p['pyomo_tee'])\n            elif mdl_p[\"solver_name\"] == 'ipopt':\n                solver.options['max_cpu_time'] = mdl_p[\"pyomo_max_time\"]\n                solver.solve(model, tee=mdl_p['pyomo_tee'])\n            elif mdl_p[\"solver_name\"] == 'cbc':\n                solver.options['seconds'] = mdl_p[\"pyomo_max_time\"]\n                solver.solve(model, tee=mdl_p['pyomo_tee'])\n            elif mdl_p[\"solver_name\"] == 'baron':\n                solver.solve(model, options={'MaxTime': mdl_p[\"pyomo_max_time\"]}, tee=mdl_p['pyomo_tee'])\n            else:\n                solver.solve(model, tee=mdl_p['pyomo_tee'])\n        else:\n            if mdl_p[\"solver_name\"] == 'mindtpy':\n                model.pprint()\n                solver.solve(model, mip_solver='cplex_persistent', nlp_solver='ipopt', tee=mdl_p['pyomo_tee'])\n            else:\n                solver.solve(model, tee=mdl_p['pyomo_tee'])\n\n    finally:\n        if mdl_p.get(\"pyomo_max_time\"):\n            stop_event.set()\n            thread.join()\n\n    return model\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.vft_model_build","title":"<code>vft_model_build(instance, printing=False)</code>","text":"<p>Builds the VFT optimization model using pyomo.</p> <p>Parameters:     instance (object): Problem instance object.     printing (bool): Whether the procedure should print something. Default is False.</p> <p>Returns:     object: Pyomo model object.</p> <p>This function builds the VFT (Value Focused Thinking) optimization model using the Pyomo library. It takes a problem instance as input and returns the constructed model.</p> <p>The function performs the following steps: 1. Initializes the Pyomo model. 2. Adjusts certain parameters used in the model. 3. Defines and initializes the decision variables of the model. 4. Defines the objective function of the model. 5. Defines the constraints of the model.</p> <p>Parameter Adjustments: The function adjusts certain parameters related to the value function breakpoints and sets. These adjustments are necessary to account for the approximate model's capability of exceeding the normal domain. The adjusted parameters are stored in a new dictionary called 'q' for use in the model.</p> <p>Variable Definitions: The function defines the decision variables used in the model, including 'x' (main decision variable), 'f_value' (AFSC objective value), 'lam' (lambda and y variables for value functions), and 'y' (binary variable for line segments between breakpoints).</p> <p>Variable Adjustments: This function initializes the variables defined above if applicable (warm start has been determined) and fixes certain 'x' variables if necessary/applicable.</p> <p>Objective Function: The objective function of the model is to maximize the overall weighted sum of all VFT objectives. It combines the AFSC objective values and the cadet utility values based on their respective weights.</p> <p>Constraints: The function defines various constraints for the model, including the constraint that each cadet receives one and only one AFSC, the 5% cap on the total percentage of USAFA cadets allowed into certain AFSCs, the value function constraints linking the main methodology with the value function methodology, and optional decision-maker constraints.</p> <p>AFSC Objective Measure Constraints: The function adds AFSC objective measure constraints for each AFSC and objective. It calculates the objective measure components and adds linear value function constraints based on the measure and value functions.</p> <p>AFSC Value Constraints: Optional decision-maker constraints can be added to enforce minimum AFSC objective values. The function adds constraints to ensure that the weighted sum of AFSC objective values meets the specified minimum value for each AFSC.</p> <p>Cadet Value Constraints: Optional decision-maker constraints can be added to enforce minimum cadet utility values. The function adds constraints to ensure that the weighted sum of cadet utility values meets the specified minimum value for each cadet.</p> <p>AFSCs Overall Min Value Constraint: If a minimum overall value for AFSCs is specified, the function adds a constraint to ensure that the weighted sum of AFSC objective values meets the specified minimum value for all AFSCs.</p> <p>Note: The function assumes the availability of additional helper functions, such as 'add_objective_measure_constraint', which are used to add specific types of constraints to the model.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def vft_model_build(instance, printing=False):\n    \"\"\"\n    Builds the VFT optimization model using pyomo.\n\n    Parameters:\n        instance (object): Problem instance object.\n        printing (bool): Whether the procedure should print something. Default is False.\n\n    Returns:\n        object: Pyomo model object.\n\n    This function builds the VFT (Value Focused Thinking) optimization model using the Pyomo library. It takes a\n    problem instance as input and returns the constructed model.\n\n    The function performs the following steps:\n    1. Initializes the Pyomo model.\n    2. Adjusts certain parameters used in the model.\n    3. Defines and initializes the decision variables of the model.\n    4. Defines the objective function of the model.\n    5. Defines the constraints of the model.\n\n    Parameter Adjustments:\n    The function adjusts certain parameters related to the value function breakpoints and sets. These adjustments are\n    necessary to account for the approximate model's capability of exceeding the normal domain. The adjusted parameters\n    are stored in a new dictionary called 'q' for use in the model.\n\n    Variable Definitions:\n    The function defines the decision variables used in the model, including 'x' (main decision variable), 'f_value'\n    (AFSC objective value), 'lam' (lambda and y variables for value functions), and 'y' (binary variable for line\n    segments between breakpoints).\n\n    Variable Adjustments:\n    This function initializes the variables defined above if applicable (warm start has been determined) and fixes\n    certain 'x' variables if necessary/applicable.\n\n    Objective Function:\n    The objective function of the model is to maximize the overall weighted sum of all VFT objectives. It combines the\n    AFSC objective values and the cadet utility values based on their respective weights.\n\n    Constraints:\n    The function defines various constraints for the model, including the constraint that each cadet receives one and\n    only one AFSC, the 5% cap on the total percentage of USAFA cadets allowed into certain AFSCs, the value function\n    constraints linking the main methodology with the value function methodology, and optional decision-maker\n    constraints.\n\n    AFSC Objective Measure Constraints:\n    The function adds AFSC objective measure constraints for each AFSC and objective. It calculates the objective measure\n    components and adds linear value function constraints based on the measure and value functions.\n\n    AFSC Value Constraints:\n    Optional decision-maker constraints can be added to enforce minimum AFSC objective values. The function adds\n    constraints to ensure that the weighted sum of AFSC objective values meets the specified minimum value for each AFSC.\n\n    Cadet Value Constraints:\n    Optional decision-maker constraints can be added to enforce minimum cadet utility values. The function adds\n    constraints to ensure that the weighted sum of cadet utility values meets the specified minimum value for each cadet.\n\n    AFSCs Overall Min Value Constraint:\n    If a minimum overall value for AFSCs is specified, the function adds a constraint to ensure that the weighted sum of\n    AFSC objective values meets the specified minimum value for all AFSCs.\n\n    Note: The function assumes the availability of additional helper functions, such as 'add_objective_measure_constraint',\n    which are used to add specific types of constraints to the model.\n\n    \"\"\"\n\n    if printing:\n        print('Building VFT Model...')\n\n    # Build Model\n    m = ConcreteModel()\n\n    # Shorthand\n    p, vp, mdl_p = instance.parameters, instance.value_parameters, instance.mdl_p\n\n    # _________________________________PARAMETER ADJUSTMENTS_________________________________\n    def adjust_parameters():\n        \"\"\"\n        Function defined here to adjust certain parameters. The parameters adjusted here are the value function\n        breakpoint parameters (r, a, f^hat) and set (L) as well as the AFSC objective constraint min, max values since\n        they've been stored as strings (3, 6, for example) up until this point. These parameters are saved into a new\n        dictionary \"q\" for use in the model. This is done because the value function breakpoints need to be adjusted\n        due to the approximate model's capability of exceeding the normal domain, and I don't want it saved to \"vp\"\n        \"\"\"\n        # Written here, so I can reference it below (Keys \"r\" and \"L\" both use this)\n        r = [[len(vp['a'][j][k]) for k in vp['K']] for j in p['J']]\n\n        # New dictionary of parameters used in this main function (\"vft_model_build\") and in \"vft_model_solve\"\n        q = {\"r\": r,  # Number of breakpoints (bps) for objective k's function for AFSC j\n             \"L\": [[list(range(r[j][k])) for k in vp['K']] for j in p['J']],  # Set of breakpoints\n             \"a\": [[[vp['a'][j][k][l] for l in vp['L'][j][k]] for k in vp['K']] for j in p['J']],  # Measures of bps\n             \"f^hat\": [[[vp['f^hat'][j][k][l] for l in vp['L'][j][k]] for k in vp['K']] for j in\n                       p['J']]}  # Values of bps\n\n        # Loop through each AFSC\n        for j in p['J']:\n\n            # Loop through each objective for each AFSC\n            for k in vp['K^A'][j]:\n\n                # We need to add an extra breakpoint to effectively extend the domain\n                if instance.mdl_p[\"add_breakpoints\"]:\n                    # We add an extra breakpoint far along the x-axis with the same y value as the previous one\n                    last_a = q[\"a\"][j][k][q['r'][j][k] - 1]\n                    last_f = q[\"f^hat\"][j][k][q['r'][j][k] - 1]\n                    q[\"a\"][j][k].append(last_a * 2000)  # arbitrarily large number in the domain (x-space)\n                    q[\"f^hat\"][j][k].append(last_f)  # same AFSC objective \"y-value\" as previous one\n                    q[\"L\"][j][k].append(q['r'][j][k])  # add the new breakpoint index\n                    q['r'][j][k] += 1  # increase number of breakpoints by 1\n\n        # Convert to numpy arrays of lists\n        for key in [\"L\", \"r\", \"a\", \"f^hat\"]:\n            q[key] = np.array(q[key])\n\n        return q  # Return the new dictionary\n\n    q = adjust_parameters()  # Call the function\n\n    # _________________________________VARIABLE DEFINITIONS_________________________________\n    m = common_optimization_handling(m, p, vp, mdl_p)  # Define x along with additional functional constraints\n    m.f_value = Var(((j, k) for j in p['J'] for k in vp['K^A'][j]), within=NonNegativeReals)  # AFSC objective value\n    m.lam = Var(((j, k, l) for j in p['J'] for k in vp['K^A'][j] for l in q['L'][j, k]),\n                within=NonNegativeReals, bounds=(0, 1))  # Lambda and y variables for value functions\n    m.y = Var(((j, k, l) for j in p['J'] for k in vp['K^A'][j] for l in range(q['r'][j, k] - 1)), within=Binary)\n\n    def variable_adjustments(m):\n        \"\"\"\n        This function initializes the 4 variables defined above if applicable (warm start has been determined) and also\n        fixes certain x variables if necessary/applicable as well.\n        \"\"\"\n\n        # If we initialize variables\n        if instance.mdl_p[\"warm_start\"] is not None:\n\n            # For each cadet, for each AFSC that the cadet is eligible\n            for i in p['I']:\n                for j in p['J^E'][i]:\n                    # x: 1 if we assign cadet i to AFSC j; 0 otherwise\n                    m.x[i, j] = round(instance.mdl_p[\"warm_start\"]['x'][i, j])\n\n            # Loop through each AFSC objective for each AFSC\n            for j in p['J']:\n                for k in vp['K^A'][j]:\n\n                    # Value for AFSC j objective k  (Used in Constraint 20b in VFT thesis)\n                    m.f_value[j, k] = instance.mdl_p[\"warm_start\"]['f(measure)'][j, k]\n\n                    # Loop through each breakpoint for this AFSC objective value function\n                    for l in q['L'][j, k]:\n\n                        # % between breakpoint l and l + 1 that the measure for AFSC j objective k \"has yet to travel\"\n                        m.lam[j, k, l] = instance.mdl_p[\"warm_start\"]['lambda'][j, k, l]\n\n                        # There is one less \"y\" variable than lambda because this is for the line segments between bps\n                        if l &lt; q['r'][j, k] - 1:\n                            # 1 if AFSC j objective measure k is on line segment between breakpoints l and l + 1; 0 o/w\n                            m.y[j, k, l] = instance.mdl_p[\"warm_start\"]['y'][j, k, l]\n\n        # Return model (m)\n        return m\n\n    m = variable_adjustments(m)  # Call the function\n\n    # _________________________________OBJECTIVE FUNCTION_________________________________\n    if mdl_p['solve_extra_components']:\n\n        # Base/Training model extra components\n        m = base_training_model_handling(m, p, mdl_p)\n\n        def objective_function(m):  # Z^VFT (w/base/training revision on cadet_value)\n            \"\"\"\n            The objective function is to maximize \"Z\", the overall weighted sum of all VFT objectives\n            \"\"\"\n            return vp['afscs_overall_weight'] * np.sum(vp['afsc_weight'][j] * np.sum(\n                vp['objective_weight'][j, k] * m.f_value[j, k] for k in vp['K^A'][j]) for j in p['J']) + \\\n                   vp['cadets_overall_weight'] * np.sum(vp['cadet_weight'][i] * m.cadet_value[i] for i in p['I'])\n\n    else:\n\n        # AFSC-only objective function\n        def objective_function(m):  # Z^VFT (Definition of variable in written formulation)\n            \"\"\"\n            The objective function is to maximize \"Z\", the overall weighted sum of all VFT objectives\n            \"\"\"\n            return vp['afscs_overall_weight'] * np.sum(vp['afsc_weight'][j] * np.sum(\n                vp['objective_weight'][j, k] * m.f_value[j, k] for k in vp['K^A'][j]) for j in p['J']) + \\\n                   vp['cadets_overall_weight'] * np.sum(vp['cadet_weight'][i] * np.sum(\n                p['cadet_utility'][i, j] * m.x[i, j] for j in p['J^E'][i]) for i in p['I'])\n\n    m.objective = Objective(rule=objective_function, sense=maximize)\n\n    # ____________________________________CONSTRAINTS_____________________________________\n    pass  # Here so pycharm doesn't yell at me for the constraint line above\n\n    # Value Function Constraints: Linking main methodology with value function methodology...\n    m = initialize_value_function_constraint_lists(m)  # ...and then enforcing that methodology\n\n    # AFSC Value Constraints (Optional decision-maker constraints)\n    m.min_afsc_value_constraints = ConstraintList()\n\n    # AFSC Objective Measure Constraints (Optional decision-maker constraints)\n    m.measure_constraints = ConstraintList()\n\n    # Loop through all AFSCs to add AFSC objective measure constraints\n    for j in p['J']:\n\n        # Loop through all AFSC objectives\n        for k, objective in enumerate(vp['objectives']):\n\n            # Add AFSC objective measure value function \"functional\" constraints\n            if k in vp['K^A'][j]:\n\n                # Calculate AFSC objective measure components\n                measure, numerator = afccp.solutions.handling.calculate_objective_measure_matrix(\n                    m.x, j, objective, p, vp, approximate=instance.mdl_p['approximate'])\n\n                # Add Value Function constraints (for functionality)\n                m = add_objective_value_function_constraints(m, j, k, measure, q=q)\n\n                # Add AFSC objective measure constraint\n                if k in vp['K^C'][j]:\n                    m = add_objective_measure_constraint(m, j, k, measure, numerator, p, vp)\n\n        # AFSC value constraint\n        if vp['afsc_value_min'][j] != 0:\n            m.min_afsc_value_constraints.add(expr=np.sum(\n                vp['objective_weight'][j, k] * m.f_value[j, k] for k in vp['K^A'][j]) &gt;= vp['afsc_value_min'][j])\n\n    # AFSCs Overall Min Value\n    def afsc_min_value_constraint(m):\n        return vp['afscs_overall_value_min'] &lt;= np.sum(vp['afsc_weight'][j] * np.sum(\n            vp['objective_weight'][j, k] * m.f_value[j, k] for k in vp['K^A'][j]) for j in p['J'])\n\n    if vp['afscs_overall_value_min'] != 0:\n        m.afsc_min_value_constraint = Constraint(rule=afsc_min_value_constraint)\n\n    # Cadets Overall Min Value\n    def cadet_min_value_constraint(m):\n        return vp['cadets_overall_value_min'] &lt;= np.sum(vp['cadet_weight'][i] * np.sum(\n            p['cadet_utility'][i, j] * m.x[i, j] for j in p['J^E'][i]) for i in p['I'])\n\n    if vp['cadets_overall_value_min'] != 0:\n        m.cadet_min_value_constraint = Constraint(rule=cadet_min_value_constraint)\n\n    return m, q  # Return model and additional component dictionary\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.initialize_value_function_constraint_lists","title":"<code>initialize_value_function_constraint_lists(m)</code>","text":"<p>Initialize constraint lists for the value function methodology.</p> <p>This function sets up empty constraint lists in the Pyomo model to enforce the relationships between the primary methodology and the value function methodology. These constraints are used later when defining the value function constraints.</p> <p>The constraint lists initialized correspond to the following formulations:</p> <ul> <li><code>measure_vf_constraints</code> (20a): Ensures the measure is computed using a weighted sum.</li> <li><code>value_vf_constraints</code> (20b): Computes the value function as a weighted sum.</li> <li><code>lambda_y_constraint1</code> (20c): Ensures the first lambda variable is bounded by y.</li> <li><code>lambda_y_constraint2</code> (20d): Ensures intermediate lambda variables are bounded by y variables.</li> <li><code>lambda_y_constraint3</code> (20e): Ensures the last lambda variable is bounded by y.</li> <li><code>y_sum_constraint</code> (20f): Ensures the y variables sum to 1.</li> <li><code>lambda_sum_constraint</code> (20g): Ensures the lambda variables sum to 1.</li> <li><code>lambda_positive</code> (20h): Enforces non-negativity on lambda variables.</li> <li><code>f_value_positive</code>: Enforces non-negativity on the AFSC objective value.</li> </ul> <p>Args:     m (ConcreteModel): The Pyomo model to which the constraint lists will be added.</p> <p>Returns:     ConcreteModel: The updated Pyomo model with initialized constraint lists.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def initialize_value_function_constraint_lists(m):\n    \"\"\"\n    Initialize constraint lists for the value function methodology.\n\n    This function sets up empty constraint lists in the Pyomo model to enforce the relationships\n    between the primary methodology and the value function methodology. These constraints\n    are used later when defining the value function constraints.\n\n    The constraint lists initialized correspond to the following formulations:\n\n    - `measure_vf_constraints` (20a): Ensures the measure is computed using a weighted sum.\n    - `value_vf_constraints` (20b): Computes the value function as a weighted sum.\n    - `lambda_y_constraint1` (20c): Ensures the first lambda variable is bounded by y.\n    - `lambda_y_constraint2` (20d): Ensures intermediate lambda variables are bounded by y variables.\n    - `lambda_y_constraint3` (20e): Ensures the last lambda variable is bounded by y.\n    - `y_sum_constraint` (20f): Ensures the y variables sum to 1.\n    - `lambda_sum_constraint` (20g): Ensures the lambda variables sum to 1.\n    - `lambda_positive` (20h): Enforces non-negativity on lambda variables.\n    - `f_value_positive`: Enforces non-negativity on the AFSC objective value.\n\n    Args:\n        m (ConcreteModel): The Pyomo model to which the constraint lists will be added.\n\n    Returns:\n        ConcreteModel: The updated Pyomo model with initialized constraint lists.\n    \"\"\"\n\n    # Value Function Constraints: Linking main methodology with value function methodology\n    m.measure_vf_constraints = ConstraintList()  # 20a in Thesis\n    m.value_vf_constraints = ConstraintList()  # 20b in Thesis\n\n    # Value Function Constraints: Functional constraints enforcing the relationship above\n    m.lambda_y_constraint1 = ConstraintList()  # 20c in Thesis\n    m.lambda_y_constraint2 = ConstraintList()  # 20d in Thesis\n    m.lambda_y_constraint3 = ConstraintList()  # 20e in Thesis\n    m.y_sum_constraint = ConstraintList()  # 20f in Thesis\n    m.lambda_sum_constraint = ConstraintList()  # 20g in Thesis\n    m.lambda_positive = ConstraintList()  # Lambda domain (20h)\n    m.f_value_positive = ConstraintList()  # AFSC objective value domain\n\n    # Return updated model\n    return m\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.add_objective_measure_constraint","title":"<code>add_objective_measure_constraint(m, j, k, measure, numerator, p, vp)</code>","text":"<p>Add an objective measure constraint to the model.</p> <p>This function takes the model (m), AFSC index (j), objective, objective measure, numerator of the function, problem parameters (p), and value parameters (vp) as inputs. It adds a constraint to the constraint list of the model based on the given objective measure.</p> <p>For objectives related to the number of cadets (such as Combined Quota, USAFA Quota, ROTC Quota), the minimum and maximum values of the measure are directly enforced.</p> <p>For objectives with constrained approximate measures, the function checks whether the constrained minimum number of cadets is lower than the Program Guidance Letter (PGL). If the constrained minimum is below the PGL, the objective constraint is based on that minimum value, otherwise, it is based on the PGL target.</p> <p>For objectives with constrained exact measures, the constraint is directly based on the minimum and maximum values multiplied by the count of cadets for the AFSC. (Numerator / Count) -&gt; Objective Measure</p> <p>Args:     m (ConcreteModel): The Pyomo model to which the constraint will be added.     j (int): The index of the AFSC.     k (int): The index of the objective.     measure (Expression): The objective measure.     numerator (Expression): The numerator of the objective measure function.     p (dict): The problem parameters.     vp (dict): The value parameters.</p> <p>Returns:     ConcreteModel: The updated Pyomo model with the objective measure constraint added.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def add_objective_measure_constraint(m, j, k, measure, numerator, p, vp):\n    \"\"\"\n    Add an objective measure constraint to the model.\n\n    This function takes the model (m), AFSC index (j), objective, objective measure, numerator of the function,\n    problem parameters (p), and value parameters (vp) as inputs. It adds a constraint to the constraint list of the model\n    based on the given objective measure.\n\n    For objectives related to the number of cadets (such as Combined Quota, USAFA Quota, ROTC Quota), the minimum and\n    maximum values of the measure are directly enforced.\n\n    For objectives with constrained approximate measures, the function checks whether the constrained minimum number\n    of cadets is lower than the Program Guidance Letter (PGL). If the constrained minimum is below the PGL, the\n    objective constraint is based on that minimum value, otherwise, it is based on the PGL target.\n\n    For objectives with constrained exact measures, the constraint is directly based on the minimum and maximum values\n    multiplied by the count of cadets for the AFSC. (Numerator / Count) -&gt; Objective Measure\n\n    Args:\n        m (ConcreteModel): The Pyomo model to which the constraint will be added.\n        j (int): The index of the AFSC.\n        k (int): The index of the objective.\n        measure (Expression): The objective measure.\n        numerator (Expression): The numerator of the objective measure function.\n        p (dict): The problem parameters.\n        vp (dict): The value parameters.\n\n    Returns:\n        ConcreteModel: The updated Pyomo model with the objective measure constraint added.\n    \"\"\"\n\n    # Get count variables for this AFSC\n    count = np.sum(m.x[i, j] for i in p['I^E'][j])\n\n    try:\n        # \"Number of Cadets\" objectives handled separately\n        if vp['objectives'][k] in ['Combined Quota', 'USAFA Quota', 'ROTC Quota', 'OTS Quota']:\n            m.measure_constraints.add(expr=measure &gt;= vp[\"objective_min\"][j, k])\n            m.measure_constraints.add(expr=measure &lt;= vp[\"objective_max\"][j, k])\n\n        else:\n            # Constrained Approximate Measure\n            if vp['constraint_type'][j, k] == 1:\n\n                # Take the smallest value between the PGL and constrained minimum number for this constraint\n                m.measure_constraints.add(\n                    expr=numerator - vp[\"objective_min\"][j, k] * min(p[\"pgl\"][j], p['quota_min'][j]) &gt;= 0)\n                m.measure_constraints.add(\n                    expr=numerator - vp[\"objective_max\"][j, k] * min(p[\"pgl\"][j], p['quota_min'][j]) &lt;= 0)\n\n            # Constrained Exact Measure\n            elif vp['constraint_type'][j, k] == 2:\n                m.measure_constraints.add(expr=numerator - vp[\"objective_min\"][j, k] * count &gt;= 0)\n                m.measure_constraints.add(expr=numerator - vp[\"objective_max\"][j, k] * count &lt;= 0)\n\n    except Exception as error:\n\n        print(\"AFSC '\" + p['afscs'][j] + \"' Objective '\" + vp['objectives'][k] + \" constraint failed to add.\")\n        print(\"Exception:\", error)\n\n    # Return updated model\n    return m\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.add_objective_value_function_constraints","title":"<code>add_objective_value_function_constraints(m, j, k, measure, q)</code>","text":"<p>Add linear value function constraints to the Pyomo model.</p> <p>This function incorporates constraints related to the value function into the Pyomo optimization model. These constraints ensure that the measure and value function constraints are properly enforced, the lambda variables are bounded by y variables, and that summation and positivity constraints hold.</p> <p>The constraints implemented correspond to the following formulations:</p> <ul> <li>Measure Constraint (20a): Ensures the measure is computed as a weighted sum of coefficients.</li> <li>Value Function Constraint (20b): Computes the value function as a weighted sum of given parameters.</li> <li>Lambda-Y Constraints (20c, 20d, 20e): Enforce relationships between lambda and y variables.</li> <li>Y Summation Constraint (20f): Ensures the sum of y values equals 1.</li> <li>Lambda Summation Constraint (20g): Ensures the sum of lambda values equals 1.</li> <li>Lambda and Value Function Positivity Constraints (20h): Enforces non-negativity of lambda and the value function.</li> </ul> <p>Args:     m (ConcreteModel): The Pyomo model to which the constraints will be added.     j (int): The index representing the AFSC.     k (int): The index representing the objective.     measure (Expression): The measure variable in the value function.     q (dict): A dictionary containing problem parameters, including:         - 'a': Coefficients for the measure function.         - 'f^hat': Coefficients for the value function.         - 'L': Set of lambda indices.         - 'r': The range parameter defining the number of lambda variables.</p> <p>Returns:     ConcreteModel: The updated Pyomo model with the value function constraints added.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def add_objective_value_function_constraints(m, j, k, measure, q):\n    \"\"\"\n    Add linear value function constraints to the Pyomo model.\n\n    This function incorporates constraints related to the value function into the Pyomo optimization model.\n    These constraints ensure that the measure and value function constraints are properly enforced, the lambda\n    variables are bounded by y variables, and that summation and positivity constraints hold.\n\n    The constraints implemented correspond to the following formulations:\n\n    - Measure Constraint (20a): Ensures the measure is computed as a weighted sum of coefficients.\n    - Value Function Constraint (20b): Computes the value function as a weighted sum of given parameters.\n    - Lambda-Y Constraints (20c, 20d, 20e): Enforce relationships between lambda and y variables.\n    - Y Summation Constraint (20f): Ensures the sum of y values equals 1.\n    - Lambda Summation Constraint (20g): Ensures the sum of lambda values equals 1.\n    - Lambda and Value Function Positivity Constraints (20h): Enforces non-negativity of lambda and the value function.\n\n    Args:\n        m (ConcreteModel): The Pyomo model to which the constraints will be added.\n        j (int): The index representing the AFSC.\n        k (int): The index representing the objective.\n        measure (Expression): The measure variable in the value function.\n        q (dict): A dictionary containing problem parameters, including:\n            - 'a': Coefficients for the measure function.\n            - 'f^hat': Coefficients for the value function.\n            - 'L': Set of lambda indices.\n            - 'r': The range parameter defining the number of lambda variables.\n\n    Returns:\n        ConcreteModel: The updated Pyomo model with the value function constraints added.\n    \"\"\"\n\n    # Add Linear Value Function Constraints\n    m.measure_vf_constraints.add(expr=measure == np.sum(  # Measure Constraint for Value Function (20a)\n        q['a'][j, k][l] * m.lam[j, k, l] for l in q['L'][j, k]))\n    m.value_vf_constraints.add(expr=m.f_value[j, k] == np.sum(  # Value Constraint for Value Function (20b)\n        q['f^hat'][j, k][l] * m.lam[j, k, l] for l in q['L'][j, k]))\n\n    # Lambda .. y constraints (20c, 20d, 20e)\n    m.lambda_y_constraint1.add(expr=m.lam[j, k, 0] &lt;= m.y[j, k, 0])  # (20c)\n    if q['r'][j, k] &gt; 2:\n        for l in range(1, q['r'][j, k] - 1):\n            m.lambda_y_constraint2.add(expr=m.lam[j, k, l] &lt;= m.y[j, k, l - 1] + m.y[j, k, l])  # (20d)\n    m.lambda_y_constraint3.add(expr=m.lam[j, k, q['r'][j, k] - 1] &lt;= m.y[j, k, q['r'][j, k] - 2])  # (20e)\n\n    # Y sum to 1 constraint (20f)\n    m.y_sum_constraint.add(expr=np.sum(m.y[j, k, l] for l in range(0, q['r'][j, k] - 1)) == 1)\n\n    # Lambda sum to 1 constraint (20g)\n    m.lambda_sum_constraint.add(expr=np.sum(m.lam[j, k, l] for l in q['L'][j, k]) == 1)\n\n    # Lambda .. value positive constraint (20h) although the \"f_value\" constraint is implied in the thesis\n    for l in q['L'][j, k]:\n        m.lambda_positive.add(expr=m.lam[j, k, l] &gt;= 0)\n    m.f_value_positive.add(expr=m.f_value[j, k] &gt;= 0)\n\n    # Return updated model\n    return m\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.base_training_model_handling","title":"<code>base_training_model_handling(m, p, mdl_p)</code>","text":"<p>Adds optimization model components to handle base and training (IST) assignments.</p> <p>Parameters: m (ConcreteModel): The Pyomo ConcreteModel instance to which the optimization model components will be added. p (dict): A dictionary containing problem data, including cadet, base, course, utility, and weight information. mdl_p (dict): A dictionary containing model-specific parameters and configurations.</p> <p>Returns: ConcreteModel: The modified Pyomo ConcreteModel instance with added optimization model components.</p> <p>Notes: - This function extends the given Pyomo ConcreteModel (m) by adding optimization model components to handle base and   training (IST) assignments for cadets. - The parameters are as follows:     - m: The Pyomo ConcreteModel instance to be extended.     - p: A dictionary containing various problem data, such as cadet information, base information, course       information, utility values, and weight information.     - mdl_p: A dictionary containing model-specific parameters and configurations. - The added optimization model components include variables and constraints to handle cadet assignments to bases,   courses, and values based on utility outcomes and constraints to ensure that assigned bases and courses do not   exceed their capacities. - Cadet assignments are modeled using binary variables (v and q), which represent assignments to bases and courses,   respectively. - Constraints are formulated to ensure cadet value calculations based on cadet states, base assignments, course   assignments, and utility values. - Additionally, constraints ensure that cadet assignments to bases and courses do not exceed base and course   capacities.</p> <p>Note: The given ConcreteModel (m) is modified in-place and returned for further use.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def base_training_model_handling(m, p, mdl_p):\n    \"\"\"\n    Adds optimization model components to handle base and training (IST) assignments.\n\n    Parameters:\n    m (ConcreteModel): The Pyomo ConcreteModel instance to which the optimization model components will be added.\n    p (dict): A dictionary containing problem data, including cadet, base, course, utility, and weight information.\n    mdl_p (dict): A dictionary containing model-specific parameters and configurations.\n\n    Returns:\n    ConcreteModel: The modified Pyomo ConcreteModel instance with added optimization model components.\n\n    Notes:\n    - This function extends the given Pyomo ConcreteModel (m) by adding optimization model components to handle base and\n      training (IST) assignments for cadets.\n    - The parameters are as follows:\n        - m: The Pyomo ConcreteModel instance to be extended.\n        - p: A dictionary containing various problem data, such as cadet information, base information, course\n          information, utility values, and weight information.\n        - mdl_p: A dictionary containing model-specific parameters and configurations.\n    - The added optimization model components include variables and constraints to handle cadet assignments to bases,\n      courses, and values based on utility outcomes and constraints to ensure that assigned bases and courses do not\n      exceed their capacities.\n    - Cadet assignments are modeled using binary variables (v and q), which represent assignments to bases and courses,\n      respectively.\n    - Constraints are formulated to ensure cadet value calculations based on cadet states, base assignments, course\n      assignments, and utility values.\n    - Additionally, constraints ensure that cadet assignments to bases and courses do not exceed base and course\n      capacities.\n\n    Note: The given ConcreteModel (m) is modified in-place and returned for further use.\n    \"\"\"\n\n    # Define the v and q-variables\n    m.v = Var(((i, b) for i in p['I'] for b in p['B^E'][i]), within=Binary)\n    m.q = Var(((i, j, c) for i in p['I'] for j in p['J^E'][i] for c in p['C^E'][i][j]), within=Binary)\n\n    # Define the new cadet value variable\n    m.cadet_value = Var((i for i in p['I']), within=NonNegativeReals, bounds=(0, 1))\n\n    # Cadet Value Constraints. Define what the \"cadet_value\" variable should be based on which \"state\" the cadet is in.\n    m.bc_cadet_value_constraints = ConstraintList()\n    for i in p['I']:\n        for d in p['D'][i]:\n\n            # Calculate auxiliary variables for AFSC, base, course utility outcomes\n            u = {\n                'A': (1 / p['u^S'][i][d]) * np.sum(p['cadet_utility'][i, j] * m.x[i, j] for j in p['J^State'][i][d]),\n                'C': np.sum(np.sum(\n                    p['course_utility'][i][j][c] * m.q[i, j, c] for c in p['C^E'][i][j]) for j in p['J^State'][i][d])\n            }\n\n            # Weighted sum of cadet utilities in each area depends on if bases are involved\n            if len(p['B^State'][i][d]) &gt; 0:\n                u['B'] = np.sum(p['base_utility'][i, b] * m.v[i, b] for b in p['B^State'][i][d])\n                weighted_sum = p['w^A'][i][d] * u['A'] + p['w^B'][i][d] * u['B'] + p['w^C'][i][d] * u['C']\n            else:\n                weighted_sum = p['w^A'][i][d] * u['A'] + p['w^C'][i][d] * u['C']\n\n            # This is the base/course state cadet value constraint. It ensures cadet_value will be the right value\n            m.bc_cadet_value_constraints.add(expr=m.cadet_value[i] &lt;= p['u^S'][i][d] * weighted_sum +\n                                                  mdl_p['BIG M'] * (1 - np.sum(m.x[i, j] for j in p['J^State'][i][d])))\n\n    # Cadet Base Constraints. If a cadet is assigned to a base, it has to be one that the AFSC is located at\n    m.bc_cadet_base_constraints = ConstraintList()\n    for i in p['I']:\n        m.bc_cadet_base_constraints.add(expr=np.sum(m.v[i, b] for b in p['B^E'][i]) ==\n                                             np.sum(m.x[i, j] for j in np.intersect1d(p['J^E'][i], p['J^B'])))\n        for j in np.intersect1d(p['J^B'], p['J^E'][i]):\n            m.bc_cadet_base_constraints.add(expr=m.x[i, j] &lt;= np.sum(m.v[i, b] for b in p['B^A'][j]))\n\n    # Cadet Course Constraints. Cadets have to be assigned to a course for their designated AFSC\n    m.bc_cadet_course_constraints = ConstraintList()\n    for i in p['I']:\n        for j in p['J^E'][i]:\n            m.bc_cadet_course_constraints.add(expr=m.x[i, j] == np.sum(m.q[i, j, c] for c in p['C^E'][i][j]))\n\n    # Base Capacity Constraints. A base/AFSC pair cannot exceed its capacity\n    m.bc_base_capacity_constraints = ConstraintList()\n    for j in p['J^B']:\n        for b in p['B^A'][j]:\n            m.bc_base_capacity_constraints.add(expr=np.sum(m.v[i, b] for i in p['I^E'][j]) &lt;= p['hi^B'][j][b])\n            m.bc_base_capacity_constraints.add(expr=np.sum(m.v[i, b] for i in p['I^E'][j]) &gt;= p['lo^B'][j][b])\n\n    # Course Capacity Constraints. A course/AFSC pair cannot exceed its capacity\n    m.bc_course_capacity_constraints = ConstraintList()\n    for j in p['J']:\n        for c in p['C'][j]:\n            m.bc_course_capacity_constraints.add(expr=np.sum(m.q[i, j, c] for i in p['I^A'][j][c]) &lt;= p['hi^C'][j][c])\n            m.bc_course_capacity_constraints.add(expr=np.sum(m.q[i, j, c] for i in p['I^A'][j][c]) &gt;= p['lo^C'][j][c])\n\n    return m\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.bubble_chart_configuration_model","title":"<code>bubble_chart_configuration_model(b)</code>","text":"<p>Builds a Pyomo optimization model to determine the x and y coordinates of AFSC squares on a chart.</p>"},{"location":"reference/solutions/optimization/#solutions.optimization.bubble_chart_configuration_model--parameters","title":"Parameters:","text":"<p>b : dict     A dictionary containing configuration parameters for the model.     The dictionary should include the following key-value pairs:     - 'n^sorted' : numpy array         Sorted values of the AFSC sizes (cadet box sizes).     - 'M' : int         The number of AFSCs (cadet boxes).     - 'add_legend' : bool         Whether to include a legend box in the chart.     - 'simplified_model' : bool         Whether to use a simplified model without positional constraints.     - 'row_constraint' : bool         Whether to incorporate a row constraint for AFSCs.     - Additional bounds and constants used in the model.</p>"},{"location":"reference/solutions/optimization/#solutions.optimization.bubble_chart_configuration_model--returns","title":"Returns:","text":"<p>m : ConcreteModel     The constructed Pyomo ConcreteModel instance representing the optimization model.</p>"},{"location":"reference/solutions/optimization/#solutions.optimization.bubble_chart_configuration_model--notes","title":"Notes:","text":"<p>This function creates an optimization model to determine the x and y coordinates of AFSC squares (cadet boxes) on a chart. The objective is to maximize the size of the cadet boxes, which are represented by the variable 'm.s'. The model seeks to find an optimal placement of the AFSC squares while satisfying various constraints. The specific constraints and objective function formulation depend on the configuration parameters provided in the 'b' dictionary.</p> <p>The function defines decision variables for the AFSC sizes ('m.s') and the x and y coordinates of each AFSC square ('m.x' and 'm.y'). Depending on the configuration parameters, additional variables for the legend box and positional relationships between AFSCs may be included.</p> <p>Constraints are added to ensure that the AFSC squares stay within the chart borders, avoid overlapping with the legend box (if present), and meet any specified row constraints. The constraints vary based on whether the simplified model or the full model with positional relationships between AFSCs is used.</p> <p>The objective function aims to maximize the size of the cadet boxes ('m.s'), representing the objective of maximizing the visual prominence of each AFSC on the chart.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def bubble_chart_configuration_model(b):\n    \"\"\"\n    Builds a Pyomo optimization model to determine the x and y coordinates of AFSC squares on a chart.\n\n    Parameters:\n    -----------\n    b : dict\n        A dictionary containing configuration parameters for the model.\n        The dictionary should include the following key-value pairs:\n        - 'n^sorted' : numpy array\n            Sorted values of the AFSC sizes (cadet box sizes).\n        - 'M' : int\n            The number of AFSCs (cadet boxes).\n        - 'add_legend' : bool\n            Whether to include a legend box in the chart.\n        - 'simplified_model' : bool\n            Whether to use a simplified model without positional constraints.\n        - 'row_constraint' : bool\n            Whether to incorporate a row constraint for AFSCs.\n        - Additional bounds and constants used in the model.\n\n    Returns:\n    --------\n    m : ConcreteModel\n        The constructed Pyomo ConcreteModel instance representing the optimization model.\n\n    Notes:\n    ------\n    This function creates an optimization model to determine the x and y coordinates of AFSC squares (cadet boxes)\n    on a chart. The objective is to maximize the size of the cadet boxes, which are represented by the variable 'm.s'.\n    The model seeks to find an optimal placement of the AFSC squares while satisfying various constraints.\n    The specific constraints and objective function formulation depend on the configuration parameters provided in the 'b' dictionary.\n\n    The function defines decision variables for the AFSC sizes ('m.s') and the x and y coordinates of each AFSC square ('m.x' and 'm.y').\n    Depending on the configuration parameters, additional variables for the legend box and positional relationships between AFSCs may be included.\n\n    Constraints are added to ensure that the AFSC squares stay within the chart borders, avoid overlapping with the legend box (if present),\n    and meet any specified row constraints. The constraints vary based on whether the simplified model or the full model with positional\n    relationships between AFSCs is used.\n\n    The objective function aims to maximize the size of the cadet boxes ('m.s'), representing the objective of maximizing the visual prominence\n    of each AFSC on the chart.\n    \"\"\"\n\n    # Initialize Model\n    m = ConcreteModel()  # Concrete model allows native numpy/python objects\n    n = b['n^sorted']  # Number of squares on edge of AFSC box (use sorted AFSCs)\n    J = np.arange(b['M'])  # Use sorted AFSCs!\n    M = len(J)\n\n    # ______________________________VARIABLE DEFINITIONS________________________________________________________\n    m.s = Var(within=NonNegativeReals)  # Size of the cadet boxes (AFSC objective value)\n    m.x = Var((j for j in J), within=NonNegativeReals)  # X coordinate of bottom left corner of AFSC j box\n    m.y = Var((j for j in J), within=NonNegativeReals)  # Y coordinate of bottom left corner of AFSC j box\n    m.q = Var((j for j in np.arange(1, M)), within=Binary)  # 1 if AFSC j is below AFSC j - 1, 0 otherwise\n\n    # ______________________________OBJECTIVE FUNCTION__________________________________________________________\n    def objective_function(m):\n        return m.s  # Objective is to maximize the size of the cadet boxes!\n\n    m.objective = Objective(rule=objective_function, sense=maximize)\n\n    # ____________________________________CONSTRAINTS___________________________________________________________\n    # Loop through each AFSC to add the border constraints\n    m.border_constraints = ConstraintList()  # List of constraints that enforce AFSCs to stay within the borders\n    m.border_constraints.add(expr=m.x[0] &lt;= b['bw^l'])  # Pin the first AFSC to the left\n    for j in J:\n        m.border_constraints.add(expr=m.x[j] &gt;= b['bw^l'])  # Left Border\n        m.border_constraints.add(expr=m.x[j] + m.s * n[j] &lt;= b['fw'] - b['bw^r'])  # Right Border\n        m.border_constraints.add(expr=m.y[j] &gt;= b['bw^b'])  # Bottom Border\n        m.border_constraints.add(expr=m.y[j] + m.s * n[j] &lt;= b['fh'] - b['bw^t'])  # Top Border\n\n    # Loop through each AFSC (after the first one) to add the grid constraints\n    m.grid_constraints = ConstraintList()  # List of constraints that line up AFSCs in a nice grid\n    for j in np.arange(1, M):\n        m.grid_constraints.add(expr=m.y[j] &lt;= m.y[j - 1] - (m.s * n[j] + b['abw^ud']) * m.q[j])\n        m.grid_constraints.add(expr=m.y[j] &gt;= m.y[j - 1] * (1 - m.q[j]))\n        m.grid_constraints.add(expr=m.x[j] &gt;= (m.x[j - 1] + m.s * n[j - 1] + b['abw^lr']) * (1 - m.q[j]))\n        m.grid_constraints.add(expr=m.x[j] &lt;= b['bw^l'] * m.q[j] +\n                                    (m.x[j - 1] + m.s * n[j - 1] + b['abw^lr']) * (1 - m.q[j]))\n    return m\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.gp_model_build","title":"<code>gp_model_build(instance, printing=False)</code>","text":"<p>Builds Rebecca's goal programming (GP) model using the provided problem instance.</p> <p>Args:     instance (object): The problem instance to solve.     printing (bool, optional): Specifies whether to print status updates during model building. Default is False.</p> <p>Returns:     pyomo.core.base.PyomoModel.ConcreteModel: The constructed Pyomo model.</p> <p>Raises:     None</p> <p>Detailed Description:     This function builds the GP model according to Rebecca's goal programming formulation using the provided problem instance.     The model incorporates Rebecca's parameters and constructs the necessary variables, objective function, and constraints.</p> <pre><code>The function iterates over each constraint and AFSC to create the decision variables, penalty variables, and reward variables.\nIt defines the main objective function that represents the overall goal programming problem.\nAdditionally, it defines penalty and reward specific objective functions to obtain raw penalties and rewards.\n\nThe function also constructs various constraints related to AFSC assignments, penalty terms, and reward terms.\n</code></pre> <p>Parameter Details:     - instance (object): The problem instance to solve. It should contain the following attributes:         - gp_parameters (dict): The GP parameters, including the constraint terms, utility values, and sets.         - mdl_p (dict): Additional model parameters, including the current constraint term and the reward/penalty flag.     - printing (bool, optional): Specifies whether to print status updates during model building. Default is False.</p> <p>Returns:     - model (pyomo.core.base.PyomoModel.ConcreteModel): The constructed Pyomo model representing the GP problem.</p> <p>Note:     The function assumes that the necessary libraries and packages (such as NumPy) are imported.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def gp_model_build(instance, printing=False):\n    \"\"\"\n    Builds Rebecca's goal programming (GP) model using the provided problem instance.\n\n    Args:\n        instance (object): The problem instance to solve.\n        printing (bool, optional): Specifies whether to print status updates during model building. Default is False.\n\n    Returns:\n        pyomo.core.base.PyomoModel.ConcreteModel: The constructed Pyomo model.\n\n    Raises:\n        None\n\n    Detailed Description:\n        This function builds the GP model according to Rebecca's goal programming formulation using the provided problem instance.\n        The model incorporates Rebecca's parameters and constructs the necessary variables, objective function, and constraints.\n\n        The function iterates over each constraint and AFSC to create the decision variables, penalty variables, and reward variables.\n        It defines the main objective function that represents the overall goal programming problem.\n        Additionally, it defines penalty and reward specific objective functions to obtain raw penalties and rewards.\n\n        The function also constructs various constraints related to AFSC assignments, penalty terms, and reward terms.\n\n    Parameter Details:\n        - instance (object): The problem instance to solve. It should contain the following attributes:\n            - gp_parameters (dict): The GP parameters, including the constraint terms, utility values, and sets.\n            - mdl_p (dict): Additional model parameters, including the current constraint term and the reward/penalty flag.\n        - printing (bool, optional): Specifies whether to print status updates during model building. Default is False.\n\n    Returns:\n        - model (pyomo.core.base.PyomoModel.ConcreteModel): The constructed Pyomo model representing the GP problem.\n\n    Note:\n        The function assumes that the necessary libraries and packages (such as NumPy) are imported.\n    \"\"\"\n\n    if printing:\n        print('Building GP Model...')\n\n    # Shorthand\n    gp = instance.gp_parameters\n    mdl_p = instance.mdl_p\n\n    # Create model\n    m = ConcreteModel()\n\n    # ___________________________________VARIABLE DEFINITIONS_________________________________\n    m.x = Var(((c, a) for c in gp['C'] for a in gp['A^']['E'][c]), within=Binary)\n\n    # Amount by which the constraint is not met\n    m.Y = Var(((con, a) for con in gp['con'] for a in gp['A^'][con]), within=NonNegativeReals)\n\n    # Amount by which the constraint is exceeded\n    m.Z = Var(((con, a) for con in gp['con'] for a in gp['A^'][con]), within=NonNegativeReals)\n\n    # Binary variable indicating if Y is used (1) or if Z is used (0)\n    m.alpha = Var(((con, a) for con in gp['con'] for a in gp['A^'][con]), within=Binary)\n\n    # ___________________________________OBJECTIVE FUNCTION___________________________________\n    def main_objective_function(m):\n        return np.sum(  # Sum across each constraint\n            np.sum(  # Sum across each AFSC with that constraint\n\n                # Calculate penalties and rewards for each necessary AFSC\n                gp['lam^'][con] * m.Z[con, a] - gp['mu^'][con] * m.Y[con, a] for a in gp['A^'][con]) for con in\n            gp['con']) + gp['lam^']['S'] * np.sum(  # Sum across every cadet\n            np.sum(  # Sum across each AFSC that the cadet is both eligible for and has placed a preference on\n\n                # Calculate utility that the cadet received  (for each preferred AFSC for each constraint)\n                gp['utility'][c, a] * m.x[c, a] for a in gp['A^']['W^E'][c]) for c in gp['C'])\n\n    def penalty_objective_function(m):\n        return np.sum(m.Y[mdl_p[\"con_term\"], a] for a in gp['A^'][mdl_p[\"con_term\"]])\n\n    def reward_objective_function(m):\n        if mdl_p[\"con_term\"] == 'S':\n            return np.sum(np.sum(gp['utility'][c, a] * m.x[c, a] for a in gp['A^']['W^E'][c]) for c in gp['C'])\n        else:\n            return np.sum(m.Z[mdl_p[\"con_term\"], a] for a in gp['A^'][mdl_p[\"con_term\"]])\n\n    # Define model objective function\n    if mdl_p[\"con_term\"] is not None:  # Reward/Penalty specific objective function to get raw rewards/penalties\n        if mdl_p[\"get_reward\"]:\n            m.objective = Objective(rule=reward_objective_function, sense=maximize)\n        else:\n            m.objective = Objective(rule=penalty_objective_function, sense=maximize)\n    else:  # Regular objective function\n        m.objective = Objective(rule=main_objective_function, sense=maximize)\n\n    # ___________________________________CONSTRAINTS______________________________________\n    pass\n\n    # Each Cadet gets one AFSC for which they're eligible\n    m.one_afsc_constraints = ConstraintList()\n    for c in gp['C']:\n        m.one_afsc_constraints.add(expr=np.sum(m.x[c, a] for a in gp['A^']['E'][c]) == 1)\n\n    m.con_constraints = ConstraintList()  # List of goal constraints (Each goal constraint for each AFSC)\n    m.Y_constraints = ConstraintList()  # List of Y/alpha constraints\n    m.Z_constraints = ConstraintList()  # List of Z/alpha constraints\n\n    # Loop through each \"goal\" constraint\n    for con in gp['con']:\n\n        # Loop through all AFSCs for this constraint\n        for a in gp['A^'][con]:\n\n            # Number of cadets assigned to this AFSC\n            count = np.sum(m.x[c, a] for c in gp['C^']['E'][a])\n\n            if con in ['R_under', 'R_over']:\n\n                # Sum of percentiles of cadets assigned to this AFSC\n                con_count = np.sum(gp['merit'][c] * m.x[c, a] for c in gp['C^'][con][a])\n            else:\n\n                # Number of cadets assigned to this AFSC that pertain to this constraint\n                con_count = np.sum(m.x[c, a] for c in gp['C^'][con][a])\n\n            # Parameter for this constraint for this AFSC\n            parameter = gp['param'][con][a]\n\n            if con == 'T':\n                m.con_constraints.add(expr=count == parameter - m.Y[con, a] + m.Z[con, a])\n            elif con == 'F':\n                m.con_constraints.add(expr=count == parameter + m.Y[con, a] - m.Z[con, a])\n            elif con in ['M', 'D_under', 'W', 'U_under', 'R_under']:\n                m.con_constraints.add(expr=con_count == parameter * count - m.Y[con, a] + m.Z[con, a])\n            else:  # ('D_over', 'P', 'U_over', 'R_over')\n                m.con_constraints.add(expr=con_count == parameter * count + m.Y[con, a] - m.Z[con, a])\n\n            # Y/alpha constraint\n            m.Y_constraints.add(expr=m.Y[con, a] &lt;= gp['Big_M'] * m.alpha[con, a])\n\n            # Z/alpha constraint\n            m.Z_constraints.add(expr=m.Z[con, a] &lt;= gp['Big_M'] * (1 - m.alpha[con, a]))\n\n    # If we have AFSCs that have specified a limit on the number of USAFA cadets\n    if len(gp['A^']['U_lim']) &gt; 0:\n        # Number of USAFA cadets assigned to AFSCs that have an upper limit on USAFA cadets\n        usafa_cadet_lim_afsc_count = np.sum(np.sum(m.x[c, a] for c in gp['C^']['U'][a]) for a in gp['A^']['U_lim'])\n\n        # Overall number of cadets assigned to AFSCs that have an upper limit on USAFA cadets\n        cadet_lim_afsc_count = np.sum(np.sum(m.x[c, a] for c in gp['C^']['E'][a]) for a in gp['A^']['U_lim'])\n\n        # USAFA upper limit constraint\n        def USAFA_Limit(model):\n            return usafa_cadet_lim_afsc_count &lt;= gp['u_limit'] * cadet_lim_afsc_count\n\n        m.usafa_limit_constraint = Constraint(rule=USAFA_Limit)\n\n    if printing:\n        print('Model built.')\n    return m\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.calculate_rewards_penalties","title":"<code>calculate_rewards_penalties(instance, printing=True)</code>","text":"<p>This function calculates the normalized penalties and rewards specific to an instance of Rebecca's goal programming (GP) model.</p> <p>Args:     instance (object): The problem instance to solve, which contains the GP parameters.     printing (bool, optional): Specifies whether to print status updates during the calculation. Default is True.</p> <p>Returns:     tuple: A tuple containing the normalized penalties and rewards as NumPy arrays.</p> <p>Detailed Description:     This function takes a set of Rebecca's goal programming parameters and returns the normalized penalties and     rewards specific to the given instance. The function iterates over each constraint in the GP parameters and     calculates the penalties and rewards using a GP model.</p> <pre><code>The GP model is built by initializing the necessary parameters and solving the model for each constraint.\nThe rewards are calculated by maximizing the objective function that represents the reward term, while the\npenalties are calculated by maximizing the objective function that represents the penalty term.\n\nThe function also calculates the reward term for the special constraint 'S' separately.\n</code></pre> <p>Parameter Details:     - instance (object): The problem instance to solve. It should contain the following attributes:         - gp_parameters (dict): The GP parameters, including the constraint terms, utility values, and sets.     - printing (bool, optional): Specifies whether to print status updates during the calculation. Default is True.</p> <p>Returns:     - rewards (numpy.ndarray): An array containing the normalized rewards for each constraint, including the reward     for constraint 'S'.     - penalties (numpy.ndarray): An array containing the normalized penalties for each constraint.</p> <p>Note:     The function assumes that the necessary functions 'gp_model_build' and 'solve_pyomo_model'     are defined and accessible.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def calculate_rewards_penalties(instance, printing=True):\n    \"\"\"\n    This function calculates the normalized penalties and rewards specific to an instance of\n    Rebecca's goal programming (GP) model.\n\n    Args:\n        instance (object): The problem instance to solve, which contains the GP parameters.\n        printing (bool, optional): Specifies whether to print status updates during the calculation. Default is True.\n\n    Returns:\n        tuple: A tuple containing the normalized penalties and rewards as NumPy arrays.\n\n    Detailed Description:\n        This function takes a set of Rebecca's goal programming parameters and returns the normalized penalties and\n        rewards specific to the given instance. The function iterates over each constraint in the GP parameters and\n        calculates the penalties and rewards using a GP model.\n\n        The GP model is built by initializing the necessary parameters and solving the model for each constraint.\n        The rewards are calculated by maximizing the objective function that represents the reward term, while the\n        penalties are calculated by maximizing the objective function that represents the penalty term.\n\n        The function also calculates the reward term for the special constraint 'S' separately.\n\n    Parameter Details:\n        - instance (object): The problem instance to solve. It should contain the following attributes:\n            - gp_parameters (dict): The GP parameters, including the constraint terms, utility values, and sets.\n        - printing (bool, optional): Specifies whether to print status updates during the calculation. Default is True.\n\n    Returns:\n        - rewards (numpy.ndarray): An array containing the normalized rewards for each constraint, including the reward\n        for constraint 'S'.\n        - penalties (numpy.ndarray): An array containing the normalized penalties for each constraint.\n\n    Note:\n        The function assumes that the necessary functions 'gp_model_build' and 'solve_pyomo_model'\n        are defined and accessible.\n    \"\"\"\n\n    # Shorthand\n    gp = instance.gp_parameters\n\n    # Initialize gp arrays\n    num_constraints = len(gp['con']) + 1\n    rewards = np.zeros(num_constraints)\n    penalties = np.zeros(num_constraints)\n\n    # Initialize model\n    instance.mdl_p[\"con_term\"] = gp['con'][0]  # Initialize constraint term\n    instance.mdl_p[\"get_reward\"] = True  # We want the reward term\n    instance.mdl_p[\"solve_time\"] = 60 * 4  # Don't want to be solving this thing for too long\n    model = gp_model_build(instance, printing=False)  # Build model\n\n    # Loop through each constraint\n    for c, con in enumerate(gp['con']):\n\n        # Set the constraint term\n        instance.mdl_p[\"con_term\"] = con\n\n        # Get reward term\n        def objective_function(m):\n            return np.sum(m.Z[con, a] for a in gp['A^'][con])\n\n        if printing:\n            print('')\n            print('Obtaining reward for constraint ' + con + '...')\n        model.objective = Objective(rule=objective_function, sense=maximize)\n        rewards[c] = solve_pyomo_model(instance, model, \"GP\")\n        if printing:\n            print('Reward:', rewards[c])\n\n        # Get penalty term\n        def objective_function(m):\n            return np.sum(m.Y[con, a] for a in gp['A^'][con])\n\n        if printing:\n            print('')\n            print('Obtaining penalty for constraint ' + con + '...')\n        model.objective = Objective(rule=objective_function, sense=maximize)\n        penalties[c] = solve_pyomo_model(instance, model, \"GP\")\n        if printing:\n            print('Penalty:', penalties[c])\n\n    # S reward term\n    def objective_function(m):\n        return np.sum(np.sum(gp['utility'][c, a] * m.x[c, a] for a in gp['A^']['W^E'][c]) for c in gp['C'])\n\n    if printing:\n        print('')\n        print('Obtaining reward for constraint S...')\n    model.objective = Objective(rule=objective_function, sense=maximize)\n    rewards[num_constraints - 1] = solve_pyomo_model(instance, model, \"GP\")\n    if printing:\n        print('Reward:', rewards[num_constraints - 1])\n\n    return rewards, penalties\n</code></pre>"},{"location":"reference/solutions/sensitivity/","title":"Sensitivity","text":""},{"location":"reference/solutions/sensitivity/#solutions.sensitivity","title":"<code>solutions.sensitivity</code>","text":""},{"location":"reference/solutions/sensitivity/#solutions.sensitivity.determine_model_constraints","title":"<code>determine_model_constraints(instance)</code>","text":"<p>Iteratively evaluate the VFT (Value Focussed Thinking) model by adding constraints until a feasible solution is obtained, in order of importance.</p> <p>This function takes a problem instance containing parameters and value parameters as input. It starts with no constraints activated and gradually adds constraints in order of their importance. The function builds and solves the VFT model at each constraint iteration, evaluating the feasibility and objective value of the solution. The process continues until all constraints have been considered.</p> <p>Args:     instance (ProblemInstance): An instance of the problem containing the problem parameters and value parameters.</p> <p>Returns:     A tuple containing:         - constraint_type (ndarray): The adjusted constraint type matrix, indicating the active constraints.         - solutions_df (DataFrame): A DataFrame with the solutions for different constraint iterations.         - report_df (DataFrame): A DataFrame containing the report of each constraint iteration, including information                                  about the solution, the new constraint applied, the objective value, and if the solution                                  failed or not.</p> Source code in <code>afccp/solutions/sensitivity.py</code> <pre><code>def determine_model_constraints(instance):\n    \"\"\"\n    Iteratively evaluate the VFT (Value Focussed Thinking) model by adding constraints until a feasible solution is obtained,\n    in order of importance.\n\n    This function takes a problem instance containing parameters and value parameters as input. It starts with no constraints\n    activated and gradually adds constraints in order of their importance. The function builds and solves the VFT model at each\n    constraint iteration, evaluating the feasibility and objective value of the solution. The process continues until all\n    constraints have been considered.\n\n    Args:\n        instance (ProblemInstance): An instance of the problem containing the problem parameters and value parameters.\n\n    Returns:\n        A tuple containing:\n            - constraint_type (ndarray): The adjusted constraint type matrix, indicating the active constraints.\n            - solutions_df (DataFrame): A DataFrame with the solutions for different constraint iterations.\n            - report_df (DataFrame): A DataFrame containing the report of each constraint iteration, including information\n                                     about the solution, the new constraint applied, the objective value, and if the solution\n                                     failed or not.\n    \"\"\"\n\n    # Shorthand\n    p, vp, ip = instance.parameters, copy.deepcopy(instance.value_parameters), instance.mdl_p\n\n    # Create a copy of the problem instance\n    adj_instance = copy.deepcopy(instance)  # \"Adjusted Instance\"\n    real_constraint_type = copy.deepcopy(vp[\"constraint_type\"])  # All constraints (Not 0s)\n\n    # Initially, we'll start with no constraints turned on\n    vp[\"constraint_type\"] = np.zeros([p[\"M\"], vp[\"O\"]])\n    vp['K^C'] = {j: np.array([]) for j in p['J']}\n    adj_instance.value_parameters = vp  # Set to instance\n\n    # Initialize Report\n    report_columns = [\"Solution\", \"New Constraint\", \"Objective Value\", \"Failed\"]\n    report = {col: [] for col in report_columns}\n\n    # Determine which model we're going to solve (either VFT or Assignment model)\n    if ip['constraint_model_to_use'] == 'VFT':\n        print(\"Initializing VFT Model Constraint Algorithm...\")\n\n        # Build the model\n        model, q = afccp.solutions.optimization.vft_model_build(adj_instance)\n        model_name, obj_metric = 'VFT', 'z'\n\n    else:  # Assignment model\n        print(\"Initializing Assignment Model Constraint Algorithm...\")\n\n        # Build the model\n        adj_instance.mdl_p['assignment_model_obj'] = 'Global Utility'  # Force the correct objective function\n        model, q = afccp.solutions.optimization.assignment_model_build(adj_instance), None\n        model_name, obj_metric = 'Assignment', 'z^gu'\n    print(\"Done. Solving model with no constraints active...\")\n\n    # Dictionary of solutions with different constraints!\n    current_solution = afccp.solutions.optimization.solve_pyomo_model(\n        adj_instance, model, model_name, q=q, printing=False)\n    solutions = {0: current_solution}\n    current_solution = afccp.solutions.handling.evaluate_solution(current_solution, p, vp)\n    afsc_solutions = {0: current_solution['afsc_array']}\n\n    # Add first solution to the report\n    report[\"Solution\"].append(0)\n    report[\"Objective Value\"].append(round(current_solution[obj_metric], 4))\n    report[\"New Constraint\"].append(\"None\")\n    report[\"Failed\"].append(0)\n    print(\"Done. New solution objective value:\", str(report[\"Objective Value\"][0]))\n\n    # Get importance \"list\" based on multiplied weight\n    afsc_weight = np.atleast_2d(vp[\"afsc_weight\"]).T  # Turns 1d array into 2d column\n    scaled_weights = afsc_weight * vp[\"objective_weight\"]\n    flat = np.ndarray.flatten(scaled_weights)  # flatten them\n    tuples = [(j, k) for j in range(p['M']) for k in range(vp['O'])]  # get a list of tuples (0, 0), (0, 1) etc.\n    tuples = np.array(tuples)\n    sort_flat = np.argsort(flat)[::-1]\n    importance_list = [(j, k) for (j, k) in tuples[sort_flat] if real_constraint_type[j, k] != 0]\n    num_constraints = len(importance_list)\n\n    # Begin the algorithm!\n    cons = 0\n    print(\"Running through \" + str(num_constraints) + \" total constraint iterations...\")\n    for (j, k) in importance_list:\n        afsc = p[\"afscs\"][j]\n        objective = vp[\"objectives\"][k]\n\n        # Make a copy of the model (In case we have to remove a constraint)\n        new_model = copy.deepcopy(model)\n\n        # Calculate AFSC objective measure components\n        measure, numerator = afccp.solutions.handling.calculate_objective_measure_matrix(\n            new_model.x, j, objective, p, vp, approximate=True)\n\n        # Add AFSC objective measure constraint\n        vp['constraint_type'][j, k] = copy.deepcopy(real_constraint_type[j, k])\n        new_model = afccp.solutions.optimization.add_objective_measure_constraint(\n            new_model, j, k, measure, numerator, p, vp)\n        num_measure_constraints = len(new_model.measure_constraints)\n\n        # Update constraint type within the problem instance\n        adj_instance.value_parameters['constraint_type'][j, k] = copy.deepcopy(real_constraint_type[j, k])\n\n        # Print message\n        cons += 1\n        print_str = \"\\n------[\" + str(cons) + \"] AFSC \" + afsc + \" Objective \" + objective\n        print_str += \"-\" * (55 - len(print_str))\n        print(print_str)\n\n        # Loop through each of the constraints to validate how many are on\n        num_activated = 0\n        for i in list(new_model.measure_constraints):\n            if new_model.measure_constraints[i].active:\n                num_activated += 1\n        print(\"Constraint\", cons, \"Active Constraints:\", int(num_measure_constraints / 2),\n                               \"Validated:\", int(num_activated / 2))\n\n        # Variable to determine the outcome of this iteration\n        feasible = True  # Assume model is feasible until proven otherwise\n\n        # We can skip the quota constraint (leave it on without solving)\n        if objective == \"Combined Quota\" and ip[\"skip_quota_constraint\"]:\n            print(\"Result: SKIPPED [Combined Quota]\")\n            solutions[cons] = copy.deepcopy(current_solution)\n            skipped_obj = True\n\n        # If our most current solution is already meeting this constraint, then we can skip this constraint\n        elif vp['objective_min'][j, k] &lt;= current_solution[\"objective_measure\"][j, k] &lt;= vp['objective_max'][j, k]:\n            print(\"Result: SKIPPED [Measure:\", str(round(current_solution[\"objective_measure\"][j, k], 2)) + \"], \",\n                  \"Range: (\" + str(vp['objective_min'][j, k]) +\",\", str(vp['objective_max'][j, k]) + \")\")\n            solutions[cons] = copy.deepcopy(current_solution)\n            skipped_obj = True\n\n        # We can't skip the constraint, so we solve it\n        else:\n            skipped_obj = False\n\n            # Solution Solved!\n            try:\n                solutions[cons] = copy.deepcopy(afccp.solutions.optimization.solve_pyomo_model(\n                    adj_instance, new_model, model_name, q=q, printing=False))\n\n            # Solution Failed :(\n            except:\n                solutions[cons] = copy.deepcopy(current_solution)\n                feasible = False\n\n        # Get solution information\n        current_solution = copy.deepcopy(solutions[cons])\n        current_solution = copy.deepcopy(afccp.solutions.handling.evaluate_solution(current_solution, p, vp))\n        afsc_solutions[cons] = copy.deepcopy(current_solution['afsc_array'])\n\n        # Add this solution to report\n        report[\"Solution\"].append(cons)\n        report[\"New Constraint\"].append(afsc + \" \" + objective)\n\n        if feasible:\n            report[\"Objective Value\"].append(round(current_solution[obj_metric], 4))\n            if not skipped_obj:\n                print(\"Result: SOLVED [Z = \" + str(report[\"Objective Value\"][cons]) + \"]\")\n            report[\"Failed\"].append(0)\n            model = copy.deepcopy(new_model)  # Save this model!\n\n        else:\n            print(\"Result: INFEASIBLE. Proceeding with next constraint.\")\n            report[\"Objective Value\"].append(0)\n            report[\"Failed\"].append(1)\n\n            # Update constraint type within the problem instance (Remove this constraint)\n            vp[\"constraint_type\"][j, k] = 0\n\n        # Measure it again\n        current_solution = copy.deepcopy(afccp.solutions.handling.evaluate_solution(current_solution, p, vp))\n\n        # Validate solution meets the constraints:\n        num_constraint_check = np.sum(vp[\"constraint_type\"] != 0)\n        print(\"Active Objective Measure Constraints:\", num_constraint_check)\n        print(\"Total Failed Constraints:\", int(current_solution[\"total_failed_constraints\"]))\n        print(\"Current Objective Measure:\", round(current_solution[\"objective_measure\"][j, k], 2), \"Range:\",\n              vp[\"objective_value_min\"][j, k])\n\n        for con_fail_str in current_solution[\"failed_constraints\"]:\n            print(\"Failed:\", con_fail_str)\n\n        # Check all other AFSC objectives to see if we're suddenly failing them now for some reason\n        c = 0\n        measure_fails = 0\n        while c &lt; cons:\n            j_1, k_1 = importance_list[c]\n            afsc_1, objective_1 = p[\"afscs\"][j_1], vp[\"objectives\"][k_1]\n            if current_solution[\"objective_measure\"][j_1, k_1] &gt; (vp['objective_max'][j_1, k_1] * 1.05) or \\\n                    current_solution[\"objective_measure\"][j_1, k_1] &lt; (vp['objective_min'][j_1, k_1] * 0.95):\n                print(\"Measure Fail:\", afsc_1, objective_1, \"Measure:\",\n                      round(current_solution[\"objective_measure\"][j_1, k_1], 2), \"Range:\",\n                      vp[\"objective_value_min\"][j_1, k_1])\n                measure_fails += 1\n            c += 1\n        print_str = \"-\" * 10 + \" Objective Measure Fails:\" + str(measure_fails)\n        print(print_str + \"-\" * (55 - len(print_str)))\n\n    # Build Report\n    solutions_df = pd.DataFrame(afsc_solutions)\n    report_df = pd.DataFrame(report)\n    return vp[\"constraint_type\"], solutions_df, report_df\n</code></pre>"},{"location":"reference/solutions/sensitivity/#solutions.sensitivity.populate_initial_ga_solutions_from_vft_model","title":"<code>populate_initial_ga_solutions_from_vft_model(instance, printing=True)</code>","text":"<p>This function takes a problem instance and creates several initial solutions for the genetic algorithm to evolve from</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <p>problem instance</p> required <code>printing</code> <p>whether to print something or not</p> <code>True</code> <p>Returns:</p> Type Description <p>initial population</p> Source code in <code>afccp/solutions/sensitivity.py</code> <pre><code>def populate_initial_ga_solutions_from_vft_model(instance, printing=True):\n    \"\"\"\n    This function takes a problem instance and creates several initial solutions for the genetic algorithm to evolve\n    from\n    :param instance: problem instance\n    :param printing: whether to print something or not\n    :return: initial population\n    \"\"\"\n\n    if printing:\n        print(\"Generating initial population of solutions for the genetic algorithm from the approximate VFT model...\")\n\n    # Load parameters/variables\n    p, vp = instance.parameters, copy.deepcopy(instance.value_parameters)\n    previous_estimate = p[\"quota_e\"]\n    initial_solutions = []\n\n    # We get our first round of solutions by iterating on the estimated number of cadets\n    if instance.mdl_p[\"iterate_from_quota\"]:\n\n        # Initialize variables\n        deviations = np.ones(p[\"M\"])\n        quota_k = np.where(vp[\"objectives\"] == 'Combined Quota')[0][0]\n        i = 1\n        while sum(deviations) &gt; 0:\n\n            if printing:\n                print(\"\\nSolving VFT model... (\" + str(i) + \")\")\n\n            # Set the current estimated number of cadets\n            current_estimate = p[\"quota_e\"]\n\n            try:\n\n                # Build &amp; solve the VFT model\n                model, q = vft_model_build(instance)\n                solution = solve_pyomo_model(instance, model, \"VFT\", q=q, printing=False)\n                solution = afccp.solutions.handling.evaluate_solution(solution, p, vp)\n                initial_solutions.append(solution['j_array'])\n\n                # Save this estimate for quota\n                previous_estimate = current_estimate\n\n                # Update new quota information (based on the number of cadets assigned from this solution)\n                instance.parameters[\"quota_e\"] = solution[\"objective_measure\"][:, quota_k].astype(int)\n\n                # Validate the estimated number is within the appropriate range\n                for j in p[\"J\"]:\n\n                    # Reset the parameter if necessary\n                    if instance.parameters[\"quota_e\"][j] &lt; p[\"quota_min\"][j]:\n                        instance.parameters[\"quota_e\"][j] = p[\"quota_min\"][j]\n                    elif instance.parameters[\"quota_e\"][j] &gt; p[\"quota_max\"][j]:\n                        instance.parameters[\"quota_e\"][j] = p[\"quota_max\"][j]\n\n                # Calculate deviations and proceed with next iteration\n                p = instance.parameters\n                deviations = [abs(p[\"quota_e\"][j] - current_estimate[j]) for j in p[\"J\"]]\n                i += 1\n\n                if printing:\n                    print(\"Current Number of Quota Differences:\", sum(deviations), \"with objective value of\",\n                          round(solution[\"z\"], 4))\n\n                # Don't solve this thing too many times (other stopping conditions)\n                if i &gt; instance.mdl_p[\"max_quota_iterations\"]:\n                    break\n\n            except:\n\n                if printing:\n                    print(\"Something went wrong with this iteration, proceeding with overall weight technique...\")\n\n                # Revert to the previous quota estimate\n                instance.parameters[\"quota_e\"] = previous_estimate\n                break\n\n    # Solve for different overall weights on cadets/AFSCs\n    weights = np.arange(instance.mdl_p[\"population_additions\"])\n    weights = weights / np.max(weights)\n    for w in weights:\n\n        if printing:\n            print(\"\\nSolving VFT model with 'w' of \", str(round(w, 2)) + \"...\")\n\n        # Update overall weights\n        instance.value_parameters[\"cadets_overall_weight\"] = w\n        instance.value_parameters[\"afscs_overall_weight\"] = 1 - w\n\n        # Solve model\n        try:\n\n            # Build &amp; solve the model\n            model, q = vft_model_build(instance)\n            solution = solve_pyomo_model(instance, model, \"VFT\", q=q, printing=False)\n            solution = afccp.solutions.handling.evaluate_solution(solution, p, vp)\n            initial_solutions.append(solution['j_array'])\n\n            if printing:\n                print(\"Objective value of\", round(solution[\"z\"], 4), \"obtained\")\n        except:\n\n            if printing:\n                print(\"Failed to solve. Going to next iteration...\")\n\n    instance.value_parameters = vp\n    return np.array(initial_solutions)\n</code></pre>"},{"location":"reference/solutions/sensitivity/#solutions.sensitivity.populate_initial_ga_solutions_from_assignment_model","title":"<code>populate_initial_ga_solutions_from_assignment_model(instance, printing=True)</code>","text":"<p>This function generates several initial solutions for the genetic algorithm to evolve from using the new and improved Assignment Problem Model as a heuristic</p> Source code in <code>afccp/solutions/sensitivity.py</code> <pre><code>def populate_initial_ga_solutions_from_assignment_model(instance, printing=True):\n    \"\"\"\n    This function generates several initial solutions for the genetic algorithm to evolve from using the\n    *new and improved* Assignment Problem Model as a heuristic\n    \"\"\"\n\n    if printing:\n        print(\"Generating initial population of solutions for the genetic algorithm from the approximate VFT model...\")\n\n    # Force the correct objective function\n    instance.mdl_p['assignment_model_obj'] = 'Global Utility'\n\n    # Load parameters/variables\n    p, vp = instance.parameters, copy.deepcopy(instance.value_parameters)\n    initial_solutions = []\n\n    # Solve using different \"global utility\" matrices calculated from different overall weights on cadets/AFSCs\n    weights = np.arange(instance.mdl_p[\"population_additions\"])\n    weights = weights / np.max(weights)\n    for w in weights:\n\n        if printing:\n            print(\"\\nSolving assignment model with 'w' of \", str(round(w, 2)) + \"...\")\n\n        # Update global utility matrix\n        instance.value_parameters['global_utility'] = np.zeros([p['N'], p['M'] + 1])\n        for j in p['J']:\n            instance.value_parameters['global_utility'][:, j] = w * p['cadet_utility'][:, j] + \\\n                                                                (1 - w) * p['afsc_utility'][:, j]\n\n        # Solve model\n        try:\n\n            # Build &amp; solve the model\n            model = assignment_model_build(instance)\n            solution = solve_pyomo_model(instance, model, \"Assignment\", printing=False)\n            solution = afccp.solutions.handling.evaluate_solution(solution, p, vp)\n            initial_solutions.append(solution['j_array'])\n\n            if printing:\n                print(\"Objective value of\", round(solution[\"z\"], 4), \"obtained\")\n        except:\n\n            if printing:\n                print(\"Failed to solve. Going to next iteration...\")\n\n    instance.value_parameters = vp\n    return np.array(initial_solutions)\n</code></pre>"},{"location":"reference/solutions/sensitivity/#solutions.sensitivity.optimization_what_if_analysis","title":"<code>optimization_what_if_analysis(instance, printing=True)</code>","text":"<p>This function takes in an AFSC/cadet problem instance and performs some \"What If\" analysis based on the items listed in \"What If List.csv\". We manipulate the \"value parameters\" to meet these pre-defined conditions and then evaluate the model with the new constraints. We can then create a pareto frontier by modifying the weights on cadets/AFSCs. These results are all exported to a sub-folder called \"What If\" in the Analysis &amp; Results folder.</p> Source code in <code>afccp/solutions/sensitivity.py</code> <pre><code>def optimization_what_if_analysis(instance, printing=True):\n    \"\"\"\n    This function takes in an AFSC/cadet problem instance and performs some \"What If\" analysis based on the items listed\n    in \"What If List.csv\". We manipulate the \"value parameters\" to meet these pre-defined conditions and then evaluate\n    the model with the new constraints. We can then create a pareto frontier by modifying the weights on cadets/AFSCs.\n    These results are all exported to a sub-folder called \"What If\" in the Analysis &amp; Results folder.\n    \"\"\"\n\n    # Shorthand\n    p, vp, mdl_p = instance.parameters, instance.value_parameters, instance.mdl_p\n\n    # Import dataframe\n    df = afccp.globals.import_csv_data(instance.export_paths['Analysis &amp; Results'] + \"What If List.csv\")\n\n    # Make sure the first name is in the solutions dictionary\n    if df.loc[0, 'Name'] not in instance.solutions:\n        raise ValueError(\"Error. Constraint name '\" + df.loc[0, 'Name'] + \"' is the baseline solution and is currently\"\n                                                                          \" not in the solutions dictionary.\")\n\n    # Get baseline solution and evaluate it\n    baseline = instance.solutions[df.loc[0, 'Name']]\n    baseline = afccp.solutions.handling.evaluate_solution(baseline, p, vp)\n\n    # Dictionary of metric column names and their associated variable name in the solution dictionary\n    metrics_dictionary = {'Effect on Global Utility': 'z^gu', 'Effect on Cadet Utility': 'cadet_utility_overall',\n                          'Effect on AFSC Utility': 'afsc_utility_overall',\n                          'Effect on USAFA Cadet Utility': 'usafa_cadet_utility',\n                          'Effect on ROTC Cadet Utility': 'rotc_cadet_utility',\n                          'Effect on USSF Cadet Utility': 'ussf_cadet_utility',\n                          'Effect on USAF Cadet Utility': 'usaf_cadet_utility',\n                          'Effect on USSF AFSC Utility': 'ussf_afsc_utility',\n                          'Effect on USAF AFSC Utility': 'usaf_afsc_utility',\n                          'Effect on USSF AFSC Norm Score': 'weighted_average_ussf_afsc_score',\n                          'Effect on USAF AFSC Norm Score': 'weighted_average_usaf_afsc_score'}\n\n    # Dictionary of AFSC solutions\n    afsc_solutions = {}\n\n    # Loop through each constraint type\n    names, con = np.array(df['Name']), 0\n    for name in names[1:]:  # Skip the baseline\n        con += 1  # Next constraint iteration (skips baseline too)\n        c_vp = copy.deepcopy(vp)  # set of value parameters for this constraint iteration\n\n        # Print statement\n        if printing:\n            print('Iteration', con, name)\n\n        # If we don't want to re-calculate something we can skip it\n        if not df.loc[con, 'Calculate']:\n            print(\"Skipped\")\n            continue\n\n        # Set the appropriate value parameters for this iteration\n        if name == 'Unconstrained':  # Turn off all the AFSC objective constraints\n            c_vp['constraint_type'] = np.zeros([p['M'], vp['O']])\n\n            # Turn off cadet constraints\n            c_vp['cadet_value_min'] = np.zeros(p['N'])\n\n        elif name == 'PGL Only':  # Turn of all the AFSC objective constraints except PGL\n            c_vp['constraint_type'] = np.zeros([p['M'], vp['O']])\n\n            # Turn on PGL constraints\n            k = np.where(vp['objectives'] == 'Combined Quota')[0][0]\n            c_vp['constraint_type'][:, k] = np.ones(p['M']) * 2\n\n            # Turn off cadet constraints\n            c_vp['cadet_value_min'] = np.zeros(p['N'])\n\n        elif 'Top 10 First Choice' in name:  # Cadets from the top 10% of the class need to get first choice\n\n            if \"Replace\" in name:  # Do we add these constraints on top of current cadet value constraints?\n\n                # Turn off current cadet constraints\n                c_vp['cadet_value_min'] = np.zeros(p['N'])\n\n            # Constrained slots\n            constrained_slots = np.zeros(p['M'])\n\n            # Need an algorithm to see which constraints are possible based on GOM\n            sorted_cadets = np.argsort(p['merit'])[::-1]\n            for i in sorted_cadets:\n\n                # Once we're passed the top 10% we're done\n                if p['merit'][i] &lt; 0.9:\n                    break\n\n                # Loop through choices until we find one under capacity\n                for choice in [0, 1, 2, 3]:\n                    j = p['cadet_preferences'][i][choice]\n\n                    # Only constrain this preference if we're under constrained capacity\n                    if constrained_slots[j] &lt; p['pgl'][j]:\n\n                        # Constrain the utility of this preference\n                        utility = p['cadet_utility'][i, j]\n                        c_vp['cadet_value_min'][i] = utility\n\n                        # Increment constrained slots by one\n                        constrained_slots[j] += 1\n\n                        # Break out of this choice\n                        break\n\n        elif name == \"USSF OM\":  # Turn on USSF OM constraint\n            c_vp[\"USSF OM\"] = True\n\n        elif name == \"Strict AFOCD M Tier\":  # Turn on mandatory AFOCD constraints\n\n            # Loop through each degree tier to find AFSCs that have mandatory degree tier requirements\n            for t in [0, 1, 2, 3]:\n                j_indices = np.where(p[\"t_mandatory\"][:, t])[0]\n                vp['constraint_type'][j_indices] = 1  # Turn on these constraints\n\n        else:  # Skip the rest of this loop\n            print(\"Skipped\")\n            df.loc[con, \"Result\"] = \"Skipped\"\n            continue\n\n        # Set of constrained objectives for each AFSC\n        c_vp['K^C'] = {}  # constrained objectives\n        for j in p[\"J\"]:\n            c_vp['K^C'][j] = np.where(c_vp['constraint_type'][j, :] &gt; 0)[0].astype(int)\n\n        # Create a duplicate instance and set its value parameters\n        c_instance = copy.deepcopy(instance)\n        c_instance.value_parameters = copy.deepcopy(c_vp)\n\n        # Solve the model\n        model = afccp.solutions.optimization.assignment_model_build(c_instance)\n\n        # Check for feasibility\n        try:\n\n            # Solve model and get solution\n            solution = afccp.solutions.optimization.solve_pyomo_model(c_instance, model, 'Assignment',\n                                                                      printing=printing)\n            solution = afccp.solutions.handling.evaluate_solution(solution, p, c_vp)\n            afsc_solutions[name] = copy.deepcopy(solution['afsc_array'])\n\n            # Calculate metrics\n            for key, value in metrics_dictionary.items():\n                df.loc[con, key] = solution[value] - baseline[value]\n\n            # It was feasible!\n            df.loc[con, \"Result\"] = \"Feasible\"\n\n            if printing:\n                print(\"Feasible :)\")\n\n        except:\n\n            # Empty solution\n            afsc_solutions[name] = np.array([\"*\" for _ in p['I']])\n\n            # It was infeasible!\n            df.loc[con, \"Result\"] = \"Infeasible\"\n\n            if printing:\n                print(\"Infeasible :(\")\n\n    # Export main dataframe\n    df.to_csv(instance.export_paths['Analysis &amp; Results'] + \"What If List.csv\", index=False)\n\n    # Create and export solutions dataframe\n    solution_df = pd.DataFrame(afsc_solutions)\n    solution_df.to_csv(instance.export_paths['Analysis &amp; Results'] + \"What If Solutions.csv\", index=False)\n</code></pre>"},{"location":"reference/solutions/sensitivity/#solutions.sensitivity.solve_pgl_capacity_sensitivity","title":"<code>solve_pgl_capacity_sensitivity(instance, p_dict={}, printing=True)</code>","text":"<p>Doc string here</p> Source code in <code>afccp/solutions/sensitivity.py</code> <pre><code>def solve_pgl_capacity_sensitivity(instance, p_dict={}, printing=True):\n    \"\"\"\n    Doc string here\n    \"\"\"\n\n    def alter_quota_max(done_iterating):\n        \"\"\"\n\n        :return:\n        \"\"\"\n\n        # Determine which AFSCs were most over quota\n        count = instance.solution['count']\n        surplus = count - p['pgl']\n        percentage = count / p['pgl']\n\n        # Determine which AFSC to alter\n        sorted_afscs = np.argsort(percentage)[::-1]\n        for j in sorted_afscs:\n\n            # If we're already at our \"true max\", pick the next AFSC in the list\n            if count[j] &lt;= true_max[j]:\n                continue\n\n            # Calculate what the new max should be\n            new_max_val = np.floor(p['pgl'][j] + surplus[j] / 2)\n\n            # If the difference is small enough, skip straight to true max\n            difference = count[j] - new_max_val\n            if difference &lt;= 5:\n                new_max_val = true_max[j]\n\n            # If this would put the maximum under the \"true maximum\", force it to be the true maximum\n            if new_max_val &lt; true_max[j]:\n                new_max_val = true_max[j]\n\n            # Set the new maximum value for this AFSC\n            if p['quota_max'][j] == new_max_val:\n                print(\"Iterations complete.\")\n                done_iterating = True\n            else:\n                p['quota_max'][j] = new_max_val\n\n            # Break out of the loop\n            break\n\n        return done_iterating\n\n    # Shorthand\n    p, vp, mdl_p = instance.parameters, instance.value_parameters, instance.mdl_p\n\n    # Make the main directory if needed\n    folder_path = instance.export_paths['Analysis &amp; Results']\n    if \"PGL Sensitivity Analysis\" not in os.listdir(folder_path):\n        os.mkdir(folder_path + '/' + 'PGL Sensitivity Analysis')\n    folder_path += '/' + 'PGL Sensitivity Analysis/'\n\n    # Adjust the chart settings\n    p_dict[\"objective\"] = \"Combined Quota\"\n    p_dict[\"version\"] = \"quantity_bar\"\n    p_dict['macro_chart_kind'] = 'AFSC Chart'\n    p_dict['save'] = False\n\n    # Get contents of folder to determine sub-folder this analysis will be in\n    folder = os.listdir(folder_path)\n\n    # Settings for max quotas\n    true_max = copy.deepcopy(p['quota_max'])\n\n    # If we are starting where we left off and have provided a valid Analysis folder, we import there\n    if mdl_p['import_pgl_analysis_folder'] in folder:\n        sub_folder_name = mdl_p['import_pgl_analysis_folder']\n        folder_path += sub_folder_name + \"/\"\n\n        # Print statement\n        if printing:\n            print(\"Conducting PGL sensitivity analysis on this problem instance \"\n                  \"from imported '\" + sub_folder_name + \"'...\")\n\n        # Import dataframes\n        capacities_df = pd.read_csv(folder_path + \"Capacities.csv\")\n        solutions_df = pd.read_csv(folder_path + \"Solutions.csv\")\n\n        # Load dictionaries\n        capacities_dict = {int(col): np.array(capacities_df[col]) for col in capacities_df}\n        solutions_dict = {int(col): np.array(solutions_df[col]) for col in solutions_df}\n\n        # Determine what our last iteration was\n        iteration = len(capacities_df.columns) - 1\n\n        # Set initial quota_max\n        p['quota_max'] = capacities_dict[iteration]\n\n        # Add the current solution to the instance\n        instance.add_solution(solutions_dict[iteration])\n\n        # Process that solution to get new quota max\n        alter_quota_max(done_iterating=False)\n\n        # Set the iterations\n        iteration += 1\n        iterations = np.arange(iteration, iteration + mdl_p['num_pgl_analysis_iterations'])\n\n    # If we are starting from scratch, create the new analysis folder and start that way\n    else:\n\n        # Crate the new folder\n        name_determined, i = False, 1\n        while not name_determined:\n            sub_folder_name = \"Analysis \" + str(i)\n            if sub_folder_name not in folder:\n                folder_path += sub_folder_name + \"/\"\n                os.mkdir(folder_path)  # Make the folder\n                name_determined = True\n            else:\n                i += 1\n\n        # Print statement\n        if printing:\n            print(\"Conducting PGL sensitivity analysis on this problem instance \"\n                  \"using new '\" + sub_folder_name + \"'...\")\n\n        # Set essentially no maximum value for each AFSC at the beginning\n        p['quota_max'] = np.array([1000 if j in p['J^NRL'] else p['quota_max'][j] for j in p['J']])\n\n        # Create dictionaries of solution/capacity arrays\n        solutions_dict, capacities_dict = {},{}\n\n        # Set the iterations\n        iterations = np.arange(mdl_p['num_pgl_analysis_iterations'])\n\n    # Loop through each iteration\n    done_iterating = False\n    for iteration in iterations:\n\n        # Update the value parameters with the new quota max\n        instance.update_value_parameters()\n\n        # Run the model\n        if printing:\n            print(\"\\n\\nSolving iteration\", iteration, \"with capacities\", p['quota_max'])\n        instance.solve_guo_pyomo_model(p_dict, printing=True)\n\n        # Save solution and capacities information\n        capacities_dict[iteration] = copy.deepcopy(p['quota_max'])\n        solutions_dict[iteration] = instance.solution['afsc_array']\n\n        # Process the solution\n        done_iterating = alter_quota_max(done_iterating)\n\n        # If we're done iterating, stop. Otherwise, build the chart\n        if done_iterating:\n            break\n        else:\n\n            # Save dataframes at each step\n            print(\"Saving dataframes..\")\n            capacities_df = pd.DataFrame(capacities_dict)\n            capacities_df.to_csv(folder_path + \"Capacities.csv\", index=False)\n            solutions_df = pd.DataFrame(solutions_dict)\n            solutions_df.to_csv(folder_path + \"Solutions.csv\", index=False)\n            print(\"Done.\")\n</code></pre>"},{"location":"reference/visualizations/bubbles/","title":"Bubbles","text":""},{"location":"reference/visualizations/bubbles/#visualizations.bubbles","title":"<code>visualizations.bubbles</code>","text":""},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart","title":"<code>BubbleChart(instance, printing=None)</code>","text":"<p>Initialize an \"AFSC/Cadet Bubble\" chart and animation object.</p> <p>This class is designed to construct a graphical representation of the \"AFSC/Cadet Bubble,\" showing the placement of cadets in a solution and their movement through various algorithms. The problem instance is the only required parameter.</p> <p>Args:     instance: A CadetCareerProblem instance, containing various attributes and parameters necessary for constructing         the bubble chart.     printing (bool, None): A flag to control whether to print information during chart creation and animation. If set         to True, the class will print progress and debugging information. If set to False, it will suppress printing.         If None, the class will use the default printing setting from the instance.</p> <p>Notes: - This constructor extracts various attributes from the <code>CadetCareerProblem</code> instance provided as <code>instance</code>. - The <code>solution_iterations</code> attribute of the problem instance is expected to be a dictionary of a particular set of   solutions used in the figure. - The 'b' dictionary contains hyperparameters for the animation/plot, as defined in <code>afccp.core.data.ccp_helping_functions.py</code>.</p> <p>Attributes: - p: A dictionary containing parameters extracted from the <code>instance</code>. - vp: A dictionary containing value parameters extracted from the <code>instance</code>. - b: A dictionary containing hyperparameters for the bubble chart, populated from the <code>instance</code>. - data_name: The name of the data used for the chart. - data_version: The version of the data used for the chart. - solution: The solution data extracted from the <code>instance</code>. - mdl_p: Model parameters extracted from the <code>instance</code>. - paths: Export paths from the <code>instance</code>. - printing: A boolean flag for controlling printing behavior during chart creation and animation. - v_hex_dict: A dictionary mapping value parameter values to their corresponding hexadecimal colors. - ...</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def __init__(self, instance, printing=None):\n    \"\"\"\n    Initialize an \"AFSC/Cadet Bubble\" chart and animation object.\n\n    This class is designed to construct a graphical representation of the \"AFSC/Cadet Bubble,\" showing the placement\n    of cadets in a solution and their movement through various algorithms. The problem instance is the only required\n    parameter.\n\n    Args:\n        instance: A CadetCareerProblem instance, containing various attributes and parameters necessary for constructing\n            the bubble chart.\n        printing (bool, None): A flag to control whether to print information during chart creation and animation. If set\n            to True, the class will print progress and debugging information. If set to False, it will suppress printing.\n            If None, the class will use the default printing setting from the instance.\n\n    Notes:\n    - This constructor extracts various attributes from the `CadetCareerProblem` instance provided as `instance`.\n    - The `solution_iterations` attribute of the problem instance is expected to be a dictionary of a particular set of\n      solutions used in the figure.\n    - The 'b' dictionary contains hyperparameters for the animation/plot, as defined in `afccp.core.data.ccp_helping_functions.py`.\n\n    Attributes:\n    - p: A dictionary containing parameters extracted from the `instance`.\n    - vp: A dictionary containing value parameters extracted from the `instance`.\n    - b: A dictionary containing hyperparameters for the bubble chart, populated from the `instance`.\n    - data_name: The name of the data used for the chart.\n    - data_version: The version of the data used for the chart.\n    - solution: The solution data extracted from the `instance`.\n    - mdl_p: Model parameters extracted from the `instance`.\n    - paths: Export paths from the `instance`.\n    - printing: A boolean flag for controlling printing behavior during chart creation and animation.\n    - v_hex_dict: A dictionary mapping value parameter values to their corresponding hexadecimal colors.\n    - ...\n    \"\"\"\n\n    # Initialize attributes that we take directly from the CadetCareerProblem instance\n    self.p, self.vp = instance.parameters, instance.value_parameters\n    self.b, self.data_name, self.data_version = instance.mdl_p, instance.data_name, instance.data_version\n    self.solution, self.mdl_p = instance.solution, instance.mdl_p\n    self.paths = instance.export_paths\n    self.printing = printing\n\n    # Load in hex values/colors\n    filepath = afccp.globals.paths['files'] + 'value_hex_translation.xlsx'\n    if self.mdl_p['use_rainbow_hex']:\n        hex_df = afccp.globals.import_data(filepath, sheet_name='Rainbow')\n    else:\n        hex_df = afccp.globals.import_data(filepath)\n    self.v_hex_dict = {hex_df.loc[i, 'Value']: hex_df.loc[i, 'Hex'] for i in range(len(hex_df))}\n\n    # Figure Height\n    self.b['fh'] = self.b['fw'] * self.b['fh_ratio']\n\n    # Border Widths\n    for i in ['t', 'l', 'r', 'b', 'u']:\n        self.b['bw^' + i] = self.b['fw'] * self.b['bw^' + i + '_ratio']\n\n    # AFSC border/buffer widths\n    self.b['abw^lr'] = self.b['fw'] * self.b['abw^lr_ratio']\n    self.b['abw^ud'] = self.b['fw'] * self.b['abw^ud_ratio']\n\n    # Legend width/height\n    if self.b['add_legend']:\n        self.b['lw'] = self.b['fw'] * self.b['lw_ratio']\n        self.b['lh'] = self.b['fw'] * self.b['lh_ratio']\n    else:\n        self.b['lw'], self.b['lh'] = 0, 0\n\n    # Set up \"solutions\" properly\n    if 'iterations' in self.solution:\n        self.b['solutions'] = copy.deepcopy(self.solution['iterations']['matches'])\n        self.b['last_s'] = self.solution['iterations']['last_s']\n        if 'rejections' in self.solution['iterations']:  # OTS specific alg functionality\n            self.b['rejections'] = copy.deepcopy(self.solution['iterations']['rejections'])\n            self.b['new_match'] = copy.deepcopy(self.solution['iterations']['new_match'])\n    else:\n        self.b['solutions'] = {0: self.solution['j_array']}\n        self.b['last_s'] = 0\n\n    # Basic information about this sequence for the animation\n    self.b['afscs'] = self.mdl_p['afscs']\n\n    # Determine which cadets were solved for in this solution\n    if self.b['cadets_solved_for'] is None:\n        self.b['cadets_solved_for'] = self.solution['cadets_solved_for']\n\n    # Rated cadets only\n    if 'Rated' in self.b['cadets_solved_for']:\n        for soc in self.p['SOCs']:\n            if soc.upper() in self.b['cadets_solved_for']:\n                self.b['cadets'] = self.p['Rated Cadets'][soc]\n                self.b['max_afsc'] = self.p[f'{soc}_quota']\n                self.b['min_afsc'] = self.p[f'{soc}_quota']\n                self.b['afscs'] = determine_soc_rated_afscs(soc, all_rated_afscs=self.p['afscs_acc_grp'][\"Rated\"])\n                self.soc = soc\n                break\n\n    # Specific SOC cadets!\n    elif 'USAFA' in self.b['cadets_solved_for'] or 'ROTC' in self.b['cadets_solved_for'] or \\\n            'OTS' in self.b['cadets_solved_for']:\n        for soc in self.p['SOCs']:\n            if soc.upper() in self.b['cadets_solved_for']:\n                if soc.upper() in self.b['cadets_solved_for']:\n                    self.b['cadets'] = self.p[f'I^{soc.upper()}']\n                    self.b['max_afsc'] = self.p[f'{soc}_quota']\n                    self.b['min_afsc'] = self.p[f'{soc}_quota']\n                    self.soc = soc\n                    break\n\n    # All the cadets!\n    else:\n        self.b['cadets'] = self.p['I']\n        if 'max_bubbles' in self.p:\n            self.b['max_afsc'] = self.p['max_bubbles']\n        else:\n            self.b['max_afsc'] = self.p['quota_max']\n        self.b['min_afsc'] = self.p['pgl']\n        self.soc = 'both'\n\n    # Correct cadet parameters\n    self.b['N'] = len(self.b['cadets'])\n\n    # Correct AFSC parameters\n    self.b['M'] = len(self.b['afscs'])\n    self.b['J'] = np.array([np.where(afsc == self.p['afscs'])[0][0] for afsc in self.b['afscs']])\n\n    # These are attributes to use in the title of each iteration\n    self.num_unmatched = self.b['N']\n    self.average_afsc_choice = None\n    self.average_cadet_choice = None\n\n    # Setup OTS algorithm specifics\n    if self.solution.get('iterations', {}).get('type') == 'OTS Status Quo Algorithm':\n        self.b['max_assigned'] = self.p['ots_quota'] + 1\n\n        # Precompute intersection for each solution and AFSC\n        self.b['cadets_matched'] = {\n            s: {\n                j: np.intersect1d(np.where(self.b['solutions'][s] == j)[0], self.p['I^OTS'])\n                for j in self.b['J']\n            }\n            for s in self.b['solutions']\n        }\n\n    # Initialize Figure\n    self.fig, self.ax = plt.subplots(figsize=self.b['b_figsize'], dpi=self.b['dpi'],\n                                     facecolor=self.b['figure_color'], tight_layout=True)\n    self.ax.set_facecolor(self.b['figure_color'])\n    self.ax.set_aspect('equal', adjustable='box')\n    self.ax.set(xlim=(-self.b['x_ext_left'], self.b['fw'] + self.b['x_ext_right']))\n    self.ax.set(ylim=(-self.b['y_ext_left'], self.b['fh'] + self.b['y_ext_right']))\n\n    # Remove tick marks\n    self.ax.tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)\n\n    if printing:\n        print('Bubble Chart initialized.')\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.main","title":"<code>main()</code>","text":"<p>Main method to call all other methods based on what parameters the user provides</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def main(self):\n    \"\"\"\n    Main method to call all other methods based on what parameters the user provides\n    \"\"\"\n\n    # Run through some initial preprocessing (calculating 'n' for example)\n    self.preprocessing()\n    x_y_initialized = self.import_board_parameters()  # Potentially import x and y\n\n    # If we weren't able to initialize x and y coordinates for the board, determine that here\n    if not x_y_initialized:\n\n        # Determine x and y coordinates (and potentially 's')\n        if self.b['use_pyomo_model']:\n            self.calculate_afsc_x_y_s_through_pyomo()\n        else:\n            self.calculate_afsc_x_y_through_algorithm()\n\n    # Redistribute the AFSCs along each row by spacing out the x coordinates\n    if self.b['redistribute_x']:\n        self.redistribute_x_along_row()\n\n    # Only saving one image for a single solution\n    if 'iterations' not in self.solution:\n        self.b['save_iteration_frames'] = False\n        self.b['build_orientation_slides'] = False\n        self.b['save_board_default'] = False\n\n    # Create the rest of the main figure\n    self.calculate_cadet_box_x_y()\n\n    # Save the board parameters\n    self.export_board_parameters()\n\n    # Build out the orientation slides\n    if self.b['build_orientation_slides']:\n\n        # Orientation slides first\n        self.orientation_slides()\n    else:\n\n        # Initialize the board!\n        self.initialize_board(include_surplus=self.b['show_white_surplus_boxes'])\n\n    # Just making one picture\n    if 'iterations' not in self.solution:\n        self.solution_iteration_frame(0, cadets_to_show='cadets_matched', kind='Final Solution')\n\n        # Save frame to solution sub-folder with solution name\n        filepath = self.paths['Analysis &amp; Results'] + self.solution['name'] + '/' + self.solution['name'] + ' ' +\\\n                   self.b['chart_filename'] + '.png'\n        self.fig.savefig(filepath)\n\n        if self.printing:\n            print('Done.')\n\n    # Create all the iteration frames\n    if self.b['save_iteration_frames']:\n\n        # Make the \"focus\" directory if needed\n        folder_path = self.paths['Analysis &amp; Results'] + 'Cadet Board/' + self.solution['iterations']['sequence']\n        if self.b['focus'] not in os.listdir(folder_path):\n            os.mkdir(folder_path + '/' + self.b['focus'])\n\n        # ROTC Rated Board\n        if self.solution['iterations']['type'] in ['ROTC Rated Board']:\n\n            if self.printing:\n                print(\"Creating \" + str(len(self.solution['iterations']['matches'])) + \" animation images...\")\n\n            # Loop through each solution\n            for s in self.b['solutions']:\n                self.solution_iteration_frame(s, cadets_to_show='cadets_matched')\n\n        # Matching Algorithm Proposals &amp; Rejections\n        elif self.solution['iterations']['type'] in ['HR', 'Rated SOC HR']:\n\n            if self.printing:  # \"Plus 2\" to account for orientation and final solution frames\n                print(\"Creating \" + str(len(self.b['solutions']) + 2) + \" animation images...\")\n\n            # Save the orientation slide\n            filepath = folder_path + '/' + self.b['focus'] + '/0 (Orientation).png'\n            self.fig.savefig(filepath)\n\n            # Loop through each iteration\n            for s in self.b['solutions']:\n                self.solution_iteration_frame(s, cadets_to_show='cadets_proposing', kind='Proposals')\n                self.rejections_iteration_frame(s, kind='Rejections')\n\n            # Final Solution\n            self.solution_iteration_frame(s, cadets_to_show='cadets_matched', kind='Final Solution')\n            if self.printing:\n                print('Done.')\n\n        elif self.solution['iterations']['type'] == 'OTS Status Quo Algorithm':\n\n            if self.printing:  # \"Plus 2\" to account for orientation and final solution frames\n                print(\"Creating \" + str(len(self.b['solutions'].keys()) + 2) + \" animation images...\")\n\n            # Save the frames\n            self.build_ots_alg_frames()\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.preprocessing","title":"<code>preprocessing()</code>","text":"<p>This method preprocesses the different specs for this particular figure instance</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def preprocessing(self):\n    \"\"\"\n    This method preprocesses the different specs for this particular figure instance\n    \"\"\"\n\n    # Default AFSC fontsize and whether they're on two lines or not (likely overwritten later)\n    self.b['afsc_fontsize'] = {j: self.b['afsc_title_size'] for j in self.b['J']}\n    self.b['afsc_title_two_lines'] = {j: False for j in self.b['J']}\n\n    # Proposal iterations\n    if 'iterations' in self.solution:\n        if 'proposals' in self.solution['iterations']:\n            self.b['cadets_proposing'] = {}\n\n    # Determine maximum number of assigned cadets to each AFSC\n    if 'max_assigned' not in self.b:\n\n        # Maximum number of cadets assigned to each AFSC across solutions\n        self.b['max_assigned'] = {j: 0 for j in self.b[\"J\"]}\n\n        # Subset of cadets assigned to the AFSC in each solution\n        self.b['counts'] = {}\n        self.b['cadets_matched'] = {}\n\n        # Loop through each solution (iteration)\n        for s in self.b['solutions']:\n\n            self.b['cadets_matched'][s], self.b['counts'][s] = {}, {}\n\n            # Proposal iterations\n            if 'iterations' in self.solution:\n                if 'proposals' in self.solution['iterations']:\n                    self.b['cadets_proposing'][s] = {}\n\n            # Loop through each AFSC\n            for j in self.b['J']:\n\n                # The cadets that were matched have to be taken from the cadets we're showing too\n                all_cadets_matched = np.where(self.b['solutions'][s] == j)[0]  # cadets assigned to this AFSC\n                self.b['cadets_matched'][s][j] = np.intersect1d(all_cadets_matched, self.b['cadets'])\n                self.b['counts'][s][j] = len(self.b['cadets_matched'][s][j])  # number of cadets assigned to AFSC\n                max_count = self.b['counts'][s][j]\n\n                # Proposal iterations\n                if 'iterations' in self.solution:\n                    if 'proposals' in self.solution['iterations']:\n                        self.b['cadets_proposing'][s][j] = \\\n                            np.where(self.solution['iterations']['proposals'][s] == j)[0]\n                        proposal_counts = len(self.b['cadets_proposing'][s][j])  # number of proposing cadets\n                        max_count = max(self.b['counts'][s][j], proposal_counts)\n\n                # Update maximum number of cadets assigned if necessary\n                if max_count &gt; self.b['max_assigned'][j]:\n                    self.b['max_assigned'][j] = max_count\n\n    # Get number of unassigned cadets at the end of the iterations\n    if 'last_s' in self.b:  # cadets left unmatched\n        self.b['unassigned_cadets'] = np.where(self.b['solutions'][self.b['last_s']] == self.p['M'])[0]\n        self.b['N^u'] = len(self.b['unassigned_cadets'])  # number of cadets left unmatched\n\n    # Determine number of cadet boxes for AFSCs based on nearest square\n    squares_required = [max(self.b['max_assigned'][j], self.b['max_afsc'][j]) for j in self.b['J']]\n    n = np.ceil(np.sqrt(squares_required)).astype(int)\n    n2 = (np.ceil(np.sqrt(squares_required)) ** 2).astype(int)\n    self.b['n'] = {j: n[idx] for idx, j in enumerate(self.b['J'])}\n    self.b['n^2'] = {j: n2[idx] for idx, j in enumerate(self.b['J'])}\n\n    # Number of boxes in row of unmatched box\n    self.b['n^u'] = int((self.b['fw'] - self.b['bw^r'] - self.b['bw^l']) / self.b['s'])\n\n    # Number of rows in unmatched box\n    self.b['n^urow'] = int(self.b['N^u'] / self.b['n^u'])\n\n    # Sort the AFSCs by 'n' (descending), then by AFSC name (ascending)\n    n = np.array([self.b['n'][j] for j in self.b['J']])  # Convert dictionary to numpy array\n    afsc_names = np.array([self.b['afscs'][j] for j in self.b['J']])\n\n    # Use lexsort: secondary key goes first (name), then primary (negated size for descending)\n    indices = np.lexsort((afsc_names, -n))\n    sorted_J = self.b['J'][indices]  # J Array sorted by n\n    sorted_n = n[indices]  # n Array sorted by n\n    self.b['J^sorted'] = {index: sorted_J[index] for index in range(self.b['M'])}  # Translate 'new j' to 'real j'\n    self.b['n^sorted'] = {index: sorted_n[index] for index in range(self.b['M'])}  # Translate 'new n' to 'real n'\n    self.b['J^translated'] = {sorted_J[index]: index for index in range(self.b['M'])}  # Translate 'real j' to 'new j'\n\n    if self.printing:\n        print('Bubble Chart preprocessed.')\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.orientation_slides","title":"<code>orientation_slides()</code>","text":"<p>Build out the orientation slides for a particular sequence (intended to be used on ONE AFSC)</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def orientation_slides(self):\n    \"\"\"\n    Build out the orientation slides for a particular sequence (intended to be used on ONE AFSC)\n    \"\"\"\n\n    # Make the \"orientation\" directory if needed\n    folder_path = self.paths['Analysis &amp; Results'] + 'Cadet Board/' + self.solution['iterations']['sequence']\n    if 'Orientation' not in os.listdir(folder_path):\n        os.mkdir(folder_path + '/Orientation')\n\n    # Save the \"zero\" slide (just black screen)\n    filepath = folder_path + '/Orientation/0.png'\n    self.fig.savefig(filepath)\n\n    # Create first frame\n    self.initialize_board(include_surplus=False)\n\n    # Save the real first frame\n    filepath = folder_path + '/Orientation/1.png'\n    self.fig.savefig(filepath)\n\n    # Reset Figure\n    self.fig, self.ax = plt.subplots(figsize=self.b['b_figsize'], dpi=self.b['dpi'],\n                                     facecolor=self.b['figure_color'], tight_layout=True)\n    self.ax.set_facecolor(self.b['figure_color'])\n    self.ax.set_aspect('equal', adjustable='box')\n    self.ax.set(xlim=(-self.b['x_ext_left'], self.b['fw'] + self.b['x_ext_right']))\n    self.ax.set(ylim=(-self.b['y_ext_left'], self.b['fh'] + self.b['y_ext_right']))\n\n    # Create second frame\n    self.initialize_board(include_surplus=True)\n\n    # Save the second frame\n    filepath = folder_path + '/Orientation/2.png'\n    self.fig.savefig(filepath)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.calculate_afsc_x_y_through_algorithm","title":"<code>calculate_afsc_x_y_through_algorithm()</code>","text":"<p>This method calculates the x and y locations of the AFSC boxes using a very simple algorithm.</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def calculate_afsc_x_y_through_algorithm(self):\n    \"\"\"\n    This method calculates the x and y locations of the AFSC boxes using a very simple algorithm.\n    \"\"\"\n\n    # Determine x and y coordinates of bottom left corner of AFSC squares algorithmically\n    self.b['x'], self.b['y'] = {j: 0 for j in self.b['J']}, {j: 0 for j in self.b['J']}\n    n = np.array([self.b['n'][j] for j in self.b['J']])  # Convert dictionary to numpy array\n\n    # Start at top left corner of main container (This is the algorithm)\n    x, y = self.b['bw^l'], self.b['fh'] - self.b['bw^t']\n    current_max_n = np.max(n)\n    for j in self.b['J']:\n        check_x = x + self.b['s'] * self.b['n'][j]\n\n        if check_x &gt; self.b['fw'] - self.b['bw^r'] - self.b['lw']:\n            x = self.b['bw^l']  # move back to left-most column\n            y = y - self.b['s'] * current_max_n - self.b['abw^ud']  # drop to next row\n            current_max_n = self.b['n'][j]\n\n        self.b['x'][j], self.b['y'][j] = x, y - self.b['s'] * self.b['n'][j]  # bottom left corner of box\n        x += self.b['s'] * self.b['n'][j] + self.b['abw^lr']  # move over to next column\n\n    if self.printing:\n        print(\"Board parameters 'x' and 'y' determined through simple algorithm.\")\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.calculate_afsc_x_y_s_through_pyomo","title":"<code>calculate_afsc_x_y_s_through_pyomo()</code>","text":"<p>This method calculates the x and y locations of the AFSC boxes, as well as the size (s) of the cadet boxes, using the pyomo optimization model to determine the optimal placement of all these objects</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def calculate_afsc_x_y_s_through_pyomo(self):\n    \"\"\"\n    This method calculates the x and y locations of the AFSC boxes, as well as the size (s) of the cadet boxes,\n    using the pyomo optimization model to determine the optimal placement of all these objects\n    \"\"\"\n\n    if not afccp.globals.use_pyomo:\n        raise ValueError(\"Pyomo not installed.\")\n\n    # Build the model\n    model = afccp.solutions.optimization.bubble_chart_configuration_model(self.b)\n\n    # Get coordinates and size of boxes by solving the model\n    self.b['s'], self.b['x'], self.b['y'] = afccp.solutions.optimization.solve_pyomo_model(\n        self, model, \"Bubbles\", q=None, printing=self.printing)\n\n    if self.printing:\n        print(\"Board parameters 'x' and 'y' determined through pyomo model.\")\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.redistribute_x_along_row","title":"<code>redistribute_x_along_row()</code>","text":"<p>This method re-calculates the x coordinates by spacing out the AFSCs along each row</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def redistribute_x_along_row(self):\n    \"\"\"\n    This method re-calculates the x coordinates by spacing out the AFSCs along each row\n    \"\"\"\n\n    # Unique y coordinates\n    y_unique = np.unique(np.array([round(self.b['y'][j], 4) for j in self.b['J']]))[::-1]\n\n    # Need to get ordered list of AFSCs in each row\n    sorted_J = np.array([j for j in self.b['J^translated']])\n    rows = {row: [] for row in range(len(y_unique))}\n    for j in sorted_J:\n        y = round(self.b['y'][j], 4)\n        row = np.where(y_unique == y)[0][0]\n        rows[row].append(j)\n\n    # Loop through each row to determine optimal spacing\n    for row in rows:\n\n        # Only adjust spacing for rows with more than one AFSC\n        if len(rows[row]) &gt; 1:\n\n            # Calculate total spacing to play around with\n            total_spacing = self.b['fw'] - self.b['bw^l'] - self.b['bw^r']\n            for j in rows[row]:\n                total_spacing -= (self.b['s'] * self.b['n'][j])\n\n            # Spacing used to fill in the gaps\n            new_spacing = total_spacing / (len(rows[row]) - 1)\n\n            # Loop through each AFSC in this row to calculate the new x position\n            for num, j in enumerate(rows[row]):\n\n                # Calculate the appropriate x coordinate\n                if num == 0:\n                    x = self.b['x'][j] + (self.b['n'][j] * self.b['s']) + new_spacing\n                else:\n                    self.b['x'][j] = x\n                    x += (self.b['n'][j] * self.b['s']) + new_spacing\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.calculate_cadet_box_x_y","title":"<code>calculate_cadet_box_x_y()</code>","text":"<p>This method uses the x and y coordinates of the AFSC boxes, along with the size of the cadet boxes, to calculate the x and y coordinates of all the individual cadet boxes.</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def calculate_cadet_box_x_y(self):\n    \"\"\"\n    This method uses the x and y coordinates of the AFSC boxes, along with the size of the cadet boxes, to calculate\n    the x and y coordinates of all the individual cadet boxes.\n    \"\"\"\n\n    # Get coordinates of all cadet boxes\n    self.b['cb_coords'] = {}\n    for j in self.b['J']:\n        self.b['cb_coords'][j] = {}\n\n        # Bottom left corner of top left cadet square\n        x, y = self.b['x'][j], self.b['y'][j] + self.b['s'] * (self.b['n'][j] - 1)\n\n        # Loop through all cadet boxes to get individual coordinates of bottom left corner of each cadet box\n        i = 0\n        for r in range(self.b['n'][j]):\n            for c in range(self.b['n'][j]):\n                x_i = x + c * self.b['s']\n                y_i = y - r * self.b['s']\n                self.b['cb_coords'][j][i] = (x_i, y_i)\n                i += 1\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.initialize_board","title":"<code>initialize_board(include_surplus=False)</code>","text":"<p>This method takes all the necessary board parameters and constructs the board to then be manipulated in other algorithms based on what the user wants to do.</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def initialize_board(self, include_surplus=False):\n    \"\"\"\n    This method takes all the necessary board parameters and constructs the board to then be manipulated in other\n    algorithms based on what the user wants to do.\n    \"\"\"\n\n    # Is there only one row?\n    max_y = np.max(np.array([self.b['y'][j] for j in self.b['J']]))\n    only_one_row = max_y &lt;= 0.04\n\n    # Loop through each AFSC to add certain elements\n    self.b['afsc_name_text'] = {}\n    self.b['c_boxes'] = {}\n    self.b['c_circles'] = {}\n    self.b['c_rank_text'] = {}\n    for j in self.b['J']:\n\n        # AFSC names\n        if self.b['afsc_names_sized_box']:\n\n            # Calculate fontsize and put AFSC name in middle of box\n            x = self.b['x'][j] + (self.b['n'][j] / 2) * self.b['s']\n            y = self.b['y'][j] + (self.b['n'][j] / 2) * self.b['s']\n            w, h = self.b['n'][j] * self.b['s'], self.b['n'][j] * self.b['s']\n            self.b['afsc_fontsize'][j] = get_fontsize_for_text_in_box(self.ax, self.p['afscs'][j], (x, y), w, h,\n                                                                   va='center')\n            va = 'center'\n            ha = 'center'\n        else:\n\n            # AFSC fontsize is given and put AFSC name above box\n            x = self.b['x'][j] + (self.b['n'][j] / 2) * self.b['s']\n            y = self.b['y'][j] + self.b['n'][j] * self.b['s'] + 0.02\n            va = 'bottom'\n            ha = 'center'\n\n            self.b['x'] = {key: round(val, 4) for key, val in self.b['x'].items()}\n            self.b['y'] = {key: round(val, 4) for key, val in self.b['y'].items()}\n\n            # Are we on a bottom edge?\n            row = np.array([j_p for j_p, val in self.b['y'].items() if val == self.b['y'][j]])\n            x_coords = np.array([self.b['x'][j_p] for j_p in row])\n            if not only_one_row:\n                if self.b['x'][j] == np.max(x_coords) and self.b['y'][j] &lt;= self.b['y_val_to_pin']:\n                    x = self.b['x'][j] + (self.b['n'][j]) * self.b['s']  # We're at the right edge\n                    ha = 'right'\n                elif self.b['x'][j] == np.min(x_coords) and self.b['y'][j] &lt;= self.b['y_val_to_pin']:\n                    x = self.b['x'][j]  # We're at the left edge\n                    ha = 'left'\n\n        # AFSC text\n        self.b['afsc_name_text'][j] = self.ax.text(x, y, self.p['afscs'][j], fontsize=self.b['afsc_fontsize'][j],\n                                                   horizontalalignment=ha, verticalalignment=va,\n                                                   color=self.b['text_color'])\n\n        # Cadet box text size\n        cb_s = get_fontsize_for_text_in_box(self.ax, \"0\", (0, 0), self.b['s'], self.b['s'], va='center')\n\n        # Loop through each cadet to add the cadet boxes and circles\n        self.b['c_boxes'][j] = {}\n        self.b['c_circles'][j] = {}\n        self.b['c_rank_text'][j] = {}\n        for i in range(self.b['n^2'][j]):  # All cadet boxes\n\n            # If we are under the maximum number of cadets allowed\n            if i + 1 &lt;= self.b['max_afsc'][j]:\n\n                # Boxes based on SOC PGL Breakouts\n                if 'SOC PGL' in self.b['focus']:\n\n                    # If we are under the USAFA PGL\n                    if i + 1 &lt;= self.p['usafa_quota'][j]:\n                        linestyle = self.b['pgl_linestyle']\n                        color = self.b['usafa_pgl_color']\n                        alpha = self.b['pgl_alpha']\n\n                    # We're in the ROTC range\n                    elif i + 1 &lt;= self.p['usafa_quota'][j] + self.p['rotc_quota'][j]:\n                        linestyle = self.b['pgl_linestyle']\n                        color = self.b['rotc_pgl_color']\n                        alpha = self.b['pgl_alpha']\n\n                    # 'Surplus' Range\n                    else:\n                        linestyle = self.b['surplus_linestyle']\n                        color = self.b['surplus_color']\n                        alpha = self.b['surplus_alpha']\n\n                else:\n\n                    # If we are under the PGL\n                    if i + 1 &lt;= self.b['min_afsc'][j]:\n                        linestyle = self.b['pgl_linestyle']\n                        color = self.b['pgl_color']\n                        alpha = self.b['pgl_alpha']\n\n                    # 'Surplus' Range\n                    else:\n                        linestyle = self.b['surplus_linestyle']\n                        color = self.b['surplus_color']\n                        alpha = self.b['surplus_alpha']\n\n                # Make the rectangle patch (cadet box)\n                self.b['c_boxes'][j][i] = patches.Rectangle(self.b['cb_coords'][j][i], self.b['s'], self.b['s'],\n                                                            linestyle=linestyle, linewidth=1, facecolor=color,\n                                                            alpha=alpha, edgecolor=self.b['cb_edgecolor'])\n\n                # Add the patch to the figure\n                if include_surplus or linestyle == self.b['pgl_linestyle']:\n                    self.ax.add_patch(self.b['c_boxes'][j][i])\n\n            # If we are under the maximum number of cadets assigned to this AFSC across the solutions\n            if i + 1 &lt;= self.b['max_assigned'][j]:\n\n                # Make the circle patch (cadet)\n                x, y = self.b['cb_coords'][j][i][0] + (self.b['s'] / 2), \\\n                       self.b['cb_coords'][j][i][1] + (self.b['s'] / 2)\n                self.b['c_circles'][j][i] = patches.Circle(\n                    (x, y), radius = (self.b['s'] / 2) * self.b['circle_radius_percent'], linestyle='-', linewidth=1,\n                    facecolor='black', alpha=1, edgecolor='black')\n\n                # Add the patch to the figure\n                self.ax.add_patch(self.b['c_circles'][j][i])\n\n                # Hide the circle\n                self.b['c_circles'][j][i].set_visible(False)\n\n                # We may want to include rank text on the cadets\n                if self.b['show_rank_text']:\n                    self.b['c_rank_text'][j][i] = self.ax.text(x, y, '0', fontsize=cb_s, horizontalalignment='center',\n                                                               verticalalignment='center',\n                                                               color=self.b['rank_text_color'])\n                    self.b['c_rank_text'][j][i].set_visible(False)\n\n    # Remove tick marks\n    self.ax.tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)\n\n    # Add the title\n    if self.b['b_title'] is None:\n        title = \"Round 0 (Orientation)\"\n    else:\n        title = self.b['b_title']\n    self.fig.suptitle(title, fontsize=self.b['b_title_size'], color=self.b['text_color'])\n\n    # Add the legend if necessary\n    if self.b['b_legend']:\n        self.create_legend()\n\n    # Save the figure\n    if self.b['save_board_default']:\n        folder_path = self.paths['Analysis &amp; Results'] + 'Cadet Board/'\n        if self.solution['iterations']['sequence'] not in os.listdir(folder_path):\n            os.mkdir(folder_path + self.b['sequence'])\n\n        # Get the filepath and save the \"default\" graph\n        filepath = folder_path + self.solution['iterations']['sequence'] + '/Default Board'\n        if type(self.mdl_p['afscs_to_show']) == str:\n            filepath += ' (' + self.mdl_p['afscs_to_show'] + ' Cadets).png'\n        else:\n            filepath += ' (M = ' + str(self.b['M']) + ').png'\n        self.fig.savefig(filepath)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.solution_iteration_frame","title":"<code>solution_iteration_frame(s, cadets_to_show='cadets_matched', kind=None)</code>","text":"<p>This method reconstructs the figure to reflect the cadet/afsc state in this iteration</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def solution_iteration_frame(self, s, cadets_to_show='cadets_matched', kind=None):\n    \"\"\"\n    This method reconstructs the figure to reflect the cadet/afsc state in this iteration\n    \"\"\"\n\n    # AFSC Normalized scores\n    self.b['scores'] = {j: 0 for j in self.b['J']}\n\n    # Loop through each AFSC\n    for j in self.b['J']:\n\n        # Sort the cadets based on whatever method we choose\n        unsorted_cadets = self.b[cadets_to_show][s][j]\n        cadets = self.sort_cadets(j, unsorted_cadets)\n\n        # Make sure we have cadets assigned to this AFSC in this frame\n        if len(cadets) &gt; 0:\n\n            # Change the colors of the circles based on the desired method\n            self.change_circle_features(s, j, cadets)\n\n            # Hide the circles/text that aren't in the solution\n            for i in range(len(cadets), self.b['max_assigned'][j]):\n\n                # Hide the circle\n                self.b['c_circles'][j][i].set_visible(False)\n\n                # If rank text is included\n                if self.b['show_rank_text']:\n                    self.b['c_rank_text'][j][i].set_visible(False)\n\n            # Update the text above the AFSC square\n            self.update_afsc_text(s, j)\n\n        else:  # There aren't any assigned cadets yet!\n            self.b['afsc_name_text'][j].set_color('white')\n            self.b['afsc_name_text'][j].set_text(self.p['afscs'][j] + \": 0\")\n\n    # Update the title of the figure\n    self.update_title_text(s, kind=kind)\n\n    # Save the figure\n    if self.b['save_iteration_frames']:\n        self.save_iteration_frame(s, kind=kind)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.build_ots_alg_frames","title":"<code>build_ots_alg_frames()</code>","text":"<p>This method reconstructs the figure to reflect the cadet/afsc state in this iteration</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def build_ots_alg_frames(self):\n    \"\"\"\n    This method reconstructs the figure to reflect the cadet/afsc state in this iteration\n    \"\"\"\n\n    # AFSC Normalized scores\n    self.b['scores'] = {j: 0 for j in self.b['J']}\n\n    # Initialize AFSC text\n    for j in self.b['J']:\n        self.b['afsc_name_text'][j].set_color('white')\n        self.b['afsc_name_text'][j].set_text(self.p['afscs'][j] + \": 0\")\n\n    iterations = [s for s in self.b['solutions']]\n    for s in tqdm(iterations, desc=\"Animation Image\"):\n\n        # AFSC Normalized scores\n        self.b['scores'] = {j: 0 for j in self.b['J']}\n\n        # Loop through each AFSC\n        for j in self.b['J']:\n\n            # Sort the cadets based on whatever method we choose\n            unsorted_cadets = self.b['cadets_matched'][s][j]\n            cadets = self.sort_cadets(j, unsorted_cadets)\n\n            # Make sure we have cadets assigned to this AFSC in this frame\n            if len(cadets) &gt; 0:\n\n                # Change the colors of the circles based on the desired method\n                self.change_circle_features(s, j, cadets)\n\n                # Hide the circles/text that aren't in the solution\n                for i in range(len(cadets), self.b['max_assigned'][j]):\n\n                    # Hide the circle\n                    self.b['c_circles'][j][i].set_visible(False)\n\n                # Update the text above the AFSC square\n                self.update_afsc_text(s, j)\n\n            else:  # There aren't any assigned cadets yet!\n                self.b['afsc_name_text'][j].set_color('white')\n                self.b['afsc_name_text'][j].set_text(self.p['afscs'][j] + \": 0\")\n\n        # Get the location of this new cadet-AFSC pair\n        i, j = self.b['new_match'][s]\n        unsorted_cadets = self.b['cadets_matched'][s][j]\n        cadets = self.sort_cadets(j, unsorted_cadets)\n        idx = np.where(cadets == i)[0][0]\n\n        # Highlight this new cadet-AFSC pair!\n        self.b['c_circles'][j][idx].set_edgecolor('yellow')\n\n        # Update the title of the figure\n        self.update_title_text(s, kind='OTS Algorithm')\n\n        # Save the figure\n        self.save_iteration_frame(s, kind='Matched')\n\n        # Is this a rejected match?\n        if s in self.b['rejections']:\n\n            # Get line coordinates\n            x_values_1 = [self.b['cb_coords'][j][idx][0], self.b['cb_coords'][j][idx][0] + self.b['s']]\n            y_values_1 = [self.b['cb_coords'][j][idx][1], self.b['cb_coords'][j][idx][1] + self.b['s']]\n            x_values_2 = [self.b['cb_coords'][j][idx][0], self.b['cb_coords'][j][idx][0] + self.b['s']]\n            y_values_2 = [self.b['cb_coords'][j][idx][1] + self.b['s'], self.b['cb_coords'][j][idx][1]]\n\n            # Plot the 'Big Red X' lines\n            line_1 = self.ax.plot(x_values_1, y_values_1, linestyle='-', c='red')[0]\n            line_2 = self.ax.plot(x_values_2, y_values_2, linestyle='-', c='red')[0]\n\n            # Save the figure\n            self.save_iteration_frame(s, kind='Rejected')\n\n            # Remove the lines and the cadet\n            line_1.remove()\n            line_2.remove()\n            self.b['c_circles'][j][idx].set_visible(False)  # Hide the circle\n\n        # Remove the outline around this cadet-AFSC pair\n        self.b['c_circles'][j][idx].set_edgecolor('black')\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.rejections_iteration_frame","title":"<code>rejections_iteration_frame(s, kind='Rejections')</code>","text":"<p>This method reconstructs the figure to reflect the cadet/afsc state in this iteration</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def rejections_iteration_frame(self, s, kind='Rejections'):\n    \"\"\"\n    This method reconstructs the figure to reflect the cadet/afsc state in this iteration\n    \"\"\"\n\n    # Rejection 'Xs' lines\n    line_1, line_2 = {}, {}\n\n    # Loop through each AFSC\n    for j in self.b['J']:\n\n        # Sort the cadets based on whatever method we choose\n        unsorted_cadets = self.b['cadets_proposing'][s][j]\n        cadets_proposing = self.sort_cadets(j, unsorted_cadets)\n\n        # Rejection lines\n        line_1[j], line_2[j] = {}, {}\n        for i, cadet in enumerate(cadets_proposing):\n            if cadet not in self.b['cadets_matched'][s][j]:\n\n                # Get line coordinates\n                x_values_1 = [self.b['cb_coords'][j][i][0], self.b['cb_coords'][j][i][0] + self.b['s']]\n                y_values_1 = [self.b['cb_coords'][j][i][1], self.b['cb_coords'][j][i][1] + self.b['s']]\n                x_values_2 = [self.b['cb_coords'][j][i][0], self.b['cb_coords'][j][i][0] + self.b['s']]\n                y_values_2 = [self.b['cb_coords'][j][i][1] + self.b['s'], self.b['cb_coords'][j][i][1]]\n\n                # Plot the 'Big Red X' lines\n                line_1[j][i] = self.ax.plot(x_values_1, y_values_1, linestyle='-', c='red')\n                line_2[j][i] = self.ax.plot(x_values_2, y_values_2, linestyle='-', c='red')\n\n    # Update the title of the figure\n    self.update_title_text(s, kind=kind)\n\n    # Save the figure\n    if self.b['save_iteration_frames']:\n        self.save_iteration_frame(s, kind)\n\n    # Remove the \"Big Red X\" lines\n    for j in self.b['J']:\n        for i in line_1[j]:\n            line = line_1[j][i].pop(0)\n            line.remove()\n            line = line_2[j][i].pop(0)\n            line.remove()\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.sort_cadets","title":"<code>sort_cadets(j, cadets_unsorted)</code>","text":"<p>This method sorts the cadets in this frame through some means</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def sort_cadets(self, j, cadets_unsorted):\n    \"\"\"\n    This method sorts the cadets in this frame through some means\n    \"\"\"\n\n    # Sort the cadets by SOC\n    if self.b['focus'] == 'SOC PGL':\n        indices = np.argsort(self.p['usafa'][cadets_unsorted])[::-1]\n\n    # Sort the cadets by AFSC preferences\n    elif self.mdl_p['sort_cadets_by'] == 'AFSC Preferences':\n        indices = np.argsort(self.p['a_pref_matrix'][cadets_unsorted, j])\n\n    # Sort the cadets by order of merit (OM)\n    elif self.mdl_p['sort_cadets_by'] == 'OM':\n        indices = np.argsort(self.p['merit'][cadets_unsorted])[::-1]\n\n    # Return the sorted cadets\n    return cadets_unsorted[indices]\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.change_circle_features","title":"<code>change_circle_features(s, j, cadets)</code>","text":"<p>This method determines the color and edgecolor of the circles to show</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def change_circle_features(self, s, j, cadets):\n    \"\"\"\n    This method determines the color and edgecolor of the circles to show\n    \"\"\"\n\n    # Colors based on cadet utility\n    if self.b['focus'] == 'Cadet Utility':\n        utility = self.p['cadet_utility'][cadets, j]\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n\n            # Change circle color\n            color = self.v_hex_dict[round(utility[i], 2)]\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif self.b['focus'] == 'Cadet Choice':\n        choice = self.p['c_pref_matrix'][cadets, j]\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n\n            # Change circle color\n            if choice[i] in self.mdl_p['choice_colors']:\n                color = self.mdl_p['choice_colors'][choice[i]]\n            else:\n                color = self.mdl_p['all_other_choice_colors']\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif self.b['focus'] == 'Cadet Choice Categories':\n        choice = self.p['c_pref_matrix'][cadets, j]\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n\n            # If the AFSC was a top 6 choice, we use that color\n            if choice[i] in [1, 2, 3, 4, 5, 6]:\n                color = self.mdl_p['choice_colors'][choice[i]]\n\n            # If the AFSC was at least selected, we make it that color\n            elif j in self.p['J^Selected'][cadet]:\n\n                # Use the color for the 8th choice\n                color = self.mdl_p['choice_colors'][8]\n\n            # If the AFSC was not in the bottom 3 choices, we make it that color\n            elif j not in self.p['J^Bottom 2 Choices'][cadet] and j != self.p['J^Last Choice'][cadet]:\n\n                # Use the color for the 9th choice\n                color = self.mdl_p['choice_colors'][9]\n\n            # Otherwise, it's a bottom 3 choice\n            else:\n                color = self.mdl_p['all_other_choice_colors']\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif self.b['focus'] == 'AFSC Choice':\n        choice = self.p['afsc_utility'][cadets, j]\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n\n            value = round(choice[i], 2)\n\n            # Change circle color\n            color = self.v_hex_dict[value]\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif self.b['focus'] == 'ROTC Rated Interest':\n        afsc_index = np.where(self.b['J'] == j)[0][0]\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n            idx = self.p['Rated Cadet Index Dict']['rotc'][cadet]\n            interest = self.p['rr_interest_matrix'][idx, afsc_index]\n\n            # Change circle color\n            color = self.mdl_p['interest_colors'][interest]\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif self.b['focus'] == 'Reserves':\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n            if cadet in self.solution['iterations']['matched'][s]:\n                color = self.b['matched_slot_color']\n            elif cadet in self.solution['iterations']['reserves'][s]:\n                color = self.b['reserved_slot_color']\n            else:\n                color = self.b['unmatched_color']\n\n            # Change circle color\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif self.b['focus'] == 'SOC PGL':\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n            if cadet in self.p['usafa_cadets']:\n                color = self.b['usafa_bubble']\n            else:\n                color = self.b['rotc_bubble']\n\n            # Change circle color\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif self.b['focus'] == 'Rated Choice':\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n            rated_choices = self.p['Rated Choices'][self.soc][cadet]\n\n            # Get color of this choice\n            if j in rated_choices:\n                choice = np.where(rated_choices == j)[0][0] + 1\n            else:\n                choice = 100  # Arbitrary big number\n\n            # Change circle color\n            if choice in self.mdl_p['choice_colors']:\n                color = self.mdl_p['choice_colors'][choice]\n            else:\n                color = self.mdl_p['all_other_choice_colors']\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif 'Specific Choice' in self.b['focus']:\n\n        # Get the AFSC we're highlighting\n        j_focus = np.where(self.p['afscs'] == self.mdl_p['afsc'])[0][0]\n        choice = self.p['c_pref_matrix'][cadets, j_focus]\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n\n            # Change circle color\n            if choice[i] in self.mdl_p['choice_colors']:\n                color = self.mdl_p['choice_colors'][choice[i]]\n            elif choice[i] == 0:  # Ineligible\n                color = self.mdl_p['unfocused_color']\n            else:  # All other choices\n                color = self.mdl_p['all_other_choice_colors']\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif 'Tier 1' in self.b['focus']:\n        choice = self.p['c_pref_matrix'][cadets, j]\n\n        # Get the AFSC we're highlighting\n        j_focus = np.where(self.p['afscs'] == self.mdl_p['afsc'])[0][0]\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n\n            # Change circle color\n            if '1' in self.p['qual'][cadet, j_focus]:\n                if choice[i] in self.mdl_p['choice_colors']:\n                    color = self.mdl_p['choice_colors'][choice[i]]\n                else:\n                    color = self.mdl_p['all_other_choice_colors']\n            else:\n                color = self.mdl_p['unfocused_color']\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Edgecolor (Don't worry about exception anymore)\n            if 'E' in self.p['qual'][cadet, j_focus]:# and j == j_focus:\n                self.b['c_circles'][j][i].set_edgecolor(self.mdl_p['exception_edge'])\n            else:\n                self.b['c_circles'][j][i].set_edgecolor(self.mdl_p['base_edge'])\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    # Cadet rank text\n    if self.b['show_rank_text']:\n        choice = self.p['a_pref_matrix'][cadets, j]\n        for i, cadet in enumerate(cadets):\n            txt = str(choice[i])\n            x, y = self.b['cb_coords'][j][i][0] + (self.b['s'] / 2), \\\n                   self.b['cb_coords'][j][i][1] + (self.b['s'] / 2)\n            w, h = self.b['s'] * self.b['circle_radius_percent'], self.b['s'] * self.b['circle_radius_percent']\n            fontsize = get_fontsize_for_text_in_box(self.ax, txt, (x, y), w, h, va='center')\n\n            # Adjust fontsize for single digit ranks\n            if int(txt) &lt; 10:\n                fontsize = int(fontsize * self.b['fontsize_single_digit_adj'])\n            self.b['c_rank_text'][j][i].set_text(txt)\n            self.b['c_rank_text'][j][i].set_fontsize(fontsize)\n            self.b['c_rank_text'][j][i].set_visible(True)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.update_afsc_text","title":"<code>update_afsc_text(s, j)</code>","text":"<p>This method updates the text above the AFSC squares</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def update_afsc_text(self, s, j):\n    \"\"\"\n    This method updates the text above the AFSC squares\n    \"\"\"\n\n    # Set of ranks for all the cadets \"considered\" in this solution for this AFSC\n    cadets_considered = np.intersect1d(self.b['cadets'], self.p['I^E'][j])\n    ranks = self.p['a_pref_matrix'][cadets_considered, j]\n    achieved_ranks = self.p['a_pref_matrix'][self.b['cadets_matched'][s][j], j]\n\n    # Calculate AFSC Norm Score and use it in the new text\n    self.b['scores'][j] = round(afccp.solutions.handling.calculate_afsc_norm_score_general(\n        ranks, achieved_ranks), 2)\n\n    # If we want to put this AFSC title on two lines or not\n    if self.b['afsc_title_two_lines'][j]:\n        afsc_text = self.p['afscs'][j] + \":\\n\"\n    else:\n        afsc_text = self.p['afscs'][j] + \": \"\n\n    # Change the text for the AFSCs\n    if self.b['focus'] == 'SOC PGL':\n        more = 'neither'\n        for soc, other_soc in {'usafa': 'rotc', 'rotc': 'usafa'}.items():\n            soc_cadets = len(np.intersect1d(self.b['cadets_matched'][s][j], self.p[soc + '_cadets']))\n            soc_pgl = self.p[soc + '_quota'][j]\n            diff = soc_cadets - soc_pgl\n            if diff &gt; 0:\n                more = soc\n                afsc_text += '+' + str(diff)\n\n        if more == 'neither':\n            color = 'white'\n            afsc_text += '+0'\n        else:\n            color = self.b[more + '_bubble']\n        self.b['afsc_name_text'][j].set_color(color)\n\n    elif self.b['afsc_text_to_show'] == 'Norm Score':\n        color = self.v_hex_dict[self.b['scores'][j]]  # New AFSC color\n        afsc_text += str(self.b['scores'][j])\n        self.b['afsc_name_text'][j].set_color(color)\n\n    # Determine average cadet choice and use it in the new text\n    elif self.b['afsc_text_to_show'] == 'Cadet Choice':\n        average_choice = round(np.mean(self.p['c_pref_matrix'][self.b['cadets_matched'][s][j], j]), 2)\n        color = 'white'\n        afsc_text += str(average_choice)\n        self.b['afsc_name_text'][j].set_color(color)\n\n    # Text shows number of cadets matched/proposing\n    else:\n        afsc_text += str(len(self.b['cadets_matched'][s][j]))\n\n    # Update the text\n    self.b['afsc_name_text'][j].set_text(afsc_text)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.update_title_text","title":"<code>update_title_text(s, kind=None)</code>","text":"<p>This method purely updates the text in the title of the figure</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def update_title_text(self, s, kind=None):\n    \"\"\"\n    This method purely updates the text in the title of the figure\n    \"\"\"\n\n    # Change the text and color of the title\n    if kind == 'Proposals':\n        title_text = 'Round ' + str(s + 1) + ' (Proposals)'\n\n        # Get the color of the title\n        if s + 1 in self.b['choice_colors']:\n            title_color = self.b['choice_colors'][s + 1]\n        else:\n            title_color = self.b['all_other_choice_colors']\n    else:\n        title_color = self.b['text_color']\n\n        # Update the title text in a specific way\n        if kind == 'Final Solution':\n            title_text = 'Solution'\n        elif kind == 'Rejections':\n            title_text = 'Round ' + str(s + 1) + ' (Rejections)'\n\n            # Get the color of the title\n            if s + 1 in self.b['choice_colors']:\n                title_color = self.b['choice_colors'][s + 1]\n            else:\n                title_color = self.b['all_other_choice_colors']\n        else:\n            title_text = self.solution['iterations']['names'][s]\n\n    # All unmatched cadets in the solution (even the ones we're not considering)\n    unmatched_cadets_all = np.where(self.b['solutions'][s] == self.p['M'])[0]\n\n    # Unmatched cadets that we're concerned about in this solution (This really just applies to Rated)\n    unmatched_cadets = np.intersect1d(unmatched_cadets_all, self.b['cadets'])\n    self.num_unmatched = len(unmatched_cadets)\n    matched_cadets = np.array([i for i in self.b['cadets'] if i not in unmatched_cadets])\n\n    # Calculate average cadet choice based on matched cadets\n    choices = np.zeros(len(matched_cadets))\n    for idx, i in enumerate(matched_cadets):\n        j = self.b['solutions'][s][i]\n        choices[idx] = self.p['c_pref_matrix'][i, j]\n    self.average_cadet_choice = round(np.mean(choices), 2)\n\n    # Calculate AFSC weighted average score (and add number of unmatched cadets)\n    counts = np.array([len(np.where(self.b['solutions'][s] == j)[0]) for j in self.b['J']])\n    weights = counts / np.sum(counts)\n    scores = np.array([self.b['scores'][j] for j in self.b['J']])\n    self.average_afsc_choice = round(np.dot(weights, scores), 2)\n\n    # Add title text\n    if self.b['focus'] in ['Specific Choice', 'Tier 1']:\n        title_text += ' Highlighting Results for ' + self.mdl_p['afsc']\n    elif kind not in ['OTS Algorithm']:\n        percent_text = str(np.around(self.solution['top_3_choice_percent'] * 100, 3)) + \"%\"\n        title_text += ' Results: Cadet Top3: ' + percent_text\n        title_text += ', AFSC Score: ' + str(np.around(self.average_afsc_choice, 2))\n        if 'z^CASTLE (Values)' in self.solution:\n            title_text += f', CASTLE: {round(self.solution[\"z^CASTLE (Values)\"], 2)}'\n\n    # Update the title\n    if self.b['b_title'] is not None:  # We specified a title directly\n        title_text = self.b['b_title']\n    self.fig.suptitle(title_text, fontsize=self.b['b_title_size'], color=title_color)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.save_iteration_frame","title":"<code>save_iteration_frame(s, kind=None)</code>","text":"<p>Saves the iteration frame to the appropriate folder</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def save_iteration_frame(self, s, kind=None):\n    \"\"\"\n    Saves the iteration frame to the appropriate folder\n    \"\"\"\n\n    # Save the figure\n    if self.b['save_iteration_frames']:\n\n        # 'Sequence' Folder\n        folder_path = self.paths['Analysis &amp; Results'] + 'Cadet Board/'\n        if self.solution['iterations']['sequence'] not in os.listdir(folder_path):\n            os.mkdir(folder_path + self.solution['iterations']['sequence'])\n\n        # 'Sequence Focus' Sub-folder\n        sub_folder_name = self.b['focus']\n        if sub_folder_name not in os.listdir(folder_path + self.solution['iterations']['sequence'] + '/'):\n            os.mkdir(folder_path + self.solution['iterations']['sequence'] + '/' + sub_folder_name)\n        sub_folder_path = folder_path + self.solution['iterations']['sequence']  + '/' + sub_folder_name + '/'\n        if kind is None:\n            filepath = sub_folder_path + str(s + 1) + '.png'\n        elif kind == \"Final Solution\":\n            filepath = sub_folder_path + str(s + 2) + ' (' + kind + ').png'\n        else:\n            filepath = sub_folder_path + str(s + 1) + ' (' + kind + ').png'\n\n        # Save frame\n        self.fig.savefig(filepath)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.export_board_parameters","title":"<code>export_board_parameters()</code>","text":"<p>This function exports the board parameters back to excel</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def export_board_parameters(self):\n    \"\"\"\n    This function exports the board parameters back to excel\n    \"\"\"\n\n    if 'iterations' not in self.solution:\n\n        # Solutions Folder\n        filepath = self.paths['Analysis &amp; Results'] + self.solution['name'] + '/Board Parameters.csv'\n        if self.solution['name'] not in os.listdir(self.paths['Analysis &amp; Results']):\n            os.mkdir(self.paths['Analysis &amp; Results'] + self.solution['name'] + '/')\n    else:\n\n        # 'Sequence' Folder\n        folder_path = self.paths['Analysis &amp; Results'] + 'Cadet Board/'\n        filepath = folder_path + self.solution['iterations']['sequence'] + '/Board Parameters.csv'\n        if self.solution['iterations']['sequence'] not in os.listdir(folder_path):\n            os.mkdir(folder_path + self.solution['iterations']['sequence'])\n\n    # Create dataframe\n    df = pd.DataFrame({'J': [j for j in self.b['J']],\n                       'AFSC': [self.p['afscs'][j] for j in self.b['J']],\n                       'x': [self.b['x'][j] for j in self.b['J']],\n                       'y': [self.b['y'][j] for j in self.b['J']],\n                       'n': [self.b['n'][j] for j in self.b['J']],\n                       's': [self.b['s'] for _ in self.b['J']],\n                       'afsc_fontsize': [self.b['afsc_fontsize'][j] for j in self.b['J']],\n                       'afsc_title_two_lines': [self.b['afsc_title_two_lines'][j] for j in self.b['J']]})\n\n    # Export file\n    df.to_csv(filepath, index=False)\n\n    if self.printing:\n        print(\"Sequence parameters (J, x, y, n, s) exported to\", filepath)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.import_board_parameters","title":"<code>import_board_parameters()</code>","text":"<p>This method imports the board parameters from excel if applicable</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def import_board_parameters(self):\n    \"\"\"\n    This method imports the board parameters from excel if applicable\n    \"\"\"\n\n    # 'Solutions' Folder\n    if 'iterations' not in self.solution:\n        folder_path = self.paths['Analysis &amp; Results'] + self.solution['name']\n\n        # Import the file if we have it\n        if 'Board Parameters.csv' in os.listdir(folder_path):\n            filepath = folder_path + '/Board Parameters.csv'\n            df = afccp.globals.import_csv_data(filepath)\n\n            # Load parameters\n            self.b['J'] = np.array(df['J'])\n            self.b['afscs'] = np.array(df['AFSC'])\n            self.b['s'] = float(df.loc[0, 's'])\n            for key in ['x', 'y', 'n', 'afsc_fontsize', 'afsc_title_two_lines']:\n                self.b[key] = {j: df.loc[idx, key] for idx, j in enumerate(self.b['J'])}\n\n            if self.printing:\n                print(\"Sequence parameters (J, x, y, n, s) imported from\", filepath)\n            return True\n\n        else:\n\n            if self.printing:\n                print(\"No Sequence parameters found in solution analysis sub-folder '\" +\n                      self.solution['name'] + \"'.\")\n            return False\n\n\n    # 'Sequence' Folder\n    folder_path = self.paths['Analysis &amp; Results'] + 'Cadet Board/'\n    if self.solution['iterations']['sequence'] in os.listdir(folder_path):\n\n        # Import the file if we have it\n        if 'Board Parameters.csv' in os.listdir(folder_path + self.solution['iterations']['sequence']):\n            filepath = folder_path + self.solution['iterations']['sequence'] + '/Board Parameters.csv'\n            df = afccp.globals.import_csv_data(filepath)\n\n            # Load parameters\n            self.b['J'] = np.array(df['J'])\n            self.b['afscs'] = np.array(df['AFSC'])\n            self.b['s'] = float(df.loc[0, 's'])\n            for key in ['x', 'y', 'n', 'afsc_fontsize', 'afsc_title_two_lines']:\n                self.b[key] = {j: df.loc[idx, key] for idx, j in enumerate(self.b['J'])}\n\n            if self.printing:\n                print(\"Sequence parameters (J, x, y, n, s) imported from\", filepath)\n            return True\n\n        else:\n\n            if self.printing:\n                print(\"Sequence folder '\" + self.solution['iterations']['sequence'] + \"' in 'Cadet Board' analysis sub-folder, but no \"\n                                                                 \"board parameter file found within sequence folder.\")\n            return False\n\n    else:\n        if self.printing:\n            print(\"No sequence folder '\" + self.solution['iterations']['sequence'] + \"' in 'Cadet Board' analysis sub-folder.\")\n        return False\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.get_fontsize_for_text_in_box","title":"<code>get_fontsize_for_text_in_box(self, txt, xy, width, height, *, transform=None, ha='center', va='center', **kwargs)</code>","text":"<p>Determines fontsize of the text that needs to be inside a specific box</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def get_fontsize_for_text_in_box(self, txt, xy, width, height, *, transform=None,\n                                 ha='center', va='center', **kwargs):\n    \"\"\"\n    Determines fontsize of the text that needs to be inside a specific box\n    \"\"\"\n\n    # Transformation\n    if transform is None:\n        if isinstance(self, plt.Axes):\n            transform = self.transData\n        if isinstance(self, plt.Figure):\n            transform = self.transFigure\n\n    # Align the x and y\n    x_data = {'center': (xy[0] - width / 2, xy[0] + width / 2),\n              'left': (xy[0], xy[0] + width),\n              'right': (xy[0] - width, xy[0])}\n    y_data = {'center': (xy[1] - height / 2, xy[1] + height / 2),\n              'bottom': (xy[1], xy[1] + height),\n              'top': (xy[1] - height, xy[1])}\n\n    (x0, y0) = transform.transform((x_data[ha][0], y_data[va][0]))\n    (x1, y1) = transform.transform((x_data[ha][1], y_data[va][1]))\n\n    # Rectangle region size to constrain the text\n    rect_width = x1 - x0\n    rect_height = y1 - y0\n\n    # Doing stuff\n    fig = self.get_figure() if isinstance(self, plt.Axes) else self\n    dpi = fig.dpi\n    rect_height_inch = rect_height / dpi\n    fontsize = rect_height_inch * 72\n\n    # Put on the text\n    if isinstance(self, plt.Axes):\n        text = self.annotate(txt, xy, ha=ha, va=va, xycoords=transform,\n                             **kwargs)\n\n    # Adjust the fontsize according to the box size.\n    text.set_fontsize(fontsize)\n    bbox: Bbox = text.get_window_extent(fig.canvas.get_renderer())\n    adjusted_size = fontsize * rect_width / bbox.width\n    text.set_fontsize(adjusted_size)\n\n    # Remove the text but return the font size\n    text.remove()\n    return text.get_fontsize()\n</code></pre>"},{"location":"reference/visualizations/charts/","title":"Charts","text":""},{"location":"reference/visualizations/charts/#visualizations.charts","title":"<code>visualizations.charts</code>","text":""},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart","title":"<code>AFSCsChart(instance)</code>","text":"<p>This is a class dedicated to creating \"AFSCs Charts\" which are all charts that include AFSCs on the x-axis. This is meant to condense the amount of code and increase read-ability of the various kinds of charts.</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def __init__(self, instance):\n    \"\"\"\n    This is a class dedicated to creating \"AFSCs Charts\" which are all charts\n    that include AFSCs on the x-axis. This is meant to condense the amount of code and increase\n    read-ability of the various kinds of charts.\n    \"\"\"\n\n    # Load attributes\n    self.parameters = instance.parameters\n    self.value_parameters, self.vp_name = instance.value_parameters, instance.vp_name\n    self.ip = instance.mdl_p  # \"instance plot parameters\"\n    self.solution, self.solution_name = instance.solution, instance.solution_name\n    self.data_name, self.data_version = instance.data_name, instance.data_version\n\n    # Dictionaries of instance components (sets of value parameters, solutions)\n    self.vp_dict, self.solutions = instance.vp_dict, instance.solutions\n\n    # Initialize the matplotlib figure/axes\n    self.fig, self.ax = plt.subplots(figsize=self.ip['figsize'], facecolor=self.ip['facecolor'], tight_layout=True,\n                                     dpi=self.ip['dpi'])\n\n    # Label dictionary for AFSC objectives\n    self.label_dict = copy.deepcopy(afccp.globals.obj_label_dict)\n\n    # This is going to be a dictionary of all the various chart-specific components we need\n    self.c = {\"J\": self.ip['J'], 'afscs': self.ip['afscs'], 'M': self.ip['M'], 'k': 0,  # Default k\n              'y_max': self.ip['y_max'], 'legend_elements': None, 'use_calculated_y_max': False,\n              'legend_title': None}\n\n    # If we skip AFSCs\n    if self.ip[\"skip_afscs\"]:\n        self.c[\"tick_indices\"] = np.arange(1, self.c[\"M\"], 2).astype(int)\n    else:\n        self.c[\"tick_indices\"] = np.arange(self.c[\"M\"]).astype(int)\n\n    # Where to save the chart\n    self.paths = {\"Data\": instance.export_paths[\"Analysis &amp; Results\"] + \"Data Charts/\",\n                  \"Solution\": instance.export_paths[\"Analysis &amp; Results\"] + self.solution_name + \"/\",\n                  \"Comparison\": instance.export_paths[\"Analysis &amp; Results\"] + \"Comparison Charts/\"}\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.build","title":"<code>build(chart_type='Data', printing=True)</code>","text":"<p>Builds the specific chart based on what the user passes within the \"instance plot parameters\" (ip)</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def build(self, chart_type=\"Data\", printing=True):\n    \"\"\"\n    Builds the specific chart based on what the user passes within the \"instance plot parameters\" (ip)\n    \"\"\"\n\n    # If we don't have that data, just fill this in so this chart still works\n    if 'race_categories' not in self.parameters.keys():\n        self.parameters['race_categories'] = ['Blank']\n    if 'ethnicity_categories' not in self.parameters.keys():\n        self.parameters['ethnicity_categories'] = ['Blank']\n\n    # Determine which chart to build\n    if chart_type == \"Data\":\n        if self.ip['data_graph'] in ['Average Merit', 'USAFA Proportion', 'Average Utility']:\n            self.data_average_chart()\n        elif self.ip[\"data_graph\"] == \"AFOCD Data\":\n            self.data_afocd_chart()\n        elif self.ip[\"data_graph\"] == \"Cadet Preference Analysis\":\n            self.data_preference_chart()\n        elif self.ip[\"data_graph\"] == \"Eligible Quota\":\n            self.data_quota_chart()\n\n        # Get filename\n        if self.ip[\"filename\"] is None:\n            self.ip[\"filename\"] = \\\n                self.data_name + \" (\" + self.data_version + \") \" + self.ip[\"data_graph\"] + \" (Data).png\"\n\n    elif chart_type in [\"Solution\", \"Comparison\"]:\n\n        # Only perform the following steps if it's for a \"real\" VP objective\n        if self.ip['objective'] != 'Extra':\n\n            # AFSC objective index and condense the AFSCs if this is an AFOCD objective\n            self.c['k'] = np.where(self.value_parameters['objectives'] == self.ip['objective'])[0][0]\n            self.condense_afscs_based_on_objective()\n\n        # Need to know number of cadets assigned\n        self.c['total_count'] = self.solution[\"count\"][self.c['J']]\n\n        # Determine if we sort the AFSCs by PGL or not\n        if self.ip['sort_by_pgl'] and \"STEM\" not in self.ip['version']:\n            quota = np.array([self.parameters['pgl'][j] for j in self.c['J']])\n\n            # Sort the AFSCs by the PGL\n            indices = np.argsort(quota)[::-1]\n            self.c['afscs'] = self.c['afscs'][indices]\n            self.c['total_count'] = self.c['total_count'][indices]\n            self.c['J'] = self.c['J'][indices]\n\n        # Sort by STEM AFSCs\n        if \"STEM\" in self.ip['version']:\n\n            # Sort all the AFSCs by the PGL\n            sorted_indices = np.argsort(self.parameters['pgl'])[::-1]\n\n            # Sort the AFSCs by \"Not STEM\", \"Hybrid\", \"STEM\" and then by PGL\n            sorted_j = []\n            for cat in [\"Not STEM\", \"Hybrid\", \"STEM\"]:\n                for j in sorted_indices:\n                    if j in p['J^' + cat] and j in self.c['J']:\n                        sorted_j.append(j)\n\n            # Sort the specific elements of this chart\n            indices = np.array(sorted_j)\n            self.c['afscs'] = self.c['afscs'][indices]\n            self.c['total_count'] = self.c['total_count'][indices]\n            self.c['J'] = self.c['J'][indices]\n\n        if self.ip['results_graph'] == 'Solution Comparison':\n            self.results_solution_comparison_chart()\n        else:\n\n            if self.ip['objective'] != 'Extra':\n\n                # Default y-label\n                self.c['y_label'] = self.label_dict[self.ip['objective']]\n\n                # Shared elements\n                self.c['measure'] = self.solution['objective_measure'][self.c['J'], self.c['k']]\n\n                # Build the Merit Chart\n                if self.ip['objective'] == 'Merit':\n                    self.results_merit_chart()\n\n                # Demographic Chart\n                elif self.ip['objective'] in ['USAFA Proportion', 'Male', 'Minority']:\n                    self.results_demographic_chart()\n\n                # AFOCD Degree Tier Chart\n                elif self.ip['objective'] in ['Mandatory', 'Desired', 'Permitted', 'Tier 1', 'Tier 2',\n                                              'Tier 3', 'Tier 4']:\n                    self.results_degree_tier_chart()\n\n                # Combined Quota Chart\n                elif self.ip['objective'] == 'Combined Quota':\n                    self.results_quota_chart()\n\n                # Cadet/AFSC Preference Chart\n                elif self.ip['objective'] == 'Utility':\n                    self.results_preference_chart()\n                elif self.ip['objective'] == 'Norm Score':\n                    if self.ip['version'] == 'bar':\n                        self.results_norm_score_chart()\n                    else:\n                        self.results_preference_chart()\n\n            else:\n\n                # Demographic Charts\n                if self.ip['version'] in ['Race Chart', 'Gender Chart', 'Ethnicity Chart', 'SOC Chart',\n                                          'Race Chart_proportion', 'Gender Chart_proportion',\n                                          'Ethnicity Chart_proportion', 'SOC Chart_proportion']:\n\n                    # if 'race_categories' not in self.parameters:\n                    #     return None  # We're not doing this\n\n                    self.results_demographic_proportion_chart()\n\n        # Get filename\n        if self.ip[\"filename\"] is None:\n            self.ip[\"filename\"] = self.data_name + \" (\" + self.data_version + \") \" + self.solution_name + \" \" + \\\n                                  self.ip['objective'] + ' ' + self.ip[\"results_graph\"] + \" [\" + \\\n                                  self.ip['version'] + \"] (Results).png\"\n    else:\n        raise ValueError(\"Error. Invalid AFSC 'main' chart type value of '\" +\n                         chart_type + \"'. Valid inputs are 'Data' or 'Results'.\")\n\n    # Put the solution name in the title\n    if self.ip[\"solution_in_title\"]:\n        self.ip['title'] = self.solution_name + \": \" + self.ip['title']\n\n    # Display title\n    if self.ip['display_title']:\n        self.fig.suptitle(self.ip['title'], fontsize=self.ip['title_size'])\n\n    # Labels\n    self.ax.set_ylabel(self.c[\"y_label\"])\n    self.ax.yaxis.label.set_size(self.ip['label_size'])\n    self.ax.set_xlabel('AFSCs')\n    self.ax.xaxis.label.set_size(self.ip['label_size'])\n\n    if self.ip[\"color_afsc_text_by_grp\"]:\n        afsc_colors = [self.ip['bar_colors'][self.parameters['acc_grp'][j]] for j in self.c['J']]\n    else:\n        afsc_colors = [\"black\" for _ in self.c['afscs']]\n\n    # X axis\n    self.ax.tick_params(axis='x', labelsize=self.ip['afsc_tick_size'])\n    self.ax.set_xticklabels(self.c[\"afscs\"][self.c[\"tick_indices\"]], rotation=self.ip['afsc_rotation'])\n    self.ax.set_xticks(self.c[\"tick_indices\"])\n    self.ax.set(xlim=(-0.8, self.c[\"M\"]))\n\n    # Unique AFSC colors potentially based on accessions group\n    for index, xtick in enumerate(self.ax.get_xticklabels()):\n        xtick.set_color(afsc_colors[index])\n\n    # Y axis\n    self.ax.tick_params(axis='y', labelsize=self.ip['yaxis_tick_size'])\n    self.ax.set(ylim=(0, self.c[\"y_max\"]))\n    if \"y_ticks\" in self.c and self.c['y_max'] &gt; 50:\n        self.ax.set_yticklabels(self.c['y_ticks'])\n        self.ax.set_yticks(self.c['y_ticks'])\n\n    # Legend\n    if self.ip[\"add_legend_afsc_chart\"] and self.c['legend_elements'] is not None:\n\n        if self.c['legend_title']:\n            self.ax.legend(handles=self.c[\"legend_elements\"], edgecolor='black', loc=self.ip['legend_loc'],\n                           fontsize=self.ip['legend_size'], ncol=self.ip['ncol'], labelspacing=1, handlelength=0.8,\n                           handletextpad=0.2, borderpad=0.2, handleheight=2, title=self.c['legend_title'],\n                           title_fontsize=self.ip['legend_fontsize'])\n        else:\n            self.ax.legend(handles=self.c[\"legend_elements\"], edgecolor='black', loc=self.ip['legend_loc'],\n                           fontsize=self.ip['legend_size'], ncol=self.ip['ncol'], labelspacing=1, handlelength=0.8,\n                           handletextpad=0.2, borderpad=0.2, handleheight=2)\n\n    # Save the chart\n    if self.ip['save']:\n        self.fig.savefig(self.paths[chart_type] + self.ip[\"filename\"])\n\n        if printing:\n            print(\"Saved\", self.ip[\"filename\"], \"Chart to \" + self.paths[chart_type] + \".\")\n    else:\n        if printing:\n            print(\"Created\", self.ip[\"filename\"], \"Chart.\")\n\n    # Return the full chart object\n    return self\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.condense_afscs_based_on_objective","title":"<code>condense_afscs_based_on_objective()</code>","text":"<p>This method reduces the AFSCs we're looking at based on the AFSCs that have a non-zero objective weight for AFOCD objectives</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def condense_afscs_based_on_objective(self):\n    \"\"\"\n    This method reduces the AFSCs we're looking at based on the AFSCs that have a non-zero objective weight\n    for AFOCD objectives\n    \"\"\"\n\n    # If it's an AFOCD objective, we only take the AFSCs that have that objective\n    if self.ip['objective'] in ['Mandatory', 'Desired', 'Permitted', 'Tier 1', 'Tier 2', 'Tier 3', 'Tier 4']:\n        self.c['J'] = np.array([j for j in self.c['J'] if self.c['k'] in self.value_parameters['K^A'][j]]).astype(int)\n        self.c['afscs'] = self.parameters['afscs'][self.c['J']]\n        self.c['M'] = len(self.c['afscs'])\n\n        # Make sure we're not skipping AFSCs at this point\n        self.c[\"tick_indices\"] = np.arange(self.c[\"M\"]).astype(int)\n\n    # Make sure at least one AFSC has this objective selected\n    if self.c['M'] == 0:\n        raise ValueError(\"Error. No AFSCs have objective '\" + self.ip[\"objective\"] + \"'.\")\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.determine_y_max_and_y_ticks","title":"<code>determine_y_max_and_y_ticks()</code>","text":"<p>This method calculates the correct y_max and y_ticks for this chart in place</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def determine_y_max_and_y_ticks(self):\n    \"\"\"\n    This method calculates the correct y_max and y_ticks for this chart in place\n    \"\"\"\n    # Y max\n    if self.ip['y_exact_max'] is None:\n        self.c['y_max'] = self.ip['y_max'] * max(self.c['total_count'])\n    else:\n        self.c['y_max'] = self.ip['y_max'] * self.ip['y_exact_max']\n\n    if 100 &lt;= self.c['y_max'] &lt; 150:\n        self.c['y_ticks'] = [50, 100, 150]\n    elif 150 &lt;= self.c['y_max'] &lt; 200:\n        self.c['y_ticks'] = [50, 100, 150, 200]\n    elif 200 &lt;= self.c['y_max'] &lt; 250:\n        self.c['y_ticks'] = [50, 100, 150, 200, 250]\n    elif 250 &lt;= self.c['y_max'] &lt; 300:\n        self.c['y_ticks'] = [50, 100, 150, 200, 250, 300]\n    elif 250 &lt;= self.c['y_max'] &lt; 300:\n        self.c['y_ticks'] = [50, 100, 150, 200, 250, 300, 350]\n    elif self.c['y_max'] &gt;= 500:\n        self.c['y_ticks'] = [100, 200, 300, 400, 500, 600]\n    else:\n        self.c['y_ticks'] = [50]\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.construct_gradient_chart","title":"<code>construct_gradient_chart(parameter_to_use='cadet_utility')</code>","text":"<p>Constructs the gradient chart with \"DIY color bar\"</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def construct_gradient_chart(self, parameter_to_use='cadet_utility'):\n    \"\"\"\n    Constructs the gradient chart with \"DIY color bar\"\n    \"\"\"\n\n    # Shorthand\n    p = self.parameters\n\n    for index, j in enumerate(self.c['J']):\n        cadets = np.where(self.solution['j_array'] == j)[0]\n\n        # What are we plotting\n        if 'parameter_to_use' == 'cadet_utility':\n            measure = p[\"utility\"][cadets, j]\n        else:\n            measure = p[\"merit\"][cadets]\n\n        # Plot the bar\n        uq = np.unique(measure)\n        count_sum = 0\n        for val in uq:\n            count = len(np.where(measure == val)[0])\n\n            if parameter_to_use == 'cadet_utility':\n                c = (1 - val, 0, val)  # Blue to Red\n            else:\n                c = str(val)  # Grayscale\n            self.ax.bar([index], count, bottom=count_sum, color=c)\n            count_sum += count\n\n        # Add the text\n        self.ax.text(index, self.c['total_count'][index] + self.ip['bar_text_offset'], int(self.c['total_count'][index]),\n                     fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n\n    # DIY Colorbar\n    h = (100 / 245) * self.c['y_max']\n    w1 = 0.8\n    w2 = 0.74\n    vals = np.arange(101) / 100\n    current_height = (150 / 245) * self.c['y_max']\n    self.ax.add_patch(Rectangle((self.c['M'] - 2, current_height), w1, h, edgecolor='black', facecolor='black',\n                                fill=True, lw=2))\n    self.ax.text(self.c['M'] - 3.3, (245 / 245) * self.c['y_max'], '100%', fontsize=self.ip[\"xaxis_tick_size\"])\n    self.ax.text(self.c['M'] - 2.8, current_height, '0%', fontsize=self.ip[\"xaxis_tick_size\"])\n    self.ax.text((self.c['M'] - 0.95), (166 / 245) * self.c['y_max'], 'Cadet Satisfaction',\n                fontsize=self.ip[\"xaxis_tick_size\"], rotation=270)\n    for val in vals:\n        if parameter_to_use == 'cadet_utility':\n            c = (1 - val, 0, val)  # Blue to Red\n        else:\n            c = str(val)  # Grayscale\n        self.ax.add_patch(Rectangle((self.c['M'] - 1.95, current_height), w2, h / 101, facecolor=c, fill=True))\n        current_height += h / 101\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.data_average_chart","title":"<code>data_average_chart()</code>","text":"<p>This method builds the \"Average Merit\", \"USAFA Proportion\", and \"Average Utility\" data graph charts. They are all in a very similar format and are therefore combined</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def data_average_chart(self):\n    \"\"\"\n    This method builds the \"Average Merit\", \"USAFA Proportion\", and \"Average Utility\" data graph charts. They are\n    all in a very similar format and are therefore combined\n    \"\"\"\n\n    # Shorthand\n    p = self.parameters\n\n    # Get correct solution and targets\n    if self.ip['data_graph'] == \"Average Merit\":\n        metric = np.array([np.mean(p['merit'][p['I^E'][j]]) for j in self.c[\"J\"]])\n        target = 0.5\n    elif self.ip['data_graph'] == 'USAFA Proportion':\n        metric = np.array([len(p['I^D']['USAFA Proportion'][j]) / len(p['I^E'][j]) for j in self.c[\"J\"]])\n        target = p['usafa_proportion']\n    else:\n        if self.ip[\"eligibility\"]:\n            metric = np.array([np.mean(p['utility'][p['I^E'][j], j]) for j in self.c[\"J\"]])\n        else:\n            metric = np.array([np.mean(p['utility'][:, j]) for j in self.c[\"J\"]])\n        target = None\n\n    # Axis Adjustments\n    self.ax.set(ylim=(0, 1))\n\n    # Bar Chart\n    self.ax.bar(self.c['afscs'], metric, color=self.ip[\"bar_color\"], alpha=self.ip[\"alpha\"], edgecolor='black')\n\n    # Add a \"target\" line\n    if target is not None:\n        self.ax.axhline(y=target, color='black', linestyle='--', alpha=self.ip[\"alpha\"])\n\n    # Get correct label, title\n    self.c['y_label'] = self.ip['data_graph']\n    if self.ip['title'] is None:\n        self.ip['title'] = self.ip['data_graph'] + ' Across '\n        if self.ip['data_graph'] == 'Average Utility' and not self.ip['eligibility']:\n            self.ip['title'] += 'All Cadets'\n        else:\n            self.ip['title'] += 'Eligible Cadets'\n        if self.ip['eligibility_limit'] != p['N']:\n            self.ip['title'] += ' for AFSCs with &lt;= ' + \\\n                                str(self.ip['eligibility_limit']) + ' Eligible Cadets'\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.data_afocd_chart","title":"<code>data_afocd_chart()</code>","text":"<p>This method builds the \"AFOCD Data\" data graph chart.</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def data_afocd_chart(self):\n    \"\"\"\n    This method builds the \"AFOCD Data\" data graph chart.\n    \"\"\"\n\n    # Shorthand\n    p = self.parameters\n\n    # Legend\n    self.c[\"legend_elements\"] = [\n        Patch(facecolor=self.ip[\"bar_colors\"][\"Permitted\"], label='Permitted', edgecolor='black'),\n        Patch(facecolor=self.ip[\"bar_colors\"][\"Desired\"], label='Desired', edgecolor='black'),\n        Patch(facecolor=self.ip[\"bar_colors\"][\"Mandatory\"], label='Mandatory', edgecolor='black')]\n\n    # Get solution\n    mandatory_count = np.array([np.sum(p['mandatory'][:, j]) for j in self.c[\"J\"]])\n    desired_count = np.array([np.sum(p['desired'][:, j]) for j in self.c[\"J\"]])\n    permitted_count = np.array([np.sum(p['permitted'][:, j]) for j in self.c[\"J\"]])\n\n    # Bar Chart\n    self.ax.bar(self.c[\"afscs\"], mandatory_count, color=self.ip[\"bar_colors\"][\"Mandatory\"], edgecolor='black')\n    self.ax.bar(self.c[\"afscs\"], desired_count, bottom=mandatory_count,\n                color=self.ip[\"bar_colors\"][\"Desired\"], edgecolor='black')\n    self.ax.bar(self.c[\"afscs\"], permitted_count, bottom=mandatory_count + desired_count,\n                color=self.ip[\"bar_colors\"][\"Permitted\"], edgecolor='black')\n\n    # Axis Adjustments\n    self.ax.set(ylim=(0, self.ip['eligibility_limit'] + self.ip['eligibility_limit'] / 100))\n\n    # Get correct text\n    self.c[\"y_label\"] = \"Number of Cadets\"\n    if self.ip['title'] is None:\n        self.ip['title'] = 'AFOCD Degree Tier Breakdown'\n        if self.ip['eligibility_limit'] != p['N']:\n            self.ip['title'] += ' for AFSCs with &lt;= ' + \\\n                                str(self.ip['eligibility_limit']) + ' Eligible Cadets'\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.data_preference_chart","title":"<code>data_preference_chart()</code>","text":"<p>This method generates the \"Cadet Preference\" charts based on the version specified</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def data_preference_chart(self):\n    \"\"\"\n    This method generates the \"Cadet Preference\" charts based on the version\n    specified\n    \"\"\"\n\n    # Shorthand\n    p = self.parameters\n\n    # Choice Counts\n    top_3_count = np.array([sum(p[\"Choice Count\"][choice][j] for choice in [0, 1, 2]) for j in p[\"J\"]])\n    next_3_count = np.array([sum(p[\"Choice Count\"][choice][j] for choice in [3, 4, 5]) for j in p[\"J\"]])\n\n    # Sets of cadets that have the AFSC in their top 3 choices and are eligible for the AFSC\n    top_3_cadets = {}\n    top_3_eligible_cadets = {}\n    for j in p[\"J\"]:\n        top_3_cadets[j] = []\n        top_3_eligible_cadets[j] = []\n        for i in p[\"I\"]:\n            for choice in [0, 1, 2]:\n                if i in p[\"I^Choice\"][choice][j]:\n                    top_3_cadets[j].append(i)\n                    if i in p[\"I^E\"][j]:\n                        top_3_eligible_cadets[j].append(i)\n        top_3_cadets[j] = np.array(top_3_cadets[j])\n        top_3_eligible_cadets[j] = np.array(top_3_eligible_cadets[j])\n\n    # AFOCD solution\n    mandatory_count = np.array([np.sum(p['mandatory'][top_3_cadets[j], j]) for j in p[\"J\"]])\n    desired_count = np.array([np.sum(p['desired'][top_3_cadets[j], j]) for j in p[\"J\"]])\n    permitted_count = np.array([np.sum(p['permitted'][top_3_cadets[j], j]) for j in p[\"J\"]])\n    ineligible_count = np.array([np.sum(p['ineligible'][top_3_cadets[j], j]) for j in p[\"J\"]])\n\n    # Version 1\n    if self.ip[\"version\"] == \"1\":\n        self.c[\"legend_elements\"] = [\n            Patch(facecolor=self.ip['bar_colors'][\"top_choices\"], label='Top 3 Choices', edgecolor='black'),\n            Patch(facecolor=self.ip['bar_colors'][\"mid_choices\"], label='Next 3 Choices', edgecolor='black')]\n\n        # Bar Chart\n        self.ax.bar(self.c[\"afscs\"], next_3_count, color=self.ip['bar_colors'][\"mid_choices\"], edgecolor='black')\n        self.ax.bar(self.c[\"afscs\"], top_3_count, bottom=next_3_count, color=self.ip['bar_colors'][\"top_choices\"],\n                    edgecolor='black')\n\n        # Y max used for axis adjustments\n        self.c[\"y_max\"] = np.max(top_3_count + next_3_count)\n\n        if self.ip['title'] is None:\n            self.ip['title'] = \"Cadet Preferences Placed on Each AFSC (Before Match)\"\n\n    # Version 2\n    elif self.ip[\"version\"] == \"2\":\n        self.c[\"legend_elements\"] = [\n            Patch(facecolor=self.ip['bar_colors'][\"top_choices\"], label='Top 3 Choices', edgecolor='black')]\n\n        # Bar Chart\n        self.ax.bar(self.c[\"afscs\"], top_3_count, color=self.ip['bar_colors'][\"top_choices\"], edgecolor='black')\n\n        # Y max used for axis adjustments\n        self.c[\"y_max\"] = np.max(top_3_count)\n\n        if self.ip['title'] is None:\n            self.ip['title'] = \"Cadet Top 3 Preferences Placed on Each AFSC (Before Match)\"\n\n    # Version 3\n    elif self.ip[\"version\"] == \"3\":\n        self.c[\"legend_elements\"] = [Patch(facecolor=self.ip['bar_colors'][objective], label=objective) for\n                                     objective in [\"Ineligible\", \"Permitted\", \"Desired\", \"Mandatory\"]]\n\n        # Bar Chart\n        self.ax.bar(self.c[\"afscs\"], mandatory_count, color=self.ip['bar_colors'][\"Mandatory\"], edgecolor='black')\n        self.ax.bar(self.c[\"afscs\"], desired_count, bottom=mandatory_count, color=self.ip['bar_colors'][\"Desired\"],\n               edgecolor='black')\n        self.ax.bar(self.c[\"afscs\"], permitted_count, bottom=desired_count + mandatory_count,\n                    color=self.ip['bar_colors'][\"Permitted\"], edgecolor='black')\n        self.ax.bar(self.c[\"afscs\"], ineligible_count, bottom=permitted_count + desired_count + mandatory_count,\n               color=self.ip['bar_colors'][\"Ineligible\"], edgecolor='black')\n\n        # Y max used for axis adjustments\n        self.c[\"y_max\"] = np.max(top_3_count)\n\n        if self.ip['title'] is None:\n            self.ip['title'] = \"Cadet Degree Eligibility of Preferred Cadets on Each AFSC (Before Match)\"\n\n    # Version 4\n    elif self.ip[\"version\"] == \"4\":\n        self.c[\"legend_elements\"] = [Patch(facecolor=self.ip['bar_colors'][objective], label=objective) for\n                                     objective in [\"Permitted\", \"Desired\", \"Mandatory\"]]\n\n        # Bar Chart\n        self.ax.bar(self.c[\"afscs\"], mandatory_count, color=self.ip['bar_colors'][\"Mandatory\"],\n                    edgecolor='black')\n        self.ax.bar(self.c[\"afscs\"], desired_count, bottom=mandatory_count,\n                    color=self.ip['bar_colors'][\"Desired\"],\n                    edgecolor='black')\n        self.ax.bar(self.c[\"afscs\"], permitted_count, bottom=desired_count + mandatory_count,\n                    color=self.ip['bar_colors'][\"Permitted\"], edgecolor='black')\n\n        # Y max used for axis adjustments\n        self.c[\"y_max\"] = np.max(top_3_count)\n\n        if self.ip['title'] is None:\n            self.ip['title'] = \"Cadet Degree Eligibility of Preferred Cadets on Each AFSC (Before Match)\"\n\n    # Version 5\n    elif self.ip[\"version\"] == \"5\":\n\n        # Build a gradient\n        for j in p[\"J\"]:\n            merit = p[\"merit\"][top_3_eligible_cadets[j]]\n            uq = np.unique(merit)\n            count_sum = 0\n            for val in uq:\n                count = len(np.where(merit == val)[0])\n                c = str(val)  # Grayscale\n                self.ax.bar([j], count, bottom=count_sum, color=c, zorder=2)\n                count_sum += count\n\n            # Add the text and an outline\n            self.ax.text(j, len(top_3_eligible_cadets[j]) + 4, round(np.mean(merit), 2),\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n            self.ax.bar([j], len(top_3_eligible_cadets[j]), color=\"black\", zorder=1, edgecolor=\"black\")\n\n        # Y max used for axis adjustments\n        self.c[\"y_max\"] = np.max(top_3_count)\n\n        # DIY Colorbar\n        h = (100 / 245) * self.c[\"y_max\"]\n        w1 = 0.8\n        w2 = 0.74\n        current_height = (150 / 245) * self.c[\"y_max\"]\n        self.ax.add_patch(Rectangle((self.c[\"M\"] - 2, current_height), w1, h, edgecolor='black', facecolor='black',\n                                    fill=True, lw=2))\n        self.ax.text(self.c[\"M\"] - 3.3, (245 / 245) * self.c[\"y_max\"], '100%', fontsize=self.ip[\"text_size\"])\n        self.ax.text(self.c[\"M\"] - 2.8, current_height, '0%', fontsize=self.ip[\"text_size\"])\n        self.ax.text((self.c[\"M\"] - 0.95), (166 / 245) * self.c[\"y_max\"], 'Cadet Percentile',\n                     fontsize=self.ip[\"text_size\"], rotation=270)\n        vals = np.arange(101) / 100\n        for val in vals:\n            c = str(val)  # Grayscale\n            self.ax.add_patch(Rectangle((self.c[\"M\"] - 1.95, current_height), w2, h / 101, color=c, fill=True))\n            current_height += h / 101\n\n        # Y max used for axis adjustments\n        self.c[\"y_max\"] = np.max(top_3_count)\n\n        if self.ip['title'] is None:\n            self.ip['title'] = \"Merit of Preferred Cadets on Each AFSC (Before Match)\"\n\n    # Version 6\n    elif self.ip[\"version\"] == \"6\":\n        self.c[\"legend_elements\"] = [\n            Patch(facecolor=self.ip['bar_colors'][\"usafa\"], label='USAFA'),\n            Patch(facecolor=self.ip['bar_colors'][\"rotc\"], label='ROTC'),\n            mlines.Line2D([], [], color=\"red\", linestyle='-', linewidth=3, label=\"Baseline\")]\n\n        # USAFA/ROTC Numbers\n        rotc_baseline = np.array([len(top_3_eligible_cadets[j]) - (\n                len(top_3_eligible_cadets[j]) * p[\"usafa_proportion\"]) for j in p[\"J\"]])\n        usafa_count = np.array([np.sum(p['usafa'][top_3_eligible_cadets[j]]) for j in p[\"J\"]])\n        rotc_count = np.array([len(top_3_eligible_cadets[j]) - usafa_count[j] for j in p[\"J\"]])\n\n        # Bar Chart\n        self.ax.bar(self.c[\"afscs\"], rotc_count, color=self.ip['bar_colors'][\"rotc\"], edgecolor='black')\n        self.ax.bar(self.c[\"afscs\"], usafa_count, bottom=rotc_count, color=self.ip['bar_colors'][\"usafa\"],\n                    edgecolor='black')\n\n        # Add the baseline marks\n        for j in p[\"J\"]:\n            self.ax.plot((j - 0.4, j + 0.4), (rotc_baseline[j], rotc_baseline[j]),\n                    color=\"red\", linestyle=\"-\", zorder=2, linewidth=3)\n\n        # Y max used for axis adjustments\n        self.c[\"y_max\"] = np.max(top_3_count)\n\n        if self.ip['title'] is None:\n            self.ip['title'] = \"USAFA/ROTC Breakdown of Preferred Cadets on Each AFSC (Before Match)\"\n\n    # Version 7\n    elif self.ip[\"version\"] == \"7\":\n        self.c[\"legend_elements\"] = [\n            Patch(facecolor=self.ip['bar_colors'][\"male\"], label='Male'),\n            Patch(facecolor=self.ip['bar_colors'][\"female\"], label='Female'),\n            mlines.Line2D([], [], color=\"red\", linestyle='-', linewidth=3, label=\"Baseline\")]\n\n        # USAFA/ROTC Numbers\n        female_baseline = np.array([len(top_3_eligible_cadets[j]) - (\n                len(top_3_eligible_cadets[j]) * p[\"male_proportion\"]) for j in p[\"J\"]])\n        male_count = np.array([np.sum(p['male'][top_3_eligible_cadets[j]]) for j in p[\"J\"]])\n        female_count = np.array([len(top_3_eligible_cadets[j]) - male_count[j] for j in p[\"J\"]])\n\n        # Bar Chart\n        self.ax.bar(self.c[\"afscs\"], female_count, color=self.ip['bar_colors'][\"female\"], edgecolor='black')\n        self.ax.bar(self.c[\"afscs\"], male_count, bottom=female_count, color=self.ip['bar_colors'][\"male\"],\n                    edgecolor='black')\n\n        # Add the baseline marks\n        for j in p[\"J\"]:\n            self.ax.plot((j - 0.4, j + 0.4), (female_baseline[j], female_baseline[j]),\n                         color=\"red\", linestyle=\"-\", zorder=2, linewidth=3)\n\n        # Y max used for axis adjustments\n        self.c[\"y_max\"] = np.max(top_3_count)\n\n        if self.ip['title'] is None:\n            self.ip['title'] = \"Male/Female Breakdown of Preferred Cadets on Each AFSC (Before Match)\"\n\n    else:\n        raise ValueError(\"Version '\" + str(\n            self.ip[\"version\"]) + \"' is not valid for the Cadet Preference Analysis data graph.\")\n\n    # Axis Adjustments\n    self.ax.set(ylim=(0, self.c[\"y_max\"] * self.ip[\"y_max\"]))\n\n    # Get correct y-label\n    self.c[\"y_label\"] = \"Number of Cadets\"\n\n    # Get filename\n    if self.ip[\"filename\"] is None:\n        self.ip[\"filename\"] = self.data_name + \" (\" + self.data_version + \\\n                              \") Cadet Preference Analysis Version \" + self.ip[\"version\"] + \" (Data).png\"\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.data_quota_chart","title":"<code>data_quota_chart()</code>","text":"<p>This method builds the \"Eligible Quota\" data graph chart.</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def data_quota_chart(self):\n    \"\"\"\n    This method builds the \"Eligible Quota\" data graph chart.\n    \"\"\"\n\n    # Shorthand\n    p = self.parameters\n\n    # Legend\n    self.c[\"legend_elements\"] = [Patch(facecolor='blue', label='Eligible Cadets', edgecolor='black'),\n                                 Patch(facecolor='black', alpha=0.5, label='AFSC Quota', edgecolor='black')]\n\n    # Get solution\n    eligible_count = p[\"num_eligible\"][self.c[\"J\"]]\n    quota = p['pgl'][self.c[\"J\"]]\n\n    # Bar Chart\n    self.ax.bar(self.c[\"afscs\"], eligible_count, color='blue', edgecolor='black')\n    self.ax.bar(self.c[\"afscs\"], quota, color='black', edgecolor='black', alpha=0.5)\n\n    # Axis Adjustments\n    self.ax.set(ylim=(0, self.ip['eligibility_limit'] + self.ip['eligibility_limit'] / 100))\n\n    # Get correct text\n    self.c[\"y_label\"] = \"Number of Cadets\"\n    if self.ip['title'] is None:\n        self.ip['title'] = 'Eligible Cadets and Quotas'\n        if self.ip['eligibility_limit'] != p['N']:\n            self.ip['title'] += ' for AFSCs with &lt;= ' + \\\n                           str(self.ip['eligibility_limit']) + ' Eligible Cadets'\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.results_solution_comparison_chart","title":"<code>results_solution_comparison_chart()</code>","text":"<p>This method plots the solution comparison chart for the chosen objective specified</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_solution_comparison_chart(self):\n    \"\"\"\n    This method plots the solution comparison chart for the chosen objective specified\n    \"\"\"\n\n    # Shorthand\n    p, vp = self.parameters, self.value_parameters\n    k = self.c['k']\n\n    # Make sure at least one AFSC has this objective selected\n    if self.c['M'] == 0:\n        raise ValueError(\"Error. No AFSCs have objective '\" + ip[\"objective\"] + \"'.\")\n\n    # Keep track of useful variables\n    x_under, x_over = [], []\n    quota_percent_filled, max_quota_percent = np.zeros(self.c['M']), np.zeros(self.c['M'])\n    self.c['legend_elements'] = []\n    max_measure = np.zeros(self.c['M'])\n    y_top = 0\n\n    if self.ip['ncol'] != 1:\n        self.ip['ncol'] = len(self.ip['solution_names'])\n\n    # Loop through each solution\n    for s, solution in enumerate(self.ip[\"solution_names\"]):\n\n        # Calculate objective measure\n        if self.ip['version'] == 'median_preference':\n            cadets = [np.where(self.solutions[solution]['j_array'] == j)[0] for j in p['J']]\n            measure = np.array([np.median(p['c_pref_matrix'][cadets[j], j]) for j in self.c['J']])\n            self.label_dict[self.ip['objective']] = 'Median Cadet Choice'\n        elif self.ip['version'] == 'mean_preference':\n            cadets = [np.where(self.solutions[solution]['j_array'] == j)[0] for j in p['J']]\n            measure = np.array([np.mean(p['c_pref_matrix'][cadets[j], j]) for j in self.c['J']])\n            self.label_dict[self.ip['objective']] = 'Average Cadet Choice'\n        elif self.ip['version'] == 'Race Chart':\n            measure = np.array([self.solutions[solution]['simpson_index'][j] for j in self.c['J']])\n            self.label_dict[self.ip['objective']] = 'Simpson Diversity Index'\n        else:\n            measure = self.solutions[solution][\"objective_measure\"][self.c['J'], k]\n        if self.ip[\"objective\"] == \"Combined Quota\":\n            self.label_dict[self.ip[\"objective\"]] = 'Proportion of PGL Target Met'  # Adjust Label\n\n            # Assign the right color to the AFSCs\n            for idx, j in enumerate(self.c['J']):\n\n                # Get bounds\n                value_list = vp['objective_value_min'][j, k].split(\",\")\n                ub = float(value_list[1].strip())  # upper bound\n                quota = p[\"pgl\"][j]\n\n                # Constraint violations\n                if quota &gt; measure[idx]:\n                    x_under.append(idx)\n                elif measure[idx] &gt; ub:\n                    x_over.append(idx)\n\n                quota_percent_filled[idx] = measure[idx] / quota\n                max_quota_percent[idx] = ub / quota\n\n            # Top dot location\n            y_top = max(y_top, max(quota_percent_filled))\n\n            # Plot the points\n            self.ax.scatter(self.c['afscs'], quota_percent_filled, color=self.ip[\"colors\"][solution],\n                            marker=self.ip[\"markers\"][solution], alpha=self.ip[\"alpha\"], edgecolor='black',\n                            s=self.ip[\"dot_size\"], zorder=self.ip[\"zorder\"][solution])\n\n        else:\n\n            # Plot the points\n            self.ax.scatter(self.c['afscs'], measure, color=self.ip[\"colors\"][solution],\n                            marker=self.ip[\"markers\"][solution], alpha=self.ip[\"alpha\"], edgecolor='black',\n                            s=self.ip[\"dot_size\"], zorder=self.ip[\"zorder\"][solution])\n\n        max_measure = np.array([max(max_measure[idx], measure[idx]) for idx in range(self.c['M'])])\n        element = mlines.Line2D([], [], color=self.ip[\"colors\"][solution], marker=self.ip[\"markers\"][solution],\n                                linestyle='None', markeredgecolor='black', markersize=self.ip['legend_dot_size'],\n                                label=solution, alpha=self.ip[\"alpha\"])\n        self.c['legend_elements'].append(element)\n\n    # Lines to the top solution's dot\n    if self.ip[\"objective\"] not in [\"Combined Quota\", \"Mandatory\", \"Desired\", \"Permitted\", 'Tier 1', 'Tier 2',\n                                    'Tier 3', 'Tier 4']:\n        for idx in range(self.c['M']):\n            self.ax.plot((idx, idx), (0, max_measure[idx]), color='black', linestyle='--', zorder=1, alpha=0.5,\n                          linewidth=2)\n\n    # Objective Specific elements\n    if self.ip[\"objective\"] == \"Merit\":\n\n        # Tick marks and extra lines\n        self.c['y_ticks'] = [0, 0.35, 0.50, 0.65, 0.80, 1]\n        self.ax.plot((-1, 50), (0.65, 0.65), color='blue', linestyle='-', zorder=1, alpha=0.5, linewidth=1.5)\n        self.ax.plot((-1, 50), (0.5, 0.5), color='black', linestyle='--', zorder=1, alpha=0.5, linewidth=1.5)\n        self.ax.plot((-1, 50), (0.35, 0.35), color='blue', linestyle='-', zorder=1, alpha=0.5, linewidth=1.5)\n\n        # Set the max for the y-axis\n        self.c['y_max'] = self.ip['y_max'] * np.max(max_measure)\n\n    elif self.ip['version'] == 'Race Chart':\n        baseline = self.parameters['baseline_simpson_index']\n        self.c['y_ticks'] = [0, baseline, 1]\n        self.ax.plot((-1, 50), (baseline, baseline), color='black', linestyle='--', zorder=1, alpha=0.5,\n                     linewidth=1.5)\n\n        # Set the max for the y-axis\n        self.c['y_max'] = self.ip['y_max'] * np.max(max_measure)\n\n    elif self.ip[\"objective\"] in [\"USAFA Proportion\", \"Male\", \"Minority\"]:\n\n        # Demographic Proportion elements\n        prop_dict = {\"USAFA Proportion\": \"usafa_proportion\", \"Male\": \"male_proportion\",\n                     \"Minority\": \"minority_proportion\"}\n        up_lb = round(p[prop_dict[self.ip[\"objective\"]]] - 0.15, 2)\n        up_ub = round(p[prop_dict[self.ip[\"objective\"]]] + 0.15, 2)\n        up = round(p[prop_dict[self.ip[\"objective\"]]], 2)\n        self.c['y_ticks'] = [0, up_lb, up, up_ub, 1]\n\n        # Add lines for the ranges\n        self.ax.axhline(y=up, color='black', linestyle='--', alpha=0.5)\n        self.ax.axhline(y=up_lb, color='blue', linestyle='-', alpha=0.5)\n        self.ax.axhline(y=up_ub, color='blue', linestyle='-', alpha=0.5)\n\n        # Set the max for the y-axis\n        self.c['y_max'] = self.ip['y_max'] * np.max(max_measure)\n\n    elif self.ip[\"objective\"] in [\"Mandatory\", \"Desired\", \"Permitted\", \"Tier 1\", \"Tier 2\", 'Tier 3', \"Tier 4\"]:\n\n        # Degree Tier elements\n        self.c['y_ticks'] = [0, 0.2, 0.4, 0.6, 0.8, 1]\n        minimums = np.zeros(self.c['M'])\n        maximums = np.zeros(self.c['M'])\n\n        # Assign the right color to the AFSCs\n        for idx, j in enumerate(self.c['J']):\n            if \"Increasing\" in vp[\"value_functions\"][j, k]:\n                minimums[idx] = vp['objective_target'][j, k]\n                maximums[idx] = 1\n            else:\n                minimums[idx] = 0\n                maximums[idx] = vp['objective_target'][j, k]\n\n        # Calculate ranges\n        y = [(minimums[idx], maximums[idx]) for idx in range(self.c['M'])]\n        y_lines = [(0, minimums[idx]) for idx in range(self.c['M'])]\n\n        # Plot bounds\n        self.ax.scatter(range(self.c['M']), minimums, c=\"black\", marker=\"_\", linewidth=2, zorder=1)\n        self.ax.scatter(range(self.c['M']), maximums, c=\"black\", marker=\"_\", linewidth=2, zorder=1)\n\n        # Constraint Range\n        self.ax.plot((range(self.c['M']), range(self.c['M'])), ([i for (i, j) in y], [j for (i, j) in y]),\n                      c=\"black\", zorder=1)\n\n        # Line from x-axis to constraint range\n        self.ax.plot((range(self.c['M']), range(self.c['M'])), ([i for (i, j) in y_lines], [j for (i, j) in y_lines]),\n                      c=\"black\", zorder=1, alpha=0.5, linestyle='--', linewidth=2)\n\n    elif self.ip[\"objective\"] == \"Combined Quota\":\n\n        # Y axis adjustments\n        self.c['y_ticks'] = [0, 0.5, 1, 1.5, 2]\n        self.c['y_max'] = self.ip['y_max'] * y_top\n\n        # Lines\n        y_mins = np.repeat(1, self.c['M'])\n        y_maxs = max_quota_percent\n        y = [(y_mins[idx], y_maxs[idx]) for idx in range(self.c['M'])]\n        y_under = [(quota_percent_filled[idx], 1) for idx in x_under]\n        y_over = [(max_quota_percent[idx], quota_percent_filled[idx]) for idx in x_over]\n\n        # Plot Bounds\n        self.ax.scatter(self.c['afscs'], y_mins, c=np.repeat('black', self.c['M']), marker=\"_\", linewidth=2, zorder=1)\n        self.ax.scatter(self.c['afscs'], y_maxs, c=np.repeat('black', self.c['M']), marker=\"_\", linewidth=2, zorder=1)\n\n        # Plot Range Lines\n        self.ax.plot((range(self.c['M']), range(self.c['M'])), ([i for (i, j) in y], [j for (i, j) in y]),\n                     c='black', zorder=1)\n        self.ax.plot((x_under, x_under), ([i for (i, j) in y_under], [j for (i, j) in y_under]), c='black',\n                     linestyle='--', zorder=1)\n        self.ax.plot((x_over, x_over), ([i for (i, j) in y_over], [j for (i, j) in y_over]), c='black',\n                      linestyle='--', zorder=1)\n        self.ax.plot((range(self.c['M']), range(self.c['M'])), (np.zeros(self.c['M']), np.ones(self.c['M'])),\n                     c='black', linestyle='--', alpha=0.3, zorder=1)\n\n        # Quota Line\n        self.ax.axhline(y=1, color='black', linestyle='-', alpha=0.5, zorder=1)\n\n    elif self.ip[\"objective\"] in [\"Utility\", \"Norm Score\"] and self.ip['version'] == 'dot':\n\n        # Fix some things for this chart (y_ticks and label)\n        self.c['y_ticks'] = [0, 0.2, 0.4, 0.6, 0.8, 1]\n        self.label_dict[self.ip['objective']] = afccp.globals.obj_label_dict[self.ip['objective']]\n\n    # Set the max for the y-axis\n    if self.ip['version'] in ['median_preference', 'mean_preference']:\n        self.c['y_max'] = self.ip['y_max'] * np.max(max_measure)\n\n    # Get y-label\n    self.c['y_label'] = self.label_dict[self.ip['objective']]\n\n    # Get names of Solutions\n    solution_names = ', '.join(self.ip[\"solution_names\"])\n\n    # Create the title!\n    if self.ip[\"title\"] is None:\n        self.ip['title'] = solution_names + ' ' + self.label_dict[self.ip[\"objective\"]] + \" Across Each AFSC\"\n\n    # Update the version of the data using the solution names\n    self.ip['version'] = solution_names + ' ' + self.ip['version']\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.results_merit_chart","title":"<code>results_merit_chart()</code>","text":"<p>This method constructs the different charts showing the \"Balance Merit\" objective</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_merit_chart(self):\n    \"\"\"\n    This method constructs the different charts showing the \"Balance Merit\" objective\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = self.parameters, self.value_parameters, self.solution\n    k, quota, measure = self.c['k'], p['pgl'][self.c['J']], self.c['measure']\n    colors, afscs = np.array([self.ip['bar_colors'][\"small_afscs\"] for _ in self.c['J']]), self.c['afscs']\n\n    if self.ip[\"version\"] == \"large_only_bar\":\n\n        # Get the title\n        self.ip[\"title\"] = \"Average Merit Across Each Large AFSC\"\n\n        # Y-axis\n        self.c['use_calculated_y_max'] = True\n        self.c['y_max'] = self.ip['y_max']  # * np.max(measure)\n\n        # Assign the right color to the AFSCs\n        for j in range(self.c['M']):\n            if 0.35 &lt;= measure[j] &lt;= 0.65:\n                colors[j] = self.ip['bar_colors'][\"merit_within\"]\n            elif measure[j] &gt; 0.65:\n                colors[j] = self.ip['bar_colors'][\"merit_above\"]\n            else:\n                colors[j] = self.ip['bar_colors'][\"merit_below\"]\n\n        # Add lines for the ranges\n        self.ax.axhline(y=0.5, color='black', linestyle='--', alpha=0.5)\n\n        # Bound lines\n        if self.ip['add_bound_lines']:\n            self.c['y_ticks'] = [0, 0.35, 0.50, 0.65, 0.80, 1]\n            self.ax.axhline(y=0.35, color='blue', linestyle='-', alpha=0.5)\n            self.ax.axhline(y=0.65, color='blue', linestyle='-', alpha=0.5)\n        else:\n            self.c['y_ticks'] = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n\n        # Bar Chart\n        self.ax.bar(afscs, measure, color=colors, edgecolor='black', alpha=self.ip[\"alpha\"])\n\n    elif self.ip[\"version\"] == \"bar\":\n\n        # Get the title\n        self.ip[\"title\"] = \"Average Merit Across Each AFSC\"\n\n        # Set the max for the y-axis\n        self.c['use_calculated_y_max'] = True\n        self.c['y_max'] = self.ip['y_max']  # * np.max(measure)\n\n        # Merit elements\n        if self.ip['large_afsc_distinction']:\n            self.c['legend_elements'] = [Patch(facecolor=self.ip['bar_colors'][\"small_afscs\"], label='Small AFSC'),\n                                         Patch(facecolor=self.ip['bar_colors'][\"large_afscs\"], label='Large AFSC')]\n\n        # Assign the right color to the AFSCs\n        for j in range(self.c['M']):\n\n            # Colors\n            if self.ip['large_afsc_distinction']:\n                if quota[j] &gt;= 40:\n                    colors[j] = self.ip['bar_colors'][\"large_afscs\"]\n                else:\n                    colors[j] = self.ip['bar_colors'][\"small_afscs\"]\n            else:\n                colors[j] = self.ip['bar_color']\n\n            # Add the text\n            self.ax.text(j, measure[j] + 0.013, round(measure[j], 2),\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n\n        # Add lines for the ranges\n        self.ax.axhline(y=0.5, color='black', linestyle='--', alpha=0.5)\n\n        # Bound lines\n        if self.ip['add_bound_lines']:\n            self.c['legend_elements'].append(mlines.Line2D([], [], color=\"blue\", linestyle='-', label=\"Bound\"))\n            self.c['y_ticks'] = [0, 0.35, 0.50, 0.65, 0.80, 1]\n            self.ax.axhline(y=0.35, color='blue', linestyle='-', alpha=0.5)\n            self.ax.axhline(y=0.65, color='blue', linestyle='-', alpha=0.5)\n        else:\n            self.c['y_ticks'] = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n\n        # Bar Chart\n        self.ax.bar(afscs, measure, color=colors, edgecolor='black', alpha=self.ip[\"alpha\"])\n\n    elif self.ip[\"version\"] == \"quantity_bar_gradient\":\n\n        # Get the title and label\n        self.ip[\"title\"] = \"Cadet Merit Breakdown Across Each AFSC\"\n        self.c['y_label'] = \"Number of Cadets\"\n\n        # Calculate y-axis attributes\n        self.determine_y_max_and_y_ticks()\n\n        # Build the gradient chart\n        self.construct_gradient_chart(parameter_to_use='merit')\n\n    else:  # quantity_bar_proportion  (Quartiles in this case)\n\n        # Update the title\n        self.ip[\"title\"] = \"Cadet Quartiles Across Each AFSC\"\n        self.c['y_label'] = \"Number of Cadets\"\n\n        # Legend\n        self.c['legend_elements'] = [Patch(facecolor=self.ip['bar_colors'][\"quartile_1\"], label='1st Quartile'),\n                                     Patch(facecolor=self.ip['bar_colors'][\"quartile_2\"], label='2nd Quartile'),\n                                     Patch(facecolor=self.ip['bar_colors'][\"quartile_3\"], label='3rd Quartile'),\n                                     Patch(facecolor=self.ip['bar_colors'][\"quartile_4\"], label='4th Quartile')]\n\n        # Calculate y-axis attributes\n        self.determine_y_max_and_y_ticks()\n\n        percentile_dict = {1: (0.75, 1), 2: (0.5, 0.75), 3: (0.25, 0.5), 4: (0, 0.25)}\n        for index, j in enumerate(self.c['J']):\n            cadets = np.where(self.solution['j_array'] == j)[0]\n            merit = p[\"merit\"][cadets]\n\n            # Loop through each quartile\n            count_sum = 0\n            for q in [4, 3, 2, 1]:\n                lb, ub = percentile_dict[q][0], percentile_dict[q][1]\n                count = len(np.where((merit &lt;= ub) &amp; (merit &gt; lb))[0])\n                self.ax.bar([index], count, bottom=count_sum,\n                            color=self.ip['bar_colors'][\"quartile_\" + str(q)], zorder=2)\n                count_sum += count\n\n                # Put a number on the bar\n                if count &gt;= 10:\n                    if q == 1:\n                        c = \"white\"\n                    else:\n                        c = \"black\"\n                    self.ax.text(index, (count_sum - count / 2 - 2), int(count), color=c,\n                                 zorder=3, fontsize=self.ip[\"bar_text_size\"], horizontalalignment='center')\n\n            # Add the text and an outline\n            self.ax.text(index, self.c['total_count'][index] + self.ip['bar_text_offset'], int(self.c['total_count'][index]),\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n            self.ax.bar([index], self.c['total_count'][index], color=\"black\", zorder=1, edgecolor=\"black\")\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.results_demographic_chart","title":"<code>results_demographic_chart()</code>","text":"<p>Chart to visualize the demographics of the solution</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_demographic_chart(self):\n    \"\"\"\n    Chart to visualize the demographics of the solution\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = self.parameters, self.value_parameters, self.solution\n    k, quota, measure = self.c['k'], p['pgl'][self.c['J']], self.c['measure']\n    colors, afscs = np.array([self.ip['bar_colors'][\"small_afscs\"] for _ in self.c['J']]), self.c['afscs']\n\n    # Demographic Proportion elements\n    prop_dict = {\"USAFA Proportion\": \"usafa_proportion\", \"Male\": \"male_proportion\",\n                 \"Minority\": \"minority_proportion\"}\n    legend_dict = {\"USAFA Proportion\": \"USAFA Proportion\", \"Male\": \"Male Proportion\",\n                   \"Minority\": \"Minority Proportion\"}\n    up_lb = round(p[prop_dict[self.ip[\"objective\"]]] - 0.15, 2)\n    up_ub = round(p[prop_dict[self.ip[\"objective\"]]] + 0.15, 2)\n    up = round(p[prop_dict[self.ip[\"objective\"]]], 2)\n\n    if self.ip[\"version\"] == \"large_only_bar\":\n\n        # Get the title and filename\n        self.ip[\"title\"] = legend_dict[self.ip[\"objective\"]] + \" Across Large AFSCs\"\n\n        # Set the max for the y-axis\n        self.c['use_calculated_y_max'] = True\n        self.c['y_max'] = self.ip['y_max']  # * np.max(measure)\n        self.c['y_ticks'] = [0, up_lb, up, up_ub, 1]\n\n        # Legend elements\n        self.c['legend_elements'] = [\n            Patch(facecolor=self.ip['bar_colors'][\"large_within\"], label=str(up_lb) + ' &lt; ' + legend_dict[\n                self.ip[\"objective\"]] + ' &lt; ' + str(up_ub)), Patch(facecolor=self.ip['bar_colors'][\"large_else\"],\n                                                                   label='Otherwise')]\n\n        # Assign the right color to the AFSCs\n        for j in range(self.c['M']):\n            if up_lb &lt;= measure[j] &lt;= up_ub:\n                colors[j] = self.ip['bar_colors'][\"large_within\"]\n            else:\n                colors[j] = self.ip['bar_colors'][\"large_else\"]\n\n        # Add lines for the ranges\n        self.ax.axhline(y=up, color='black', linestyle='--', alpha=0.5)\n        self.ax.axhline(y=up_lb, color='blue', linestyle='-', alpha=0.5)\n        self.ax.axhline(y=up_ub, color='blue', linestyle='-', alpha=0.5)\n\n        # Bar Chart\n        self.ax.bar(afscs, measure, color=colors, edgecolor='black', alpha=self.ip[\"alpha\"])\n\n    elif self.ip[\"version\"] == \"bar\":\n\n        # Get the title and filename\n        self.ip[\"title\"] = legend_dict[self.ip[\"objective\"]] + \" Across Each AFSC\"\n\n        # Y-axis\n        self.c['use_calculated_y_max'] = True\n        self.c['y_max'] = self.ip['y_max']  # * np.max(measure)\n        self.c['y_ticks'] = [0, up_lb, up, up_ub, 1]\n\n        # Legend elements\n        self.c['legend_elements'] = [Patch(facecolor=self.ip['bar_colors'][\"small_afscs\"], label='Small AFSC'),\n                                     Patch(facecolor=self.ip['bar_colors'][\"large_afscs\"], label='Large AFSC'),\n                                     mlines.Line2D([], [], color=\"blue\", linestyle='-', label=\"Bound\")]\n\n        # Assign the right color to the AFSCs\n        for j in range(self.c['M']):\n            if quota[j] &gt;= 40:\n                colors[j] = self.ip['bar_colors'][\"large_afscs\"]\n            else:\n                colors[j] = self.ip['bar_colors'][\"small_afscs\"]\n\n            # Add the text\n            self.ax.text(j, measure[j] + 0.013, round(measure[j], 2),\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n\n        # Add lines for the ranges\n        self.ax.axhline(y=up, color='black', linestyle='--', alpha=0.5)\n        self.ax.axhline(y=up_lb, color='blue', linestyle='-', alpha=0.5)\n        self.ax.axhline(y=up_ub, color='blue', linestyle='-', alpha=0.5)\n\n        # Bar Chart\n        self.ax.bar(afscs, measure, color=colors, edgecolor='black', alpha=self.ip[\"alpha\"])\n\n    elif self.ip[\"version\"] == \"preference_chart\":\n        self.c['y_label'] = \"Number of Cadets\"\n\n        # Objective specific components\n        if self.ip[\"objective\"] == \"USAFA Proportion\":\n\n            # Get the title\n            self.ip[\"title\"] = \"USAFA/ROTC 7+ Choice Across Each AFSC\"\n            classes = [\"USAFA\", \"ROTC\"]\n\n        elif self.ip[\"objective\"] == \"Male\":\n\n            # Get the title\n            self.ip[\"title\"] = \"Male/Female 7+ Choice Across Each AFSC\"\n            classes = [\"Male\", \"Female\"]\n\n        else:  # Minority\n\n            # Get the title\n            self.ip[\"title\"] = \"Minority/Non-Minority 7+ Choice Across Each AFSC\"\n            classes = [\"Minority\", \"Non-Minority\"]\n\n        # Calculate y-axis attributes\n        self.determine_y_max_and_y_ticks()\n\n        # Categories! (Volunteers/Non-Volunteers)\n        categories = [\"Top 6 Choices\", \"7+ Choice\"]\n\n        # Get the counts for each category and class\n        counts = {cls: {cat: np.zeros(self.c['M']) for cat in categories} for cls in classes}\n        dem = classes[0].lower()  # reference demographic (male, usafa, minority, etc.)\n        for index, afsc in enumerate(afscs):\n            j = np.where(p[\"afscs\"] == afsc)[0][0]\n            cadets_assigned = np.where(self.solution['j_array'] == j)[0]\n            cadets_with_demographic = np.where(p[dem] == 1)[0]\n            cadets_class = {classes[0]: np.intersect1d(cadets_assigned, cadets_with_demographic),\n                            classes[1]: np.array([cadet for cadet in cadets_assigned if\n                                                  cadet not in cadets_with_demographic])}\n\n            # Determine volunteer status\n            if categories == [\"Top 6 Choices\", \"7+ Choice\"]:\n                cadets_with_category = np.where(p['c_pref_matrix'][:, j] &lt; 7)[0]\n                cadets_cat = {\"Top 6 Choices\": np.intersect1d(cadets_assigned, cadets_with_category),\n                              \"7+ Choice\": np.array(\n                                  [cadet for cadet in cadets_assigned if cadet not in cadets_with_category])}\n\n            # Loop through each demographic\n            for cls in classes:\n                for cat in categories:\n                    counts[cls][cat][index] = len(np.intersect1d(cadets_class[cls], cadets_cat[cat]))\n\n        # Legend\n        self.c['legend_elements'] = [Patch(facecolor=self.ip['bar_colors'][cls.lower()],\n                                           label=cls, edgecolor='black') for cls in classes]\n        self.c['legend_elements'].append(\n            Patch(facecolor=self.ip['bar_colors'][\"7+ Choice\"], label=\"7+ Choice\"))\n\n        # Loop through each AFSC to plot the bars\n        for index, afsc in enumerate(afscs):\n\n            # Plot the AFOCD bars\n            count_sum = 0\n            for cls in classes[::-1]:\n                for cat in categories[::-1]:\n\n                    if cat == \"Top 6 Choices\":\n                        color = self.ip[\"bar_colors\"][cls.lower()]\n                    else:\n                        color = self.ip['bar_colors'][cat]\n\n                    # Plot the bars\n                    count = counts[cls][cat][index]\n                    self.ax.bar([index], count, bottom=count_sum, edgecolor=\"black\", color=color)\n                    count_sum += count\n\n                    # Put a number on the bar\n                    if count &gt;= 10:\n\n                        if cls in [\"Male\", \"USAFA\", \"Minority\"]:\n                            color = \"white\"\n                        else:\n                            color = \"black\"\n                        self.ax.text(index, (count_sum - count / 2 - 2), int(count), color=color,\n                                     zorder=2, fontsize=self.ip[\"bar_text_size\"], horizontalalignment='center')\n\n            # Add the text\n            self.ax.text(index, self.c['total_count'][index] + self.ip['bar_text_offset'], int(self.c['total_count'][index]),\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n\n    else:  # Sorted Sized Bar Chart\n        self.c['y_label'] = \"Number of Cadets\"\n\n        # Objective specific components\n        if self.ip[\"objective\"] == \"USAFA Proportion\":\n            self.ip[\"title\"] = \"Source of Commissioning Breakdown Across Each AFSC\"\n            class_1_color = self.ip['bar_colors'][\"usafa\"]\n            class_2_color = self.ip['bar_colors'][\"rotc\"]\n\n            # Legend\n            self.c['legend_elements'] = [Patch(facecolor=class_1_color, label='USAFA'),\n                                         Patch(facecolor=class_2_color, label='ROTC')]\n\n        elif self.ip[\"objective\"] == \"Minority\":\n            self.ip[\"title\"] = \"Minority/Non-Minority Breakdown Across Each AFSC\"\n            class_1_color = self.ip['bar_colors'][\"minority\"]\n            class_2_color = self.ip['bar_colors'][\"non-minority\"]\n\n            # Legend\n            self.c['legend_elements'] = [Patch(facecolor=class_1_color, label='Minority'),\n                                         Patch(facecolor=class_2_color, label='Non-Minority')]\n\n        else:\n            self.ip[\"title\"] = \"Gender Breakdown Across Each AFSC\"\n            class_1_color = self.ip['bar_colors'][\"male\"]\n            class_2_color = self.ip['bar_colors'][\"female\"]\n\n            # Legend\n            self.c['legend_elements'] = [Patch(facecolor=class_1_color, label='Male'),\n                                         Patch(facecolor=class_2_color, label='Female')]\n\n        # Calculate y-axis attributes\n        self.determine_y_max_and_y_ticks()\n\n        # Get \"class\" objective measures (number of cadets with demographic)\n        class_1 = measure * self.c['total_count']\n        class_2 = (1 - measure) * self.c['total_count']\n        self.ax.bar(afscs, class_2, color=class_2_color, zorder=2, edgecolor=\"black\")\n        self.ax.bar(afscs, class_1, bottom=class_2, color=class_1_color, zorder=2, edgecolor=\"black\")\n        for j, afsc in enumerate(afscs):\n            if class_2[j] &gt;= 10:\n                self.ax.text(j, class_2[j] / 2, int(class_2[j]), color=\"black\",\n                             zorder=3, fontsize=self.ip[\"bar_text_size\"], horizontalalignment='center')\n            if class_1[j] &gt;= 10:\n                self.ax.text(j, class_2[j] + class_1[j] / 2, int(class_1[j]), color=\"white\", zorder=3,\n                             fontsize=self.ip[\"bar_text_size\"], horizontalalignment='center')\n\n            # Add the text and an outline\n            self.ax.text(j, self.c['total_count'][j] + self.ip['bar_text_offset'], round(measure[j], 2), fontsize=self.ip[\"text_size\"],\n                         horizontalalignment='center')\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.results_demographic_proportion_chart","title":"<code>results_demographic_proportion_chart()</code>","text":"<p>Chart to visualize the demographics of the solution across each AFSC</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_demographic_proportion_chart(self):\n    \"\"\"\n    Chart to visualize the demographics of the solution across each AFSC\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = self.parameters, self.value_parameters, self.solution\n\n    # Category Dictionary\n    category_dict = {\"Race Chart\": p['race_categories'], 'Ethnicity Chart': p['ethnicity_categories'],\n                     'Gender Chart': ['Male', 'Female'], 'SOC Chart': ['USAFA', 'ROTC']}\n    title_dict = {\"Race Chart\": 'Racial Demographics Across Each AFSC',\n                  'Ethnicity Chart': 'Ethnicity Demographics Across Each AFSC',\n                  'Gender Chart': 'Gender Breakdown Across Each AFSC',\n                  'SOC Chart': 'Source of Commissioning Breakdown Across Each AFSC'}\n    afsc_num_dict = {\"Race Chart\": \"simpson_index\", \"Ethnicity Chart\": \"simpson_index_eth\",\n                     \"Gender Chart\": \"male_proportion_afscs\", \"SOC Chart\": \"usafa_proportion_afscs\"}\n    baseline_dict = {\"Gender Chart\": \"male_proportion\", \"SOC Chart\": \"usafa_proportion\",\n                     \"Race Chart\": \"baseline_simpson_index\", \"Ethnicity Chart\": \"baseline_simpson_index_eth\"}\n\n    # Proportion Chart\n    if '_proportion' in self.ip['version']:\n        proportion_chart = True\n        version = self.ip['version'][:-11]\n    else:\n        proportion_chart = False\n        version = self.ip['version']\n\n    # Extract the specific information for this chart from the dictionaries above\n    self.ip['title'] = title_dict[version]\n    categories = category_dict[version]\n    afsc_num_dict_s = afsc_num_dict[version]\n    baseline_p = baseline_dict[version]\n\n    # Legend elements\n    self.c['legend_elements'] = []\n    for cat in categories[::-1]:  # Flip the legend\n        color = self.ip['bar_colors'][cat]\n        self.c['legend_elements'].append(Patch(facecolor=color, label=cat, edgecolor='black'))\n\n    # Calculate y-axis attributes\n    if proportion_chart:\n\n        # Get y axis characteristics\n        self.c['use_calculated_y_max'] = True\n        self.c['y_ticks'] = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n        self.c['y_label'] = \"Proportion of Cadets\"\n        self.c['y_max'] *= 1.03  # expand it a little\n        self.ip['legend_size'] = self.ip['proportion_legend_size']  # Change the size of the legend\n        self.ip['ncol'] = 20  # Adjust number of columns for legend (Arbitrarily large number for horizontal legend)\n        self.ip['text_bar_threshold'] = self.ip['proportion_text_bar_threshold']  # Adjust this threshold\n\n        # Baseline\n        if len(categories) == 2:\n            self.c['legend_elements'].append(mlines.Line2D([], [], color=\"black\", linestyle='--', label=\"Baseline\"))\n            self.ax.axhline(y=p[baseline_p], color='black', linestyle='--', alpha=1, zorder=4)\n            self.c['y_ticks'] = [0, round(p[baseline_p], 2), 1]\n    else:\n        self.determine_y_max_and_y_ticks()\n        self.c['y_label'] = \"Number of Cadets\"\n\n    # Loop through each category and AFSC pair\n    quantities, proportions = {}, {}\n    for cat in categories:\n        quantities[cat], proportions[cat] = np.zeros(self.c['M']), np.zeros(self.c['M'])\n        for idx, j in enumerate(self.c['J']):\n            cadets = np.intersect1d(p['I^' + cat], solution['cadets_assigned'][j])\n\n            # Load metrics\n            quantities[cat][idx] = int(len(cadets))\n            proportions[cat][idx] = len(cadets) / len(solution['cadets_assigned'][j])\n\n    # Loop through each AFSC to add the text above the bars\n    for idx, j in enumerate(self.c['J']):\n\n        # Get the text for the top of the bar\n        txt = str(solution[afsc_num_dict_s][j])\n        if txt[0] == '0' and txt != '0.0':\n            txt = txt[1:]\n        elif txt == 'nan':\n            txt = ''\n\n        # Add the text\n        if proportion_chart:\n            self.ax.text(idx, 1.005, txt, verticalalignment='bottom', fontsize=self.ip[\"text_size\"],\n                         horizontalalignment='center')\n        else:\n            self.ax.text(idx, solution['count'][j] + self.ip['bar_text_offset'], txt, verticalalignment='bottom',\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n\n    # Plot the data\n    totals = np.zeros(self.c['M'])\n    for cat in quantities:\n        color = self.ip['bar_colors'][cat]\n\n        if proportion_chart:\n            self.ax.bar(range(self.c['M']), proportions[cat], bottom=totals, color=color, zorder=2,\n                        edgecolor='black')\n            totals += proportions[cat]\n        else:\n            self.ax.bar(range(self.c['M']), quantities[cat], bottom=totals, color=color, zorder=2,\n                        edgecolor='black')\n            totals += quantities[cat]\n\n        # If it's a dark color, change text color to white\n        if 'Black' in cat or \"Male\" in cat:\n            text_color = 'white'\n        else:\n            text_color = 'black'\n\n        # Put a number on the bar\n        for idx, j in enumerate(self.c['J']):\n            if proportion_chart:\n                if proportions[cat][idx] &gt;= self.ip['text_bar_threshold'] / max(solution['count']):\n\n                    # Rotate triple digit text\n                    if quantities[cat][idx] &gt;= 100:\n                        rotation = 90\n                    else:\n                        rotation = 0\n\n                    # Place the text\n                    self.ax.text(idx, (totals[idx] - proportions[cat][idx] / 2), int(quantities[cat][idx]),\n                                 color=text_color, zorder=2, fontsize=self.ip[\"text_size\"],\n                                 horizontalalignment='center', verticalalignment='center', rotation=rotation)\n            else:\n                if proportions[cat][idx] &gt;= self.ip['text_bar_threshold'] / max(solution['count']):\n\n                    # Place the text\n                    self.ax.text(idx, (totals[idx] - quantities[cat][idx] / 2), int(quantities[cat][idx]),\n                                 color=text_color, zorder=2, fontsize=self.ip[\"text_size\"],\n                                 horizontalalignment='center', verticalalignment='center')\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.results_degree_tier_chart","title":"<code>results_degree_tier_chart()</code>","text":"<p>Builds the degree tier results chart</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_degree_tier_chart(self):\n    \"\"\"\n    Builds the degree tier results chart\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = self.parameters, self.value_parameters, self.solution\n    k, quota, measure = self.c['k'], p['pgl'][self.c['J']], self.c['measure']\n    colors, afscs = np.array([self.ip['bar_colors'][\"small_afscs\"] for _ in self.c['J']]), self.c['afscs']\n\n    # Get the title\n    self.ip[\"title\"] = self.ip[\"objective\"] + \" Proportion Across Each AFSC\"\n\n    # Set the max for the y-axis\n    self.c['use_calculated_y_max'] = True\n    self.c['y_max'] = self.ip['y_max']  # * np.max(measure)\n\n    minimums = np.zeros(self.c['M'])\n    maximums = np.zeros(self.c['M'])\n    x_under = []\n    x_over = []\n    x_within = []\n\n    # Assign the right color to the AFSCs\n    for index, j in enumerate(self.c['J']):\n        if \"Increasing\" in vp[\"value_functions\"][j, k]:\n            minimums[index] = vp['objective_target'][j, k]\n            maximums[index] = 1\n        else:\n            minimums[index] = 0\n            maximums[index] = vp['objective_target'][j, k]\n\n        if minimums[index] &lt;= measure[index] &lt;= maximums[index]:\n            colors[index] = \"blue\"\n            x_within.append(index)\n        else:\n            colors[index] = \"red\"\n            if measure[index] &lt; minimums[index]:\n                x_under.append(index)\n            else:\n                x_over.append(index)\n\n    # Plot points\n    self.ax.scatter(afscs, measure, c=colors, linewidths=4, s=self.ip[\"dot_size\"], zorder=3)\n\n    # Calculate ranges\n    y_within = [(minimums[j], maximums[j]) for j in x_within]\n    y_under_ranges = [(minimums[j], maximums[j]) for j in x_under]\n    y_over_ranges = [(minimums[j], maximums[j]) for j in x_over]\n    y_under = [(measure[j], minimums[j]) for j in x_under]\n    y_over = [(maximums[j], measure[j]) for j in x_over]\n\n    # Plot bounds\n    self.ax.scatter(afscs, minimums, c=\"black\", marker=\"_\", linewidth=2)\n    self.ax.scatter(afscs, maximums, c=\"black\", marker=\"_\", linewidth=2)\n\n    # Plot Ranges\n    self.ax.plot((x_within, x_within), ([i for (i, j) in y_within], [j for (i, j) in y_within]),\n                 c=\"black\")\n    self.ax.plot((x_under, x_under), ([i for (i, j) in y_under_ranges], [j for (i, j) in y_under_ranges]),\n                 c=\"black\")\n    self.ax.plot((x_over, x_over),([i for (i, j) in y_over_ranges], [j for (i, j) in y_over_ranges]), c=\"black\")\n\n    # How far off\n    self.ax.plot((x_under, x_under), ([i for (i, j) in y_under], [j for (i, j) in y_under]), c='red', linestyle='--')\n    self.ax.plot((x_over, x_over), ([i for (i, j) in y_over], [j for (i, j) in y_over]), c='red', linestyle='--')\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.results_quota_chart","title":"<code>results_quota_chart()</code>","text":"<p>This method produces the \"Combined Quota\" chart for each AFSC</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_quota_chart(self):\n    \"\"\"\n    This method produces the \"Combined Quota\" chart for each AFSC\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = self.parameters, self.value_parameters, self.solution\n    k, quota, measure = self.c['k'], p['pgl'][self.c['J']], self.c['measure']\n    colors, afscs = np.array([self.ip['bar_colors'][\"small_afscs\"] for _ in self.c['J']]), self.c['afscs']\n\n    if self.ip[\"version\"] == \"dot\":\n\n        # Get the title and label\n        self.ip[\"title\"] = \"Percent of PGL Target Met Across Each AFSC\"\n        self.c['y_label'] = \"Percent of PGL Target Met\"  # Manual change from objective label dictionary\n\n        # Set the max for the y-axis\n        self.c['use_calculated_y_max'] = True\n        self.c['y_ticks'] = [0, 0.5, 1, 1.5, 2]\n\n        # Degree Tier elements\n        x_under = []\n        x_over = []\n        x_within = []\n        quota_percent_filled = np.zeros(self.c['M'])\n        max_quota_percent = np.zeros(self.c['M'])\n\n        # Assign the right color to the AFSCs\n        for index, j in enumerate(self.c['J']):\n\n            # Get bounds\n            value_list = vp['objective_value_min'][j, k].split(\",\")\n            max_measure = float(value_list[1].strip())\n            if quota[index] &gt; measure[index]:\n                colors[index] = \"red\"\n                x_under.append(index)\n            elif quota[index] &lt;= measure[index] &lt;= max_measure:\n                colors[index] = \"blue\"\n                x_within.append(index)\n            else:\n                colors[index] = \"orange\"\n                x_over.append(index)\n\n            quota_percent_filled[index] = measure[index] / quota[index]\n            max_quota_percent[index] = max_measure / quota[index]\n\n        # Plot points\n        self.ax.scatter(afscs, quota_percent_filled, c=colors, linewidths=4, s=self.ip[\"dot_size\"], zorder=3)\n\n        # Set the max for the y-axis\n        self.c['y_max'] = self.ip['y_max'] * np.max(quota_percent_filled)\n\n        # Lines\n        y_mins = np.repeat(1, self.c['M'])\n        y_maxs = max_quota_percent\n        y = [(y_mins[j], y_maxs[j]) for j in range(self.c['M'])]\n        y_under = [(quota_percent_filled[j], 1) for j in x_under]\n        y_over = [(max_quota_percent[j], quota_percent_filled[j]) for j in x_over]\n\n        # Plot Bounds\n        self.ax.scatter(afscs, y_mins, c=np.repeat('blue', self.c['M']), marker=\"_\", linewidth=2)\n        self.ax.scatter(afscs, y_maxs, c=np.repeat('blue', self.c['M']), marker=\"_\", linewidth=2)\n\n        # Plot Range Lines\n        self.ax.plot((np.arange(self.c['M']), np.arange(self.c['M'])), ([i for (i, j) in y], [j for (i, j) in y]),\n                     c='blue')\n        self.ax.plot((x_under, x_under), ([i for (i, j) in y_under], [j for (i, j) in y_under]), c='red',\n                linestyle='--')\n        self.ax.plot((x_over, x_over), ([i for (i, j) in y_over], [j for (i, j) in y_over]), c='orange',\n                linestyle='--')\n        self.ax.plot((np.arange(self.c['M']), np.arange(self.c['M'])), (np.zeros(self.c['M']), np.ones(self.c['M'])),\n                     c='black', linestyle='--', alpha=0.3)\n\n        # Quota Line\n        self.ax.axhline(y=1, color='black', linestyle='-', alpha=0.5)\n\n        # Put quota text\n        y_top = round(max(quota_percent_filled))\n        y_spacing = (y_top / 80)\n        for j in range(self.c['M']):\n            if int(measure[j]) &gt;= 100:\n                self.ax.text(j, quota_percent_filled[j] + 1.4 * y_spacing, int(measure[j]),\n                             fontsize=self.ip[\"xaxis_tick_size\"], multialignment='right',\n                             horizontalalignment='center')\n            elif int(measure[j]) &gt;= 10:\n                self.ax.text(j, quota_percent_filled[j] + y_spacing, int(measure[j]),\n                             fontsize=self.ip[\"xaxis_tick_size\"], multialignment='right',\n                             horizontalalignment='center')\n            else:\n                self.ax.text(j, quota_percent_filled[j] + y_spacing, int(measure[j]),\n                             fontsize=self.ip[\"xaxis_tick_size\"], multialignment='right',\n                             horizontalalignment='center')\n\n    else:  # quantity_bar\n\n        # Get the title and label\n        self.ip[\"title\"] = \"Number of Cadets Assigned to Each AFSC against PGL\"\n        self.c['y_label'] = self.label_dict[self.ip[\"objective\"]]\n\n        # Calculate y-axis attributes\n        self.determine_y_max_and_y_ticks()\n\n        # Legend\n        self.c['legend_elements'] = [Patch(facecolor=self.ip['bar_colors'][\"pgl\"], label='PGL Target',\n                                           edgecolor=\"black\"),\n                                     Patch(facecolor=self.ip['bar_colors'][\"surplus\"],\n                                           label='Cadets Exceeding PGL Target', edgecolor=\"black\"),\n                                     Patch(facecolor=self.ip['bar_colors'][\"failed_pgl\"], label='PGL Target Not Met',\n                                           edgecolor=\"black\")]\n\n        # Add the text and quota lines\n        for j in range(self.c['M']):\n\n            # Add the text\n            self.ax.text(j, measure[j] + self.ip['bar_text_offset'], int(measure[j]),\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n\n            # Determine which category the AFSC falls into\n            line_color = \"black\"\n            if measure[j] &gt; quota[j]:\n                self.ax.bar([j], quota[j], color=self.ip['bar_colors'][\"pgl\"], edgecolor=\"black\")\n                self.ax.bar([j], measure[j] - quota[j], bottom=quota[j],\n                            color=self.ip['bar_colors'][\"surplus\"], edgecolor=\"black\")\n            elif measure[j] &lt; quota[j]:\n                self.ax.bar([j], measure[j], color=self.ip['bar_colors'][\"failed_pgl\"], edgecolor=\"black\")\n                self.ax.plot((j - 0.4, j - 0.4), (quota[j], measure[j]),\n                        color=self.ip['bar_colors'][\"failed_pgl\"], linestyle=\"--\", zorder=2)\n                self.ax.plot((j + 0.4, j + 0.4), (quota[j], measure[j]),\n                        color=self.ip['bar_colors'][\"failed_pgl\"], linestyle=\"--\", zorder=2)\n                line_color = self.ip['bar_colors'][\"failed_pgl\"]\n            else:\n                self.ax.bar([j], measure[j], color=self.ip['bar_colors'][\"pgl\"], edgecolor=\"black\")\n\n            # Add the PGL lines\n            self.ax.plot((j - 0.4, j + 0.4), (quota[j], quota[j]), color=line_color, linestyle=\"-\", zorder=2)\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.results_preference_chart","title":"<code>results_preference_chart()</code>","text":"<p>This method builds the charts for cadet/AFSC preferences</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_preference_chart(self):\n    \"\"\"\n    This method builds the charts for cadet/AFSC preferences\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = self.parameters, self.value_parameters, self.solution\n    k, quota, measure = self.c['k'], p['pgl'][self.c['J']], self.c['measure']\n    colors, afscs = np.array([self.ip['bar_colors'][\"small_afscs\"] for _ in self.c['J']]), self.c['afscs']\n\n    if self.ip[\"version\"] in [\"quantity_bar_proportion\", \"quantity_bar_choice\"]:\n\n        # Counts\n        counts = {\"bottom_choices\": np.zeros(self.c['M']), \"mid_choices\": np.zeros(self.c['M']),\n                  \"top_choices\": np.zeros(self.c['M'])}\n\n        # Colors\n        colors = self.ip['bar_colors']\n\n        if self.ip[\"objective\"] == \"Utility\":\n\n            # Get the title\n            self.ip[\"title\"] = \"Cadet Preference Breakdown Across Each AFSC\"\n\n            if self.ip[\"version\"] == 'quantity_bar_choice':\n\n                # Legend (and colors)\n                self.c['legend_elements'] = []\n                self.ip['legend_size'] = int(self.ip['legend_size'] * 0.7)\n                colors = {}\n                for choice in range(p['P'])[:10]:\n                    colors[str(choice + 1)] = self.ip['choice_colors'][choice + 1]\n                    self.c['legend_elements'].append(Patch(facecolor=colors[str(choice + 1)],\n                                                           label=str(choice + 1), edgecolor='black'))\n                colors['All Others'] = self.ip['all_other_choice_colors']\n                self.c['legend_elements'].append(Patch(facecolor=colors['All Others'],\n                                                       label='All Others', edgecolor='black'))\n\n                # Add the title of the legend\n                self.c['legend_title'] = 'Cadet Choice'\n\n                # Counts\n                counts = {\"All Others\": np.zeros(self.c['M'])}\n                for choice in range(p['P'])[:10][::-1]:\n                    counts[str(choice + 1)] = np.zeros(self.c['M'])\n                for index, j in enumerate(self.c['J']):\n                    afsc = p['afscs'][j]\n                    total = 0\n                    for choice in range(p['P'])[:10]:\n                        counts[str(choice + 1)][index] = solution[\"choice_counts\"][\"TOTAL\"][afsc][choice]\n                        total += counts[str(choice + 1)][index]\n                    counts['All Others'][index] = self.c['total_count'][index] - total\n\n            else:\n\n                # Legend\n                self.c['legend_elements'] = [Patch(facecolor=self.ip['bar_colors'][\"top_choices\"],\n                                                   label='Top 3 Choices', edgecolor='black'),\n                                             Patch(facecolor=self.ip['bar_colors'][\"mid_choices\"],\n                                                   label='Next 3 Choices', edgecolor='black'),\n                                             Patch(facecolor=self.ip['bar_colors'][\"bottom_choices\"],\n                                                   label='All Others', edgecolor='black')]\n\n                # Cadet Choice Counts\n                for index, j in enumerate(self.c['J']):\n                    counts['top_choices'][index] = solution['choice_counts']['TOTAL']['Top 3'][j]\n                    counts['mid_choices'][index] = solution['choice_counts']['TOTAL']['Next 3'][j]\n                    counts['bottom_choices'][index] = solution['choice_counts']['TOTAL']['All Others'][j]\n\n        else:\n\n            # Get the title\n            self.ip[\"title\"] = \"AFSC Preference Breakdown\"\n\n            if self.ip[\"version\"] == 'quantity_bar_choice':\n\n                # Legend (and colors)\n                self.c['legend_elements'] = []\n                self.ip['legend_size'] = int(self.ip['legend_size'] * 0.7)\n                colors = {}\n                cat_choice_dict = {'90-100%': 1, '80-89%': 2, '70-79%': 3, '60-69%': 4, '50-59%': 5,\n                                   '40-49%': 6, '30-39%': 7, '20-29%': 8, '10-19%': 9, '0-10%': 10}\n                for cat, choice in cat_choice_dict.items():\n                    colors[cat] = self.ip['choice_colors'][choice]\n                    self.c['legend_elements'].append(Patch(facecolor=colors[cat],\n                                                           label=cat, edgecolor='black'))\n\n                # Add the title of the legend\n                self.c['legend_title'] = 'AFSC Rank\\nPercentile'\n\n                # Counts\n                counts = {}\n                cat_dem_dict = {'90-100%': 0.9, '80-89%': 0.8, '70-79%': 0.7, '60-69%': 0.6, '50-59%': 0.5,\n                                '40-49%': 0.4, '30-39%': 0.3, '20-29%': 0.2, '10-19%': 0.1, '0-10%': 0}\n                categories = list(cat_dem_dict.keys())\n                for cat in categories[::-1]:\n                    counts[cat] = np.zeros(self.c['M'])\n                for index, j in enumerate(self.c['J']):\n                    afsc = p['afscs'][j]\n                    total = 0\n                    for cat, dem in cat_dem_dict.items():\n                        counts[cat][index] = solution[\"afsc_choice_counts\"][afsc][cat]\n                        total += counts[cat][index]\n\n            else:\n\n                # Legend\n                self.c['legend_elements'] = [Patch(facecolor=self.ip['bar_colors'][\"top_choices\"], label='Top Third',\n                                                   edgecolor='black'),\n                                             Patch(facecolor=self.ip['bar_colors'][\"mid_choices\"], label='Middle Third',\n                                                   edgecolor='black'),\n                                             Patch(facecolor=self.ip['bar_colors'][\"bottom_choices\"],\n                                                   label='Bottom Third', edgecolor='black')]\n\n                # AFSC Choice Counts\n                for i, j in enumerate(self.solution['j_array']):\n                    if j in self.c['J']:\n                        index = np.where(self.c['J'] == j)[0][0]\n                        if p[\"afsc_utility\"][i, j] &lt; 1 / 3:\n                            counts[\"bottom_choices\"][index] += 1\n                        elif p[\"afsc_utility\"][i, j] &lt; 2 / 3:\n                            counts[\"mid_choices\"][index] += 1\n                        else:\n                            counts[\"top_choices\"][index] += 1\n\n        # Set label\n        self.c['y_label'] = \"Number of Cadets\"\n\n        # Calculate y-axis attributes\n        self.determine_y_max_and_y_ticks()\n\n        # Loop through each AFSC to plot the bars\n        for index, j in enumerate(self.c[\"J\"]):\n\n            count_sum = 0\n            for cat in counts:\n                text_color = \"black\"\n\n                # Plot the bars\n                count = counts[cat][index]\n                self.ax.bar([index], count, bottom=count_sum, edgecolor=\"black\", color=colors[cat])\n                count_sum += count\n\n                # Put a number on the bar\n                if count &gt;= self.ip['text_bar_threshold']:\n                    self.ax.text(index, (count_sum - count / 2 - 2), int(count), color=text_color, zorder=2,\n                                 fontsize=self.ip[\"bar_text_size\"], horizontalalignment='center')\n\n            # Add the text\n            self.ax.text(index, self.c['total_count'][index] + self.ip['bar_text_offset'], int(self.c['total_count'][index]),\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n\n    elif self.ip[\"version\"] in [\"dot\", \"bar\"]:\n\n        # Get the title\n        self.ip[\"title\"] = self.label_dict[self.ip[\"objective\"]] + \" Across Each AFSC\"\n\n        # Average Utility Chart (simple)\n        self.c['y_ticks'] = [0, 0.2, 0.4, 0.6, 0.8, 1]\n        self.c['use_calculated_y_max'] = True\n        self.ax.bar(afscs, measure, color=\"black\", edgecolor='black', alpha=self.ip[\"alpha\"])\n\n        for j in range(self.c['M']):\n\n            # Add the text\n            self.ax.text(j, measure[j] + 0.013, round(measure[j], 2), fontsize=self.ip[\"text_size\"],\n                         horizontalalignment='center')\n\n    elif self.ip[\"version\"] == \"quantity_bar_gradient\":\n\n        # Get the title and label\n        self.ip[\"title\"] = \"Cadet Satisfaction Breakdown Across Each AFSC\"\n        self.c['y_label'] = 'Number of Cadets'\n\n        # Calculate y-axis attributes\n        self.determine_y_max_and_y_ticks()\n\n        # Build the gradient chart\n        self.construct_gradient_chart(parameter_to_use='cadet_utility')\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.results_norm_score_chart","title":"<code>results_norm_score_chart()</code>","text":"<p>This method constructs the different charts showing the \"Norm Score\" objective</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_norm_score_chart(self):\n    \"\"\"\n    This method constructs the different charts showing the \"Norm Score\" objective\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = self.parameters, self.value_parameters, self.solution\n    k, quota, measure = self.c['k'], p['pgl'][self.c['J']], self.c['measure']\n    colors, afscs = np.array([self.ip[\"bar_color\"] for _ in self.c['J']]), self.c['afscs']\n\n    if self.ip[\"version\"] == \"bar\":\n\n        # Get the title and label\n        self.ip[\"title\"] = \"Normalized Score Across Each AFSC\"\n\n        # Y-axis\n        self.c['use_calculated_y_max'] = True\n        self.c['y_max'] = self.ip['y_max']\n        self.c['y_ticks'] = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n\n        # Add the text\n        for j in range(self.c['M']):\n\n            # Add the text\n            self.ax.text(j, measure[j] + 0.013, round(measure[j], 2),\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n\n        # Bar Chart\n        self.ax.bar(afscs, measure, color=colors, edgecolor='black', alpha=self.ip[\"alpha\"])\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.CadetUtilityGraph","title":"<code>CadetUtilityGraph(instance)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>instance</code> required Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def __init__(self, instance):\n    \"\"\"\n\n    :param instance:\n    \"\"\"\n\n    # Load attributes\n    self.parameters = instance.parameters\n    self.value_parameters, self.vp_name = instance.value_parameters, instance.vp_name\n    self.ip = instance.mdl_p  # \"instance plot parameters\"\n    self.data_name, self.data_version = instance.data_name, instance.data_version\n\n    # Initialize the matplotlib figure/axes\n    self.fig, self.ax = plt.subplots(figsize=self.ip['figsize'], facecolor=self.ip['facecolor'], tight_layout=True,\n                                     dpi=self.ip['dpi'])\n\n    # Where to save the chart\n    self.path = instance.export_paths[\"Analysis &amp; Results\"] + \"Data Charts/\"\n\n    # Shorthand\n    i, p = self.ip['cadet'], self.parameters\n    J = p['cadet_preferences'][i]\n    afscs, M = p['afscs'][J], len(J)\n\n    # Utility categories\n    categories = ['Utility Ascribed', 'Normalized Rank', 'Not Bottom 3', 'Not Last Choice']\n    legend_elements = []\n    for cat in categories:\n        legend_elements.append(Patch(facecolor=self.ip['bar_colors'][cat], label=cat,\n                                     edgecolor='black'))\n\n    # AFSCs the cadet is eligible for and selected (ordered appropriately)\n    intersection = np.intersect1d(p['J^Selected'][i], J)\n    intersection = np.array([j for j in p['cadet_preferences'][i] if j in intersection])\n    num_selected = len(intersection)\n\n    # 1, 2, 3, 4, ..., N  (Pure rankings)\n    rankings = np.arange(num_selected) + 1\n\n    # 1, 0.8, 0.6, 0.4, ..., 1 / N  (Scale rankings to range from 1 to 0)\n    normalized_rankings = 1 - (rankings / np.max(rankings)) + (1 / np.max(rankings))\n\n    # Create dictionary of normalized ordinal rankings\n    norm_ord_rankings_dict = {j: normalized_rankings[index] for index, j in enumerate(intersection)}\n\n    # A: AFSC is NOT the LAST choice\n    a = np.array([(j != p['J^Last Choice'][i]) * 1 for j in J])\n\n    # B: AFSC is NOT in the bottom 3 choices\n    b = np.array([((j not in p['J^Bottom 2 Choices'][i]) and (j != p['J^Last Choice'][i])) * 1 for j in J])\n\n    # C: AFSC was selected as a preference\n    c = np.array([(j in p['J^Selected'][i]) * 1 for j in J])\n\n    # D: AFSC was selected as a preference and has a utility assigned\n    d = np.array([(p['utility'][i, j] &gt; 0) * 1 for j in J])\n\n    # X: Normalized ordinal ranking of the AFSC\n    x = np.array([norm_ord_rankings_dict[j] if j in norm_ord_rankings_dict else 0 for j in J])\n\n    # Y: Utility value the cadet assigned to the AFSC\n    y = p['utility'][i, J]\n\n    # # Execute the formula and load it into the cadet utility matrix\n    # p['cadet_utility'][i, j] = 0.05 * a + 0.05 * b + 0.9 * (0.3 * c * x + 0.7 * d * y)\n\n    # Plot the bars\n    total = np.zeros(M)\n    self.ax.bar(np.arange(M), a * 0.05, color=self.ip['bar_colors'][\"Not Last Choice\"], edgecolor='black')\n    total += a * 0.05\n    self.ax.bar(np.arange(M), b * 0.05, bottom=total, color=self.ip['bar_colors'][\"Not Bottom 3\"], edgecolor='black')\n    total += b * 0.05\n    self.ax.bar(np.arange(M), c * x  * 0.3 * 0.9, bottom=total, color=self.ip['bar_colors'][\"Normalized Rank\"],\n                edgecolor='black')\n    total += c * x  * 0.3 * 0.9\n    self.ax.bar(np.arange(M), d * y * 0.7 * 0.9, bottom=total, color=self.ip['bar_colors'][\"Utility Ascribed\"],\n                edgecolor='black')\n\n    # Put text on the bars\n    for index, j in enumerate(J):\n\n        # Final utility above bar\n        self.ax.text(index, p['cadet_utility'][i, j] + 0.005,\n                     np.around(100 * p['cadet_utility'][i, j], 1).astype(str) + \"%\", fontsize=self.ip[\"bar_text_size\"],\n                     horizontalalignment='center')\n\n        # Reported utility in bar\n        val = y[index] * 0.7 * 0.9\n        if d[index] == 1 and val &gt; 0.02:\n            y_pt = 0.1 + x[index] * 0.3 * 0.9 + val / 2\n            self.ax.text(index, y_pt,\n                         np.around(p['utility'][i, j], 2), fontsize=self.ip[\"bar_text_size\"],\n                         horizontalalignment='center', verticalalignment='center')\n\n        # Normalized ranking val in bar\n        val = x[index] * 0.3 * 0.9\n        if c[index] == 1 and val &gt; 0.02:\n            y_pt = 0.1 + val / 2\n            self.ax.text(index, y_pt,\n                         np.around(norm_ord_rankings_dict[j], 2), fontsize=self.ip[\"bar_text_size\"],\n                         horizontalalignment='center', verticalalignment='center')\n\n    # # Put text above the bar\n    # self.ax.text(np.arange(M), p['cadet_utility'][i, J] + 0.02,\n    #              np.around(p['cadet_utility'][i, J], 3).astype(str), fontsize=self.ip[\"bar_text_size\"],\n    #              horizontalalignment='center')\n\n    # Display title\n    self.ip['title'] = 'Cadet \"' + str(i) + '\" Utility Chart'\n    if self.ip['display_title']:\n        self.fig.suptitle(self.ip['title'], fontsize=self.ip['title_size'])\n\n    # Labels\n    self.ax.set_ylabel(\"Utility\")\n    self.ax.yaxis.label.set_size(self.ip['label_size'])\n    self.ax.set_xlabel('AFSCs')\n    self.ax.xaxis.label.set_size(self.ip['label_size'])\n\n    # Color the AFSCs on the x axis\n    if self.ip[\"color_afsc_text_by_grp\"]:\n        afsc_colors = [self.ip['bar_colors'][p['acc_grp'][j]] for j in p['cadet_preferences'][i]]\n    else:\n        afsc_colors = [\"black\" for _ in afscs]\n\n    # X axis\n    self.ax.tick_params(axis='x', labelsize=self.ip['afsc_tick_size'])\n    self.ax.set_xticks(np.arange(M))\n    self.ax.set_xticklabels(afscs, rotation=self.ip['afsc_rotation'])\n    self.ax.set(xlim=(-0.8, M))\n\n    # Unique AFSC colors potentially based on accessions group\n    for index, xtick in enumerate(self.ax.get_xticklabels()):\n        xtick.set_color(afsc_colors[index])\n\n    # Y axis\n    self.ax.tick_params(axis='y', labelsize=self.ip['yaxis_tick_size'])\n    self.ax.set_yticks([0, 0.2, 0.4, 0.6, 0.8, 1])\n    self.ax.set_yticklabels(['0%', '20%', '40%', '60%', '80%', '100%'])\n\n    # Legend\n    if self.ip[\"add_legend_afsc_chart\"]:\n        self.ax.legend(handles=legend_elements, edgecolor='black', loc=self.ip['legend_loc'],\n                       fontsize=self.ip['legend_size'], ncol=self.ip['ncol'], labelspacing=1, handlelength=0.8,\n                       handletextpad=0.2, borderpad=0.2, handleheight=2)\n\n    # Save the chart\n    self.ip['filename'] = self.ip['title']\n    if self.ip['save']:\n        self.fig.savefig(self.path + self.ip[\"filename\"])\n        print(\"Saved\", self.ip[\"filename\"], \"Chart to \" + self.path + \".\")\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AccessionsGroupChart","title":"<code>AccessionsGroupChart(instance)</code>","text":"<p>This is a class dedicated to creating \"Accessions Group Charts\" which are all charts that include the \"accessions groups\" on the x-axis alongside the basline. This is meant to condense the amount of code and increase read-ability of the various kinds of charts.</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def __init__(self, instance):\n    \"\"\"\n    This is a class dedicated to creating \"Accessions Group Charts\" which are all charts\n    that include the \"accessions groups\" on the x-axis alongside the basline. This is meant to condense the amount\n    of code and increase read-ability of the various kinds of charts.\n    \"\"\"\n\n    # Load attributes\n    self.parameters = instance.parameters\n    self.value_parameters, self.vp_name = instance.value_parameters, instance.vp_name\n    self.ip = instance.mdl_p  # \"instance plot parameters\"\n    self.solution, self.solution_name = instance.solution, instance.solution_name\n    self.data_name, self.data_version = instance.data_name, instance.data_version\n\n    # Dictionaries of instance components (sets of value parameters, solutions)\n    self.vp_dict, self.solutions = instance.vp_dict, instance.solutions\n\n    # Initialize the matplotlib figure/axes\n    self.fig, self.ax = plt.subplots(figsize=self.ip['figsize'], facecolor=self.ip['facecolor'], tight_layout=True,\n                                     dpi=self.ip['dpi'])\n\n    # Label dictionary for AFSC objectives\n    self.label_dict = copy.deepcopy(afccp.globals.obj_label_dict)\n\n    # Where to save the chart\n    self.paths = {\"Data\": instance.export_paths[\"Analysis &amp; Results\"] + \"Data Charts/\",\n                  \"Solution\": instance.export_paths[\"Analysis &amp; Results\"] + self.solution_name + \"/\",\n                  \"Comparison\": instance.export_paths[\"Analysis &amp; Results\"] + \"Comparison Charts/\"}\n\n    # Initialize \"c\" dictionary (specific chart parameters)\n    self.c = {\"x_labels\": [\"All Cadets\"]}\n    for acc_grp in self.parameters['afscs_acc_grp']:\n        self.c['x_labels'].append(acc_grp)\n    self.c['g'] = len(self.c['x_labels'])\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AccessionsGroupChart.build","title":"<code>build(chart_type='Data', printing=True)</code>","text":"<p>Builds the specific chart based on what the user passes within the \"instance plot parameters\" (ip)</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def build(self, chart_type=\"Data\", printing=True):\n    \"\"\"\n    Builds the specific chart based on what the user passes within the \"instance plot parameters\" (ip)\n    \"\"\"\n\n    # Determine what kind of chart we're showing\n    if chart_type == \"Data\":  # \"Before Solution\" chart\n        pass\n\n    elif chart_type == \"Solution\":  # Solution chart\n\n        if 'race_categories' not in self.parameters:\n            return None  # We're not doing this\n\n        self.results_demographic_chart()\n\n    # Put the solution name in the title if specified\n    if self.ip[\"solution_in_title\"]:\n        self.ip['title'] = self.solution['name'] + \": \" + self.ip['title']\n\n    # Display title\n    if self.ip['display_title']:\n        self.fig.suptitle(self.ip['title'], fontsize=self.ip['title_size'])\n\n    # Labels\n    self.ax.set_ylabel(self.c[\"y_label\"])\n    self.ax.yaxis.label.set_size(self.ip['label_size_acc'])\n    self.ax.set_xlabel('Accessions Group')\n    self.ax.xaxis.label.set_size(self.ip['label_size_acc'])\n\n    # Color the x-axis labels\n    if self.ip[\"color_afsc_text_by_grp\"]:\n        label_colors = [self.ip['bar_colors'][grp] for grp in self.c['x_labels']]\n    else:\n        label_colors = [\"black\" for _ in self.c['x_labels']]\n\n    # X axis\n    self.ax.tick_params(axis='x', labelsize=self.ip['xaxis_tick_size'])\n    self.ax.set_xticklabels(self.c['x_labels'])\n\n    # Unique label colors potentially based on accessions group\n    for index, xtick in enumerate(self.ax.get_xticklabels()):\n        xtick.set_color(label_colors[index])\n\n    # Y axis\n    self.ax.tick_params(axis='y', labelsize=self.ip['yaxis_tick_size'])\n    self.ax.set(ylim=(0, self.ip[\"y_max\"] * 1.03))\n\n    # Legend\n    if self.c['legend_elements'] is not None:\n        self.ax.legend(handles=self.c[\"legend_elements\"], edgecolor='black', loc=self.ip['legend_loc'],\n                       fontsize=self.ip['acc_legend_size'], ncol=self.ip['ncol'], labelspacing=1, handlelength=0.8,\n                       handletextpad=0.2, borderpad=0.2, handleheight=2)\n\n    # Get the filename\n    if self.ip[\"filename\"] is None:\n        self.ip[\"filename\"] = self.data_name + \" (\" + self.data_version + \") \" + self.solution['name'] + \\\n                              \" Accessions Group [\" + self.ip['version'] + \"] (Results).png\"\n\n    # Save the chart\n    if self.ip['save']:\n        self.fig.savefig(self.paths[chart_type] + self.ip[\"filename\"])\n\n        if printing:\n            print(\"Saved\", self.ip[\"filename\"], \"Chart to \" + self.paths[chart_type] + \".\")\n    else:\n        if printing:\n            print(\"Created\", self.ip[\"filename\"], \"Chart.\")\n\n    # Return the chart\n    return self.fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AccessionsGroupChart.results_demographic_chart","title":"<code>results_demographic_chart()</code>","text":"<p>Displays a demographic breakdown across accessions groups</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_demographic_chart(self):\n    \"\"\"\n    Displays a demographic breakdown across accessions groups\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = self.parameters, self.value_parameters, self.solution\n\n    # Update certain things that apply to all versions of this kind of chart\n    self.c['y_label'] = 'Proportion of Cadets'\n\n    # Category Dictionary\n    category_dict = {\"Race Chart\": p['race_categories'], 'Ethnicity Chart': p['ethnicity_categories'],\n                     'Gender Chart': ['Male', 'Female'], 'SOC Chart': ['USAFA', 'ROTC']}\n    title_dict = {\"Race Chart\": 'Racial Demographics Across Each Accessions Group',\n                  'Ethnicity Chart': 'Ethnicity Demographics Across Each Accessions Group',\n                  'Gender Chart': 'Gender Breakdown Across Each Accessions Group',\n                  'SOC Chart': 'Source of Commissioning Breakdown Across Each Accessions Group'}\n    baseline_num_dict = {\"Race Chart\": \"baseline_simpson_index\", \"Ethnicity Chart\": \"baseline_simpson_index_eth\",\n                         \"Gender Chart\": \"male_proportion\", \"SOC Chart\": \"usafa_proportion\"}\n    acc_grp_num_dict = {\"Race Chart\": \"simpson_index_\", \"Ethnicity Chart\": \"simpson_index_eth_\",\n                        \"Gender Chart\": \"male_proportion_\", \"SOC Chart\": \"usafa_proportion_\"}\n\n    # Extract the specific information for this chart from the dictionaries above\n    self.ip['title'] = title_dict[self.ip['version']]\n    categories = category_dict[self.ip['version']]\n    baseline_p = baseline_num_dict[self.ip['version']]\n    acc_grp_num_dict_s = acc_grp_num_dict[self.ip['version']]\n\n    # Legend elements\n    self.c['legend_elements'] = []\n    for cat in categories[::-1]:  # Flip the legend\n        color = self.ip['bar_colors'][cat]\n        self.c['legend_elements'].append(Patch(facecolor=color, label=cat, edgecolor='black'))\n\n    # Baseline\n    if len(categories) == 2:\n        self.c['legend_elements'].append(mlines.Line2D([], [], color=\"black\", linestyle='--', label=\"Baseline\"))\n        self.ax.axhline(y=p[baseline_p], color='black', linestyle='--', zorder=4)\n        self.c['y_ticks'] = [0, round(p[baseline_p], 2), 1]\n\n    self.ip['ncol'] = len(self.c['legend_elements'])  # Adjust number of columns for legend\n\n    # Loop through each category and accessions group pair\n    quantities, proportions = {}, {}\n    for cat in categories:\n        quantities[cat], proportions[cat] = np.zeros(self.c['g']), np.zeros(self.c['g'])\n        for idx, grp in enumerate(self.c['x_labels']):\n\n            # Get metrics from this category group in this accessions group\n            if grp == \"All Cadets\":\n                cadets = p['I^' + cat]\n\n                # Load metrics\n                quantities[cat][idx] = int(len(cadets))\n                proportions[cat][idx] = len(cadets) / p['N']\n            else:\n                cadets = np.intersect1d(p['I^' + cat], solution['I^' + grp])\n\n                # Load metrics\n                quantities[cat][idx] = int(len(cadets))\n                proportions[cat][idx] = len(cadets) / len(solution['I^' + grp])\n\n    # Loop through each accession group to add the text above the bars\n    for idx, grp in enumerate(self.c['x_labels']):\n        if grp == \"All Cadets\":\n            txt = str(round(p[baseline_p], 2))\n        else:\n            txt = str(solution[acc_grp_num_dict_s + grp])\n        self.ax.text(idx, 1.005, txt, verticalalignment='bottom', fontsize=self.ip[\"acc_text_size\"],\n                     horizontalalignment='center')\n\n    # Plot the data\n    totals = np.zeros(self.c['g'])\n    for cat in quantities:\n        color = self.ip['bar_colors'][cat]\n        self.ax.bar(self.c['x_labels'], proportions[cat], bottom=totals, color=color, zorder=2, edgecolor='black')\n        totals += proportions[cat]\n\n        # Put a number on the bar\n        for idx in range(self.c['g']):\n            if proportions[cat][idx] &gt;= self.ip['acc_text_bar_threshold'] / max(solution['count']):\n\n                # If it's a dark color, change text color to white\n                if 'Black' in cat or \"Male\" in cat:\n                    text_color = 'white'\n                else:\n                    text_color = 'black'\n\n                # Place the text\n                self.ax.text(idx, (totals[idx] - proportions[cat][idx] / 2), int(quantities[cat][idx]),\n                             color=text_color, zorder=2, fontsize=self.ip[\"acc_bar_text_size\"],\n                             horizontalalignment='center', verticalalignment='center')\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.individual_weight_graph","title":"<code>individual_weight_graph(instance)</code>","text":"<p>This function creates the chart for either the individual weight function for cadets or the actual individual weights on the AFSCs</p> <p>Returns:</p> Type Description <p>chart</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def individual_weight_graph(instance):\n    \"\"\"\n    This function creates the chart for either the individual weight function for cadets or the actual\n    individual weights on the AFSCs\n    :return: chart\n    \"\"\"\n\n    # Shorthand\n    p, vp, ip = instance.parameters, instance.value_parameters, instance.mdl_p\n\n    # Initialize figure and title\n    if ip[\"title\"] is None:\n        if ip[\"cadets_graph\"]:\n            title = 'Individual Weight on Cadets'\n        else:\n            title = 'Individual Weight on AFSCs'\n    else:\n        title = ip[\"title\"]\n\n    # Build figure\n    if ip[\"cadets_graph\"]:\n\n        # Cadets Graph\n        fig, ax = plt.subplots(figsize=ip[\"square_figsize\"], facecolor=ip[\"facecolor\"], dpi=ip[\"dpi\"],\n                               tight_layout=True)\n        # ax.set_aspect('equal', adjustable='box')\n\n        # Get x and y coordinates\n        if 'merit_all' in p:\n            x = p['merit_all']\n        else:\n            x = p['merit']\n        y = vp['cadet_weight'] / np.max(vp['cadet_weight'])\n\n        # Plot\n        ax.scatter(x, y, color=ip[\"bar_color\"], alpha=ip[\"alpha\"], linewidth=3)\n\n        # Labels\n        ax.set_ylabel('Cadet Weight', fontname='Times New Roman')\n        ax.yaxis.label.set_size(ip[\"label_size\"])\n        ax.set_xlabel('Percentile', fontname='Times New Roman')\n        ax.xaxis.label.set_size(ip[\"label_size\"])\n\n        # Ticks\n        # x_ticks = [0, 0.2, 0.4, 0.6, 0.8, 1]\n        # ax.set_xticklabels(x_ticks, fontname='Times New Roman')\n        ax.tick_params(axis='x', labelsize=ip[\"xaxis_tick_size\"])\n        ax.tick_params(axis='y', labelsize=ip[\"yaxis_tick_size\"])\n\n        # Margins\n        ax.set(xlim=(-0.02, 1.02))\n        # ax.margins(x=0)\n        # ax.margins(y=0)\n\n    else:  # AFSC Chart\n\n        # AFSCs Graph\n        fig, ax = plt.subplots(figsize=ip[\"figsize\"], facecolor=ip[\"facecolor\"], dpi=ip[\"dpi\"], tight_layout=True)\n\n        # Labels\n        ax.set_ylabel('AFSC Weight')\n        ax.yaxis.label.set_size(ip[\"label_size\"])\n        ax.set_xlabel('AFSCs')\n        ax.xaxis.label.set_size(ip[\"label_size\"])\n\n        # We can skip AFSCs\n        if ip[\"skip_afscs\"]:\n            tick_indices = np.arange(1, p[\"M\"], 2).astype(int)\n        else:\n            tick_indices = np.arange(p[\"M\"])\n\n        # Plot\n        afscs = p['afscs'][:p[\"M\"]]\n        ax.bar(afscs, vp['afsc_weight'], color=ip[\"bar_color\"], alpha=ip[\"alpha\"])\n\n        # Ticks\n        ax.set(xlim=(-0.8, p[\"M\"]))\n        ax.tick_params(axis='x', labelsize=ip[\"afsc_tick_size\"])\n        ax.set_yticks([])\n        ax.set_xticklabels(afscs[tick_indices], rotation=ip[\"afsc_rotation\"])\n        ax.set_xticks(tick_indices)\n\n    if ip[\"display_title\"]:\n        ax.set_title(title, fontsize=ip[\"label_size\"])\n\n    if ip[\"save\"]:\n        fig.savefig(instance.export_paths['Analysis &amp; Results'] + 'Value Parameters/' + title + '.png',\n                    bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.afsc_multi_criteria_graph","title":"<code>afsc_multi_criteria_graph(instance, max_num=None)</code>","text":"<p>This chart compares certain AFSCs in a solution according to multiple criteria</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def afsc_multi_criteria_graph(instance, max_num=None):\n    \"\"\"\n    This chart compares certain AFSCs in a solution according to multiple criteria\n    \"\"\"\n\n    # Shorthand\n    ip = instance.plt_p\n    p = instance.parameters\n    vp = instance.value_parameters\n\n    # Create figure\n    fig, ax = plt.subplots(figsize=ip['figsize'], facecolor=ip['facecolor'], tight_layout=True, dpi=ip['dpi'])\n\n    # Get list of AFSCs we're considering\n    afscs = np.array(ip[\"comparison_afscs\"])\n    used_indices = np.array([np.where(p[\"afscs\"] == afsc)[0][0] for afsc in afscs])\n    criteria = ip[\"comparison_criteria\"]\n    num_afscs = len(afscs)\n    num_criteria = len(criteria)\n\n    # Get quota\n    if \"pgl\" in p:\n        quota = p[\"pgl\"][used_indices]\n    else:\n        quota = p[\"quota\"][used_indices]\n\n    # Need to know number of cadets assigned\n    quota_k = np.where(vp[\"objectives\"] == \"Combined Quota\")[0][0]\n    total_count = instance.metrics[\"objective_measure\"][used_indices, quota_k]\n    full_count = instance.metrics[\"objective_measure\"][:, quota_k]\n\n    # Sort the AFSCs by the PGL\n    if ip[\"sort_by_pgl\"]:\n        indices = np.argsort(quota)[::-1]\n\n    # Sort the AFSCs by the number of cadets assigned\n    else:\n        indices = np.argsort(total_count)[::-1]\n\n    # Re-sort the AFSCs, quota, and total count\n    afscs = afscs[indices]\n    quota = quota[indices]\n    total_count = total_count[indices]\n    indices = used_indices[indices]\n\n    # Set the bar chart structure parameters\n    label_locations = np.arange(num_afscs)\n    bar_width = 0.8 / num_criteria\n\n    # Y max\n    if max_num is None:\n        y_max = ip[\"y_max\"] * max(instance.metrics[\"objective_measure\"][:, quota_k])\n    else:\n        y_max = ip[\"y_max\"] * max_num\n\n    # Y tick marks\n    if 100 &lt;= y_max &lt; 150:\n        y_ticks = [50, 100, 150]\n    elif 150 &lt;= y_max &lt; 200:\n        y_ticks = [50, 100, 150, 200]\n    elif 200 &lt;= y_max &lt; 250:\n        y_ticks = [50, 100, 150, 200, 250]\n    elif 250 &lt;= y_max &lt; 300:\n        y_ticks = [50, 100, 150, 200, 250, 300]\n    elif y_max &gt;= 300:\n        y_ticks = [50, 100, 150, 200, 250, 300, 350]\n    else:\n        y_ticks = [50]\n\n    # Convert utility matrix to utility columns\n    preferences, utilities_array = afccp.data.preferences.get_utility_preferences(p)\n\n    # AFOCD\n    afocd_objectives = [\"Mandatory\", \"Desired\", \"Permitted\"]\n    afocd_k = {objective: np.where(vp[\"objectives\"] == objective)[0][0] for objective in afocd_objectives}\n    afocd_count = {objective: full_count * instance.metrics[\"objective_measure\"][:, afocd_k[objective]]\n                   for objective in afocd_objectives}\n    afocd_count = {objective: afocd_count[objective][indices] for objective in afocd_objectives}  # Re-sort\n\n    # Counts\n    top_3_count = np.zeros(p[\"M\"])\n    next_3_count = np.zeros(p[\"M\"])\n    non_vol_count = np.zeros(p[\"M\"])\n    for i, j in enumerate(instance.solution):\n\n        # Preference Counts\n        afsc = p[\"afscs\"][j]\n        if afsc in preferences[i, 0:3]:\n            top_3_count[j] += 1\n        elif afsc in preferences[i, 3:6]:\n            next_3_count[j] += 1\n        else:\n            non_vol_count[j] += 1\n\n    # Re-sort preferences\n    top_3_count, next_3_count = top_3_count[indices], next_3_count[indices]\n    non_vol_count = non_vol_count[indices]\n\n    # Percentile\n    percentile_dict = {1: (0.75, 1), 2: (0.5, 0.75), 3: (0.25, 0.5), 4: (0, 0.25)}\n\n    # Loop through each solution/AFSC bar\n    M = len(indices)\n    for index, j in enumerate(indices):\n        cadets = np.where(instance.solution == j)[0]\n        merit = p[\"merit\"][cadets]\n        utility = p[\"utility\"][cadets, j]\n        for c, obj in enumerate(criteria):\n\n            if obj == \"Preference\":\n\n                # Plot preference bars\n                ax.bar(label_locations[index] + bar_width * c, non_vol_count[index], bar_width,\n                       edgecolor='black', color=ip['bar_colors'][\"bottom_choices\"])\n                ax.bar(label_locations[index] + bar_width * c, next_3_count[index], bar_width,\n                       bottom=non_vol_count[index], edgecolor='black',\n                       color=ip['bar_colors'][\"mid_choices\"])\n                ax.bar(label_locations[index] + bar_width * c, top_3_count[index], bar_width,\n                       bottom=non_vol_count[index] + next_3_count[index], edgecolor='black',\n                       color=ip['bar_colors'][\"top_choices\"])\n\n            elif obj == \"Merit\":\n\n                # Plot the merit gradient bars\n                uq = np.unique(merit)\n                count_sum = 0\n                for val in uq:\n                    count = len(np.where(merit == val)[0])\n                    color = str(val)  # Grayscale\n                    ax.bar(label_locations[index] + bar_width * c, count, bar_width, bottom=count_sum, color=color,\n                           zorder=2)\n                    count_sum += count\n\n                # Add the text\n                ax.text(label_locations[index] + bar_width * c, total_count[index] + 2, round(np.mean(merit), 2),\n                        fontsize=ip[\"text_size\"], horizontalalignment='center')\n\n            elif obj == \"Utility\":\n\n                # Plot the utility gradient bars\n                uq = np.unique(utility)\n                count_sum = 0\n                for val in uq:\n                    count = len(np.where(utility == val)[0])\n                    color = (1 - val, 0, val)  # Blue to Red\n                    ax.bar(label_locations[index] + bar_width * c, count, bar_width, bottom=count_sum, color=color,\n                           zorder=2)\n                    count_sum += count\n\n                # Add the text\n                ax.text(label_locations[index] + bar_width * c, total_count[index] + 2, round(np.mean(utility), 2),\n                        fontsize=ip[\"text_size\"], horizontalalignment='center')\n\n            elif obj == \"Quartile\":\n\n                # Loop through each quartile\n                count_sum = 0\n                for q in [4, 3, 2, 1]:\n                    lb, ub = percentile_dict[q][0], percentile_dict[q][1]\n                    count = len(np.where((merit &lt;= ub) &amp; (merit &gt; lb))[0])\n                    ax.bar(label_locations[index] + bar_width * c, count, bar_width, bottom=count_sum,\n                           edgecolor=\"black\",\n                           color=ip['bar_colors'][\"quartile_\" + str(q)], zorder=2)\n                    count_sum += count\n\n                    # Put a number on the bar\n                    if count &gt;= 10:\n                        if q == 1:\n                            color = \"white\"\n                        else:\n                            color = \"black\"\n                        ax.text(label_locations[index] + bar_width * c, (count_sum - count / 2 - 2), int(count),\n                                color=color, zorder=3, fontsize=ip[\"bar_text_size\"], horizontalalignment='center')\n\n            elif obj == \"AFOCD\":\n\n                # Plot the AFOCD bars\n                count_sum = 0\n                for objective in afocd_objectives:\n\n                    # Plot AFOCD bars\n                    count = afocd_count[objective][index]\n                    ax.bar(label_locations[index] + bar_width * c, count, bar_width,\n                           bottom=count_sum, edgecolor='black', color=ip['bar_colors'][objective])\n                    count_sum += count\n\n                    # Put a number on the bar\n                    if count &gt;= 10:\n\n                        prop = count / total_count[index]\n                        if objective == \"Permitted\":\n                            color = \"black\"\n                        else:\n                            color = \"white\"\n                        ax.text(label_locations[index] + bar_width * c, (count_sum - count / 2 - 2),\n                                round(prop, 2), color=color, zorder=3, fontsize=ip[\"bar_text_size\"],\n                                horizontalalignment='center')\n\n                # Add the text\n                ax.text(label_locations[index] + bar_width * c, total_count[index] + 2, int(total_count[index]),\n                        fontsize=ip[\"text_size\"], horizontalalignment='center')\n\n        # Add Lines to the bar chart\n        left = label_locations[index] - bar_width / 2\n        right = label_locations[index] + bar_width * (num_criteria - 1) + bar_width / 2\n        ax.plot((left, right), (total_count[index], total_count[index]), linestyle=\"-\", linewidth=1, zorder=2,\n                color=\"black\")\n\n        # PGL Line\n        ax.plot((right - 0.02, right + 0.02), (quota[index], quota[index]), linestyle=\"-\", zorder=2, linewidth=4,\n                color=\"black\")  # PGL tick mark\n\n        # Add the text\n        ax.text(right + 0.04, quota[index], int(quota[index]), fontsize=ip[\"bar_text_size\"], horizontalalignment='left',\n                verticalalignment=\"center\")\n    # Labels\n    ax.set_ylabel(\"Number of Cadets\")\n    ax.yaxis.label.set_size(ip[\"label_size\"])\n    ax.set_xlabel(\"AFSCs\")\n    ax.xaxis.label.set_size(ip[\"label_size\"])\n\n    # Y ticks\n    ax.set_yticks(y_ticks)\n    ax.tick_params(axis=\"y\", labelsize=ip[\"yaxis_tick_size\"])\n    ax.set_yticklabels(y_ticks)\n    ax.margins(y=0)\n    ax.set(ylim=(0, y_max))\n\n    # X ticks\n    ax.set_xticklabels(afscs, rotation=0)\n    ax.set_xticks(label_locations + (bar_width / 2) * (num_criteria - 1))\n    ax.tick_params(axis=\"x\", labelsize=ip[\"afsc_tick_size\"])\n    # ax.set(xlim=[2 * bar_width - 1, num_criteria])\n\n    # Title\n    if ip[\"display_title\"]:\n        ax.set_title(ip[\"title\"], fontsize=ip[\"title_size\"])\n\n    # Filename\n    if ip[\"filename\"] is None:\n        ip[\"filename\"] = ip[\"title\"]\n\n    # Save\n    if ip['save']:\n        fig.savefig(afccp.globals.paths['figures'] + instance.data_name + \"/results/\" + ip['filename'] + '.png',\n                    bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.cadet_utility_histogram","title":"<code>cadet_utility_histogram(instance, filepath=None)</code>","text":"<p>Builds the Cadet Utility histogram</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def cadet_utility_histogram(instance, filepath=None):\n    \"\"\"\n    Builds the Cadet Utility histogram\n    \"\"\"\n\n    # Shorthand\n    ip = instance.mdl_p\n\n    # Shared elements\n    fig, ax = plt.subplots(figsize=ip[\"figsize\"], facecolor=ip[\"facecolor\"], dpi=ip[\"dpi\"], tight_layout=True)\n    bins = np.arange(21) / 20\n\n    if ip[\"solution_names\"] is not None:  # Comparing two or more solutions\n        if ip[\"title\"] is None:\n\n            # Create the title!\n            if ip[\"num_solutions\"] == 1:\n                ip['title'] = ip[\"solution_names\"][0] + \" Cadet Utility Results Histogram\"\n            elif ip[\"num_solutions\"] == 2:\n                ip['title'] = ip[\"solution_names\"][0] + \" and \" + ip[\"solution_names\"][1] + \\\n                              \" Cadet Utility Results Histogram\"\n            elif ip[\"num_solutions\"] == 3:\n                ip['title'] = ip[\"solution_names\"][0] + \", \" + ip[\"solution_names\"][1] + \\\n                              \", and \" + ip[\"solution_names\"][2] + \" Cadet Utility Results Histogram\"\n            else:\n                ip['title'] = ip[\"solution_names\"][0] + \", \" + ip[\"solution_names\"][1] + \\\n                              \", \" + ip[\"solution_names\"][2] + \", and \" + ip[\"solution_names\"][3] + \\\n                              \" Cadet Utility Results Histogram\"\n\n        # Plot the results\n        legend_elements = []\n        for solution_name in ip[\"solution_names\"]:\n            value = instance.solutions[solution_name]['cadet_utility_achieved']\n            ax.hist(value, bins=bins, edgecolor='black', color=ip[\"colors\"][solution_name], alpha=0.5)\n            legend_elements.append(Patch(facecolor=ip[\"colors\"][solution_name], label=solution_name,\n                                         alpha=0.5, edgecolor='black'))\n\n        ax.legend(handles=legend_elements, edgecolor='black', fontsize=ip[\"legend_size\"], loc='upper left',\n                  ncol=ip[\"num_solutions\"], columnspacing=0.8, handletextpad=0.25, borderaxespad=0.5, borderpad=0.4)\n    else:\n\n        # Get the title and filename\n        ip[\"title\"] = \"Cadet Utility Results Histogram\"\n        ip[\"filename\"] = instance.solution_name + \" Cadet_Utility_Histogram\"\n        if ip[\"solution_in_title\"]:\n            ip['title'] = instance.solution_name + \": \" + ip['title']\n\n        value = instance.solution[\"cadet_utility_achieved\"]\n        ax.hist(value, bins=bins, edgecolor='white', color='black', alpha=1)\n\n    # Labels\n    ax.set_ylabel('Number of Cadets')\n    ax.yaxis.label.set_size(ip[\"label_size\"])\n    ax.set_xlabel('Utility Received')\n    ax.xaxis.label.set_size(ip[\"label_size\"])\n\n    # Axis\n    x_ticks = np.arange(11) / 10\n    ax.set_xticks(x_ticks)\n    ax.tick_params(axis='x', labelsize=ip[\"xaxis_tick_size\"])\n    ax.tick_params(axis='y', labelsize=ip[\"yaxis_tick_size\"])\n\n    # Title\n    if ip[\"display_title\"]:\n        ax.set_title(ip[\"title\"], fontsize=ip[\"title_size\"])\n\n    # Filename\n    if ip[\"filename\"] is None:\n        ip[\"filename\"] = ip[\"title\"] + '.png'\n\n    # Save the figure\n    if ip[\"save\"]:\n        if filepath is None:\n            filepath = instance.export_paths['Analysis &amp; Results'] + \"Results Charts/\"\n        fig.savefig(filepath + ip[\"filename\"], bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.cadet_utility_merit_scatter","title":"<code>cadet_utility_merit_scatter(instance)</code>","text":"<p>Scatter plot of cadet utility vs cadet merit</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def cadet_utility_merit_scatter(instance):\n    \"\"\"\n    Scatter plot of cadet utility vs cadet merit\n    \"\"\"\n\n    # Shorthand\n    ip = instance.plt_p\n\n    # Shared elements\n    fig, ax = plt.subplots(figsize=ip[\"figsize\"], facecolor=ip[\"facecolor\"], dpi=ip[\"dpi\"], tight_layout=True)\n\n    # Get the title and filename\n    ip[\"title\"] = \"Cadet Preference vs. Merit\"\n    ip[\"filename\"] = instance.solution_name + \" Cadet_Preference_Merit_Scatter\"\n    if ip[\"solution_in_title\"]:\n        ip['title'] = instance.solution_name + \": \" + ip['title']\n\n    y = instance.metrics[\"cadet_value\"]\n\n    if \"merit_all\" in instance.parameters:\n        x = instance.parameters[\"merit_all\"]\n    else:\n        x = instance.parameters[\"merit\"]\n\n    ax.scatter(x, y, s=ip[\"dot_size\"], color='black', alpha=1)\n\n    # Labels\n    ax.set_ylabel('Cadet Utility Value')\n    ax.yaxis.label.set_size(ip[\"label_size\"])\n    ax.set_xlabel('Cadet Merit')\n    ax.xaxis.label.set_size(ip[\"label_size\"])\n\n    # Axis\n    x_ticks = np.arange(11) / 10\n    ax.set_xticks(x_ticks)\n    ax.tick_params(axis='x', labelsize=ip[\"xaxis_tick_size\"])\n    ax.tick_params(axis='y', labelsize=ip[\"yaxis_tick_size\"])\n\n    # Title\n    if ip[\"display_title\"]:\n        ax.set_title(ip[\"title\"], fontsize=ip[\"title_size\"])\n\n    # Filename\n    if ip[\"filename\"] is None:\n        ip[\"filename\"] = ip[\"title\"]\n\n    if ip[\"save\"]:\n        fig.savefig(afccp.globals.paths['figures'] + instance.data_name + \"/results/\" + ip[\"filename\"] + '.png',\n                    bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.holistic_color_graph","title":"<code>holistic_color_graph(parameters, value_parameters, metrics, figsize=(11, 10), save=False, facecolor='white')</code>","text":"<p>Builds the Holistic Color Chart</p> <p>Parameters:</p> Name Type Description Default <code>facecolor</code> <p>color of the background of the graph</p> <code>'white'</code> <code>figsize</code> <p>size of the figure</p> <code>(11, 10)</code> <code>save</code> <p>Whether we should save the graph</p> <code>False</code> <code>parameters</code> <p>fixed cadet/AFSC data</p> required <code>value_parameters</code> <p>value parameters</p> required <code>metrics</code> <p>solution metrics</p> required <p>Returns:</p> Type Description <p>figure</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def holistic_color_graph(parameters, value_parameters, metrics, figsize=(11, 10), save=False, facecolor='white'):\n    \"\"\"\n    Builds the Holistic Color Chart\n    :param facecolor: color of the background of the graph\n    :param figsize: size of the figure\n    :param save: Whether we should save the graph\n    :param parameters: fixed cadet/AFSC data\n    :param value_parameters: value parameters\n    :param metrics: solution metrics\n    :return: figure\n    \"\"\"\n    fig, ax = plt.subplots(figsize=figsize, facecolor=facecolor, tight_layout=True)\n    ax.set_aspect('equal', adjustable='box')\n    N = parameters['N']\n    title = 'Attribute Weights and Values Color Chart. Z = ' + str(round(metrics['z'], 2))\n    ax.set_title(title)\n\n    # Cadets\n    length = value_parameters['cadets_overall_weight']\n    values = metrics['cadet_value']\n    weights = value_parameters['cadet_weight']\n    sorted_indices = values.argsort()[::-1]\n    sorted_values = values[sorted_indices]\n    sorted_weights = weights[sorted_indices]\n    y = 0\n    for i in range(N):\n        xy = (0, y)\n        height = sorted_weights[i]\n        objective_value = sorted_values[i]\n        c = (1 - objective_value, 0, objective_value)\n        rect = Rectangle(xy, length, height, edgecolor='none', color=c)\n        ax.add_patch(rect)\n        y += height\n\n    # AFSCs\n    full_length = value_parameters['afscs_overall_weight']\n    afsc_values = metrics['afsc_value']\n    afsc_weights = value_parameters['afsc_weight']\n    sorted_afsc_indices = afsc_values.argsort()[::-1]\n    sorted_afsc_weights = afsc_weights[sorted_afsc_indices]\n    y = 0\n    for j in sorted_afsc_indices:\n        weights = value_parameters['objective_weight'][j, :]\n        values = metrics['objective_value'][j, :]\n        zeros = np.where(weights == 0)[0]\n        weights = np.delete(weights, zeros)\n        values = np.delete(values, zeros)\n        sorted_indices = values.argsort()[::-1]\n        sorted_values = values[sorted_indices]\n        sorted_weights = weights[sorted_indices]\n        x = value_parameters['cadets_overall_weight']\n        height = sorted_afsc_weights[j]\n        for k in range(len(sorted_indices)):\n            xy = (x, y)\n            objective_value = sorted_values[k]\n            c = (1 - objective_value, 0, objective_value)\n            rect = Rectangle(xy, sorted_weights[k], height, edgecolor='none', color=c)\n            ax.add_patch(rect)\n            x += sorted_weights[k] * full_length\n        height = sorted_afsc_weights[j]\n        y += height\n\n    if save:\n        fig.savefig(afccp.globals.paths['figures'] + instance.data_name + \"/results/\" + title + '.png',\n                    bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.pareto_graph","title":"<code>pareto_graph(instance, pareto_df, solution_names=None, dimensions=None, save=True, title=None, figsize=(10, 8), facecolor='white', display_title=False, l_word='Value', filepath=None)</code>","text":"<p>Builds the Pareto Frontier Chart for adjusting the overall weight on cadets</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <p>path to the folder to save this chart in</p> <code>None</code> <code>solution_names</code> <p>other solutions to plot on the chart</p> <code>None</code> <code>instance</code> <p>problem instance</p> required <code>l_word</code> <p>\"Label word\" for whether we're referring to these as \"values\" or \"utilities\"</p> <code>'Value'</code> <code>display_title</code> <p>if we should display a title or not</p> <code>False</code> <code>save</code> <p>If we should save the figure</p> <code>True</code> <code>title</code> <p>If we should include a title or not</p> <code>None</code> <code>pareto_df</code> <p>data frame of pareto analysis</p> required <code>dimensions</code> <p>N and M</p> <code>None</code> <code>facecolor</code> <p>color of the background of the graph</p> <code>'white'</code> <code>figsize</code> <p>size of the figure</p> <code>(10, 8)</code> <p>Returns:</p> Type Description <p>figure</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def pareto_graph(instance, pareto_df, solution_names=None, dimensions=None, save=True, title=None, figsize=(10, 8),\n                 facecolor='white', display_title=False, l_word='Value', filepath=None):\n    \"\"\"\n    Builds the Pareto Frontier Chart for adjusting the overall weight on cadets\n    :param filepath: path to the folder to save this chart in\n    :param solution_names: other solutions to plot on the chart\n    :param instance: problem instance\n    :param l_word: \"Label word\" for whether we're referring to these as \"values\" or \"utilities\"\n    :param display_title: if we should display a title or not\n    :param save: If we should save the figure\n    :param title: If we should include a title or not\n    :param pareto_df: data frame of pareto analysis\n    :param dimensions: N and M\n    :param facecolor: color of the background of the graph\n    :param figsize: size of the figure\n    :return: figure\n    \"\"\"\n\n    # Shorthand\n    ip = instance.mdl_p\n\n    # Colors and Axis\n    cm = plt.cm.get_cmap('RdYlBu')\n    label_size = 20\n    xaxis_tick_size = 20\n    yaxis_tick_size = 20\n\n    # Chart\n    fig, ax = plt.subplots(figsize=figsize, facecolor=facecolor, tight_layout=True)\n    ax.set_aspect('equal', adjustable='box')\n\n    sc = ax.scatter(pareto_df[l_word + ' on AFSCs'], pareto_df[l_word + ' on Cadets'], c=pareto_df['Weight on Cadets'],\n                    s=100, cmap=cm, edgecolor='black', zorder=1)\n    c_bar = plt.colorbar(sc)\n    c_bar.set_label('Weight on Cadets', fontsize=label_size)\n    c_bar.ax.tick_params(labelsize=xaxis_tick_size)\n    if title is None:\n        if dimensions is not None:\n            N = dimensions[0]\n            M = dimensions[1]\n            title = 'Pareto Frontier for Weight on Cadets (N=' + str(N) + ', M=' + str(M) + ')'\n        else:\n            title = 'Pareto Frontier for Weight on Cadets'\n    if display_title:\n        ax.set_title(title)\n\n    # Plot solution point(s)\n    if solution_names is not None:\n        for solution_name in solution_names:\n            solution = instance.solutions[solution_name]\n            ax.scatter(solution['afsc_utility_overall'], solution['cadet_utility_overall'],\n                       c=ip[\"colors\"][solution_name],\n                       s=100, edgecolor='black', zorder=2, marker=ip[\"markers\"][solution_name])\n            plt.text(solution['afsc_utility_overall'],\n                     solution['cadet_utility_overall'] + 0.003, solution_name, fontsize=15,\n                     horizontalalignment='center')\n\n    # Labels\n    ax.set_ylabel(l_word + ' on Cadets')\n    ax.yaxis.label.set_size(label_size)\n    ax.set_xlabel(l_word + ' on AFSCs')\n    ax.xaxis.label.set_size(label_size)\n\n    # Axis\n    ax.tick_params(axis='y', labelsize=yaxis_tick_size)\n    ax.tick_params(axis='x', labelsize=xaxis_tick_size)\n\n    # Save the figure\n    if save:\n        if filepath is None:\n            filepath = instance.export_paths['Analysis &amp; Results'] + \"Results Charts/\"\n        if solution_names is None:\n            filename = instance.data_name + \" \" + title + '.png'\n        else:\n            string_names = ', '.join(solution_names)\n            filename = instance.data_name + \" \" + title + '(' + string_names + ').png'\n        fig.savefig(filepath + filename, bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.afsc_objective_weights_graph","title":"<code>afsc_objective_weights_graph(parameters, value_parameters_dict, afsc, colors=None, save=False, figsize=(19, 7), facecolor='white', title=None, display_title=True, label_size=25, bar_color=None, xaxis_tick_size=15, yaxis_tick_size=25, legend_size=25, title_size=25)</code>","text":"<p>This chart compares the weights under different value parameters for AFSC objectives for a particular AFSC</p> <p>Parameters:</p> Name Type Description Default <code>bar_color</code> <p>color of bars for figure (for certain kinds of graphs)</p> <code>None</code> <code>title_size</code> <p>font size of the title</p> <code>25</code> <code>legend_size</code> <p>font size of the legend</p> <code>25</code> <code>yaxis_tick_size</code> <p>y axis tick sizes</p> <code>25</code> <code>xaxis_tick_size</code> <p>x axis tick sizes</p> <code>15</code> <code>label_size</code> <p>size of labels</p> <code>25</code> <code>display_title</code> <p>if we should show the title</p> <code>True</code> <code>title</code> <p>title of chart</p> <code>None</code> <code>parameters</code> <p>fixed cadet/AFSC parameters</p> required <code>value_parameters_dict</code> <p>dictionary of value parameters</p> required <code>afsc</code> <p>which AFSC we should plot</p> required <code>colors</code> <p>colors for the kinds of weights</p> <code>None</code> <code>save</code> <p>Whether we should save the graph</p> <code>False</code> <code>facecolor</code> <p>color of the background of the graph</p> <code>'white'</code> <code>figsize</code> <p>size of the figure</p> <code>(19, 7)</code> <p>Returns:</p> Type Description <p>figure</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def afsc_objective_weights_graph(parameters, value_parameters_dict, afsc, colors=None, save=False, figsize=(19, 7),\n                                 facecolor=\"white\", title=None, display_title=True, label_size=25, bar_color=None,\n                                 xaxis_tick_size=15, yaxis_tick_size=25, legend_size=25, title_size=25):\n    \"\"\"\n    This chart compares the weights under different value parameters for AFSC objectives for a particular AFSC\n    :param bar_color: color of bars for figure (for certain kinds of graphs)\n    :param title_size: font size of the title\n    :param legend_size: font size of the legend\n    :param yaxis_tick_size: y axis tick sizes\n    :param xaxis_tick_size: x axis tick sizes\n    :param label_size: size of labels\n    :param display_title: if we should show the title\n    :param title: title of chart\n    :param parameters: fixed cadet/AFSC parameters\n    :param value_parameters_dict: dictionary of value parameters\n    :param afsc: which AFSC we should plot\n    :param colors: colors for the kinds of weights\n    :param save: Whether we should save the graph\n    :param facecolor: color of the background of the graph\n    :param figsize: size of the figure\n    :return: figure\n    \"\"\"\n    if colors is None:\n        colors = ['blue', 'black', 'orange', 'magenta']\n\n    if title is None:\n        title = afsc + ' Objective Weights For Different Value Parameters'\n\n    fig, ax = plt.subplots(figsize=figsize, facecolor=facecolor, tight_layout=True)\n\n    # Get chart specs\n    num_weights = len(value_parameters_dict)\n    j = np.where(parameters['afscs'] == afsc)[0][0]\n    first_key = list(value_parameters_dict.keys())[0]\n    K_A = value_parameters_dict[first_key]['K^A'][j].astype(int)\n    objectives = value_parameters_dict[first_key]['objectives'][K_A]\n    for k, objective in enumerate(objectives):\n        if objective == 'USAFA Proportion':\n            objectives[k] = 'USAFA\\nProportion'\n        elif objective == 'Combined Quota':\n            objectives[k] = 'Combined\\nQuota'\n\n    if colors is None:\n        colors = ['blue', 'lime', 'orange', 'magenta', 'yellow', 'cyan', 'green', 'deeppink', 'red']\n        colors = colors[:num_weights]\n\n    if bar_color is not None:\n        colors = [bar_color for _ in range(num_weights)]\n\n    # Set the bar chart structure parameters\n    label_locations = np.arange(len(K_A))\n    bar_width = 0.8 / num_weights\n\n    # Loop through each set of value parameters\n    max_weight = 0\n    for w_num, weight_name in enumerate(value_parameters_dict):\n        # Plot weights\n        weights = value_parameters_dict[weight_name]['objective_weight'][j, K_A]\n        max_weight = max(max_weight, max(weights))\n        ax.bar(label_locations + bar_width * w_num, weights, bar_width, edgecolor='black',\n               label=weight_name, color=colors[w_num], alpha=0.5)\n\n    # Labels\n    ax.set_ylabel('Objective Weight')\n    ax.yaxis.label.set_size(label_size)\n    if bar_color is not None:\n        ax.set_xlabel('Objectives')\n        ax.xaxis.label.set_size(label_size)\n\n    # X ticks\n    ax.set(xticks=label_locations + (bar_width / 2) * (num_weights - 1),\n           xticklabels=[value_parameters_dict[first_key]['objectives'][i] for i in K_A])\n    ax.tick_params(axis='x', labelsize=xaxis_tick_size)\n    ax.set_xticklabels(objectives)\n\n    # Y ticks\n    ax.tick_params(axis='y', labelsize=yaxis_tick_size)\n    ax.margins(y=0)\n    ax.set(ylim=(0, max_weight * 1.2))\n\n    if display_title:\n        ax.set_title(title, fontsize=title_size)\n\n    if bar_color is None:\n        ax.legend(edgecolor='black', fontsize=legend_size, loc='upper right',\n                  ncol=num_weights, columnspacing=0.8, handletextpad=0.25, borderaxespad=0.5, borderpad=0.4)\n\n    if save:\n        fig.savefig(afccp.globals.paths['figures'] + instance.data_name + \"/value parameters/\" + title + '.png',\n                    bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.solution_parameter_comparison_graph","title":"<code>solution_parameter_comparison_graph(z_dict, colors=None, save=False, figsize=(19, 7), facecolor='white')</code>","text":"<p>This chart compares the solutions' objective values under different value parameters</p> <p>Parameters:</p> Name Type Description Default <code>z_dict</code> <p>dictionary of solution objective values for each set of value parameters</p> required <code>colors</code> <p>colors for the kinds of weights</p> <code>None</code> <code>save</code> <p>Whether we should save the graph</p> <code>False</code> <code>facecolor</code> <p>color of the background of the graph</p> <code>'white'</code> <code>figsize</code> <p>size of the figure</p> <code>(19, 7)</code> <p>Returns:</p> Type Description <p>figure</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def solution_parameter_comparison_graph(z_dict, colors=None, save=False, figsize=(19, 7), facecolor=\"white\"):\n    \"\"\"\n    This chart compares the solutions' objective values under different value parameters\n    :param z_dict: dictionary of solution objective values for each set of value parameters\n    :param colors: colors for the kinds of weights\n    :param save: Whether we should save the graph\n    :param facecolor: color of the background of the graph\n    :param figsize: size of the figure\n    :return: figure\n    \"\"\"\n    fig, ax = plt.subplots(figsize=figsize, facecolor=facecolor, tight_layout=True)\n\n    # Get chart specs\n    solution_names = list(z_dict.keys())\n    vp_names = list(z_dict[solution_names[0]].keys())\n    num_solutions = len(solution_names)\n    num_vps = len(vp_names)\n\n    if colors is None:\n        colors = ['blue', 'lime', 'orange', 'magenta', 'yellow', 'cyan', 'green', 'deeppink', 'red']\n        colors = colors[:num_solutions]\n\n    # Set the bar chart structure parameters\n    label_locations = np.arange(num_vps)\n    bar_width = 0.8 / num_solutions\n\n    # Loop through each set of solutions\n    legend_elements = []\n    for s_num, solution_name in enumerate(solution_names):\n        legend_elements.append(Patch(facecolor=colors[s_num], label=solution_name, alpha=0.5, edgecolor='black'))\n        for vp_num, vp_name in enumerate(vp_names):\n            # Plot solutions\n            ax.bar(label_locations[vp_num] + bar_width * s_num, z_dict[solution_name][vp_name], bar_width,\n                   edgecolor='black', color=colors[s_num])\n\n    # Text\n    ax.set_ylabel('Z')\n    ax.set(xticks=label_locations + bar_width / 2, xlim=[2 * bar_width - 1, num_vps],\n           xticklabels=vp_names)\n\n    title = 'Objective Values for Different Solutions and Value Parameters'\n    ax.set_title(title)\n    ax.legend(handles=legend_elements, edgecolor='black', loc='upper right', columnspacing=0.8, handletextpad=0.25,\n              borderaxespad=0.5, borderpad=0.4)\n    if save:\n        fig.savefig(afccp.globals.paths['figures'] + instance.data_name + \"/value parameters/\" + title + '.png',\n                    bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.solution_results_graph","title":"<code>solution_results_graph(parameters, value_parameters, solutions, vp_name, k, save=False, colors=None, figsize=(19, 7), facecolor='white')</code>","text":"<p>Builds the Graph to show how well we meet each of the objectives</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <p>colors of the solutions</p> <code>None</code> <code>vp_name</code> <p>value parameter name (to access from solutions)</p> required <code>k</code> <p>objective index</p> required <code>facecolor</code> <p>color of the background of the graph</p> <code>'white'</code> <code>figsize</code> <p>size of the figure</p> <code>(19, 7)</code> <code>save</code> <p>Whether we should save the graph</p> <code>False</code> <code>parameters</code> <p>fixed cadet/AFSC data</p> required <code>value_parameters</code> <p>value parameters</p> required <code>solutions</code> <p>solution metrics dictionary</p> required <p>Returns:</p> Type Description <p>figure</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def solution_results_graph(parameters, value_parameters, solutions, vp_name, k, save=False, colors=None,\n                           figsize=(19, 7), facecolor='white'):\n    \"\"\"\n    Builds the Graph to show how well we meet each of the objectives\n    :param colors: colors of the solutions\n    :param vp_name: value parameter name (to access from solutions)\n    :param k: objective index\n    :param facecolor: color of the background of the graph\n    :param figsize: size of the figure\n    :param save: Whether we should save the graph\n    :param parameters: fixed cadet/AFSC data\n    :param value_parameters: value parameters\n    :param solutions: solution metrics dictionary\n    :return: figure\n    \"\"\"\n\n    # Load the data\n    indices = value_parameters['J^E'][k]\n    afscs = parameters['afscs'][indices]\n    minimums = np.zeros(len(indices))\n    maximums = np.zeros(len(indices))\n    num_solutions = len(solutions.keys())\n    if colors is None:\n        colors = ['blue', 'lime', 'orange', 'magenta', 'yellow', 'cyan', 'green', 'deeppink', 'red']\n        colors = colors[:num_solutions]\n\n    fig, ax = plt.subplots(figsize=figsize, facecolor=facecolor, tight_layout=True)\n    for j, loc in enumerate(indices):\n        if k == 0:\n            minimums[j], maximums[j] = 0.35, 0.65\n        elif k == 1:\n            minimums[j], maximums[j] = 0.20, 0.40\n        elif k == 2:\n            minimums[j] = parameters['quota_min'][j] / parameters['quota'][j]\n            maximums[j] = parameters['quota_max'][j] / parameters['quota'][j]\n        elif k == 3:\n            if parameters['usafa_quota'][j] / parameters['quota'][j] == 0:\n                minimums[j], maximums[j] = 0, 0\n            elif parameters['usafa_quota'][j] / parameters['quota'][j] == 1:\n                minimums[j], maximums[j] = 1, 1\n            else:\n                minimums[j] = parameters['usafa_quota'][j] / parameters['quota'][j] - 0.1\n                maximums[j] = parameters['usafa_quota'][j] / parameters['quota'][j] + 0.1\n        elif k == 4:\n            if parameters['usafa_quota'][j] / parameters['quota'][j] == 0:\n                minimums[j], maximums[j] = 1, 1\n            elif parameters['usafa_quota'][j] / parameters['quota'][j] == 1:\n                minimums[j], maximums[j] = 0, 0\n            else:\n                minimums[j] = (parameters['quota'][j] - parameters['usafa_quota'][j]) / parameters['quota'][j] - 0.1\n                maximums[j] = (parameters['quota'][j] - parameters['usafa_quota'][j]) / parameters['quota'][j] + 0.1\n        elif k in [5, 6, 7]:\n            if k == 5 or (k == 6 and afscs[j] not in [\"14F\", \"15A\", \"17D\"]):\n                minimums[j] = value_parameters['objective_target'][loc, k]\n                maximums[j] = 1\n            else:\n                minimums[j] = 0\n                maximums[j] = value_parameters['objective_target'][loc, k]\n        elif k == 8:\n            minimums[j], maximums[j] = 0.8, 1\n        elif k == 9:\n            male_proportion = np.mean(parameters['male'])\n            minimums[j], maximums[j] = male_proportion - 0.1, male_proportion + 0.1\n        elif k == 10:\n            minority_proportion = np.mean(parameters['minority'])\n            minimums[j], maximums[j] = minority_proportion - 0.1, minority_proportion + 0.1\n\n    # ticks = list(np.arange(0, 1.1, 0.1))\n    # ax.set_yticks(ticks)\n    for s_num, solution_name in enumerate(solutions.keys()):\n        if k == 2:\n            measures = solutions[solution_name][vp_name]['objective_measure'][indices, k] / \\\n                       parameters['quota'][indices]\n        elif k == 3:\n            measures = solutions[solution_name][vp_name]['objective_measure'][indices, k] / \\\n                       parameters['usafa_quota'][indices]\n        elif k == 4:\n            measures = solutions[solution_name][vp_name]['objective_measure'][indices, k] / \\\n                       (parameters['quota'][indices] - parameters['usafa_quota'][indices])\n        else:\n            measures = solutions[solution_name][vp_name]['objective_measure'][indices, k]\n\n        ax.scatter(afscs, measures, c=colors[s_num], linewidths=4)\n\n    # Ranges\n    y = [(minimums[i], maximums[i]) for i in range(len(afscs))]\n    x = range(len(afscs))\n    for i in x:\n        plt.axvline(x=i, color='black', linestyle='--', alpha=0.2)\n    ax.plot((x, x), ([i for (i, j) in y], [j for (i, j) in y]), c='black')\n    ax.scatter(afscs, minimums, c='black', marker=\"_\", linewidth=2)\n    ax.scatter(afscs, maximums, c='black', marker=\"_\", linewidth=2)\n\n    # Titles and Labels\n    objective = value_parameters['objectives'][k]\n    ax.set_title(objective + ' Solution Comparison')\n    ax.set_ylabel(objective + ' Measure')\n\n    if save:\n        fig.savefig(afccp.globals.paths['figures'] + instance.data_name + \"/results/Solution Results Graph.png\",\n                    bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.solution_similarity_graph","title":"<code>solution_similarity_graph(instance, coords, solution_names, filepath=None)</code>","text":"<p>This is the chart that compares the approximate and exact models (with genetic algorithm) in solve time and objective value</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def solution_similarity_graph(instance, coords, solution_names, filepath=None):\n    \"\"\"\n    This is the chart that compares the approximate and exact models (with genetic algorithm) in solve time and\n    objective value\n    \"\"\"\n\n    # Load in plot parameters\n    ip = instance.mdl_p\n    ip[\"figsize\"] = (10, 10)\n\n    if ip[\"title\"] is None:\n        ip[\"title\"] = instance.data_name + \" Solution Similarity\"\n\n    # Create figure\n    fig, ax = plt.subplots(figsize=ip[\"figsize\"], facecolor=ip[\"facecolor\"], tight_layout=True)\n    ax.set_aspect('equal', adjustable='box')\n\n    # Plot the solution dot\n    legend_elements = []\n    special_solutions = []\n    for i, solution_name in enumerate(solution_names):\n        x, y = coords[i, 0], coords[i, 1]\n\n        # \"Special\" Solutions to show\n        if solution_name in ip['solution_names']:\n            special_solutions.append(solution_name)\n            ax.scatter(x, y, c=ip[\"colors\"][solution_name], marker=ip[\"markers\"][solution_name], edgecolor=\"black\",\n                       s=ip[\"sim_dot_size\"], zorder=2)\n\n            # Add legend element\n            legend_elements.append(mlines.Line2D([], [], color=ip[\"colors\"][solution_name],\n                                                 marker=ip[\"markers\"][solution_name], linestyle='None',\n                                                 markeredgecolor='black', markersize=20, label=solution_name))\n\n        # \"Basic\" solutions\n        else:\n\n            ax.scatter(x, y, c=ip['default_sim_color'], marker=ip[\"default_sim_marker\"], edgecolor=\"black\",\n                       s=ip[\"sim_dot_size\"], zorder=2)\n\n    ax.legend(handles=legend_elements, edgecolor='black', fontsize=ip[\"legend_size\"], loc='upper right',\n              ncol=len(legend_elements), columnspacing=0.4, handletextpad=0.1, borderaxespad=0.5, borderpad=0.2)\n\n    # Remove tick marks\n    ax.tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)\n\n    # Save the figure\n    if ip[\"save\"]:\n        if filepath is None:\n            filepath = instance.export_paths['Analysis &amp; Results'] + \"Results Charts/\"\n        if len(special_solutions) &gt; 0:\n            string_names = ', '.join(special_solutions)\n            filename = ip['title'] + '(' + string_names + ').png'\n        else:\n            filename = ip['title'] + '.png'\n        fig.savefig(filepath + filename, bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/slides/","title":"Slides","text":""},{"location":"reference/visualizations/slides/#visualizations.slides","title":"<code>visualizations.slides</code>","text":""},{"location":"reference/visualizations/slides/#visualizations.slides.generate_results_slides","title":"<code>generate_results_slides(instance)</code>","text":"<p>Function to generate the results slides for a particular problem instance with solution</p> Source code in <code>afccp/visualizations/slides.py</code> <pre><code>def generate_results_slides(instance):\n    \"\"\"\n    Function to generate the results slides for a particular problem instance with solution\n    \"\"\"\n\n    # Shorthand\n    mdl_p = instance.mdl_p\n\n    # Build the presentation object\n    prs = Presentation(afccp.globals.paths['files'] + 'results_slide_template.pptx')\n\n    # Delete the current slides in the template\n    for i in range(len(prs.slides) - 1, -1, -1):\n        rId = prs.slides._sldIdLst[i].rId\n        prs.part.drop_rel(rId)\n        del prs.slides._sldIdLst[i]\n\n    # Slide Layouts\n    title_slide_layout = prs.slide_layouts[0]\n    content_slide_layout = prs.slide_layouts[1]\n    chart_slide_layout = prs.slide_layouts[2]\n    bubble_slide_layout = prs.slide_layouts[3]\n    closing_slide_layout = prs.slide_layouts[4]\n\n    # Set width and height of presentation\n    prs.slide_width = Inches(mdl_p['b_figsize'][0])\n    prs.slide_height = Inches(mdl_p['b_figsize'][1])\n\n    # Add title slide\n    slide = prs.slides.add_slide(title_slide_layout)\n    title = slide.shapes.title\n    title.text = instance.data_name + \" Classification Results (\" + instance.solution['name'] + \")\"\n    # print(len(slide.placeholders))\n    # print(slide.placeholders)\n    # content = slide.placeholders[1]\n    # content.text = \"Rank, Name\\nAFPC/DSYA\\nTBD\"\n\n    # Initial content slide\n    slide = prs.slides.add_slide(content_slide_layout)\n    title = slide.shapes.title\n    title.text = \"Overview\"\n    content = slide.placeholders[1]\n    content.text = \"Here's where the overview goes\"\n\n    # Size of the chart\n    # top, left = Inches(instance.mdl_p['ch_top']), Inches(instance.mdl_p['ch_left'])\n    # height, width = Inches(instance.mdl_p['ch_height']), Inches(instance.mdl_p['ch_width'])\n\n    # # Size of the chart\n    # top, left = Inches(0), Inches(0)\n    # height, width = Inches(mdl_p['figsize'][1]), Inches(mdl_p['figsize'][0])\n\n    # Get the file paths to all the relevant images\n    folder_path = instance.export_paths['Analysis &amp; Results'] + instance.solution_name + \"/\"\n    folder = os.listdir(folder_path)\n    chart_paths = {}\n    for file in folder:\n        if instance.solution_name in file and '.png' in file:\n            chart_paths[file] = folder_path + file\n\n    # Loop through the pictures I want in the order I want\n    chart_text_order = {\"PGL\": [\"Combined Quota\", \"quantity_bar\"], \"BUBBLE CHART\": [\"Cadet Choice.png\"],\n                        \"SOC by Accessions Group\": [\"Accessions\", \"SOC Chart\"],\n                        \"Gender by Accessions Group\": [\"Accessions\", \"Gender Chart\"],\n                        \"Race by Accessions Group\": [\"Accessions\", \"Race Chart\"],\n                        \"Ethnicity by Accessions Group\": [\"Accessions\", \"Ethnicity Chart\"],\n                        \"SOC by AFSC\": [\"Extra Measure\", \"SOC Chart_proportion\"],\n                        \"Gender by AFSC\": [\"Extra Measure\", \"Gender Chart_proportion\"],\n                        \"Race by AFSC\": [\"Extra Measure\", \"Race Chart_proportion\"],\n                        \"Ethnicity by AFSC\": [\"Extra Measure\", \"Ethnicity Chart_proportion\"],\n                        \"Cadet Preference by AFSC\": [\"Utility\", \"quantity_bar_choice\"],\n                        \"AFSC Preference\": [\"Norm Score\", \"quantity_bar_choice\"],\n                        \"62EXE BUBBLE CHART\": [\"62EXE Specific Choice.png\"],}\n    for title_text in chart_text_order:\n\n        # Loop through each potential image\n        for file in chart_paths:\n\n            # Determine if this is the image I want here\n            found = True\n            for test_text in chart_text_order[title_text]:\n                if test_text not in file:\n                    found = False\n                    break\n\n            # If this is the file I want, we do things\n            if found:\n\n                # Determine the layout of the chart needed\n                if \"BUBBLE CHART\" in title_text:\n\n                    # Create the bubble chart slide\n                    slide = prs.slides.add_slide(bubble_slide_layout)\n\n                    # Add the image to the slide\n                    for shape in slide.placeholders:\n                        if \"Picture\" in shape.name:\n                            shape.insert_picture(chart_paths[file])\n                else:\n\n                    # Create the AFSC/Accessions Chart slide\n                    slide = prs.slides.add_slide(chart_slide_layout)\n                    title = slide.shapes.title\n                    title.text = title_text\n\n                    # # Add the picture to the slide\n                    # slide.shapes.add_picture(chart_paths[file], left, top, height=height, width=width)\n\n                    # Add the image to the slide\n                    for shape in slide.placeholders:\n                        if \"Picture\" in shape.name:\n                            shape.insert_picture(chart_paths[file])\n\n                # Break out of this loop since we found the image we want\n                break\n\n\n    # Add closing slide\n    prs.slides.add_slide(closing_slide_layout)\n\n    # Save the PowerPoint\n    filepath = instance.export_paths['Analysis &amp; Results'] + instance.solution_name + '/' + \\\n               instance.data_name + ' ' + instance.solution_name + '.pptx'\n    prs.save(filepath)\n</code></pre>"},{"location":"reference/visualizations/slides/#visualizations.slides.generate_comparison_slides","title":"<code>generate_comparison_slides(instance)</code>","text":"<p>Function to generate the results slides for a particular problem instance with solution</p> Source code in <code>afccp/visualizations/slides.py</code> <pre><code>def generate_comparison_slides(instance):\n    \"\"\"\n    Function to generate the results slides for a particular problem instance with solution\n    \"\"\"\n\n    # Shorthand\n    mdl_p = instance.mdl_p\n\n    # Build the presentation object\n    prs = Presentation()\n    blank_slide_layout = prs.slide_layouts[6]\n\n    # Set width and height of presentation\n    prs.slide_width = Inches(mdl_p['b_figsize'][0])\n    prs.slide_height = Inches(mdl_p['b_figsize'][1])\n\n    # Size of the chart\n    top, left = Inches(0), Inches(0)\n\n    # Get the file paths to all the relevant images\n    folder_path = instance.export_paths['Analysis &amp; Results'] + \"Comparison Charts/\"\n    folder = os.listdir(folder_path)\n\n    # Sort the files in the folder according to my preferred method\n    chart_paths = {}\n    keyword_order = [['Combined Quota'], ['Tier 1'], ['Male'], ['USAFA Proportion'], ['Merit'], ['Norm Score'],\n                     ['Utility', 'dot'], ['Utility', 'mean_preference'], ['Utility', 'median_preference'],\n                     ['Utility', 'Histogram'], ['Pareto', 'Cadets.png'], ['Pareto', ').png'], ['Similarity']]\n\n    # Loop through each set of \"keywords\"\n    for keywords in keyword_order:\n\n        # Loop through each file until we have a match\n        for file in folder:\n\n            # Loop through all keywords to see if we have a match\n            match = True\n            for keyword in keywords:\n                if keyword not in file:\n                    match = False\n                    break\n\n            # If we have a \"match\", add it!\n            if match:\n                chart_paths[file] = folder_path + file\n                folder.remove(file)  # Remove this file since we've accounted for it\n                break\n\n    # Add any remaining files\n    for file in folder:\n        if '.png' in file:\n            chart_paths[file] = folder_path + file\n\n    # Loop through each image file path to add the image to the presentation\n    for file in chart_paths:\n\n        # Add an empty slide\n        slide = prs.slides.add_slide(blank_slide_layout)\n\n        # Add the picture to the slide\n        slide.shapes.add_picture(chart_paths[file], left, top)  #, height=height, width=width)\n\n    # Save the PowerPoint\n    filepath = instance.export_paths['Analysis &amp; Results'] + instance.data_name + ' ' + 'Comparison.pptx'\n    prs.save(filepath)\n</code></pre>"},{"location":"reference/visualizations/slides/#visualizations.slides.create_animation_slides","title":"<code>create_animation_slides(instance)</code>","text":"<p>Function to generate the results slides for a particular problem instance with solution</p> Source code in <code>afccp/visualizations/slides.py</code> <pre><code>def create_animation_slides(instance):\n    \"\"\"\n    Function to generate the results slides for a particular problem instance with solution\n    \"\"\"\n\n    # Shorthand\n    mdl_p, sequence = instance.mdl_p, instance.solution['iterations']['sequence']\n\n    # Build the presentation object\n    prs = Presentation()\n    blank_slide_layout = prs.slide_layouts[6]\n\n    # Set width and height of presentation\n    prs.slide_width = Inches(mdl_p['b_figsize'][0])\n    prs.slide_height = Inches(mdl_p['b_figsize'][1])\n\n    # Size of the chart\n    top, left = Inches(0), Inches(0)\n    height, width = Inches(mdl_p['b_figsize'][1]), Inches(mdl_p['b_figsize'][0])\n\n    # Make sure we have the \"sequence\" folder\n    if sequence not in os.listdir(instance.export_paths['Analysis &amp; Results'] + \"Cadet Board/\"):\n        raise ValueError(\"Error. Sequence folder '\" + sequence + \"' not in 'Cadet Board' folder.\")\n\n    # Get the file path to the sequence folder\n    sequence_folder_path = instance.export_paths['Analysis &amp; Results'] + \"Cadet Board/\" + sequence + '/'\n\n    # Make sure we have the \"focus\" folder\n    if mdl_p['focus'] not in os.listdir(sequence_folder_path):\n        raise ValueError(\"Error. Focus folder '\" + mdl_p['focus'] + \"' not in '\" + sequence + \"' sequence folder.\")\n\n    # Files in the focus folder\n    focus_folder_path = sequence_folder_path + mdl_p['focus'] + '/'\n    folder = np.array(os.listdir(focus_folder_path))\n\n    # Regular solution iterations frames: 1.png for example\n    if \"1.png\" in folder:\n\n        # Sort the folder in order by the frames\n        int_vals = np.array([int(file[0]) for file in folder])\n        indices = np.argsort(int_vals)\n        img_paths = {file: focus_folder_path + file for file in folder[indices]}\n\n    # Matching Algorithm proposals/rejections frames: 1 (Proposals).png &amp; 1 (Rejections).png for example\n    else:\n\n        # The integer values at the beginning of each file\n        int_vals = np.array([int(file[:2]) for file in folder])\n        min, max = np.min(int_vals), np.max(int_vals)\n\n        # Loop through the files to get the ordered list of frames\n        img_paths = {}\n        for val in np.arange(min, max + 1):\n            indices = np.where(int_vals == val)[0]\n            files = folder[indices]\n            if len(files) &gt; 1:\n                if 'Proposals' in files[0]:\n                    img_paths[files[0]] = focus_folder_path + files[0]\n                    img_paths[files[1]] = focus_folder_path + files[1]\n                else:\n                    img_paths[files[1]] = focus_folder_path + files[1]\n                    img_paths[files[0]] = focus_folder_path + files[0]\n            else:\n                img_paths[files[0]] = focus_folder_path + files[0]\n\n    # Loop through each image file path to add the image to the presentation\n    for file in img_paths:\n\n        # Add an empty slide\n        slide = prs.slides.add_slide(blank_slide_layout)\n\n        # Add the picture to the slide\n        slide.shapes.add_picture(img_paths[file], left, top, height=height, width=width)\n\n    # Save the PowerPoint\n    filepath = sequence_folder_path + mdl_p['focus'] + '.pptx'\n    prs.save(filepath)\n</code></pre>"},{"location":"reference/visualizations/slides/#visualizations.slides.create_animated_presentation","title":"<code>create_animated_presentation(instance, num_intro_slides=3)</code>","text":"<p>Generates a PowerPoint presentation with: - Orientation slide (if available) - First few still frames - Animated GIF slide with remaining frames - Final solution slide (if available)</p> <p>Parameters:     instance: Object containing model data and paths     num_intro_slides (int): Number of still slides to include before GIF</p> Source code in <code>afccp/visualizations/slides.py</code> <pre><code>def create_animated_presentation(instance, num_intro_slides=3):\n    \"\"\"\n    Generates a PowerPoint presentation with:\n    - Orientation slide (if available)\n    - First few still frames\n    - Animated GIF slide with remaining frames\n    - Final solution slide (if available)\n\n    Parameters:\n        instance: Object containing model data and paths\n        num_intro_slides (int): Number of still slides to include before GIF\n    \"\"\"\n    # Shorthand\n    mdl_p = instance.mdl_p\n    sequence = instance.solution['iterations']['sequence']\n\n    # Build the presentation\n    prs = Presentation()\n    blank_slide_layout = prs.slide_layouts[6]\n    prs.slide_width = Inches(mdl_p['b_figsize'][0])\n    prs.slide_height = Inches(mdl_p['b_figsize'][1])\n    top, left = Inches(0), Inches(0)\n    height, width = Inches(mdl_p['b_figsize'][1]), Inches(mdl_p['b_figsize'][0])\n\n    # Paths\n    base_path = instance.export_paths['Analysis &amp; Results'] + \"Cadet Board/\"\n    sequence_path = os.path.join(base_path, sequence)\n    focus_path = os.path.join(sequence_path, mdl_p['focus'])\n\n    # Get sorted image files\n    folder = np.array(os.listdir(focus_path))\n    image_files = sorted([f for f in folder if f.endswith('.png')],\n                         key=lambda x: int(''.join(filter(str.isdigit, x.split()[0]))))\n\n    # --- Orientation Slide ---\n    orientation_path = os.path.join(focus_path, 'orientation.png')\n    if os.path.exists(orientation_path):\n        slide = prs.slides.add_slide(blank_slide_layout)\n        slide.shapes.add_picture(orientation_path, left, top, height=height, width=width)\n\n    # --- Still Slides ---\n    for i, file in enumerate(image_files[:num_intro_slides]):\n        slide = prs.slides.add_slide(blank_slide_layout)\n        slide.shapes.add_picture(os.path.join(focus_path, file), left, top, height=height, width=width)\n\n    # --- Create GIF from remaining images ---\n    gif_images = []\n    for file in image_files[num_intro_slides:]:\n        img = Image.open(os.path.join(focus_path, file)).convert(\"RGB\")\n        gif_images.append(img)\n\n    if gif_images:\n        gif_path = os.path.join(focus_path, 'animation.gif')\n        gif_images[0].save(\n            gif_path,\n            save_all=True,\n            append_images=gif_images[1:],\n            duration=500,\n            loop=0\n        )\n\n        # Add GIF slide (note: PowerPoint may require manual replacement depending on viewer support)\n        slide = prs.slides.add_slide(blank_slide_layout)\n        slide.shapes.add_picture(gif_path, left, top, height=height, width=width)\n\n    # --- Final Image (if exists) ---\n    file = image_files[len(image_files) - 1]\n    slide = prs.slides.add_slide(blank_slide_layout)\n    slide.shapes.add_picture(os.path.join(focus_path, file), left, top, height=height, width=width)\n\n    # Save presentation\n    output_path = os.path.join(sequence_path, mdl_p['focus'] + '_animated.pptx')\n    prs.save(output_path)\n</code></pre>"},{"location":"user-guide/overview/","title":"\ud83d\udcd8 User Guide Overview","text":"<p>Welcome to the AFCCP User Guide \u2014 a hands-on tutorial series designed to help users explore and understand the core  functionality of the Air Force Cadet Career Problem (AFCCP) module.</p> <p>This guide is ideal for new users looking to get up and running, as well as experienced users seeking to deepen their  understanding of how parameters, value functions, and model logic interact.</p>"},{"location":"user-guide/overview/#tutorial-series-overview","title":"\ud83d\udcda Tutorial Series Overview","text":""},{"location":"user-guide/overview/#tutorial-1-introduction","title":"\u2705 Tutorial 1: Introduction","text":"<p>Learn how to set up the AFCCP environment and run your first model. This tutorial covers: - How to clone the repository and install dependencies - What to expect when running <code>main.py</code> - A basic walkthrough of the <code>instance/</code> data folder and outputs</p>"},{"location":"user-guide/overview/#tutorial-2-data-overview","title":"\u2705 Tutorial 2: Data Overview","text":"<p>Dive into the data that power the AFCCP model. You\u2019ll learn:</p>"},{"location":"user-guide/overview/#tutorial-3-parameters","title":"\u2705 Tutorial 3: Parameters","text":"<p>Explore the <code>parameters</code> dictionary and get to know all the underlying data represented by it.</p>"},{"location":"user-guide/overview/#tutorial-4-value-parameters","title":"\u2705 Tutorial 4: Value Parameters","text":"<p>Learn how the weights/values/constraints are structured within the <code>value_parameters</code> dictionary.</p>"},{"location":"user-guide/overview/#tutorial-5-data-methods","title":"\u2705 Tutorial 5: Data Methods","text":"<p>Discover the various <code>CadetCareerProblem</code> methods used to correct the data for specific purposes.</p>"},{"location":"user-guide/overview/#tutorial-6-solutions-overview","title":"\u2705 Tutorial 6: Solutions Overview","text":"<p>Get a basic understanding of how the solutions are processed in <code>afccp</code>.</p>"},{"location":"user-guide/overview/#tutorial-7-algorithms","title":"\u2705 Tutorial 7: Algorithms","text":"<p>This tutorial dives into the algorithms and meta-heuristics available to the <code>CadetCareerProblem</code> class.</p>"},{"location":"user-guide/overview/#tutorial-8-optimization","title":"\u2705 Tutorial 8: Optimization","text":"<p>Learn the different optimization models, along with some sensitivity analysis, available within this module.</p>"},{"location":"user-guide/overview/#tutorial-9-visualizations","title":"\u2705 Tutorial 9: Visualizations","text":"<p>Explore the many kinds of visualizations available to the <code>CadetCareerProblem</code> class.</p>"},{"location":"user-guide/overview/#who-should-use-this-guide","title":"\ud83e\udde0 Who Should Use This Guide?","text":"<ul> <li>Cadet assignment modelers looking to experiment with AFSC match logic  </li> <li>Researchers interested in operations research applications in workforce planning  </li> <li>Developers wanting to understand or extend the <code>afccp</code> Python codebase</li> </ul>"},{"location":"user-guide/overview/#lets-get-started","title":"\ud83d\ude80 Let\u2019s Get Started","text":"<p>Continue to Tutorial 1 to launch your first AFCCP model and start exploring how it all fits together.</p> <p>Happy modeling!</p>"},{"location":"user-guide/tutorial_1/","title":"Tutorial 1: Introduction","text":"<p>In this first tutorial, we'll go through the basics of how <code>afccp</code> is structured alongside the <code>CadetCareerProblem</code> object. </p>"},{"location":"user-guide/tutorial_1/#1-setting-up-the-developmenttesting-environment","title":"1. Setting up the Development/Testing Environment","text":"<p>By now, you should have a working version of afccp on your computer. You've tested that the module works and will  perform as expected. If this is not the case, please follow the  Installation Guide to get the code working before following along in these  tutorials.</p> <p>In my afccp repo, I have an \"executables\" folder that contains all my various .py and .ipynb files that I use to build my code and test it. If you're just getting started with this project, or if you're just getting started with python in general, I'd recommend using jupyter notebooks. You can make a new jupyter notebook (.ipynb file) and follow along with the code I use throughout these tutorials. For instructions on how to get jupyter notebook working alongside the <code>afccp</code> virtual environment, you can follow the  Jupyter Installation Instructions.</p> <p>I HIGHLY recommend actually typing out the code and following along, rather than just reading this, as that will  get you familiar with the many variables used. Assuming you're using a .py script or jupyter notebook inside an  \"executables\" sub-folder in the root directory (which is already ignored by git), you'll first need to change the  working directory back to the root directory. You can use the following code to do so:</p> <pre><code># Obtain initial working directory\nimport os\ndir_path = os.getcwd() + '/'\nprint('initial working directory:', dir_path)\n\n# Get main afccp folder path\nindex = dir_path.find('afccp') \ndir_path = dir_path[:index + 6]\n\n# Update working directory\nos.chdir(dir_path)\nprint('updated working directory:', dir_path)\n</code></pre> <p>You should expect to see the following output, relative to your paths of course!:</p> <pre><code>initial working directory: /Users/griffenlaird/Coding Projects/afccp/executables/\nupdated working directory: /Users/griffenlaird/Coding Projects/afccp/\n</code></pre> <p>The working directory is now the root <code>afccp</code> folder. As mentioned in the  Project Structure section of the installation guide, there are several folders that are generated when importing <code>afccp</code> for the first time. The root directory is shown below, with the generated folders circled in yellow:</p> <p> </p>"},{"location":"user-guide/tutorial_1/#2-the-cadetcareerproblem-class","title":"2. The <code>CadetCareerProblem</code> class","text":"<p>You are now in a position to import the main <code>CadetCareerProblem</code> object. You can do so like this:</p> <pre><code>from afccp import CadetCareerProblem\n</code></pre> <p>I like to include some print statements just to show that the module is working properly. The code also checks some less popular packages that I use to see if you have them installed because  I still want this whole thing to work even if you don't have them. You should, however, if you've followed the Installation Guide:</p> <pre><code>Importing 'afccp' module...\nPyomo module found.\nSDV module found.\nSklearn Manifold module found.\nPython PPTX module found.\n</code></pre> <p>As mentioned previously, the first time you import CadetCareerProblem three folders will be created for  you: instances, support, and solvers. The \"instances\" folder will store all the data pertaining to the  instances of CadetCareerProblem that you'll be working with. The \"support\" folder will contain the files that  apply to all instances and are therefore shared. The \"solvers\" folder is meant to store pyomo executables which may  be useful depending on how you work with pyomo.</p> <p>If for some reason the code failed and gave you some error saying it doesn't recognize \"afccp\" as a module,  you probably need to add it to the path. You can do that like this:</p> <pre><code>import sys\nsys.path.append(dir_path)  # Add the working directory to the path (contains afccp)\n</code></pre> <p>Now that the CadetCareerProblem class is imported, it's time to talk about what it does. This is the main class object  that we'll be dealing with. It represents the class of all cadet-AFSC matching problems  (various cadet class years). Please note the two different meanings of the word \"class\"  in the previous sentence! Each \"instance\" of CadetCareerProblem is a distinct academic  class year (2019, 2020, 2021, etc.) with various cadet/AFSC parameters. </p> <p>Before we get into the data, let's talk about how the code is structured.  The class \"CadetCareerProblem\" lives in main.py:</p> <p> </p> <p>CadetCareerProblem calls all the other various functions across the \"afccp\" module that handle this problem.  I higly encourage you to at least read the <code>__init__</code> function code of <code>CadetCareerProblem</code> as that is what defines the data for a particular instance. The object then runs through several processes depending on what the analyst is trying to do. I've broken up these processes into four core categories: \"data\", \"solutions\", \"visualizations\", and \"research\".  The next several tutorials will discuss these four different concepts in much more detail.</p>"},{"location":"user-guide/tutorial_1/#summary","title":"\ud83d\udccc Summary","text":"<p>In this quickstart:</p> <ul> <li>We described the necessary steps to set up the development environment</li> <li>Introduced the <code>CadetCareerProblem</code> class and showed where it resides</li> </ul> <p>Continue on to Tutorial 2.</p>"},{"location":"user-guide/tutorial_2/","title":"Tutorial 2: Data Overview","text":"<p>In this second tutorial, we'll explain the contents of the <code>data</code> module within <code>afccp</code>, as well as how the data itself  is structured in the CadetCareerProblem object.</p>"},{"location":"user-guide/tutorial_2/#1-data-module","title":"1. Data Module","text":"<p>A <code>CadetCareerProblem</code> instance comes with a lot of data, and so the largest section of this tutorial is here to  talk about that data. I'll outline where the data is coming from (the various csvs), how the data is captured within  the <code>CadetCareerProblem</code> class, and where the code is that manages all of it. </p>"},{"location":"user-guide/tutorial_2/#afccpdata","title":"afccp.data","text":"<p>The \"data\" module of afccp contains the scripts and functions that all have something to do with processing the  many sets and parameters of the problem. At a high level the modules are set up like this:</p> <p> </p> <p>The \"adjustments.py\" script holds the functions that manipulate the parameters. There is also a function that sanity  checks many sets and subsets of parameters here which is extremely important in avoiding preventable errors.  For generating simulated data, \"generation.py\" contains those functions, and \"custom_ctgan_constraints.py\" contains some constraints for the CTGAN model used to generate realistic cadet data. Because I ended up making quite a  few functions that deal with cadet and AFSC preferences, I took those and put them into \"preferences.py\".  For importing and exporting data, as well as handling some file information, we have \"processing.py\".  There are a few functions designated to support CadetCareerProblem and its hyperparameters and whatnot,  so I put those into \"support.py\". Lastly, the value parameters, which I will discuss later, are all mostly handled by  \"values.py\".</p>"},{"location":"user-guide/tutorial_2/#hyperparameters-mdl_p","title":"Hyperparameters: <code>mdl_p</code>","text":"<p>One thing I do across all my .py scripts is import each afccp module directly so that you can see which modules are  dependent on each other. All the core scripts get imported directly into \"main\" since this serves as the hub for all  the functionality of afccp. In other scripts, the modules imported are only the ones that are required.  Another thing I do for context is include the entire module \"path\" in front of each function when I call it so that  you can see where the function is written. For example, if I wanted to call the function that defines all afccp model  hyperparameters (<code>mdl_p</code>), I can do so like this:</p> <pre><code># Import the \"data.support\" module (this would be at the top of the script)\nimport afccp.data.support\n\n# Call the specific function from that script (this example returns a dictionary of default \"hyper-parameters\")\nmdl_p = afccp.data.support.initialize_instance_functional_parameters(N=20)  # Requires the number of cadets\n\n# There is a lot of information in here used across afccp\nprint(mdl_p['figsize'])  # This is the default figure size for my matplotlib plots!\n</code></pre> <p>The output, the default figure size of the matplotlib charts:</p> <pre><code>(19, 10)\n</code></pre>"},{"location":"user-guide/tutorial_2/#generating-data","title":"\ud83c\udfb2 Generating Data","text":"<p>CadetCareerProblem allows for \"fake\" class years using simulated data generated through various means.  You may or may not have real class year data, but we can generate data to play around with here:</p> <pre><code># Create a randomly generated problem instance with 20 cadets and 4 AFSCs\ninstance = CadetCareerProblem('Random', N=20, M=4, P=4)\n</code></pre> \ud83d\udcbb Console Output <pre><code>Generating 'Random_1' instance...\nInstance 'Random_1' initialized.\n</code></pre> <p>That one line above initializes a new instance of the cadet\u2013AFSC matching problem (<code>CadetCareerProblem</code>). <code>N</code> is the number of cadets, <code>M</code> is the number of AFSCs, and <code>P</code> is the number of preferences the cadets are allowed to express. Originally, cadets could only express six preferences, but today they're able to provide complete preference lists. I recommend always setting <code>P = M</code> for full preference rankings.</p> <p>\ud83d\udca1 What is <code>data_name</code>?</p> <p>The first parameter in <code>CadetCareerProblem('Random', N=20, M=4, P=4)</code> is referred to as the data name. When generating data, you can simply pass <code>\"Random\"</code> and the system will automatically create the next instance (e.g., <code>\"Random_1\"</code>) based on what already exists in your <code>instances</code> folder.  </p> <p>Since we haven\u2019t generated or exported any data yet, this will create a new in-memory instance called <code>\"Random_1\"</code>. There will be no folder named <code>Random_1</code> yet \u2014 we delay that until you explicitly call <code>instance.export_data()</code> to avoid cluttering your working directory.</p> <p>The next code block prepares the generated data to be exported as CSVs so we can reference them in other examples. This block is only needed for generated data and is included here to give you a clean dataset to import and follow along with. You don\u2019t need to worry about this yet \u2014 just know that once it's exported, you can reload the same instance later.</p> <pre><code># Fix \"Random\" data (only meant for generated data!!)\ninstance.fix_generated_data()\n</code></pre> \ud83d\udcbb Console Output <pre><code>2 Making 4 cadets ineligible for 'R3' by altering their qualification to 'I2'. \n3 Making 4 cadets ineligible for 'R4' by altering their qualification to 'I2'. \nRemoving ineligible cadets based on any of the three eligibility sources (c_pref_matrix, a_pref_matrix, qual)...\nEdit 1: Cadet 0 not eligible for R2 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (0, 1) set to 0.\nEdit 2: Cadet 4 not eligible for R4 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (4, 3) set to 0.\nEdit 3: Cadet 5 not eligible for R2 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (5, 1) set to 0.\nEdit 4: Cadet 5 not eligible for R3 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (5, 2) set to 0.\nEdit 5: Cadet 6 not eligible for R2 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (6, 1) set to 0.\nEdit 6: Cadet 7 not eligible for R4 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (7, 3) set to 0.\nEdit 7: Cadet 8 not eligible for R4 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (8, 3) set to 0.\nEdit 8: Cadet 9 not eligible for R2 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (9, 1) set to 0.\nEdit 9: Cadet 10 not eligible for R2 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (10, 1) set to 0.\nEdit 10: Cadet 12 not eligible for R2 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (12, 1) set to 0.\nEdit 11: Cadet 12 not eligible for R4 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (12, 3) set to 0.\nEdit 12: Cadet 14 not eligible for R3 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (14, 2) set to 0.\nEdit 13: Cadet 15 not eligible for R2 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (15, 1) set to 0.\nEdit 14: Cadet 15 not eligible for R3 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (15, 2) set to 0.\nEdit 15: Cadet 18 not eligible for R2 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (18, 1) set to 0.\nEdit 16: Cadet 18 not eligible for R3 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (18, 2) set to 0.\nEdit 17: Cadet 19 not eligible for R2 based on degree qualification matrix but the AFSC was in the cadet preference list. c_pref_matrix position (19, 1) set to 0.\n17 total adjustments.\nUpdating cadet preference matrices from the preference dictionaries. ie. 1, 2, 4, 6, 7 -&gt; 1, 2, 3, 4, 5 (preference lists need to omit gaps)\nUpdating cadet first choice utility value to 100%...\nFixed 4 first choice cadet utility values to 100%.\nCadets: [6, 9, 14, 18]\nConverting AFSC preferences (a_pref_matrix) into percentiles (afsc_utility on AFSCs Utility.csv)...\nUpdating cadet columns (Cadets.csv...c_utilities, c_preferences) from the preference matrix (c_pref_matrix)...\nUpdating cadet utility matrices ('utility' and 'cadet_utility') from the 'c_utilities' matrix\nModifying rated eligibiity lists/matrices by SOC... \n(Removing cadets that are on the lists but not eligible for any rated AFSC)\nSanity checking the instance parameters...\nDone, 0 issues found.\n</code></pre> <p>There are certainly a lot of things that happen when we \"fix\" the generated data. I will describe these steps in more detail later, but for more information on what is happening please refer to the  fix_generated_data() method.  Now we can export the data!</p> <pre><code># Export everything\ninstance.export_data()\n</code></pre> \ud83d\udcbb Console Output <pre><code>Exporting datasets ['Cadets', 'AFSCs', 'Preferences', 'Goal Programming', 'Value Parameters', 'Solutions', 'Additional', 'Base Solutions', 'Course Solutions']\n</code></pre>"},{"location":"user-guide/tutorial_2/#instance-folder-structure","title":"Instance Folder Structure","text":"<p>Now that we've exported the data (after manipulating it a little), you should have a \"Random_1\" sub-folder within your  \"instances\" folder:</p> <p> </p> <p>You have data now located within the \"Random_1\" sub-folder. There are 5 instance sub-folders that get created:</p> <p> </p> <p>The first 3 all relate to the pre-processing \"phases\" that AFPC/DSYA goes through to get the data into the problem  instance format and are irrelevant for this tutorial. For a real class year of cadets/AFSCs, these 3 sub-folders will  be filled with real data in order to get it into sub-folder \"4. Model Input\". </p> <p>Since we've generated data, all of these parameters are located in this sub-folder:</p> <p> </p> <p>The files shown above, and which you should also have if you're following along, contain all the information stored in  the data dictionaries \"parameters\" and \"value_parameters\". In a moment I will discuss what that data looks like and how  it's stored in this dictionary structure. Lastly, let's re-import the \"Random_1\" problem instance:</p>"},{"location":"user-guide/tutorial_2/#importing-data","title":"Importing Data","text":"<p>To import data, it is very simple: specify the \"data_name\" of the instance you want to import.  Here, we will import \"Random_1\":</p> <pre><code># Import \"Random_1\" instance\ninstance = CadetCareerProblem('Random_1')\n</code></pre> \ud83d\udcbb Console Output <pre><code>Importing 'Random_1' instance...\nInstance 'Random_1' initialized.\n</code></pre> <p>At this point, we're ready to dive into the different data elements and structures used within  CadetCareerProblem. </p>"},{"location":"user-guide/tutorial_2/#summary","title":"\ud83d\udccc Summary","text":"<p>In this tutorial:</p> <ul> <li>We introduced the <code>data</code> module within <code>afccp</code>, which handles most of the parameter creation and manipulation logic.</li> <li>We broke down the purpose of each submodule in <code>afccp.data</code>:<ul> <li><code>adjustments.py</code>: for manipulating and validating parameters  </li> <li><code>generation.py</code>: for generating synthetic cadet/AFSC data  </li> <li><code>preferences.py</code>: for managing preference matrices  </li> <li><code>processing.py</code>: for importing/exporting data files  </li> <li><code>support.py</code>: for CadetCareerProblem support functions  </li> <li><code>values.py</code>: for creating and managing value parameters</li> </ul> </li> <li>We explained the role of <code>mdl_p</code>, the instance hyperparameter dictionary used across modules.</li> <li>We demonstrated how to generate synthetic data using <code>CadetCareerProblem('Random', N=20, M=4, P=4)</code>.</li> <li>We showed how to fix and export that generated data using <code>instance.fix_generated_data()</code> and <code>instance.export_data()</code>.</li> <li>We visualized how that data is stored within the \"instances\" folder.</li> <li>We described how to import a saved problem instance using <code>CadetCareerProblem('Random_1')</code>.</li> </ul> <p>You\u2019re now ready to explore the different data elements and structures in Tutorial 3!</p>"},{"location":"user-guide/tutorial_3/","title":"Tutorial 3: Parameters","text":"<p>In this third tutorial, we're going to focus on the structure and contents of the data represented by the <code>parameters</code> dictionary attribute of <code>CadetCareerProblem</code>.</p> <pre><code># Import \"Random_1\" instance\ninstance = CadetCareerProblem('Random_1')\n</code></pre> \ud83d\udcbb Console Output <pre><code>Importing 'Random_1' instance...\nInstance 'Random_1' initialized.\n</code></pre> <p>With this line, we now have a working problem instance. This \"instance\" object has many attributes and methods  defined that we can access. The \"parameters\" of the instance are represented by a dictionary, which is an attribute of  the instance object. Various parameters are loaded in as numpy arrays within that dictionary.  These are the \"fixed\" parameters, and contain different characteristics of this particular dataset.  I call them \"fixed\" parameters because these are the attributes of the problem that the analyst does not have much,  if any, control over (the characteristics of the cadets and AFSCs themselves).  Let's first discuss the two \"primary\" datasets: \"Cadets.csv\" and \"AFSCs.csv\". </p>"},{"location":"user-guide/tutorial_3/#1-cadets","title":"1. Cadets","text":"<p>\"Random_1 Cadets.csv\" defines the basic features of the cadets in this problem instance. It looks like this:</p> <p> </p> <p>We can gain quite a bit of information from this dataset. I will reiterate that data is represented in this module as  numpy arrays within certain dictionaries. I extract these arrays from excel using pandas as the dataframe vehicle. This data processing step occurs in the  import_cadets_data() function, which is called from within the <code>__init__</code> method of CadetCareerProblem. Let's go through some of these arrays.</p> <pre><code># Cadet identifier\nprint(\"'cadets':\", instance.parameters['cadets'])\n\n# Binary USAFA array\nprint(\"'usafa':\", instance.parameters['usafa'])\n\n# Source of Commissioning array\nprint(\"'soc':\", instance.parameters['soc'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>'cadets': [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]\n'usafa': [0 1 0 0 0 0 1 0 0 0 1 0 0 0 1 1 1 1 0 0]\n'soc': ['ROTC' 'USAFA' 'ROTC' 'ROTC' 'ROTC' 'ROTC' 'USAFA' 'ROTC' 'ROTC' 'ROTC'\n 'USAFA' 'ROTC' 'ROTC' 'ROTC' 'USAFA' 'USAFA' 'USAFA' 'USAFA' 'ROTC'\n 'ROTC']\n</code></pre> <p>You'll notice the <code>parameters</code> attribute of the <code>CadetCareerProblem</code> \"<code>instance</code>\" displayed above contains the data from this csv. I've found dictionaries are quite flexible because they can contain a wide array of information all in one place. They're also nice because the keys can be any string, allowing me to use superscripts \"^\" and distinguish those from underscores \"_\". Numpy arrays are also very efficient with their fancy indexing and native  matrix operations. All throughout <code>afccp</code>, my standard is to use dictionaries containing numpy arrays.</p> <p>There are two arrays containing order of merit percentile data. This is because this module used to simply be used  for the Non-Rated line. In the NRL process, we re-scaled OM so that it averaged to about 0.50 since the Rated and USSF  cadets were not in the mix. This creates two separate OM arrays: the re-sorted OM (merit) and the \"real\" OM where the  cadets ranked among their entire class (merit_all).</p> <pre><code>print(\"'Real' Merit:\", instance.parameters['merit_all'])\nprint(\"'NRL only' Merit:\", instance.parameters['merit'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>'Real' Merit: [0.14535269 0.172255   0.28836952 0.04235069 0.32556754 0.32864838 0.84872693 0.81705048 0.34875843 \n0.41546755 0.95458219 0.03060594 0.79954327 0.58113332 0.79412205 0.26121946 0.90382693 0.57759659 \n0.84630104 0.60683198]\n'NRL only' Merit: [0.14535269 0.172255   0.28836952 0.04235069 0.32556754 0.32864838\n0.84872693 0.81705048 0.34875843 0.41546755 0.95458219 0.03060594\n0.79954327 0.58113332 0.79412205 0.26121946 0.90382693 0.57759659\n0.84630104 0.60683198]\n</code></pre> <p>You won't see a difference above because this data was generated and I didn't really see a need to differentiate it.  Additionally, since AFPC/DSYA is now tasked with matching all cadets (not just NRL), there likely won't need to be a  designation in the future, so we may go back to just one \"Merit\" column.</p> <p>The \"Assigned\" column contains the AFSCs that may be fixed for certain cadets. Perhaps some cadets were rolled over  from the previous AFSC and had already been awarded an AFSC. In those cases, we want to count them within our  calculations but don't want to change their assigned AFSC. Again, since this is generated data, it does not play  much of a role.</p> <pre><code># Array of already awarded AFSCs for each of the cadets\ninstance.parameters['assigned']  # Empty array!\n</code></pre> \ud83d\udcbb Console Output <pre><code>array([nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan,\n       nan, nan, nan, nan, nan, nan, nan])\n</code></pre> <p>The \"Util_1\" -&gt; \"Util_4\" columns indicate the \"utilities\" that the cadets have placed on their first, second, third,  and fourth choice AFSCs. The \"Pref_1\" -&gt; \"Pref_4\" columns indicate the ordered list of AFSC choices the cadets provided.  Capturing the preference data in this manner (rows are cadets &amp; columns are the choices) is the way we've always  \"initially\" represented it. I will show later in the \"Preferences\" section that we can convert them into another useful  representation of the data where the rows are still cadets but the columns are the AFSCs themselves.  <pre><code># Utility cadet columns shown in numpy arrays\nprint('Cadet Utilities\\n', instance.parameters['c_utilities'])\n\n# Preference cadet columns shown in numpy arrays\nprint('\\nCadet Preferences\\n', instance.parameters['c_preferences'])\n</code></pre></p> \ud83d\udcbb Console Output <pre><code> Cadet Utilities\n [[1.   0.27 0.05 0.  ]\n [1.   0.42 0.4  0.  ]\n [1.   0.55 0.34 0.02]\n [1.   0.92 0.61 0.  ]\n [1.   0.21 0.   0.  ]\n [1.   0.86 0.44 0.15]\n [1.   0.76 0.03 0.  ]\n [1.   0.56 0.34 0.17]\n [1.   0.1  0.02 0.  ]\n [1.   0.06 0.04 0.  ]\n [1.   0.03 0.   0.  ]\n [1.   0.93 0.45 0.  ]\n [1.   0.54 0.49 0.4 ]\n [1.   0.36 0.   0.  ]\n [1.   0.95 0.36 0.  ]\n [1.   0.78 0.51 0.  ]\n [1.   0.25 0.21 0.15]\n [1.   0.96 0.94 0.79]\n [1.   0.7  0.62 0.17]\n [1.   0.57 0.08 0.02]]\n Cadet Preferences\n [['R1' 'R2' 'R4' '          ']\n ['R1' 'R2' 'R4' '          ']\n ['R2' 'R4' 'R3' 'R1']\n ['R3' 'R1' 'R2' '          ']\n ['R1' 'R4' '          ' '          ']\n ['R1' 'R4' 'R3' 'R2']\n ['R2' 'R1' 'R3' '          ']\n ['R1' 'R4' 'R3' 'R2']\n ['R1' 'R2' 'R4' '          ']\n ['R3' 'R4' 'R1' '          ']\n ['R4' 'R1' '          ' '          ']\n ['R1' 'R2' 'R4' '          ']\n ['R3' 'R1' 'R2' 'R4']\n ['R1' 'R3' '          ' '          ']\n ['R2' 'R1' 'R4' '          ']\n ['R3' 'R1' 'R2' '          ']\n ['R3' 'R4' 'R1' 'R2']\n ['R3' 'R1' 'R2' 'R4']\n ['R1' 'R4' 'R2' 'R3']\n ['R4' 'R3' 'R1' 'R2']]\n</code></pre> <p>The last section of data contains the degree qualifications! Qualifications for AFSCs are currently determined by the  Air Force Officer Classification Directory (AFOCD). Each AFSC provides a tiered list of degree groups  (tiers 1, 2, 3, etc.) as well as a requirement level for that degree tier (\"Mandatory\", \"Desired\", \"Permitted).  In some cases, the AFSC also has an implied \"Ineligible\" tier. M, D, P, and I are the letters representing the four  kinds of tiers shown in the qualification matrix below. The numbers correspond with the tier itself (1, 2, 3, ...).</p> <pre><code>instance.parameters['qual']\n</code></pre> \ud83d\udcbb Console Output <pre><code>array([['M1', 'P1', 'I2', 'P1'],\n   ['M1', 'P1', 'I2', 'P1'],\n   ['P2', 'P1', 'M1', 'P1'],\n   ['P2', 'P1', 'M1', 'I2'],\n   ['M1', 'I2', 'I2', 'P1'],\n   ['P2', 'P1', 'M1', 'P1'],\n   ['P2', 'P1', 'M1', 'I2'],\n   ['M1', 'P1', 'M1', 'P1'],\n   ['M1', 'P1', 'I2', 'P1'],\n   ['P2', 'I2', 'M1', 'P1'],\n   ['M1', 'I2', 'I2', 'P1'],\n   ['P2', 'P1', 'I2', 'P1'],\n   ['P2', 'P1', 'M1', 'P1'],\n   ['M1', 'I2', 'M1', 'I2'],\n   ['M1', 'P1', 'I2', 'P1'],\n   ['P2', 'P1', 'M1', 'I2'],\n   ['P2', 'P1', 'M1', 'P1'],\n   ['P2', 'P1', 'M1', 'P1'],\n   ['P2', 'P1', 'M1', 'P1'],\n   ['P2', 'P1', 'M1', 'P1']], dtype='&lt;U2')\n</code></pre>"},{"location":"user-guide/tutorial_3/#2-afscs","title":"2. AFSCs","text":"<p>Like cadets, AFSCs are also defined in a separate csv file (Random_1 AFSCs.csv) which looks like this:</p> <p> </p> <p>Here we have 4 AFSCs, and each has its own set of unique characteristics. In the same way as the cadets, this data is  extracted from the import_afscs_data() function.</p> <pre><code># Array of AFSC names\nprint(instance.parameters['afscs'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>['R1' 'R2' 'R3' 'R4' '*']\n</code></pre> <p>One thing to note is the extra AFSC \"*\". This represents the \"unmatched\" AFSC since we can have partial solutions  where not all cadets go matched (think Rated) or in certain algorithms we may simply leave cadets unmatched.  By allowing this extra AFSC at the end we can still evaluate these kinds of solutions. As a result, we do have  certain parameters where we add a column at the end for this unmatched AFSC. One example is the cadet utility matrix  below. For context, this matrix represents the same information captured in \"c_utilities\" only this time the columns  are sorted by AFSC order, not the preference order.</p> <pre><code># Utility matrix (cadet submitted)\nprint(instance.parameters['utility'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>[[1.   0.27 0.   0.05 0.  ]\n [1.   0.42 0.   0.4  0.  ]\n [0.02 1.   0.34 0.55 0.  ]\n [0.92 0.61 1.   0.   0.  ]\n [1.   0.   0.   0.21 0.  ]\n [1.   0.15 0.44 0.86 0.  ]\n [0.76 1.   0.03 0.   0.  ]\n [1.   0.17 0.34 0.56 0.  ]\n [1.   0.1  0.   0.02 0.  ]\n [0.04 0.   1.   0.06 0.  ]\n [0.03 0.   0.   1.   0.  ]\n [1.   0.93 0.   0.45 0.  ]\n [0.54 0.49 1.   0.4  0.  ]\n [1.   0.   0.36 0.   0.  ]\n [0.95 1.   0.   0.36 0.  ]\n [0.78 0.51 1.   0.   0.  ]\n [0.21 0.15 1.   0.25 0.  ]\n [0.96 0.94 1.   0.79 0.  ]\n [1.   0.62 0.17 0.7  0.  ]\n [0.08 0.02 0.57 1.   0.  ]]\n</code></pre> <p>Note the extra column of zeros at index 4. There are 4 AFSCs (0, 1, 2, 3) but we make an extra for the unmatched AFSC  (always at the end!).</p> <p>When we generate random data, and if we have at least 4 AFSCs, I make sure I generate at least one AFSC from each of  the three \"accessions groups\": Rated, USSF, NRL. You can track which AFSCs are in which group here:</p> <pre><code># \"Accessions Groups\", and their associated AFSCs, represented in this instance:\ninstance.parameters['afscs_acc_grp']\n</code></pre> \ud83d\udcbb Console Output <pre><code>{'Rated': array(['R2', 'R4'], dtype=object),\n 'USSF': array(['R1'], dtype=object),\n 'NRL': array(['R3'], dtype=object)}\n</code></pre> <pre><code># Indices of AFSCs in each accessions group\nfor grp in instance.parameters['afscs_acc_grp']:\n    param = \"J^\" + grp\n    print(param, instance.parameters[param])\n</code></pre> \ud83d\udcbb Console Output <pre><code>J^Rated [1 3]\nJ^USSF [0]\nJ^NRL [2]\n</code></pre> <p>The next 7 columns all refer to the quantities of cadets assigned to the AFSCs. The USAFA and ROTC \"targets\" are  taken from the Production Guidance Letter (PGL) produced by A1PT. These outline how many new lieutenants need to be  produced from both sources of commissioning.</p> <pre><code># Number of USAFA cadets needed for each AFSC\nprint('USAFA:', instance.parameters['usafa_quota'])\n\n# Number of ROTC cadets needed for each AFSC\nprint('ROTC', instance.parameters['rotc_quota'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>USAFA: [1. 1. 0. 0.]\nROTC [7. 4. 2. 2.]\n</code></pre> <p>These numbers are largely ignored since the real goal is meeting the combination of the two targets.  If we were strict on meeting these quotas for both sources of commissioning it would be very challenging and  result in a worse outcome for everyone. Therefore, the main PGL target we shoot for is aptly named \"PGL Target\".</p> <pre><code># Real quota of cadets needed for each AFSC\ninstance.parameters['pgl']\n</code></pre> \ud83d\udcbb Console Output <pre><code>array([8., 5., 2., 2.])\n</code></pre> <p>The \"Estimated\" and \"Desired\" numbers of cadets are both used purely in the Value-Focused Thinking (VFT) model.  The VFT model, as it stands, is non-linear and non-convex since there is a variable divided by another variable in the  objective function. For example, the \"average merit\" calculation for a particular AFSC \\(j\\) is: </p> \\[ \\frac{\\sum_{i \\in \\mathcal{I}} merit_i \\cdot x_{ij}}{\\sum_{i \\in \\mathcal{I}} x_{ij}} \\] <p>Because it is non-linear, I created an \"approximate\" model where I approximate the number of cadets using some  estimated number, hence, the \"Estimated\" parameter! The \"Desired\" parameter is fed into the quota value function  which I will discuss later on. </p> <pre><code># Estimated number of cadets for each AFSC (Used in objective function as denominator for certain objectives)\nprint(\"Estimated:\", instance.parameters['quota_e'])\n\n# Desired number of cadets for each AFSC (same as above because it's fake data)\nprint(\"Desired:\", instance.parameters['quota_d'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>Estimated: [8. 8. 3. 2.]\nDesired: [8. 8. 3. 2.]\n</code></pre> <p>Since the VFT model is no longer used by AFPC to match the cadets, there isn't much use in tuning these values, so they simply remain equal to the PGL target.</p> <p>Because the PGL target only provides one data point, I still need to have a range on the number of cadets that can be  assigned. This is where the minimum and maximum quantities are used (lower and upper bounds on the number of cadets to  be assigned). </p> <pre><code># Minimum number of cadets that can be assigned to each AFSC\nprint('Minimum:', instance.parameters['quota_min'])\n\n# Maximum number of cadets that can be assigned to each AFSC\nprint('Maximum:', instance.parameters['quota_max'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>Minimum: [8. 5. 2. 2.]\nMaximum: [9. 9. 3. 3.]\n</code></pre> <p>The \"Deg Tier\" columns contain the data on the target proportions of degrees from each tier requested for the AFSCs.  This information is gathered into the value parameters that will be discussed later on.</p> <pre><code>instance.parameters['Deg Tiers']\n</code></pre> \ud83d\udcbb Console Output <pre><code>array([['M &gt; 0.27', 'P &lt; 0.73', '', ''],\n       ['P = 1', 'I = 0', '', ''],\n       ['M = 1', 'I = 0', '', ''],\n       ['P = 1', 'I = 0', '', '']], dtype='&lt;U8')\n</code></pre>"},{"location":"user-guide/tutorial_3/#3-parameter-additions","title":"3. Parameter \"Additions\"","text":"<p>From this initial set of data, we can derive more parameters and sets to use in the various models. </p> <pre><code># Numbers of Cadets, AFSCs, and AFSC preferences\nfor param in ['N', 'M', 'P']:\n    print(param + ':', instance.parameters[param])\n</code></pre> \ud83d\udcbb Console Output <pre><code>N: 20\nM: 4\nP: 4\n</code></pre> <p>These additional sets, subsets, parameters, etc. are constructed as part of the  parameter_sets_additions() function in the <code>data.adjustments</code> module. This function is executed often, since any slight data modification could tweak the  underlying sets and parameters that are ultimately used by the models and algorithms.</p> <pre><code># Sets of cadets and AFSCs (indices)\nfor param in ['I', 'J']:\n    print(param, instance.parameters[param])\n</code></pre> \ud83d\udcbb Console Output <pre><code>I [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]\nJ [0 1 2 3]\n</code></pre> <p>My sets of cadets and AFSCs (\\(\\mathcal{I}\\) and \\(\\mathcal{J}\\)) are numpy arrays of indices since this allows for more  flexibility than just using AFSC/cadet names since we can access other arrays using those indices through the power of  numpy.</p> <pre><code># Set of cadets that are eligible for AFSC at index 2 (R3)\nprint('cadet indices', instance.parameters['I^E'][2])\n</code></pre> \ud83d\udcbb Console Output <pre><code>cadet indices [ 2  3  5  6  7  9 12 13 15 16 17 18 19]\n</code></pre> <pre><code># Set of AFSCs that the cadet at index 14 is eligible for\nprint('AFSC indices', instance.parameters['J^E'][14])\n</code></pre> \ud83d\udcbb Console Output <pre><code>AFSC indices [0 1 3]\n</code></pre> <pre><code># Names of the AFSCs that the cadet at index 14 is eligible for\nprint(\"AFSC Names:\", instance.parameters['afscs'][instance.parameters['J^E'][14]])\n</code></pre> \ud83d\udcbb Console Output <pre><code>AFSC Names: ['R1' 'R2' 'R4']\n</code></pre> <pre><code># USAFA cadets\nprint(\"USAFA cadets\", instance.parameters['usafa_cadets'])\n\n# ROTC cadets\nprint(\"ROTC cadets\", instance.parameters['rotc_cadets'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>USAFA cadets [ 1  6 10 14 15 16 17]\nROTC cadets [ 0  2  3  4  5  7  8  9 11 12 13 18 19]\n</code></pre> <p>I have a dictionary \\(I^D\\) which contains the cadets with certain demographics that are also eligible for the various  AFSCs. Many of these sets and subets are also discussed in my thesis. <pre><code># The keys to the \"I^D\" dictionary are the objectives for the AFSCs that deal with demographics of the cadets\nprint(instance.parameters['I^D'].keys())\n</code></pre></p> \ud83d\udcbb Console Output <pre><code>dict_keys(['USAFA Proportion', 'Mandatory', 'Desired', 'Permitted', 'Tier 1', 'Tier 2', 'Tier 3', 'Tier 4'])\n</code></pre> <p>The objectives above are a subset of the possible AFSC objectives \\(\\mathcal{K}\\) and are used with the value parameters  that I will discuss in a later section!</p> <pre><code># Cadets with Tier 2 degrees that are eligible for the AFSC at index 3 (R4)\nprint(\"Cadets:\", instance.parameters['I^D']['Tier 2'][3])\n</code></pre> \ud83d\udcbb Console Output <pre><code>Cadets: [ 3  6 13 15]\n</code></pre> <pre><code># USAFA Cadets with Tier 2 degrees that are eligible for the AFSC at index 3 (R4)\nusafa_cadets_with_tier_2_degrees_afsc_r4 = \\\n    np.intersect1d(instance.parameters['I^D']['Tier 2'][3], instance.parameters['usafa_cadets'])\nprint(\"Intersection:\", usafa_cadets_with_tier_2_degrees_afsc_r4)\n</code></pre> \ud83d\udcbb Console Output <pre><code>Intersection: [ 6 15]\n</code></pre> <pre><code># The OM of those cadets\nprint('Merit', instance.parameters['merit'][usafa_cadets_with_tier_2_degrees_afsc_r4])\n</code></pre> \ud83d\udcbb Console Output <pre><code>Merit [0.84872693 0.26121946]\n</code></pre>"},{"location":"user-guide/tutorial_3/#4-preferences","title":"4. Preferences","text":"<p>Cadet preferences, as well as AFSC preferences now, are provided as numpy arrays of shape (NxM) with an extra column  for cadet preferences for the unmatched AFSC (like the utility matrix shown earlier). Let's discuss cadet preferences  first. There are multiple csv files containing information on cadet and AFSC preferences. </p>"},{"location":"user-guide/tutorial_3/#cadet-preferences","title":"Cadet Preferences","text":"<p>For cadets, there is the <code>utility</code> matrix I depicted earlier which is contained in  \"Random_1 Cadets Utility.csv\":</p> <p> </p> <p>As you can see, the data is the same as was printed from \"instance.parameters['utility']\" earlier  (near the start of the AFSCs section), with the exception of the extra column for the unmatched AFSC, \"*\".  If I want to access Cadet 5's utility for the AFSC at index 2 (R3), I can do so like this:</p> <pre><code>instance.parameters['utility'][5, 2]\n</code></pre> \ud83d\udcbb Console Output <pre><code>0.44\n</code></pre> <p>Remember, python index starts at 0! This \"utility\" matrix is meant to represent the cadet's reported utility for the  AFSC they receive. Here's a little history on this real problem:</p> <p>Up until FY24, cadets were allowed to express 6 preferences for NRL AFSCs and assign utility values to each.  This was the extent of their input to the process, and the optimization model just used those utility values.  Ties are allowed and are regularly provided by cadets by expressing multiple 100% utilities for their top however  many choices. Often 0s were also expressed signaling the cadets lack of desire for a given AFSC (even within their top 6). </p> <p>For the FY24 class, cadets rank ordered all 47 AFSCs (I know- yikes!) and were allowed to express utility values on  their top 10 choices (same rules as before). For FY25, FY26, and beyond, cadets must place a minimum of 10 preferences  (NRL/Rated/USSF combined) but may rank as many past 10 as they desire. They then also provide utility values on their top 10 preferences, just as before. This essentially creates two separate matrices: <code>c_pref_matrix</code> and  <code>utility</code>. \"Random_1 Cadets Preferences.csv\" contains the preference matrix (<code>c_pref_matrix</code>):</p> <p> </p> <p>The \"Cadets Utility\" and \"Cadets Preferences\" files are both extracted into their numpy array counterparts,  <code>utility</code> and <code>c_pref_matrix</code>, respectively, within the  import_afsc_cadet_matrices_data()  function. In fact, the remainder of data elements discussed in Tutorial 3 are processed by this function since they all follow the 2 dimensional cadet-AFSC row-column relationship.</p> <pre><code>instance.parameters['c_pref_matrix']\n</code></pre> \ud83d\udcbb Console Output <pre><code>array([[1, 2, 0, 3],\n       [1, 2, 0, 3],\n       [4, 1, 3, 2],\n       [2, 3, 1, 0],\n       [1, 0, 0, 2],\n       [1, 4, 3, 2],\n       [2, 1, 3, 0],\n       [1, 4, 3, 2],\n       [1, 2, 0, 3],\n       [3, 0, 1, 2],\n       [2, 0, 0, 1],\n       [1, 2, 0, 3],\n       [2, 3, 1, 4],\n       [1, 0, 2, 0],\n       [2, 1, 0, 3],\n       [2, 3, 1, 0],\n       [3, 4, 1, 2],\n       [2, 3, 1, 4],\n       [1, 3, 4, 2],\n       [3, 4, 2, 1]])\n</code></pre> <p>NOTE: this matrix takes on the same format as before where the rows are the cadets and the columns are the AFSCs  (NOT the \"choice\" of the cadets; the matrix cell values are the rank that the cadet put on that AFSC column).  Cadet 2, for example, ranks AFSC \"R2\" first followed by \"R4\" then \"R3\" then \"R1\".  The \"0\"s represent an AFSC that is not on a cadet's preference list. I will touch on the concept of \"eligibility\" later,  but this effectively means that this cadet cannot be matched to this particular AFSC. Once we have the \"c_pref_matrix\",  we can then convert it to an ordered list of AFSCs for each cadet. I have that piece as a dictionary where the keys are  the cadets and the values are lists of AFSC indices in order of the cadet's ranking of them:</p> <pre><code>instance.parameters['cadet_preferences']\n</code></pre> \ud83d\udcbb Console Output <pre><code>{0: array([0, 1, 3]),\n 1: array([0, 1, 3]),\n 2: array([1, 3, 2, 0]),\n 3: array([2, 0, 1]),\n 4: array([0, 3]),\n 5: array([0, 3, 2, 1]),\n 6: array([1, 0, 2]),\n 7: array([0, 3, 2, 1]),\n 8: array([0, 1, 3]),\n 9: array([2, 3, 0]),\n 10: array([3, 0]),\n 11: array([0, 1, 3]),\n 12: array([2, 0, 1, 3]),\n 13: array([0, 2]),\n 14: array([1, 0, 3]),\n 15: array([2, 0, 1]),\n 16: array([2, 3, 0, 1]),\n 17: array([2, 0, 1, 3]),\n 18: array([0, 3, 1, 2]),\n 19: array([3, 2, 0, 1])}\n</code></pre> <p>Cadet 0's preferences in order with AFSC names:</p> <pre><code>cadet_0_afsc_indices = instance.parameters['cadet_preferences'][0]\n\n# Ordered list of AFSC names for cadet 0\ninstance.parameters['afscs'][cadet_0_afsc_indices]\n</code></pre> \ud83d\udcbb Console Output <pre><code>array(['R1', 'R2', 'R4'], dtype=object)\n</code></pre> <p>We have the ordinal preferences that the cadets provide and we have the utility values they provide. These are two  different pieces of information that we must aggregate together to form one \"final\" cadet utility matrix. For this  random dataset, and for the FY24 class, we convert the ordinal rankings (1, 2, 3, 4, 5) to a continuous 1 -&gt; 0 scale  (1, 0.8, 0.6, 0.4, 0.2). We then average these converted rankings and the provided utility values to get the final  cadet utility matrix, <code>cadet_utility</code>, which is located in \"Random_1 Cadets Utility (Final).csv\". This occurs in the  create_new_cadet_utility_matrix()  function. For FY25, FY26, and beyond, we utilize additional information on the cadet's bottom choices and on the  AFSCs they did not select in their preferences to construct the <code>cadet_utility</code> matrix. The math behind this operation is located in the  create_final_cadet_utility_matrix_from_new_formula()  function. </p> <pre><code>instance.parameters['cadet_utility']\n</code></pre> \ud83d\udcbb Console Output <pre><code>array([[1.    , 0.4683, 0.    , 0.1917],\n       [1.    , 0.5433, 0.    , 0.3667],\n       [0.135 , 1.    , 0.42  , 0.65  ],\n       [0.7933, 0.4717, 1.    , 0.    ],\n       [1.    , 0.    , 0.    , 0.355 ],\n       [1.    , 0.2   , 0.47  , 0.805 ],\n       [0.7133, 1.    , 0.1817, 0.    ],\n       [1.    , 0.21  , 0.42  , 0.655 ],\n       [1.    , 0.3833, 0.    , 0.1767],\n       [0.1867, 0.    , 1.    , 0.3633],\n       [0.265 , 0.    , 0.    , 1.    ],\n       [1.    , 0.7983, 0.    , 0.3917],\n       [0.645 , 0.495 , 1.    , 0.325 ],\n       [1.    , 0.    , 0.43  , 0.    ],\n       [0.8083, 1.    , 0.    , 0.3467],\n       [0.7233, 0.4217, 1.    , 0.    ],\n       [0.355 , 0.2   , 1.    , 0.5   ],\n       [0.855 , 0.72  , 1.    , 0.52  ],\n       [1.    , 0.56  , 0.21  , 0.725 ],\n       [0.29  , 0.135 , 0.66  , 1.    ]])\n</code></pre> <p>Just as a reminder, here is the initial utility matrix (note the extra column for AFSC \"*\"):</p> <pre><code>instance.parameters['utility']\n</code></pre> \ud83d\udcbb Console Output <pre><code>array([[1.  , 0.27, 0.  , 0.05, 0.  ],\n       [1.  , 0.42, 0.  , 0.4 , 0.  ],\n       [0.02, 1.  , 0.34, 0.55, 0.  ],\n       [0.92, 0.61, 1.  , 0.  , 0.  ],\n       [1.  , 0.  , 0.  , 0.21, 0.  ],\n       [1.  , 0.15, 0.44, 0.86, 0.  ],\n       [0.76, 1.  , 0.03, 0.  , 0.  ],\n       [1.  , 0.17, 0.34, 0.56, 0.  ],\n       [1.  , 0.1 , 0.  , 0.02, 0.  ],\n       [0.04, 0.  , 1.  , 0.06, 0.  ],\n       [0.03, 0.  , 0.  , 1.  , 0.  ],\n       [1.  , 0.93, 0.  , 0.45, 0.  ],\n       [0.54, 0.49, 1.  , 0.4 , 0.  ],\n       [1.  , 0.  , 0.36, 0.  , 0.  ],\n       [0.95, 1.  , 0.  , 0.36, 0.  ],\n       [0.78, 0.51, 1.  , 0.  , 0.  ],\n       [0.21, 0.15, 1.  , 0.25, 0.  ],\n       [0.96, 0.94, 1.  , 0.79, 0.  ],\n       [1.  , 0.62, 0.17, 0.7 , 0.  ],\n       [0.08, 0.02, 0.57, 1.  , 0.  ]])\n</code></pre> <p>One last data element for the cadets that is used on the real data, but not the random data, is the \"Cadets Selected\"  csv which is loaded in as <code>c_selected_matrix</code>. This is a binary matrix indicating if cadet \\(i\\) selected AFSC \\(j\\) as a  preference on the survey. This was added for FY25, but is not currently generated as part of the random data generator.</p>"},{"location":"user-guide/tutorial_3/#afsc-preferences","title":"AFSC Preferences","text":"<p>As of FY24, AFSCs have preferences on cadets too now! For the Non-Rated Line AFSCs, we actually met with all the Career  Field Managers (CFMs) to discuss what was important to them in their officers.  They provided their input and \"1-N\" lists were created for each of their respective AFSCs.  For Rated, each Source of Commissioning (SOC) acted as the CFM and their specific order of merit (OM) lists were used as  the 1-Ns. I will touch on the Rated OM data momentarily. The Space Force did a similar thing for their AFSCs.  This is all captured in the \"Random_1 AFSCs Preferences.csv\" file in a very similar manner as the \"Cadets Preferences\"  version. Now, each column contains an AFSC's ranking for each cadet in <code>a_pref_matrix</code>:</p> <pre><code>instance.parameters['a_pref_matrix']\n</code></pre> \ud83d\udcbb Console Output <pre><code>array([[ 6, 16,  0, 16],\n       [ 9, 13,  0, 12],\n       [20,  6, 13, 10],\n       [17, 12, 11,  0],\n       [10,  0,  0, 11],\n       [13, 14, 12,  9],\n       [ 7,  2,  9,  0],\n       [ 1,  8,  5,  4],\n       [12, 15,  0, 15],\n       [19,  0,  4, 13],\n       [ 4,  0,  0,  1],\n       [16,  9,  0, 14],\n       [11,  5,  2,  6],\n       [ 3,  0, 10,  0],\n       [ 2,  1,  0,  8],\n       [15, 10,  7,  0],\n       [14,  7,  1,  7],\n       [ 8,  4,  3,  5],\n       [ 5,  3,  8,  2],\n       [18, 11,  6,  3]])\n</code></pre> <p>Again, 0s represent cadets that are not on the AFSC's list. </p> <p>In the exact same manner I mentioned previously with converting cadet ordinal rankings (1, 2, 3, 4, 5) to a continuous  scale (1, 0.8, 0.6, 0.4, 0.2), we do that with AFSCs to get the <code>afsc_utility</code> matrix located in \"Random_1 AFSCs Utility.csv\":</p> <pre><code>instance.parameters['afsc_utility']\n</code></pre> \ud83d\udcbb Console Output <pre><code>array([[0.75  , 0.0625, 0.    , 0.0625],\n       [0.6   , 0.25  , 0.    , 0.3125],\n       [0.05  , 0.6875, 0.0769, 0.4375],\n       [0.2   , 0.3125, 0.2308, 0.    ],\n       [0.55  , 0.    , 0.    , 0.375 ],\n       [0.4   , 0.1875, 0.1538, 0.5   ],\n       [0.7   , 0.9375, 0.3846, 0.    ],\n       [1.    , 0.5625, 0.6923, 0.8125],\n       [0.45  , 0.125 , 0.    , 0.125 ],\n       [0.1   , 0.    , 0.7692, 0.25  ],\n       [0.85  , 0.    , 0.    , 1.    ],\n       [0.25  , 0.5   , 0.    , 0.1875],\n       [0.5   , 0.75  , 0.9231, 0.6875],\n       [0.9   , 0.    , 0.3077, 0.    ],\n       [0.95  , 1.    , 0.    , 0.5625],\n       [0.3   , 0.4375, 0.5385, 0.    ],\n       [0.35  , 0.625 , 1.    , 0.625 ],\n       [0.65  , 0.8125, 0.8462, 0.75  ],\n       [0.8   , 0.875 , 0.4615, 0.9375],\n       [0.15  , 0.375 , 0.6154, 0.875 ]])\n</code></pre> <p>Also in the same manner as cadets, we have a separate dictionary of ordered cadets for each AFSC:</p> <pre><code>instance.parameters['afsc_preferences']\n</code></pre> \ud83d\udcbb Console Output <pre><code>{0: array([ 7, 14, 13, 10, 18,  0,  6, 17,  1,  4, 12,  8,  5, 16, 15, 11,  3, 19,  9,  2]),\n 1: array([14,  6, 18, 17, 12,  2, 16,  7, 11, 15, 19,  3,  1,  5,  8,  0]),\n 2: array([16, 12, 17,  9,  7, 19, 15, 18,  6, 13,  3,  5,  2]),\n 3: array([10, 18, 19,  7, 17, 12, 16, 14,  5,  2,  4,  1,  9, 11,  8,  0])}\n</code></pre> <p>In the above, the AFSC at index 0 (R1) has cadet 7 ranked #1 (first) and cadet 0 ranked #6.</p> <p>Just to confirm that these lists are the \"sorted indices\" of \"a_pref_matrix\", you can look at both the utilities and  rankings of the cadets using \"afsc_preferences\" as the indices to sort on. We'll use AFSC 'R2' as an example:</p> <pre><code>j = 1  # Index of \"R2\"\nsorted_indices = instance.parameters['afsc_preferences'][j]\nprint('Ordered cadets:', sorted_indices)\nprint('Rankings on these cadets:', instance.parameters['a_pref_matrix'][sorted_indices, j])\nprint('Utilities on these cadets:', instance.parameters['afsc_utility'][sorted_indices, j])\n</code></pre> \ud83d\udcbb Console Output <pre><code>Ordered cadets: [14  6 18 17 12  2 16  7 11 15 19  3  1  5  8  0]\nRankings on these cadets: [ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16]\nUtilities on these cadets: [1.     0.9375 0.875  0.8125 0.75   0.6875 0.625  0.5625 0.5    0.4375   0.375  0.3125 0.25   0.1875 0.125  0.0625]\n</code></pre> <p>There you have it as far as cadet and AFSC preferences go! I will soon discuss why eligibility is important as it  directly relates to who is or is not on each of the lists. First, let's discuss the rated OM situation.</p>"},{"location":"user-guide/tutorial_3/#rated-om","title":"Rated OM","text":"<p>Currently, each SOC provides their own rated OM lists that we need to combine. The lists for ROTC and USAFA are located  in \"Random_1 ROTC Rated OM.csv\" and \"Random_1 USAFA Rated OM.csv\", respectively. They are loaded into <code>rr_om_matrix</code> and  <code>ur_om_matrix</code>, respectively, as well:</p> ROTC Rated OM (Left) &amp; USAFA Rated OM (Right) <p> </p> <p>One of the reasons I like using cadet indices as identifiers (rather than some other ID or name) is for this example  right here. I can extract the indices of the rated cadets from both SOCs directly from these matrices:</p> <pre><code>instance.parameters['Rated Cadets']\n</code></pre> \ud83d\udcbb Console Output <pre><code>{'usafa': array([ 1,  6, 10, 14, 15, 16, 17]),\n 'rotc': array([ 0,  2,  3,  4,  5,  7,  8,  9, 11, 12, 18, 19])}\n</code></pre> <p>Once I have that, I can look at whatever other features I want to see from these cadets. For example:</p> <pre><code># General Order of Merit\nindices = instance.parameters['Rated Cadets']['usafa']\nprint('GOM:', instance.parameters['merit'][indices])\n\n# Preference of the rated USAFA cadets for the rated AFSC 'R4'\nprint('Cadet preference on R4:', instance.parameters['c_pref_matrix'][indices, 3])\n</code></pre> \ud83d\udcbb Console Output <pre><code>GOM: [0.172255   0.84872693 0.95458219 0.79412205 0.26121946 0.90382693 0.57759659]\nCadet preference on R4: [3 0 1 3 0 2 4]\n</code></pre> <p>Since both of these lists for <code>R4</code> are relative to each SOC, we can combine them like we do with general OM.  We convert to \"percentiles\" relative to the SOCs and then zipper them together. I have a method that does this:  construct_rated_preferences_from_om_by_soc().  It takes these two matrices and then zippers them together where the final product is an updated <code>a_pref_matrix</code> and  <code>afsc_preferences</code>. Let's demonstrate the \"zippering\":</p> <pre><code>j = 3 # R4\n\n# Alternating USAFA/ROTC cadets based on proportions of both SOCs in R4's list\nsorted_indices = instance.parameters['afsc_preferences'][j]\nprint('Binary USAFA array:', instance.parameters['usafa'][sorted_indices])\nprint('Ordered Cadet List:', sorted_indices)\n</code></pre> \ud83d\udcbb Console Output <pre><code>Binary USAFA array: [1 0 0 0 1 0 1 1 0 0 0 1 0 0 0 0]\nOrdered Cadet List: [10 18 19  7 17 12 16 14  5  2  4  1  9 11  8  0]\n</code></pre>"},{"location":"user-guide/tutorial_3/#5-eligibilityqualifications","title":"5. Eligibility/Qualifications","text":"<p>One thing I've alluded to in several areas before is the concept of eligibility. Certain cadet/AFSC pairings cannot  happen. Rated eligibility is determined by medical qualifications and volunteerism. Space Force eligibility is  determined by degree qualifications and volunteerism (for FY24, but now it is SOC-based as well).  NRL AFSC eligibility is a combination of degree qualifications and the new CFM rankings via the AFSC preferences.  The intent for them was to open the door to more people potentially being eligible for certain career fields based on  factors beyond academic degrees.</p> <p>The degree <code>qual</code> matrix outlines the tier of degree that each cadet has, but it also signals which cadets are  eligible or not for each of the AFSCs. For rated, everyone is a \"P\" unless you're ineligible  (see below for \"R2\" &amp; \"R4\"):</p> <pre><code># Degree Qualification matrix (AFOCD)\nprint(instance.parameters['qual'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>[['M1' 'P1' 'I2' 'P1']\n ['M1' 'P1' 'I2' 'P1']\n ['P2' 'P1' 'M1' 'P1']\n ['P2' 'P1' 'M1' 'I2']\n ['M1' 'I2' 'I2' 'P1']\n ['P2' 'P1' 'M1' 'P1']\n ['P2' 'P1' 'M1' 'I2']\n ['M1' 'P1' 'M1' 'P1']\n ['M1' 'P1' 'I2' 'P1']\n ['P2' 'I2' 'M1' 'P1']\n ['M1' 'I2' 'I2' 'P1']\n ['P2' 'P1' 'I2' 'P1']\n ['P2' 'P1' 'M1' 'P1']\n ['M1' 'I2' 'M1' 'I2']\n ['M1' 'P1' 'I2' 'P1']\n ['P2' 'P1' 'M1' 'I2']\n ['P2' 'P1' 'M1' 'P1']\n ['P2' 'P1' 'M1' 'P1']\n ['P2' 'P1' 'M1' 'P1']\n ['P2' 'P1' 'M1' 'P1']]\n</code></pre> <pre><code># Embedded eligibility matrix\nprint(instance.parameters['eligible'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>[[1 1 0 1]\n [1 1 0 1]\n [1 1 1 1]\n [1 1 1 0]\n [1 0 0 1]\n [1 1 1 1]\n [1 1 1 0]\n [1 1 1 1]\n [1 1 0 1]\n [1 0 1 1]\n [1 0 0 1]\n [1 1 0 1]\n [1 1 1 1]\n [1 0 1 0]\n [1 1 0 1]\n [1 1 1 0]\n [1 1 1 1]\n [1 1 1 1]\n [1 1 1 1]\n [1 1 1 1]]\n</code></pre> <p>In the age of wanting to try matching algorithms, preferences on both sides (cadets and AFSCs) must agree.  This means that if you're on one AFSC's preference list, that AFSC must be on your preference list too.  Essentially, this creates three separate eligibility sources (cadet preferences, afsc preferences, and the qual matrix).  All three of these need to match up. This is why I have one method of CadetCareerProblem that \"ensures\" this is true:  instance.remove_ineligible_choices(). This is a fairly aggressive approach since all it does is check if you're ineligible according to one source,  and if you are, it removes you from all other sources to force ineligibility. If you're doing this for real data,  make sure you know what you're doing! Here's the code I have in the  instance.fix_generated_data()  method when I remove these choices to show what you need to do afterwards to get the data looking right:</p> <pre><code># Removes ineligible cadets from all 3 matrices: degree qualifications, cadet preferences, AFSC preferences\ninstance.remove_ineligible_choices()\n\n# Take the preferences dictionaries and update the matrices from them (using cadet/AFSC indices)\ninstance.update_preference_matrices()  # 1, 2, 4, 6, 7 -&gt; 1, 2, 3, 4, 5 (preference lists need to omit gaps)\n\n# Convert AFSC preferences to percentiles (0 to 1)\ninstance.convert_afsc_preferences_to_percentiles()  # 1, 2, 3, 4, 5 -&gt; 1, 0.8, 0.6, 0.4, 0.2\n\n# The \"cadet columns\" are located in Cadets.csv and contain the utilities/preferences in order of preference\ninstance.update_cadet_columns_from_matrices()  # We haven't touched \"c_preferences\" and \"c_utilities\" until now\n</code></pre> \ud83d\udcbb Console Output <pre><code>Removing ineligible cadets based on any of the three eligibility sources (c_pref_matrix, a_pref_matrix, qual)...\n0 total adjustments.\nUpdating cadet preference matrices from the preference dictionaries. ie. 1, 2, 4, 6, 7 -&gt; 1, 2, 3, 4, 5 (preference lists need to omit gaps)\nConverting AFSC preferences (a_pref_matrix) into percentiles (afsc_utility on AFSCs Utility.csv)...\nUpdating cadet columns (Cadets.csv...c_utilities, c_preferences) from the preference matrix (c_pref_matrix)...\n</code></pre> <p>No changes are made because I've already done this earlier!</p>"},{"location":"user-guide/tutorial_3/#6-note-on-parameters","title":"6. Note on Parameters","text":"<p>To drive home the idea that my \"parameters\" dictionary is an attribute of the problem instance I've been writing  \"instance.parameters\" up until this point. In most of my functions within <code>afccp</code>, however, I convert  \"instance.parameters\" to \"p\" for sake of typing less which I highly encourage you to do when writing your own functions.</p> <pre><code># Shorthand example\np = instance.parameters\np['afscs']\n</code></pre> \ud83d\udcbb Console Output <pre><code>array(['R1', 'R2', 'R3', 'R4', '*'], dtype=object)\n</code></pre> <p>There are plenty of other parameters attached to this dictionary that you can explore.</p>"},{"location":"user-guide/tutorial_3/#parameters-details","title":"Parameters Details","text":"<ul> <li> <p><code>Qual Type</code> (<code>str</code>):</p> <p>The qualification tiering rule set in use (e.g., \"Tiers\", \"Legacy\", \"Binary\").</p> </li> <li> <p><code>afscs</code> (<code>np.ndarray[M+1]</code>):</p> <p>Array of AFSCs (Air Force Specialty Codes) used in the model. Extra AFSC is unmatched \"*\".</p> </li> <li> <p><code>acc_grp</code> (<code>np.ndarray[M]</code>):</p> <p>Mapping of AFSCs to their accession groups.</p> </li> <li> <p><code>usafa_quota</code>, <code>rotc_quota</code> (<code>np.ndarray[M]</code>):</p> <p>Number of available positions for USAFA and ROTC cadets, respectively.</p> </li> <li> <p><code>pgl</code> (<code>np.ndarray[M]</code>):   Production Guidance Letter (PGL) targets for each AFSC.</p> </li> <li> <p><code>quota_e</code>, <code>quota_d</code>, <code>quota_min</code>, <code>quota_max</code> (<code>np.ndarray[M]</code>):   AFSC-specific quota constraints (estimated, desired, min, max values).</p> </li> <li> <p><code>M</code> (<code>int</code>):   Total number of AFSCs (Does NOT include unmatched AFSC \"*\").</p> </li> <li> <p><code>Deg Tiers</code> (<code>np.ndarray[M, 4]</code>):   Array representing degree tier categories and constraints for each AFSC and tier (tiers 1 -&gt; 4)</p> </li> <li> <p><code>cadets</code> (<code>np.ndarray[N]</code>):   Array of cadet indices</p> </li> <li> <p><code>assigned</code> (<code>np.ndarray[N]</code>):   Sparse array containing data for cadets that are fixed to certain AFSCs.</p> </li> <li> <p><code>usafa</code>, <code>rotc</code> (<code>np.ndarray[N]</code>):   Binary vectors indicating if cadets are from the respective SOC or not.</p> </li> <li> <p><code>soc</code> (<code>np.ndarray[N]</code>):   Source of Commissioning (str) for each cadet (e.g., USAFA, ROTC, OTS).</p> </li> <li> <p><code>merit</code>, <code>merit_all</code> (<code>np.ndarray[N]</code>):   Cadet order of merit percentiles.</p> </li> <li> <p><code>N</code> (<code>int</code>):   Number of cadets.</p> </li> <li> <p><code>eligible</code>, <code>ineligible</code> (<code>np.ndarray[N, M]</code>):   Boolean arrays indicating cadet eligibility (&amp; ineligibility) for AFSCs.</p> </li> <li> <p><code>tier 1</code>, <code>tier 2</code>, <code>tier 3</code>, <code>tier 4</code> (<code>np.ndarray[N, M]</code>):   Tiered qualification matrices (binary) by AFSC.</p> </li> <li> <p><code>mandatory</code>, <code>desired</code>, <code>permitted</code>, <code>exception</code> (<code>np.ndarray[N, M]</code>):   AFSC qualification matrices categorized by tier level (e.g., \"M\", \"D\", \"P\", \"E\").</p> </li> <li> <p><code>t_count</code> (<code>np.ndarray[M]</code>):   Total number of tiers contained in each AFSC</p> </li> <li> <p><code>t_proportion</code> (<code>np.ndarray[M, 4]</code>):   Proportion of cadets desired by each tier.</p> </li> <li> <p><code>t_leq</code>, <code>t_geq</code>, <code>t_eq</code> (<code>np.ndarray[M, 4]</code>):   Boolean or integer matrices indicating if the tier is a <code>\u2264</code>, <code>\u2265</code>, or <code>=</code> constraint.</p> </li> <li> <p><code>t_mandatory</code>, <code>t_desired</code>, <code>t_permitted</code> (<code>np.ndarray</code>):   Boolean or integer matrices indicating if the tier is a \"M\", \"D\", or \"P\" constraint.</p> </li> <li> <p><code>qual</code> (<code>np.ndarray[N, M]</code>):   Final qualification tier matrix by cadet and AFSC (e.g., \u201cM1\u201d, \u201cD2\u201d).</p> </li> <li> <p><code>P</code> (<code>int</code>):</p> <p>Max number of cadet preferences they were allowed to provide. This is not a very useful parameter to be honest as  this is a legacy model idea. </p> </li> <li> <p><code>num_util</code> (<code>int</code>):   Max number of utilities the cadets were allowed to provide. This is 10 in the real problem.</p> </li> <li> <p><code>c_preferences</code> (<code>np.ndarray[N, P]</code>):</p> <p>Cadet preferences in easy-to-read column form. Each row corresponds to a given cadet's ordered preferences of the  AFSCs (and it contains the AFSC names, not indices). This is what is found in the \"Cadets.csv\".</p> </li> <li> <p><code>c_utilities</code> (<code>np.ndarray[N, num_util]</code>):</p> <p>Cadet utilities in easy-to-read column form. Each row corresponds to a given cadet's ordered utilities of the  AFSCs. This is what is found in the \"Cadets.csv\".</p> </li> <li> <p><code>SOCs</code> (<code>list[str]</code>):   Unique SOC categories used in the problem, i.e., <code>['usafa', 'rotc', 'ots']</code>. Or, historically, <code>['usafa', 'rotc']</code>.</p> </li> <li> <p><code>utility</code>, <code>cadet_utility</code> (<code>np.ndarray[N, M]</code>):</p> <p>Cadet utility matrices. <code>utility</code> is the directly cadet-provided matrix and <code>cadet_utility</code> is the calculated matrix  used in the optimization models.</p> </li> <li> <p><code>c_pref_matrix</code>, <code>a_pref_matrix</code> (<code>np.ndarray[N, M]</code>):   Cadet and AFSC preference matrices. Each row is the preference on the specific cadet-AFSC pair, either from the  cadet's perspective (<code>c_pref_matrix</code>) or from the AFSC's perspective (<code>a_pref_matrix</code>).</p> </li> <li> <p><code>afsc_utility</code> (<code>np.ndarray[N, M]</code>):   AFSC utility matrix. This is the preference matrix converted to linearized percentiles.</p> </li> <li> <p><code>usafa_cadets</code>, <code>rotc_cadets</code> (<code>np.ndarray</code>):   Arrays of cadet indices filtered by commissioning source. If there are 4 cadets total <code>[0, 1, 2, 3]</code> and cadet '1' is from USAFA and the other three are ROTC, then <code>usafa_cadets</code> would be <code>[1]</code> and <code>rotc_cadets</code> would be <code>[0, 2, 3]</code>.</p> </li> <li> <p><code>rr_interest_matrix</code> (<code>np.ndarray</code>):   Legacy ROTC rated \"interest\" matrix. They used to collect preferences on the Form 53 from ROTC cadets for rated  AFSCs by asking them if they had \"high\", \"medium\", or \"low\" interest in each of the four AFSCs. This was a suboptimal process for a multitude of reasons, and I used this to show them the benefit of switching to the \"One Market\" idea. This variable is no longer in use.</p> </li> <li> <p><code>rr_om_matrix</code>, <code>ur_om_matrix</code> (<code>np.ndarray</code>):   Rated order of merit (OM) matrices for both ROTC and USAFA. This data contains all the rankings for each rated AFSC for the rated cadets (cadets qualified for at least one rated AFSC). This is the data in the \" Rated OM.csv\" files. <li> <p><code>rr_om_cadets</code>, <code>ur_om_cadets</code> (<code>np.ndarray</code>):   Cadet indices of ROTC and USAFA rated eligible cadets. These are the cadets that correspond to the OM matrices.</p> </li> <li> <p><code>I</code> (<code>np.ndarray[N]</code>):   Array/set of all cadets <code>[0, 1, ..., N - 1]</code></p> </li> <li> <p><code>J</code> (<code>np.ndarray[M]</code>):   Array/set of all AFSCs <code>[0, 1, ..., M - 1]</code></p> </li> <li> <p><code>J^E</code>, <code>I^E</code>, <code>I^Choice</code>, <code>I^D</code>, <code>I^P</code>, <code>I^USAFA</code>, <code>I^ROTC</code> (<code>dict[int, np.ndarray]</code>):   Sets/subsets of cadets or AFSCs based on eligibility, choice, demographics, or commissioning source.</p> </li> <li> <p><code>num_eligible</code> (<code>np.ndarray[M]</code>):   Number of cadets eligible for each AFSC</p> </li> <li> <p><code>Choice Count</code> (<code>dict[int, np.ndarray]</code>):   Number of cadets who have each AFSC as their first (0) choice, second (1) choice, etc. Keys are the choice, values are arrays of how many people have each AFSC at that choice.</p> </li> <li> <p><code>usafa_proportion</code> (<code>float</code>):   Proportion of USAFA cadets relative to all other cadets (ROTC, maybe OTS).</p> </li> <li> <p><code>Deg Tier Values</code> (<code>dict[str, int]</code>):   Numerical mapping of tier labels to ordinal values (e.g., \u201cM1\u201d: 1).</p> </li> <li> <p><code>sum_merit</code> (<code>float</code>):   Aggregate merit score used in optimization or normalization.</p> </li> <li> <p><code>usafa_eligible_count</code>, <code>rotc_eligible_count</code> (<code>int</code>):   Count of eligible cadets by commissioning source.</p> </li> <li> <p><code>J^Fixed</code>, <code>J^Reserved</code>, <code>J^Rated</code>, <code>J^USSF</code>, <code>J^NRL</code>, <code>J^USAF</code>, <code>J^P</code> (<code>np.ndarray</code>):   Specialized AFSC subsets (fixed, reserved, rated, USSF, non-rated, USAF, priority).</p> </li> <li> <p><code>Rated Cadets</code>, <code>Rated Cadet Index Dict</code> (<code>np.ndarray</code>, <code>dict</code>):   List and mapping of rated cadets for tracking assignment requirements.</p> </li> <li> <p><code>Rated Choices</code>, <code>Num Rated Choices</code> (<code>np.ndarray</code>, <code>int</code>):   Matrix and count of rated AFSC preferences submitted by cadets.</p> </li> <li> <p><code>w^G</code> (<code>float</code>):   Overall weight on <code>GUO</code> model relative to CASTLE (0 to 1).</p> </li> <li> <p><code>N^Match</code> (<code>int</code>):   Total number of cadets to match in the optimization model.</p> </li>"},{"location":"user-guide/tutorial_3/#summary","title":"\ud83d\udccc Summary","text":"<p>This tutorial demonstrates how to initialize and prepare a full <code>CadetCareerProblem</code> instance using raw input data.  We walk through each major import function, illustrating how to load cadets, AFSCs, quotas, preferences, and utility  matrices from CSV files and transform them into structured parameter dictionaries.</p> <p>Key steps include:</p> <ul> <li>Loading cadet and AFSC data within the <code>import_cadets_data()</code> and <code>import_afscs_data()</code> as part of the <code>CadetCareerProblem</code> initialization.</li> <li>Importing compatibility and preference matrices between cadets and AFSCs via <code>import_afsc_cadet_matrices_data()</code>.</li> <li>Generating cadet utility matrices, using tier, merit, and preference information to construct a personalized utility score for each cadet-AFSC pair.</li> <li>Finalizing model inputs for downstream evaluation or optimization by integrating all components into a unified parameter dictionary.</li> </ul> <p>You\u2019re now ready to explore how the <code>value_parameters</code> work in Tutorial 4!</p>"},{"location":"user-guide/tutorial_4/","title":"Tutorial 4: Value Parameters","text":"<p>In this fourth tutorial, we're going to dive into the <code>value_parameters</code> dictionary attribute of <code>CadetCareerProblem</code>.</p> <p>The value parameters contain all the data on the weights, values, and constraints that the analyst controls on the  problem. The more data we have on what everyone cares about the more we know what to look for. Even though we no longer  use the Value-Focused Thinking (VFT) model as the official model to classify cadets to their AFSCs, we still want to  make sure we capture the needs and desires of the decision makers. Additionally, there are still many constraints that  can be toggled by the analyst. These are all captured in the <code>value_parameters</code> attribute!</p>"},{"location":"user-guide/tutorial_4/#defaults","title":"Defaults","text":"<p>The first thing I want to talk about here is the \"default value parameters\". I have a method in CadetCareerProblem to  generate value parameters which is made exclusively for simulated data. Since that is the instance we are working with,  we have already done that (it happens in  <code>instance.fix_generated_data()</code>).  This set of value parameters exists in our <code>vp_dict</code> but we haven't actually activated it yet.  My code works with the idea that you could have different sets of things you care about, and when you solve the model  with one set of value parameters you could solve it again with a different set. Let's see what this looks like:</p> <pre><code># List of sets of value parameters\nprint(instance.vp_dict.keys())\n\n# Current \"activated\" value parameters (we haven't told CadetCareerProblem to activate any yet!)\nprint('VP dictionary:', instance.value_parameters, 'VP Name:', instance.vp_name)\n</code></pre> \ud83d\udcbb Console Output <pre><code>dict_keys(['VP'])\nVP dictionary: None VP Name: None\n</code></pre> <p>We need to activate this set of value parameters, which we can do like this:</p> <pre><code>instance.set_value_parameters()  # Defaults to grabbing the first set in the list\nprint('VP Name:', instance.vp_name)\n</code></pre> \ud83d\udcbb Console Output <pre><code>VP Name: VP\n</code></pre> <p>One of the things we can do is export the current set of value parameters as \"defaults\" back to excel.  That is what I do here:</p> <pre><code>instance.export_value_parameters_as_defaults()\n</code></pre> \ud83d\udcbb Console Output <pre><code>Exporting value parameters as defaults to excel...\n</code></pre> <p>This set of value parameters now exists in it's \"default\" form in your afccp/support/value parameters defaults/  folder! I add a \"New\" to the end of the name purely as a way to ensure you don't unintentionally overwrite your  previous set of default value parameters:</p> <p> </p> <p>Simply go in and manually change the name to \"Value_Parameters_Defaults_Random_1.xlsx\" (again, the \"New\" thing is  because I don't want you to accidentally overwrite the real one if applicable!). Once you've done that, we can import  this set of value parameters as \"defaults\" rather than generating random ones like we did at the beginning for this  simulated dataset! </p> <pre><code>v = instance.import_default_value_parameters()  # I add the \"v = \" because there's a lot of output otherwise\n</code></pre> \ud83d\udcbb Console Output <pre><code>Importing default value parameters...\nImported.\n</code></pre> <p>There are two reasons I'm having you import the value parameters as defaults above: to show you how can initialize  a set of value parameters for an instance from excel (rather than generating random ones), and also to show that I  have a nifty function that checks if a new set of value parameters is really \"new\". What I mean by that is if you  acquire a new set of value parameters by importing defaults, ideally it should only be added as a new one if it  really is a unique set of parameters. You already had a set of value parameters \"VP\", and now you've just imported a  new one so you should have \"VP2\". However, you'll still only see \"VP\" in your list because the two were identical:</p> <pre><code># Only one set of value parameters found for this instance\ninstance.vp_dict.keys()\n</code></pre> \ud83d\udcbb Console Output <pre><code>dict_keys(['VP'])\n</code></pre> <p>Now that we have our value parameters imported, I want to take a moment to describe the various components.  I'm going to do this by using the \"Value_Parameters_Defaults\" excel file as a reference. Remember, these are the  \"defaults\" that get imported for a particular problem instance that then turn into the actual set of value parameters  used. To describe these value parameters, I will show the various dataframes inside the \"Value_Parameters_Defaults\" excel file structure. This default excel workbook was created when I ran the <code>instance.import_default_value_parameters()</code> method. After changing the name to remove the \"_New\" extension, I have the file:  \"support/value parameters defaults/Value_Parameters_Defaults_Random_1.xlsx\".</p>"},{"location":"user-guide/tutorial_4/#overall-value-parameters","title":"\"Overall\" value parameters","text":"<p>The first dataframe I'll show contains the information for the \"big toggles\" on the value parameters:</p> <p> </p> <p>Once initialized for the \"Random_1\" problem instance, these highest level settings are stored in  \"Random_1 Value Parameters.csv\" in the \"Model Input\" folder. This dataframe controls the overall settings  for each set of value parameters. It's also what tells <code>afccp</code> the names of the different sets of value parameters  as well. Right now, we only have one set (\"VP\").</p> <pre><code># Shorthand\np = instance.parameters\nvp = instance.value_parameters\n\nprint(\"Current value parameter set name:\", instance.vp_name)\n\n# Overall weights on Cadets/AFSCs\nprint('\\nCadets Overall Weight:', vp['cadets_overall_weight'])\nprint('AFSCs Overall Weight:', vp['afscs_overall_weight'])\n\n# If we want to constrain the overall values on Cadets/AFSCs (we won't, but it's here)\nprint('\\nCadets Overall Minimum Value:', vp['cadets_overall_value_min'])\nprint('AFSCs Overall Minimum Value:', vp['afscs_overall_value_min'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>Current value parameter set name: VP\n\nCadets Overall Weight: 0.5153395820213456\nAFSCs Overall Weight: 0.4846604179786544\n\nCadets Overall Minimum Value: 0\nAFSCs Overall Minimum Value: 0\n</code></pre> <p>For the \"individual\" weight on each cadet relative to all other cadets (and vice versa for AFSCs), we use weight  functions. For cadets, their weights are based on their order of merit. In my random set of data, the cadet weight  function initialized is \"Curve_1\". (Yours may differ!)</p> <pre><code># Cadet weight function\nvp['cadet_weight_function']\n</code></pre> \ud83d\udcbb Console Output <pre><code>'Curve_1'\n</code></pre> <p>Here, cadet weight is a \"sigmoid\" function of their order of merit. Again, yours likely will not be! I can  illustrate the weight function by plotting cadet weight versus their OM:</p> <pre><code>chart = instance.display_weight_function({\"square_figsize\": (8, 8), \"dpi\": 80})\n</code></pre> <p> </p> <p>Now, the percentiles for a real class will be uniformly distributed between 0 and 1. This is a fake class of 20 cadets  and so they were randomly selected between 0 and 1 which is why the graph looks a little weird. The y-axis shows the  \"swing weights\" for the cadets. Swing weights simply mean that they've been scaled so the biggest value is 1 and all  other weights are relative to that one. \"Local\" weights, by contrast, sum to 1 collectively. I've printed out the  differences below and you can see how I calculate them:</p> <pre><code>print(\"Merit\", np.around(p['merit'], 3))\nprint(\"\\n'Local' Weight\", np.around(vp['cadet_weight'], 3), \"Local Weight Sum:\", np.around(np.sum(vp['cadet_weight']), 3))\nprint(\"\\n'Swing' (Scaled) Weight\", np.around(vp['cadet_weight'] / np.max(vp['cadet_weight']), 3))\n</code></pre> \ud83d\udcbb Console Output <pre><code>Merit [0.145 0.172 0.288 0.042 0.326 0.329 0.849 0.817 0.349 0.415 0.955 0.031 0.8   0.581 0.794 0.261 0.904 0.578 0.846 0.607]\n\n'Local' Weight [0.026 0.027 0.03  0.026 0.033 0.033 0.074 0.073 0.034 0.04  0.075 0.026 0.073 0.06  0.073 0.029 0.074 0.059 0.074 0.062] Local Weight Sum: 1.0\n\n'Swing' (Scaled) Weight [0.354 0.36  0.408 0.343 0.436 0.438 0.987 0.98  0.457 0.537 1.    0.342 0.975 0.801 0.973 0.392 0.995 0.795 0.987 0.835]\n</code></pre> <p>We can also change the weight function through afccp if we want to.</p> <pre><code># Linear function of OM (not very \"forgiving\" to low OM cadets)\ninstance.change_weight_function(cadets=True, function=\"Direct\")\nchart = instance.display_weight_function({\"square_figsize\": (8, 8), \"dpi\": 80})\n</code></pre> <p> </p> <pre><code># Cadets are equal no matter what their OM is\ninstance.change_weight_function(cadets=True, function=\"Equal\")\nchart = instance.display_weight_function({\"square_figsize\": (8, 8), \"dpi\": 80})\n</code></pre> <p> </p> <pre><code># Exponential curve (not recommended since it puts heavy emphasis on top performers)\ninstance.change_weight_function(cadets=True, function=\"Exponential\")\nchart = instance.display_weight_function({\"square_figsize\": (8, 8), \"dpi\": 80})\n</code></pre> <p> </p> <pre><code># Sigmoid curve of OM (more forgiving in terms of differences between highest and lowest rank)\ninstance.change_weight_function(cadets=True, function=\"Curve_1\")\nchart = instance.display_weight_function({\"square_figsize\": (8, 8), \"dpi\": 80})\n</code></pre> <p> </p> <p>These curves are what I'd use since the top cadet is a little more than twice as \"important\" as the lowest cadet.  On the other linear/exponential curves, the difference is quite drastic (100% to 0%).</p> <pre><code># Sigmoid curve of OM (very similar to previous one)\ninstance.change_weight_function(cadets=True, function=\"Curve_2\")\nchart = instance.display_weight_function({\"square_figsize\": (8, 8), \"dpi\": 80})\n</code></pre> <p> </p> <pre><code># Change back to \"Curve_1\" weight function\ninstance.change_weight_function(cadets=True, function=\"Curve_1\")\ninstance.value_parameters['cadet_weight_function']\n</code></pre> \ud83d\udcbb Console Output <pre><code>'Curve_1'\n</code></pre> <p>AFSC weights may be determined as a function of their size. Ideally, in the future it'd be some function of their size,  difficulty to fill, manpower needs, and maybe more. I want a better method for determining those weights on the AFSCs.</p> <pre><code># In my generated data, AFSCs are weighted equally\nvp['afsc_weight_function']\n</code></pre> \ud83d\udcbb Console Output <pre><code>'Equal'\n</code></pre> <p>Here is the AFSC weight chart. The AFSC weight chart is a bar chart since we can show relative importance pretty well  with those kinds of charts.</p> <pre><code>chart = instance.display_weight_function(\n    {\"dpi\": 80, \"cadets_graph\": False, \"skip_afscs\": False})\n</code></pre> <p> </p> <pre><code># Weight based purely on size\ninstance.change_weight_function(cadets=False, function=\"Size\")\nchart = instance.display_weight_function({\"dpi\": 80, \"cadets_graph\": False, \"skip_afscs\": False})\n</code></pre> <p> </p> <pre><code># Slightly different function of size (function from generated data)\ninstance.change_weight_function(cadets=False, function=\"Curve_1\")\nchart = instance.display_weight_function({\"dpi\": 80, \"cadets_graph\": False, \"skip_afscs\": False})\n</code></pre> <p> </p> <pre><code># Another function of size\ninstance.change_weight_function(cadets=False, function=\"Curve_2\")\nchart = instance.display_weight_function({\"dpi\": 80, \"cadets_graph\": False, \"skip_afscs\": False})\n</code></pre> <p> </p> <pre><code># Change back to \"Equal\" weight function\ninstance.change_weight_function(cadets=False, function=\"Equal\")\ninstance.value_parameters['afsc_weight_function']\n</code></pre> \ud83d\udcbb Console Output <pre><code>'Equal'\n</code></pre> <p>If we pass the function \"Custom\" for AFSC weights, we will pull from the predefined weights in the \"AFSC Weights\"  excel sheet.</p> <p> </p> <p>Right now they are from the \"Equal\" function. If we want to constrain the AFSC values, we can do that using the  \"AFSC Min Value\" column.</p> <pre><code>print(\"AFSC 'local' weight:\", vp['afsc_weight'])  # Sum to 1!\nprint(\"AFSC minimum values:\", vp['afsc_value_min'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>AFSC 'local' weight: [0.25 0.25 0.25 0.25]\nAFSC minimum values: [0. 0. 0. 0.]\n</code></pre> <p>I'm going to show the \"overall weights\" dataset again for reference since there are a lot of charts above and I don't  want you to have to keep scrolling up!</p> <p> </p>"},{"location":"user-guide/tutorial_4/#model-controls-mdl_p-side-bar","title":"Model Controls (\"mdl_p\" side-bar)","text":"<p>I've mentioned the attribute \"mdl_p\" earlier on in this tutorial but haven't gone too much into detail on it.  Essentially, this is my dictionary of all the various toggles and components used across afccp.  Everything from genetic algorithm hyperparameters to the colors of various components of the visualizations.  There's a lot there. I've actually been using them for the charts above everytime I pass in a dictionary as a parameter  for the method I'm calling. If you recall the  <code>instance.display_weight_function()</code>  method was taking a dictionary including things like <code>{\"dpi\": 80, \"cadets_graph\": False, \"skip_afscs\": False}</code>.  These control specific components used in some place within afccp. In that context, they're controls used in the weight  function chart.</p> <pre><code># DPI (Dots per inch) of my charts\ninstance.mdl_p['dpi']\n</code></pre> \ud83d\udcbb Console Output <pre><code>80\n</code></pre> <p>I alluded to this towards the beginning of the tutorial, but essentially within <code>afccp.core.data.support</code> there is a  function called  initialize_instance_functional_parameters() that initializes the many \"hyperparameters\" of afccp. \"Hyperparameters\" traditionally refer to the parameters  that control the learning process of some algorithms and are probably not the best term to use for this since that's  really only applicable to the genetic algorithm. \"Controls\" is probably a better word, since I've generalized this  dictionary to control for a lot of different elements. When I say a lot, I mean it!</p> <pre><code># Number of keys in the \"mdl_p\" dictionary\nprint(\"Number of afccp 'controls':\", len(instance.mdl_p.keys()))\n</code></pre> \ud83d\udcbb Console Output <pre><code>Number of afccp 'controls': 246\n</code></pre> <p>If you scroll through \"main.py\" and look at the keyword arguments used you'll notice \"p_dict={}\" is quite common.  What this does is allow you to change the default settings that are initialized for mdl_p. Using \"mdl_p\" as I do  allows me to come up with a needed \"control\" for some function buried deep within afccp and not worry about passing it  through the many layers of functions to get to where it needs to be. The instance object contains mdl_p as an attribute  and so we just define it in the parameter initialization function of support.py and bam- we have it wherever we need it.  It's also now something I can have a default setting for and potentially change using \"p_dict\". Here's an example:</p> <pre><code># Default bar color- HEX codes are useful ways of selecting precise colors\nprint('Default bar color:', instance.mdl_p['bar_color'])  # (google \"color picker\")\n</code></pre> \ud83d\udcbb Console Output <pre><code>Default bar color: #3287cd\n</code></pre> <p>The color above is the light-ish shade of blue you've seen for the charts above.  Let's produce the AFSC chart again after changing the 'bar_color' parameter.</p> <pre><code># Slightly different function of size\nchart = instance.display_weight_function({\"dpi\": 80, \"cadets_graph\": False, \"skip_afscs\": False, \n                                          'bar_color': \"#08d152\"})  # Shade of green\n</code></pre> <p> </p> <p>As a reminder, in order to make use of <code>p_dict</code> as a means of passing a new value for one of the controls inside \"mdl_p\",  you simply call the desired method and pass a dictionary ie. {\"bar_color\": \"blue\"} containing the keys that you want to  change as the only argument. </p>"},{"location":"user-guide/tutorial_4/#afsc-objectives","title":"AFSC Objectives","text":"<p>Before I dive deep into the components of the AFSC objectives, it's probably worthwhile to talk about what the  objectives themselves are. Here they are printed out for you:</p> <pre><code>vp['objectives']\n</code></pre> \ud83d\udcbb Console Output <pre><code>array(['Norm Score', 'Merit', 'USAFA Proportion', 'Combined Quota',\n   'USAFA Quota', 'ROTC Quota', 'Utility', 'Mandatory', 'Desired',\n   'Permitted', 'Tier 1', 'Tier 2', 'Tier 3', 'Tier 4'], dtype='&lt;U16')\n</code></pre> <p>The \"Norm Score\" objective refers to the newly defined career field preference lists. Basically, career fields get to  rank cadets in order of preference similar to how the cadets rank their AFSC choices. To evaluate how well we meet the  needs of the AFSC according to their preferences, I came up with a normalized score idea. Imagine you have a set of ten  cadets, ranked 1 to 10. If you are picking 3 cadets from that list, the best cadets you could select are the ones  ranked 1, 2, 3. The worst are the cadets ranked 8, 9, 10. The former is a score of 1 and the latter is a score of 0.  Whatever you ultimately pick is likely going to be somewhere in between, which is where the norm score comes in.  Here is that example:</p> <pre><code>import random\n\n# Cadet rankings\nnum_cadets = 10  # 10 cadets in the above example\nrankings = np.arange(num_cadets) + 1\nprint('Rankings:', rankings)\n\n# Picking \"n\" cadets\nn = 3  # picking 3 for this example\n\n# Selecting n cadets\nprint('\\nBest Cadets:', rankings[:n])\n\n# \"Score\" is the sum of these numbers\nbest_score = np.sum(rankings[:n])\nprint('Best Cadets Score:', best_score)\n\n# Selecting n cadets\nprint('\\nWorst Cadets:', rankings[num_cadets-n:])\n\n# \"Score\" is the sum of these numbers\nworst_score = np.sum(rankings[num_cadets-n:])\nprint('Worst Cadets Score:', worst_score)\n\n# Pick a random set of n cadets\nselected_cadets = random.sample(list(rankings), n)\nprint('\\nRandomly selected cadets:', selected_cadets)\n\nselected_score = np.sum(selected_cadets)\nprint('Random cadets score:', selected_score)\n\n# \"Norm Score\" normalizes that \"selected_score\" on a 1 to 0 scale using the best/worst scores\nnorm_score = 1 - (selected_score - best_score) / (worst_score - best_score)\nprint('\\nNorm Score:', round(norm_score, 4))\n\n# Everything described above is what is used in afccp\nfrom afccp.solutions.handling import calculate_afsc_norm_score_general\n\n# This function takes the rankings and selected rankings as arguments\nnorm_score_2 = calculate_afsc_norm_score_general(rankings, selected_cadets)  \nprint('Norm Score (from afccp):', round(norm_score_2, 4))\n</code></pre> \ud83d\udcbb Console Output <pre><code>Rankings: [ 1  2  3  4  5  6  7  8  9 10]\n\nBest Cadets: [1 2 3]\nBest Cadets Score: 6\n\nWorst Cadets: [ 8  9 10]\nWorst Cadets Score: 27\n\nRandomly selected cadets: [10, 4, 8]\nRandom cadets score: 22\n\nNorm Score: 0.2381\nNorm Score (from afccp): 0.2381\n</code></pre> <p>The \"Merit\" objective is one that was used to fairly distribute \"quality\" cadets across the AFSCs.  The idea is that no single \"large\" AFSC should be composed of entirely high or low performers.  I've never liked this objective because it puts too much emphasis on defining quality for a career field purely on  graduating order of merit. I believe that the career field preferences provide a much better way of defining quality  cadets that is specific to each career field. It is no longer a zero-sum game, and it is theoretically possible  (though highly improbable) that the rankings given could perfectly line up with the needs of the Air Force such that  every single AFSC receives their top performers. Again, this won't ever happen, but we are now deviating from order of  merit as the one-size-fits-all metric of quality.</p> <pre><code># Average order of merit of the class\nprint('Average OM:', np.mean(p['merit'])) # Should be about 0.5 for a real class (random data will not)\n\n# Proportion of USAFA cadets of the class\nprint('USAFA Proportion:', np.mean(p['usafa'])) # Closer to 1/3 for a real class\n</code></pre> \ud83d\udcbb Console Output <pre><code>Average OM: 0.5044154990687344\nUSAFA Proportion: 0.35\n</code></pre> <p>In a very similar way that we want to keep average OM around 0.5 (or whatever the actual average is) for each of the  large AFSCs, we also don't want any single large AFSC to be composed of entirely USAFA or ROTC cadets.  We take the actual proportion of the cadets as the baseline and then shoot to be within +- 15% of that number.  That is another AFSC objective that may or may not actually be that important. The idea now is that it should be left  up to the career field manager to determine.</p> <pre><code># USAFA quota (for each AFSC)\nprint('USAFA Quota:', p['usafa_quota'])\n\n# ROTC quota (for each AFSC)\nprint('ROTC Quota:', p['rotc_quota'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>USAFA Quota: [1. 1. 0. 0.]\nROTC Quota: [7. 4. 2. 2.]\n</code></pre> <p>If you recall the USAFA/ROTC quotas from earlier on, these numbers are fed into their appropriate objectives.  Meeting the individual USAFA and ROTC quotas are two objectives that are separate from the USAFA proportion objective.  They're doing similar things, but one is trying to balance the proportion of cadets assigned to be around some  baseline while the others are simply trying to meet a quota and that's it. These objectives really only come into play  now with the rated AFSCs since we need to keep the slots specific to each source of commissioning.</p> <pre><code># The \"desired\" number of cadets for a given AFSC\nprint('PGL Target (Combined SOC quotas):', p['pgl'])\nprint('\\nDesired number:', p['quota_d'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>PGL Target (Combined SOC quotas): [8. 5. 2. 2.]\n\nDesired number: [8. 8. 3. 2.]\n</code></pre> <p>The quota objective that we absolutely do care about is the \"Combined Quota\" objective which is used right now to meet  the PGL. It currently provides the minimum number of cadets to classify and so as long as we meet each of the minimums  then we are good! In the future, there's a lot more we should do with this objective to really hone in on the  importance of assigning more or fewer cadets to a given AFSC (cross-collaboration with AFMAA/A1XD in the works).</p> <pre><code># The AFOCD Tier objectives (from the \"AFSCs.csv\" I showed earlier)\np['Deg Tiers']\n</code></pre> \ud83d\udcbb Console Output <pre><code>array([['M &gt; 0.27', 'P &lt; 0.73', '', ''],\n       ['P = 1', 'I = 0', '', ''],\n       ['M = 1', 'I = 0', '', ''],\n       ['P = 1', 'I = 0', '', '']], dtype='&lt;U8')\n</code></pre> <p>There are generally up to four Air Force Officer Classification Directory (AFOCD) degree tiers per career field.  Each degree tier has a target proportion and requirement level associated with it: Mandatory, Desired, or Permitted  (M, D, P). Above, the columns correspond to degree tiers (1, 2, 3, 4) and the rows are the AFSCs. It just so  happens that in this example we have 4 AFSCs and so it's worth clarifying! The format above provides a few pieces  of information: the requirement level, target proportion, and the type of inequality specified (&gt;, &lt;, or =).  So, for a degree tier format of \"D &gt; 0.54\", we know the requirement is \"Desired\" and the AFSC wants at LEAST 54% of  their accessions to have degrees in that tier. If you recall, the information on what tier everyone is placed in  for each AFSC based on their degree is located in the \"qual\" matrix. There is a function in <code>afccp.core.support</code> called <code>cip_to_qual_tiers()</code> that creates the <code>qual</code> matrix based on the cadets' degrees. This is an important function for the AFPC/DSYA analyst  to maintain, and is irrelevant for random data since it's all fake anyway!</p> <pre><code># Qual matrix! This conveys requirement level (M, D, P), tier (1, 2, 3, 4) and even eligibility (\"I\" is ineligible)\np['qual']  # Rows are cadets, columns are AFSCs!\n</code></pre> \ud83d\udcbb Console Output <pre><code>array([['M1', 'P1', 'I2', 'P1'],\n       ['M1', 'P1', 'I2', 'P1'],\n       ['P2', 'P1', 'M1', 'P1'],\n       ['P2', 'P1', 'M1', 'I2'],\n       ['M1', 'I2', 'I2', 'P1'],\n       ['P2', 'P1', 'M1', 'P1'],\n       ['P2', 'P1', 'M1', 'I2'],\n       ['M1', 'P1', 'M1', 'P1'],\n       ['M1', 'P1', 'I2', 'P1'],\n       ['P2', 'I2', 'M1', 'P1'],\n       ['M1', 'I2', 'I2', 'P1'],\n       ['P2', 'P1', 'I2', 'P1'],\n       ['P2', 'P1', 'M1', 'P1'],\n       ['M1', 'I2', 'M1', 'I2'],\n       ['M1', 'P1', 'I2', 'P1'],\n       ['P2', 'P1', 'M1', 'I2'],\n       ['P2', 'P1', 'M1', 'P1'],\n       ['P2', 'P1', 'M1', 'P1'],\n       ['P2', 'P1', 'M1', 'P1'],\n       ['P2', 'P1', 'M1', 'P1']], dtype='&lt;U2')\n</code></pre> <p>As you can imagine, the objectives for \"Tier 1\" -&gt; \"Tier 4\" are there to meet the respective degree tier proportions!  There are the legacy \"Mandatory\", \"Desired\", and \"Permitted\" objectives as well, but those were replaced with the tier objectives (\"Tier 1\" -&gt; \"Tier 4\"). Essentially, we used to just group each of the categories (M, D, P) together and  constrain the model that way. This was not completely accurate, since two tiers that both have a mandatory label (M)  should be treated separately. </p> <p>Lastly, the \"Utility\" objective is simply to maximize cadet utility (happiness) and is measured by the average  cadet utility of the cadets assigned. I have this in there so AFSCs can prioritize the preferences of their incoming  cadets as well.</p>"},{"location":"user-guide/tutorial_4/#afsc-objective-components","title":"AFSC Objective Components","text":"<p>This section describes the various pieces of the AFSC objectives: their weights, targets, and constraints.  The value functions are another component of the objectives, but we'll cover them in their own section since  there's a lot going on there! The first component of the AFSC objectives we'll discuss are the weights.</p> <p> </p> <p>Here are the objective weights for each AFSC for each objective. Like the AFSC \"individual\" weights, these are swing  weights that will be scaled for each AFSC so that they sum to 1. Many objectives are weighted at 0 which effectively  removes them from consideration for a given AFSC.</p> <p> </p> <p>This dataframe displays the target measure for each of the objectives. In a perfect world, we'd meet every AFSC  objective by hitting these values for each of them. </p> <p> </p> <p>These are the constraints for each objective for each AFSC. Most are determined automatically based on the \"fixed\" data.  For example, the Combined Quota constraint is determined by the \"Min, Max\" values in \"Random_1 AFSCs.csv\".  The AFOCD Tier objective constraint ranges come from the \"Deg Tiers\" columns of \"Random_1 AFSCs.csv\" as well.  Since this is random data, nothing else is constrained to begin with.</p> <p> </p> <p>Here is where you actually turn different constraints on or off. If there is a 0, the constraint is turned off.  A \"1\" is an \"approximate\" constraint. This means that the denominator is the PGL target for an AFSC, not the actual  number of cadets assigned. If this is confusing, please reference my thesis or my slides that talk about the  difference between the Approximate Model and the Exact Model. The \"2\", therefore, is an \"exact\" constraint.  The only place where we could legitimately use a \"1\" instead of a \"2\" is for the AFOCD constraints. </p> <p>Example: Let's say 14N wants 70% of their cadets to have tier 1 degrees. Let's also say the PGL is 190 and we assign  220 cadets. A \"1\" constraint is a less restrictive constraint, and would ensure that 133 cadets (190 * 0.70) have  \"Tier 1\" degrees. Alternatively, a \"2\" constraint ensures the actual proportion gets constrained, so 154 cadets  (220 * 0.70) will have \"Tier 1\" degrees. Sometimes it is really hard to meet the AFOCD for some AFSCs,  and so a \"1\" constraint is necessary to ensure we meet the target based on the PGL, not the actual number of cadets.  Most of the time, however, we use \"2\" as the constraint type.</p> <p>Once these default value parameters have been imported/initialized for <code>Random_1</code>, they will be imported from  \"Random_1 VP.csv\" in \"Model Input\".</p> <p> </p> <p>As you can see, this file structure has a row for every AFSC and objective pair. The dataframes shown previously are  flattened into columns and exist here. Again, these are the actual value parameters used for the problem instance,  since the \"Defaults\" could have been more generalized (they aren't here since we exported our randomly generated set  as defaults, therefore having it be the same thing as what you're seeing here).  For a real class you could simply take the previous years defaults, tweak them a bit if needed,  and import those as a starting point for a new class year. The objective targets would be updated to reflect  the information of the problem instance you're looking at (the USAFA proportion objective target would be the  proportion of the USAFA cadets of the instance you're solving, for example).</p> <p>The \"AFSC Weight\" and \"Min Value\" columns above pertain to the AFSC itself, not the AFSC-objective pair  like the others (which is why \"AFSC Weight\" is all 100s for R1). The three columns to the right pertain to the  value functions used for each AFSC and objective which I will discuss in more detail in the following section.</p>"},{"location":"user-guide/tutorial_4/#value-functions","title":"Value Functions","text":"<p>Here we have the value functions for each of the AFSC objectives. These definitely require some explaining.  I've created my own terminology so that they can be generalized and constructed into actual value functions for each  of the objectives. I have an excel file that outlines how these functions are created and what they look like  (Value_Function_Builds.xlsx), but I will also detail them here. </p> <pre><code># I need to import this script\nimport afccp.data.values\n</code></pre> <p>Before you read this next section on the value functions, please look at my \"Creating Value Functions\" slides in  VFT_Model_Slides.pptx (starts on slide 130), and just click  through them. This is how I construct the value functions, and this should help your understanding of the different  piece-wise \"segments\" used.</p> <p>The purpose of the \"vf_string\" (Value Function string) is to construct the \"segment_dict\" (Segment Dictionary)  which provides the coordinates for the main piece-wise value function segment breakpoints. As illustrated below,  there are four \"segments\" of exponential functions that are pieced together using \"breakpoints\".  There are therefore 5 breakpoints. For this example, they are at the coordinates (0, 0), (3, 0.5), (5, 1), (7, 0.5),  and (10, 0). This would compose the \"segment_dict\".</p> <p> </p> <p>Let's illustrate the \"Balance\" value function. It takes several inputs pertaining to the \"margins\" and the  \\(\\rho\\) parameters. Here is what it looks like:</p> <p>vf_string \\(=\\) \"Balance|left_base_margin, right_base_margin, \\(\\rho_1\\), \\(\\rho_2\\), \\(\\rho_3\\), \\(\\rho_4\\), margin_y\"</p> <p>Honestly, you really don't need to worry about what these all mean. The only thing you should focus on is the  \\(\\rho\\) (\"rho\") parameters. These control how steep each of the exponential segments are. Let's see an example.  We'll first generate the \"segment_dict\" based on the \"vf_string\":</p> <pre><code>vf_string = \"Balance|0.2, 0.2, 0.1, 0.08, 0.08, 0.1, 0.5\"\ntarget = 0.5\nactual = 0.5\nsegment_dict = afccp.data.values.create_segment_dict_from_string(vf_string, target=target, actual=actual)\nfor segment in segment_dict:\n    print(str(segment) + \":\", segment_dict[segment])\n</code></pre> \ud83d\udcbb Console Output <pre><code>1: {'x1': 0, 'y1': 0, 'x2': 0.3, 'y2': 0.5, 'rho': -0.1}\n2: {'x1': 0.3, 'y1': 0.5, 'x2': 0.5, 'y2': 1, 'rho': 0.08}\n3: {'x1': 0.5, 'y1': 1, 'x2': 0.7, 'y2': 0.5, 'rho': 0.08}\n4: {'x1': 0.7, 'y1': 0.5, 'x2': 1, 'y2': 0, 'rho': -0.1}\n</code></pre> <p>Now we have our segment dictionary! We know what the coordinates for the \"main\" breakpoints are, so we can now  generate the rest of the breakpoints to make the function linear. Let's calculate the x and y coordinates of our  function's breakpoints.</p> <pre><code>x, y = afccp.data.values.value_function_builder(segment_dict=segment_dict, num_breakpoints=20)\nprint(\"x:\", x, \"\\n\\n\", \"y:\", y)\n</code></pre> \ud83d\udcbb Console Output <pre><code>x: [0.   0.06 0.12 0.18 0.24 0.3  0.34 0.38 0.42 0.46 0.5  0.54 0.58 0.62 0.66 0.7  0.76 0.82 0.88 0.94 1.  ] \n\ny: [0.      0.00288 0.01245 0.04423 0.14973 0.5     0.8182  0.93527 0.97833 0.99417 1.      0.99417 0.97833 \n    0.93527 0.8182  0.5     0.14973 0.04423 0.01245 0.00288 0.     ]\n</code></pre> <p>Now we plot our value function!</p> <pre><code># \"Balance\" type of value function!\nfrom afccp.visualizations.charts import ValueFunctionChart\nchart = ValueFunctionChart(x, y)\n</code></pre> <p> </p> <p>And there we have it. This is the value function we've constructed from that initial \"vf_string\".  Play around with the different parameters and see what happens here!</p> <pre><code># Change this\nvf_string = \"Balance|0.2, 0.2, 0.1, 0.08, 0.08, 0.1, 0.5\"\ntarget = 0.5  # This is what we're after\nactual = 0.5  # This is essentially what we could realistically expect (based on set of eligible cadets)\nnum_breakpoints = 200  # How many breakpoints to use \n# (the more breakpoints used, the more the function appears non-linear)\n\n# Don't change this\nsegment_dict = afccp.data.values.create_segment_dict_from_string(vf_string, target=target, actual=actual)\nx, y = afccp.data.values.value_function_builder(segment_dict=segment_dict, num_breakpoints=num_breakpoints)\nchart = ValueFunctionChart(x, y)\n</code></pre> <p> </p> <p>That is the \"Balance\" value function type. This is intended for the objectives that seek to \"balance\" certain  characteristics of the cadets (USAFA proportions and sometimes Merit as well). I did end up changing the Merit  value function to be a \"Min Increasing\" because I decided against penalizing the objective for exceeding 0.5.  At this point, I will note that these value functions don't necessarily have to have 4 segments.  I do have value function types that use 3, 2, or even 1 segment. Let's discuss the quota value functions.</p> <p>\"Quota_Direct\" is intended for AFSCs that have a range on the number of cadets that are to be assigned,  but also know around where they'd like to fall within that range. There are 6 parameters, the \\(\\rho\\) (rho) parameters  for each of the four segments, and the y values for the two breakpoints on either side of the \"peak\". The vf_string  is then: \"Quota_Direct|\\(\\rho_1\\), \\(\\rho_2\\), \\(\\rho_3\\), \\(\\rho_4\\), \\(y_1\\), \\(y_2\\)\". The additional AFSC specific parameters  are the upper/lower bounds on the number of cadets as well as the actual target number of cadets within that range.  Here is an example:</p> <pre><code>vf_string = \"Quota_Direct|0.1, 1, 0.6, 0.1, 0.8, 0.8\"\nminimum = 120  # Lower Bound\nmaximum = 200  # Upper Bound\ntarget = 140  # Desired number of cadets within the range\nnum_breakpoints = 200  # How many breakpoints to use \n\n# Don't change this\nsegment_dict = afccp.data.values.create_segment_dict_from_string(vf_string, target=target, \n                                                                      minimum=minimum, maximum=maximum)\nx, y = afccp.data.values.value_function_builder(segment_dict=segment_dict, num_breakpoints=num_breakpoints)\nchart = ValueFunctionChart(x, y)\n</code></pre> <p> </p> <p>Here you can see that although the range of 120 to 200 is specified, there is a direction of preference within that  range (the AFSC wants around 140 cadets, but is fairly accepting of values around that range). I will note that the  target, minimum, and maximum parameters are taken from the \"Random_1 AFSCs.csv\" data!</p> <p>Another value function we can choose for the quota objective is the \"Quota_Normal\" function type.  This is intended for AFSCs that either don't care about the number of cadets (as long as they fall within a certain  range) or didn't specify. For example, the PGL says 120 and after speaking with them we determine the upper bound is  200 and they say they have no preference between 120 and 200 and everything in between. There are 2 segments for this  function, connected by a horizontal line at y = 1 for the range on the cadets. The function parameters are \\(\\rho_1\\),  \\(\\rho_2\\), and \"domain_max\" which is the max number of cadets that could have a nonzero value (arbitrary scalar just  to get a curve on the right side of the function). Here is the vf_string: \"Quota_Normal|d_max, \\(\\rho_1\\), \\(\\rho_2\\)\".  Here is an example:</p> <pre><code>vf_string = \"Quota_Normal|0.2, 0.25, 0.05\"\nminimum = 120  # Lower Bound\nmaximum = 200  # Upper Bound\ntarget = 140  # (Doesn't matter here)\nnum_breakpoints = 200  # How many breakpoints to use \n\n# Don't change this\nsegment_dict = afccp.data.values.create_segment_dict_from_string(vf_string, target=target, \n                                                                      minimum=minimum, maximum=maximum)\nx, y = afccp.data.values.value_function_builder(segment_dict=segment_dict, num_breakpoints=num_breakpoints)\nchart = ValueFunctionChart(x, y)\n</code></pre> <p> </p> <p>The last two kinds of value functions I'll discuss are the \"Min Increasing\" and \"Min Decreasing\" types.  They are very simple and only have one segment which is a simple exponentional curve to get to the target measure  (in the x space). The only parameter is \\(\\rho\\). The vf_string then looks like: \"Min Increasing|\\(\\rho\\)\" or  \"Min Decreasing|\\(\\rho\\)\". They are called \"Min\" functions because it's essentially the same thing as taking the  minimum value between some exponential curve and 1. Here are some examples:</p> <pre><code>vf_string = \"Min Increasing|0.1\"\ntarget = 0.5\nnum_breakpoints = 200  # How many breakpoints to use \n\n# Don't change this\nsegment_dict = afccp.data.values.create_segment_dict_from_string(vf_string, target=target)\nx, y = afccp.data.values.value_function_builder(segment_dict=segment_dict, num_breakpoints=num_breakpoints)\nchart = ValueFunctionChart(x, y)\n</code></pre> <p> </p> <pre><code>vf_string = \"Min Increasing|-0.1\"\ntarget = 1\nnum_breakpoints = 200  # How many breakpoints to use \n\n# Don't change this\nsegment_dict = afccp.data.values.create_segment_dict_from_string(vf_string, target=target)\nx, y = afccp.data.values.value_function_builder(segment_dict=segment_dict, num_breakpoints=num_breakpoints)\nchart = ValueFunctionChart(x, y)\n</code></pre> <p> </p> <pre><code>vf_string = \"Min Decreasing|-1\"\ntarget = 0.2\nnum_breakpoints = 200  # How many breakpoints to use \n\n# Don't change this\nsegment_dict = afccp.data.values.create_segment_dict_from_string(vf_string, target=target)\nx, y = afccp.data.values.value_function_builder(segment_dict=segment_dict, num_breakpoints=num_breakpoints)\nchart = ValueFunctionChart(x, y)\n</code></pre> <p> </p> <pre><code>vf_string = \"Min Decreasing|1\"\ntarget = 0.2\nnum_breakpoints = 200  # How many breakpoints to use \n\n# Don't change this\nsegment_dict = afccp.data.values.create_segment_dict_from_string(vf_string, target=target)\nx, y = afccp.data.values.value_function_builder(segment_dict=segment_dict, num_breakpoints=num_breakpoints)\nchart = ValueFunctionChart(x, y)\n</code></pre> <p> </p> <p>And there you have it! This is how I code up and construct my many value functions for each of the objectives for  each of the AFSCs. Please reach out if you have any questions as I know this is a confusing section.</p> <p>Now that we're done discussing the types of value functions, we can take a look at the actual value functions used on  \"Random_1\". We're plotting the breakpoints (x/y coordinates) for a specific AFSC objective value function.  Here is an example:</p> <pre><code># Plot the value function (this also saves it to the \"Value Functions\" sub-folder by default FYI)\nc = instance.show_value_function({'afsc': \"R1\", 'objective': 'Combined Quota'})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Creating value function chart for objective Combined Quota for AFSC R1\n</code></pre> <p> </p> <pre><code># Plot the value function (this also saves it to the \"Value Functions\" sub-folder by default FYI)\nc = instance.show_value_function({'afsc': \"R2\", 'objective': 'USAFA Proportion'})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Creating value function chart for objective USAFA Proportion for AFSC R2\n</code></pre> <p> </p> <pre><code># Plot the value function (this also saves it to the \"Value Functions\" sub-folder by default FYI)\nc = instance.show_value_function({'afsc': \"R1\", 'objective': 'Tier 1'})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Creating value function chart for objective Tier 1 for AFSC R1\n</code></pre> <p> </p>"},{"location":"user-guide/tutorial_4/#global-utility","title":"Global Utility","text":"<p>There are a few other components of the \"value parameters\" that I haven't mentioned yet.  The <code>global_utility</code> matrix is based on the cadets' preferences as well as the AFSCs' preferences.  The two matrices <code>cadet_utility</code> and <code>afsc_utility</code> are merged according to the overall weights on the cadets/AFSCs.</p> <pre><code># Cadet Utility Matrix\np['cadet_utility']  # As a reminder 'p' -&gt; 'instance.parameters'!!!\n</code></pre> \ud83d\udcbb Console Output <pre><code>array([[1.    , 0.4683, 0.    , 0.1917],\n       [1.    , 0.5433, 0.    , 0.3667],\n       [0.135 , 1.    , 0.42  , 0.65  ],\n       [0.7933, 0.4717, 1.    , 0.    ],\n       [1.    , 0.    , 0.    , 0.355 ],\n       [1.    , 0.2   , 0.47  , 0.805 ],\n       [0.7133, 1.    , 0.1817, 0.    ],\n       [1.    , 0.21  , 0.42  , 0.655 ],\n       [1.    , 0.3833, 0.    , 0.1767],\n       [0.1867, 0.    , 1.    , 0.3633],\n       [0.265 , 0.    , 0.    , 1.    ],\n       [1.    , 0.7983, 0.    , 0.3917],\n       [0.645 , 0.495 , 1.    , 0.325 ],\n       [1.    , 0.    , 0.43  , 0.    ],\n       [0.8083, 1.    , 0.    , 0.3467],\n       [0.7233, 0.4217, 1.    , 0.    ],\n       [0.355 , 0.2   , 1.    , 0.5   ],\n       [0.855 , 0.72  , 1.    , 0.52  ],\n       [1.    , 0.56  , 0.21  , 0.725 ],\n       [0.29  , 0.135 , 0.66  , 1.    ]])\n</code></pre> <pre><code># AFSC Utility Matrix\np['afsc_utility']\n</code></pre> \ud83d\udcbb Console Output <pre><code>array([[0.75      , 0.0625    , 0.        , 0.0625    ],\n       [0.6       , 0.25      , 0.        , 0.3125    ],\n       [0.05      , 0.6875    , 0.07692308, 0.4375    ],\n       [0.2       , 0.3125    , 0.23076923, 0.        ],\n       [0.55      , 0.        , 0.        , 0.375     ],\n       [0.4       , 0.1875    , 0.15384615, 0.5       ],\n       [0.7       , 0.9375    , 0.38461538, 0.        ],\n       [1.        , 0.5625    , 0.69230769, 0.8125    ],\n       [0.45      , 0.125     , 0.        , 0.125     ],\n       [0.1       , 0.        , 0.76923077, 0.25      ],\n       [0.85      , 0.        , 0.        , 1.        ],\n       [0.25      , 0.5       , 0.        , 0.1875    ],\n       [0.5       , 0.75      , 0.92307692, 0.6875    ],\n       [0.9       , 0.        , 0.30769231, 0.        ],\n       [0.95      , 1.        , 0.        , 0.5625    ],\n       [0.3       , 0.4375    , 0.53846154, 0.        ],\n       [0.35      , 0.625     , 1.        , 0.625     ],\n       [0.65      , 0.8125    , 0.84615385, 0.75      ],\n       [0.8       , 0.875     , 0.46153846, 0.9375    ],\n       [0.15      , 0.375     , 0.61538462, 0.875     ]])\n</code></pre> <pre><code># Overall weights on cadets/AFSCs\nprint(\"weight on cadets:\", round(vp['cadets_overall_weight'], 2))\nprint(\"weight on AFSCs:\", round(vp['afscs_overall_weight'], 2))\n</code></pre> \ud83d\udcbb Console Output <pre><code>weight on cadets: 0.52\nweight on AFSCs: 0.48\n</code></pre> <pre><code># Global Utility Matrix (Each cell is the weighted sum of cadet/AFSC utility)\nvp['global_utility']  # Extra column is for the unmatched cadets!\n</code></pre> \ud83d\udcbb Console Output <pre><code>array([[0.8788349 , 0.2716248 , 0.        , 0.12908187, 0.        ],\n       [0.80613583, 0.4011491 , 0.        , 0.34043141, 0.        ],\n       [0.09380386, 0.84854362, 0.2537242 , 0.54700966, 0.        ],\n       [0.50575097, 0.39454206, 0.62718429, 0.        , 0.        ],\n       [0.78190281, 0.        , 0.        , 0.36469321, 0.        ],\n       [0.70920375, 0.19394174, 0.31677274, 0.65717857, 0.        ],\n       [0.70685402, 0.96970872, 0.28004506, 0.        , 0.        ],\n       [1.        , 0.3808428 , 0.55197676, 0.73133402, 0.        ],\n       [0.73343677, 0.25811221, 0.        , 0.15164306, 0.        ],\n       [0.14467994, 0.        , 0.88815529, 0.30838797, 0.        ],\n       [0.54852634, 0.        , 0.        , 1.        , 0.        ],\n       [0.63650469, 0.6537258 , 0.        , 0.29273234, 0.        ],\n       [0.57472424, 0.61858841, 0.96271843, 0.5006894 , 0.        ],\n       [0.95153396, 0.        , 0.3707223 , 0.        , 0.        ],\n       [0.87697638, 1.        , 0.        , 0.45128972, 0.        ],\n       [0.51814325, 0.42935763, 0.77631058, 0.        , 0.        ],\n       [0.3525767 , 0.40598068, 1.        , 0.56058255, 0.        ],\n       [0.75564461, 0.76483109, 0.92543686, 0.6314719 , 0.        ],\n       [0.90306792, 0.71266803, 0.33191074, 0.82799034, 0.        ],\n       [0.22214754, 0.2513185 , 0.63837669, 0.93941745, 0.        ]])\n</code></pre> <pre><code>print(\"Cadet 0's utility on AFSC 0:\", p['cadet_utility'][0, 0])\nprint(\"AFSC 0's utility on cadet 0:\", p['afsc_utility'][0, 0])\nprint(\"Global Utility[0, 0]:\", round(vp['cadets_overall_weight'], 2), \"*\", p['cadet_utility'][0, 0], \"+\", \n     round(vp['afscs_overall_weight'], 2), \"*\", p['afsc_utility'][0, 0], \"=\", vp['global_utility'][0, 0])\n</code></pre> \ud83d\udcbb Console Output <pre><code>Cadet 0's utility on AFSC 0: 1.0\nAFSC 0's utility on cadet 0: 0.75\nGlobal Utility[0, 0]: 0.52 * 1.0 + 0.48 * 0.75 = 0.8788348955053363\n</code></pre> <p>The global utility matrix is unique to each set of value parameters (since you can toggle the weights on  cadets/AFSCs and get a different matrix). This matrix lives in \"Random_1 VP Global Utility.csv\":</p> <p> </p>"},{"location":"user-guide/tutorial_4/#cadet-utility-constraints-meant-just-for-afpcdsya-through-an-operational-lens","title":"Cadet Utility Constraints (Meant just for AFPC/DSYA through an operational lens)","text":"<p>Another component of the value parameters is the cadet utility constraints. These constraints ensure certain cadets  receive some minimum utility value, and the implication here usually applies to the top 10% of cadets as my method of  preventing as much of the \"adjudication\" piece on the backend. Built into the classification process is adjudication  where the sources of commissioning get to review the results prior to release and make adjustments as needed.  One thing they always want to make sure is that their top cadets are getting something they want, and if they aren't  they'll kick it back to AFPC to fix. I can use the cadet utility constraints to ensure that the top 10% of cadets  receive one of their top 3 choices, or there is a good reason why they aren't getting one (if they only have very  competitive AFSCs as their top 3 choices and don't rank high enough for them then that may cause problems). </p> <p>These constraints live in the file \"Random_1 Cadets Utility Constraints.csv\":</p> <p> </p> <p>As you can see, I include the cadet indices (as I've said before, it's because I like referring to cadets by their  indices in the numpy arrays since that allows me to do a lot of things) as well as the cadets' order of merit.  This information gives more context to why certain cadets have constrained minimum values versus other cadets!  The \"VP\" column is the actual constrained minimum utilities for all the cadets. If you have a second set of  value parameters that you're using, there would be another column called \"VP2\". As you can see, the default is to  keep all the cadets unconstrained. I've thought a lot about how this should work and wrestled with the idea of  just making a function to go through and constrain the top 10% to get a utility value greater than or equal to their  third choice but ultimately decided against it. The reason is that it's more complicated than that, and I firmly  believe the AFPC/DSYA analyst needs to be the one to do it manually. </p> <p>When I ran this for FY23 and FY24, I tuned the model parameters to be what I needed them to be based on everyone's  wants and desires and then solved it initially without any cadet constraints. I can then look at the solution at the  top 10/20% of the class and if the cadet is receiving a top 3 preference anyway (vast majority do), then I constrain  their utilities to be whatever their third choice utility was. I then filter on the people who aren't getting a top 3  preference. If the reason is just because the optimal solution involved this cadet not getting a top 3 preference,  and they really should have received one based on preferences (they didn't have 3 very hard choices to meet),  then I also enforce the utility constraint. If there's a clear reason why they're getting their fourth choice (and I  mean a VERY justifiable reason), then I constrain them to their fourth choice utility. For top 10%, I don't think this  happened at all but did occur for top 20%.</p> <pre><code># Cadet utility constriants\nvp['cadet_value_min']  # Defaults to 0! For an example problem (not real class year), don't mess with this\n</code></pre> \ud83d\udcbb Console Output <pre><code>array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0.])\n</code></pre>"},{"location":"user-guide/tutorial_4/#goal-programming-parameters","title":"Goal-Programming Parameters","text":"<p>One final input file that I haven't mentioned is \"Random_1 Goal Programming.csv\". These are the inputs that  another AFIT researcher, former Lt. Rebecca Reynolds (now Capt. Rebecca Eisemann), used for her goal-programming model.  My intent for <code>afccp</code> has always been to provide a way for researchers in this field to contribute to this  \"academic\" problem and try new things to inspire innovation for AFPC/DSYA. For her goal programming model, her  inputs are structured in this way:</p> <p> </p> <p>In order to get the penalty/reward terms here we need to run the model on the specific class year to tune the  parameters to get the actual parameters needed to run the full goal programming model. It's a little nuanced and  you can certainly view her thesis here. I will briefly cover her model a  little more later on.</p>"},{"location":"user-guide/tutorial_4/#summary","title":"\ud83d\udccc Summary","text":"<p>This tutorial explains how to generate and customize value parameters for cadet-to-AFSC matching within the AFCCP model.  Value parameters are central to the Value-Focused Thinking model through the use of modeling AFSC objectives. That said, since the main model used now is the GUO model, most of the contents of the <code>value_parameters</code> dictionary are no longer used. That said, there are still some components that are very much used (like the constraints).</p> <p>The tutorial walks through:</p> <ul> <li> <p>Default Value Generation   How to use predefined \"defaults\" to create baseline value parameters.</p> </li> <li> <p>AFSC Objectives and Components   The data available for each AFSC and objective (weights, targets, constraints, value functions)</p> </li> <li> <p>Custom Curve Generation   Methods to create and visualize alternative value functions using exponential or polynomial interpolation.</p> </li> <li> <p>Adjustments and Additions   How to modify value curves for specific AFSCs or cadet groups, including smoothing and parameter additions.</p> </li> <li> <p>Visualization   Optional plotting functions to help understand the shape and effect of each value function.</p> </li> </ul> <p>By the end, you should have a fully defined set of <code>value_parameters</code> stored in the appropriate dictionary structure  to feed into the various <code>afccp</code> optimization models. You\u2019re now ready to continue on and discover the data methods used to correct the parameters in Tutorial 5!</p>"},{"location":"user-guide/tutorial_5/","title":"Tutorial 5: Data Methods","text":"<p>Now that I've described in detail the data that afccp uses, let's talk about the data-manipulation methods available  for the <code>CadetCareerProblem</code> class. For a \"Random\" generated problem set, it doesn't really matter what you do to  the data which is why I created a convenient  <code>instance.fix_generated_data()</code>  function that gets your generated data looking right for you to run different models &amp; algorithms.  Many of the components of that function are also relevant for a real class year, but not all!</p> <pre><code># Takes the CIP codes and translates them to the qualification matrix (only works for real data)\ninstance.calculate_qualification_matrix()\n</code></pre> <p>Traceback (most recent call last)</p> <pre><code>    ValueError                                Traceback (most recent call last)\nInput In [116], in &lt;cell line: 2&gt;()\n      1 # Takes the CIP codes and translates them to the qualification matrix (only works for real data)\n----&gt; 2 instance.calculate_qualification_matrix()\n\nFile ~/Desktop/Coding Projects/afccp/afccp/core/main.py:432, in CadetCareerProblem.calculate_qualification_matrix(self, printing)\n    429         qual_matrix = afccp.core.data.support.cip_to_qual_tiers(\n    430             parameters[\"afscs\"][:parameters[\"M\"]], parameters['cip1'])\n    431 else:\n--&gt; 432     raise ValueError(\"Error. Need to update the degree tier qualification matrix to include tiers \"\n    433                      \"('M1' instead of 'M' for example) but don't have CIP codes. Please incorporate this.\")\n    435 # Load data back into parameters\n    436 parameters[\"qual\"] = qual_matrix\n\nValueError: Error. Need to update the degree tier qualification matrix to include tiers ('M1' instead of 'M' for example) but don't have CIP codes. Please incorporate this.\n</code></pre> <p>As you can see, the code above produces an error since we don't have any CIP codes in \"Random_1 Cadets.csv\".  Going further, even if we did put them into our dataset it still wouldn't work since the AFSCs themselves are also  meaningless. This function only works with real AFSC names and with CIP codes in our cadets data. As an aside,  I've tried to incorporate a lot of error handling throughout <code>afccp</code> but it's certainly not flawless and still a  work in progress so if you encounter something that doesn't make since please let me know and I will a) help you fix it  and also b) include some more error handling measures so that we catch that kind of error in a manner that  makes more sense to the analyst using <code>afccp</code>.</p>"},{"location":"user-guide/tutorial_5/#operational-data-processing-meant-just-for-afpcdsya","title":"Operational Data Processing (Meant just for AFPC/DSYA)","text":"<p>The intent of this section is primarily for the \"operational lens\" of this problem, since we have the easy  method I've already described that will fix the fake data for you anyway: <code>instance.fix_generated_data()</code>. </p> <p>Ok, your main job for processing a given class year of cadets is to construct the \"Cadets.csv\", \"AFSCs.csv\" and  \"AFSCs Preferences.csv\", and the default value parameters excel file located in the support sub-folder.  Additionally, to create the AFSC preferences for Rated career fields, you'll also need the \"ROTC Rated OM.csv\" and  \"USAFA Rated OM.csv\" files. \"AFSCs Preferences.csv\" should contain the necessary rankings for Non-Rated AFSCs,  with something as a placeholder for rated career field rankings. The two OM datasets should have the percentiles  for their respective source of commissioning cadets that are rated eligible (they volunteered). If a cadet volunteered  for Rated, and is eligible for at least one of the rated AFSCs, they should be in this dataset. If the cadet is not  eligible for a specific rated AFSC, they have a \"0\" in that position. The important thing here is that the cadets  can be sorted in descending order with highest ranking at the top and lowest at the bottom using those \"percentile\"  values (1, 0.99, 0.98, ..., 0.01, 0, 0, etc.). This is what the code does to get the ordered list of cadets (AFSC preferences). </p> <pre><code># Takes the two Rated OM datasets and re-calculates the AFSC rankings for Rated AFSCs for both SOCs\ninstance.construct_rated_preferences_from_om_by_soc()\n</code></pre> \ud83d\udcbb Console Output <pre><code>Integrating rated preferences from OM matrices for each SOC...\n</code></pre> <p>The <code>construct_rated_preferences_from_om_by_soc()</code> creates the rated AFSC preferences in the <code>a_pref_matrix</code> by splicing together the Rated OM data from each SOC.  Initially, the AFSC preferences for each rated AFSC should just be all ones or something like that as a placeholder.  After this method is run, we have the true preferences from the OM data, and we will know true eligibility as well.</p> <pre><code>instance.parameters['a_pref_matrix']  # Nothing will change here since we already had this merged correctly\n</code></pre> \ud83d\udcbb Console Output <pre><code>array([[ 6, 16,  0, 16],\n       [ 9, 15,  0, 15],\n       [20,  4, 13,  9],\n       [17, 11, 11,  0],\n       [10,  0,  0, 10],\n       [13, 13, 12,  7],\n       [ 7,  5,  9,  0],\n       [ 1,  6,  5,  4],\n       [12, 14,  0, 14],\n       [19,  0,  4, 11],\n       [ 4,  0,  0,  3],\n       [16,  8,  0, 13],\n       [11,  3,  2,  6],\n       [ 3,  0, 10,  0],\n       [ 2,  2,  0, 12],\n       [15, 12,  7,  0],\n       [14, 10,  1,  8],\n       [ 8,  7,  3,  5],\n       [ 5,  1,  8,  1],\n       [18,  9,  6,  2]])\n</code></pre> <p>Once this method is run, we should now have an <code>a_pref_matrix</code> that is almost 100% accurate (the only drift should come  from cadet preferences). Once you have the AFSC preferences file that is accurate, you can then update the  qualification matrix using these preferences. The default qual matrix allows all cadets to be eligible for rated  AFSCs and for the Space Force in general. It also restricts eligibility for Non-Rated AFSCs to be based on the  cadets' degrees (CIP codes). We need to update it by restricting Rated/USSF eligibility down to volunteerism, and  relaxing the AFOCD a bit for Non-Rated AFSCs (creating \"exceptions\" designated by \"E\"). This is accomplished through  the <code>update_qualification_matrix_from_afsc_preferences()</code> method:</p> <pre><code># Update qualification matrix from AFSC preferences (treating CFM lists as \"gospel\" except for Rated/USSF)\ninstance.update_qualification_matrix_from_afsc_preferences()\n</code></pre> \ud83d\udcbb Console Output <pre><code>1 Making 4 cadets ineligible for 'R2' by altering their qualification to 'I2'. \n3 Making 4 cadets ineligible for 'R4' by altering their qualification to 'I2'. \n</code></pre> <p>The message above isn't actually doing anything since those cadets were already ineligible since we've run  instance.fix_generated_data() earlier.</p> <p>Now, we should have a qualification matrix that agrees with the AFSC preference matrix in terms of eligibility.  If it didn't, it would warn you and tell you where the discrepancies are, so that you can correct them or ignore them  depending on what's going on. </p> <p>Once these two matrices are rectified, it's time to focus on fixing the cadet preferences. First, we fill in any AFSCs  that the cadets may be eligible for, but didn't preference. Since the cadets only have to place 10 choices, they may  not select every career field for which they are eligible. We fill in the rest of the choices arbitrarily after the  AFSCs they selected. Additionally, the cadets may have indicated which AFSCs they do NOT want. In that case, we put them at the end of their preference lists. This occurs in the <code>fill_remaining_afsc_choices()</code> method:</p> <pre><code># Fill in remaining AFSC choices that the cadets could be eligible for, but...\ninstance.fill_remaining_afsc_choices()  # ...didn't select\n</code></pre> <p>Traceback (most recent call last)</p> <pre><code>    KeyError                                  Traceback (most recent call last)\n    &lt;ipython-input-213-64cad255bf8b&gt; in &lt;cell line: 2&gt;()\n          1 # Fill in remaining AFSC choices that the cadets could be eligible for, but...\n    ----&gt; 2 instance.fill_remaining_afsc_choices()  # ...didn't select\n\n    ~/Coding Projects/afccp/afccp/main.py in fill_remaining_afsc_choices(self, printing)\n        947         # Import default value parameters\n        948         self.import_default_value_parameters(printing=printing, vp_defaults_filename=vp_defaults_filename)\n    --&gt; 949 \n        950         # Takes the two Rated OM datasets and re-calculates the AFSC rankings for Rated AFSCs for both SOCs\n        951         self.construct_rated_preferences_from_om_by_soc(printing=printing)\n\n    ~/Coding Projects/afccp/afccp/data/preferences.py in fill_remaining_preferences(parameters)\n        647 \n        648         # If this cadet does not have any preferences, we skip them (must be an OTS candidate)\n    --&gt; 649         if len(p['cadet_preferences'][i]) == 0:\n        650             continue\n        651 \n\n    KeyError: 'J^Bottom 2 Choices'\n</code></pre> <p>As you can see, there is an error when we try to run this method on fake data. This error occurs because we do not have the 'J^Bottom 2 Choices' parameter which is one of the features produced by the survey data. This is an indexed set of the 1 or 2 bottom choice AFSCs that the cadets could select (the LAST choice itself is in the 'J^Last Choice' parameter). These parameters do not exist for random data, so we don't run this action as part of the <code>fix_generated_data()</code> method.</p> <p>Now that we have all possible AFSCs in each cadet's preferences, we must remove AFSCs for which the cadet is not  actually eligible. Be careful with this one as you need to make sure  that the AFSC preferences and the qual matrix reflects accurate eligibility as this will remove cadets' choices!  It checks all three \"sources of truth\" in terms of eligibility (cadet/AFSC preferences and degree qual matrix) and  if one of them says that the cadet is ineligible for a given AFSC, this method forces all three to reflect  ineligibility. It is a rather \"nuclear\" approach, so again, be careful! Let's run the  <code>remove_ineligible_choices()</code>  method here:</p> <pre><code># Removes ineligible cadets from all 3 matrices: degree qualifications, cadet preferences, AFSC preferences\ninstance.remove_ineligible_choices()  # Nothing changed since we've already done this!\n</code></pre> \ud83d\udcbb Console Output <pre><code>Removing ineligible cadets based on any of the three eligibility sources (c_pref_matrix, a_pref_matrix, qual)...\n0 total adjustments.\n</code></pre> <p>This method also re-runs the parameter additions function which will correct the preference lists themselves  (the dictionaries for each cadet/AFSC \"key\" that has the sorted AFSCs/cadets list as the \"value\"). Just always  remember the difference between \"a_pref_matrix\" and \"afsc_preferences\" (similarly, \"c_pref_matrix\" and  \"cadet_preferences\"). One is a 2-dimensional numpy array and the other is a dictionary. </p> <p>From here, we want to \"fill the gaps\" in the matrix to create the final 1-N lists. We use the preference  dictionaries (\"afsc_preferences\" and \"cadet_preferences\") to construct their corresponding matrices from scratch using  the <code>update_preference_matrices()</code>.</p> <pre><code># Take the preferences dictionaries and update the matrices from them (using cadet/AFSC indices)\ninstance.update_preference_matrices()  # 1, 2, 4, 6, 7 -&gt; 1, 2, 3, 4, 5 (preference lists need to omit gaps)\n</code></pre> \ud83d\udcbb Console Output <pre><code>Updating cadet preference matrices from the preference dictionaries. ie. 1, 2, 4, 6, 7 -&gt; 1, 2, 3, 4, 5 (preference lists need to omit gaps)\n</code></pre> <p>When we have the final cadet preference lists, we must ensure that each cadet has a 100% utility value for their first choice AFSC. There is the possibility, and it will happen multiple times each classification cycle, that some cadets are ineligible for this first choice AFSC. Their first choice always has a utility value of 100% on the survey, but if they cannot be matched to it then they get a new first choice (their most preferred AFSC that they CAN be assigned to). Therefore, whichever AFSC is their final first choice will be given a utility value of 1 in the  <code>update_first_choice_cadet_utility_to_one()</code>  method:</p> <pre><code># Force first choice utility values to be 100%\ninstance.update_first_choice_cadet_utility_to_one()  # (We've already run this method so no one gets fixed)\n</code></pre> \ud83d\udcbb Console Output <pre><code>Updating cadet first choice utility value to 100%...\nFixed 0 first choice cadet utility values to 100%.\nCadets: []\n</code></pre> <p>Once we have the final AFSC rankings, we can construct the afsc_utility matrix (that lives in \"AFSCs Utility.csv\")  that converts the 1-N preference list into linear percentiles. This occurs in the  <code>convert_afsc_preferences_to_percentiles()</code>  method:</p> <pre><code># Convert AFSC preferences to percentiles (0 to 1)\ninstance.convert_afsc_preferences_to_percentiles()  # 1, 2, 3, 4, 5 -&gt; 1, 0.8, 0.6, 0.4, 0.2\n</code></pre> \ud83d\udcbb Console Output <pre><code>Converting AFSC preferences (a_pref_matrix) into percentiles (afsc_utility on AFSCs Utility.csv)...\n</code></pre> <p>Until now, we've only been manipulating the cadet/AFSC preference matrices (information contained in  \"Cadets Preferences.csv\" and \"AFSC Preferences.csv\"). We haven't adjusted the information from \"Cadets.csv\",  since preferences are also contained there. We do this in the  <code>update_cadet_columns_from_matrices()</code>  method:</p> <pre><code># The \"cadet columns\" are located in Cadets.csv and contain the utilities/preferences in order of preference\ninstance.update_cadet_columns_from_matrices()  # We haven't touched \"c_preferences\" and \"c_utilities\" until now\n</code></pre> \ud83d\udcbb Console Output <pre><code>Updating cadet columns (Cadets.csv...c_utilities, c_preferences) from the preference matrix (c_pref_matrix)...\n</code></pre> <p>One other thing you'll want to do is update the utility matrices for cadets from the cadets' data. These are the  \"utility\" and \"cadet_utility\" matrices that live in \"Cadets Utility.csv\" and \"Cadets Utility (Final).csv\", respectfully. We update the cadet utility matrices in the  <code>update_cadet_utility_matrices_from_cadets_data()</code>  method:</p> <pre><code>instance.update_cadet_utility_matrices_from_cadets_data()\n</code></pre> \ud83d\udcbb Console Output <pre><code>Updating cadet utility matrices ('utility' and 'cadet_utility') from the 'c_utilities' matrix\n</code></pre> <p>The last thing you should do is remove any cadets from the specific rated OM lists if they're no longer eligible for at least one rated AFSC. Cadets need to be eligible for at least one rated AFSC to be considered a \"rated eligible\"  cadet, otherwise the code breaks for \"divide-by-zero\" or \"empty set\" type errors. The  <code>modify_rated_cadet_lists_based_on_eligibility()</code>  method will handle this necessary step:</p> <pre><code># Modify rated eligibility by SOC, removing cadets that are on \"Rated Cadets\" list...\ninstance.modify_rated_cadet_lists_based_on_eligibility()  # ...but not eligible for any rated AFSC\n</code></pre> \ud83d\udcbb Console Output <pre><code>Modifying rated eligibiity lists/matrices by SOC... \n(Removing cadets that are on the lists but not eligible for any rated AFSC)\n</code></pre> <p>The methods I've just described all contribute to the main parameters (\"parameters\") of the problem.  The only other thing I've alluded to is getting the default value parameters setup in the  \"support/value parameters defaults/\" sub-folder. We created this file earlier with the \"Random_1\" instance by  exporting the randomly generated set back to excel as defaults, so it's there for reference with the name  \"Value_Parameters_Defaults_Random_1.xlsx\". The best way to do this for a real class year is to simply copy the  previous year's default file and make adjustments as needed. I did the heavy lifting for incorporating Rated/USSF  with 2024 and so the 2025+ files should be pretty similar, for example  (Update: 2025/2026 files were!).</p> <p>Once you create that default file, you'll just need to import your value parameters as defaults, and it will  initialize them for your given class year from that file. This should be one of the very first things you do  because my code relies on the value parameters extensively. </p> <pre><code># Execute that function to get your set of value parameters\nv = instance.import_default_value_parameters()  # \"v =\" prevents a lot of output (v is meaningless)\n</code></pre> \ud83d\udcbb Console Output <pre><code>Importing default value parameters...\nImported.\n</code></pre> <p>For a real class year, if you followed those steps I described above then you should have all your files good to go  and can start thinking about getting solutions! If you understand the data, and have processed it all  correctly, then solving the model and getting a solution is as easy as hitting \"go\" with whatever algorithm/model  you're using. In an effort to make this as easy as possible, I do have a method for processing the \"real\" data just like the \"fake\" data. If you're modifying fake/generated data with no care to the efficacy of that data, you can run the <code>fix_generated_data()</code> method. If,  however, you're working with real or \"realistic\" data (data that you want to treat as real), then you should execute the <code>make_all_initial_real_instance_modifications()</code>  method. This will run all the steps I've outlined in this tutorial in the correct order. I still believe this is an  important tutorial because you should understand the data modifications that are occurring, and why they're necessary.</p>"},{"location":"user-guide/tutorial_5/#summary","title":"\ud83d\udccc Summary","text":"<p>This tutorial walks through all the core data-manipulation methods in the <code>CadetCareerProblem</code> class, especially  useful when preparing a real-world dataset for modeling.</p>"},{"location":"user-guide/tutorial_5/#key-highlights","title":"Key Highlights","text":"<p>Generated Data: If you're using synthetic data, you can run <code>instance.fix_generated_data()</code> to automatically clean and configure everything for simulation and testing.</p> <p>Real Data: For operational use, you\u2019ll need to manually initialize the \"Cadets.csv\", \"AFSCs.csv\", \"AFSCs Preferences.csv\",  and OM files (e.g., \"ROTC Rated OM.csv\"). The sequence of methods outlined ensures these files reflect realistic and  consistent eligibility and preferences.</p> <p>Critical Processing Functions:</p> <ul> <li><code>import_default_value_parameters()</code>: Initializes value parameters from Excel templates.</li> <li><code>construct_rated_preferences_from_om_by_soc()</code>: Integrates OM-based rated preferences by SOC.</li> <li><code>update_qualification_matrix_from_afsc_preferences()</code>: Aligns AFSC preferences with qualification logic.</li> <li><code>fill_remaining_afsc_choices()</code>: Fills in missing preferences.</li> <li><code>remove_ineligible_choices()</code>: Removes cadets/AFSCs that fail any eligibility check.</li> <li><code>update_preference_matrices()</code>: Rebuilds matrices from preference dictionaries.</li> <li><code>update_first_choice_cadet_utility_to_one()</code>: Ensures top choice utility is set to 1.0.</li> <li><code>convert_afsc_preferences_to_percentiles()</code>: Converts ranked preferences to utility percentiles.</li> <li><code>update_cadet_columns_from_matrices()</code>: Syncs Cadets.csv preference columns.</li> <li><code>update_cadet_utility_matrices_from_cadets_data()</code>: Generates utility matrices from preferences.</li> <li><code>modify_rated_cadet_lists_based_on_eligibility()</code>: Ensures Rated OM cadets are still eligible.</li> </ul> <p>For real data, consider running <code>make_all_initial_real_instance_modifications()</code> to streamline the full process.</p> <p>\u26a0\ufe0f Note: Some functions rely on data only present in real datasets (e.g., CIP codes, OM ratings) and will throw errors if used with fake/generated data.</p>"},{"location":"user-guide/tutorial_5/#takeaway","title":"Takeaway","text":"<p>Understand and validate your input data before modeling. <code>afccp</code> offers robust tools for cleaning, verifying, and  transforming both synthetic and real datasets to prepare them for solution modeling.</p> <p>For an initial overview of the <code>solutions</code> module, continue on to Tutorial 6.</p>"},{"location":"user-guide/tutorial_6/","title":"Tutorial 6: Solutions Overview","text":"<p>As you've seen, <code>afccp</code> requires a substantial amount of data in order to work. All the various parameters, v alue parameters, hyper-parameters, and other \"controls\" are necessary to determine the best solution assignment of  cadets to AFSCs. This is the whole point of afccp: obtain the right solution! This section of the tutorial contains  the information needed for you to calculate different solutions through various algorithms and models.</p>"},{"location":"user-guide/tutorial_6/#solutions-module","title":"<code>solutions</code> Module","text":"<p>The <code>solutions</code> module of afccp contains the scripts and functions that handle the determination of a solution  assignment of cadets to AFSCs. Each script tackles solutions in a different way. At a high-level, the module is set up  as follows:</p> <p> </p> <p>The <code>algorithms</code> module contains the matching algorithms, SOC algorithms, and meta-heuristics that solve this problem.  This is meant to contain all the non-optimization solvers for the problem. Alternatively, <code>optimization</code> contains the  optimization models formulated using the python optimization library <code>pyomo</code>. Pyomo is a great library that  seamlessly links native python language with optimization components. The <code>sensitivity</code> module incorporates the  optimization models to allow for a more algorithmic approach to solving them. We can iterate through different  parameters and solve the models accordingly to provide interesting data perspectives to help inform why the solution  is the way it is. Lastly, <code>handling</code> contains the many functions that all involve handling and processing the  different solutions that are generated. We need to be able to evaluate these solutions and come up with key  metrics that are used to determine which one to implement. </p>"},{"location":"user-guide/tutorial_6/#structure","title":"Structure","text":"<p>Before we dive into the different methods of generating a solution, it's important to discuss what exactly a  solution is, or rather how a solution is represented, in the context of <code>afccp</code>. In the same way that the  parameters (data) can all be extracted from csvs and pulled into python dictionaries, the solutions for a given  instance are also pulled from csvs into a python dictionary. This is where the instance sub-folder  \"5. Analysis &amp; Results\" plays a role.</p> <p> </p> <p>When working with the <code>CadetCareerProblem</code> object, several sub-folders of this folder will be created that hold many of  the visualizations you may be working with. One of the different controls (<code>mdl_p</code>) is the dictionary key \"save\" which  determines whether we should save charts that are created back to your folders. It is defaulted to True which means  that there will be some charts saved into some of these sub-folders already, assuming that you've been following along  with your own code. </p> <p>As mentioned previously, we use dictionaries to hold solutions and solution elements. There are two instance  attributes that contain this information: \"<code>solution</code>\" and \"<code>solutions</code>\". The first, \"<code>solution</code>\", is a dictionary  containing all the components and metrics of the current activated solution. In the same way that we activate a  particular set of <code>value_parameters</code>, we also activate a particular solution to analyze for the problem. The second  attribute \"<code>solutions</code>\" is a dictionary of solution dictionaries. The keys are the names of each solution and the  values are that particular solution's component dictionary. Confusing, yes, but it will hopefully be made clear soon.</p> <pre><code># Re-import Random_1 instance\ninstance = CadetCareerProblem('Random_1')\ninstance.set_value_parameters()\ninstance.update_value_parameters()\ninstance.parameter_sanity_check()\nprint('')  # Add buffer between print statements\n\n# Showing that there currently are no solutions available to this \"Random_1\" instance\nprint(\"Current activated solution (instance.solution):\", instance.solution)\nprint(\"Current set of solutions (instance.solutions):\", instance.solutions)\n</code></pre> \ud83d\udcbb Console Output <pre><code>Importing 'Random_1' instance...\nInstance 'Random_1' initialized.\nSanity checking the instance parameters...\nDone, 0 issues found.\n\nCurrent activated solution (instance.solution): None\nCurrent set of solutions (instance.solutions): None\n</code></pre> <p>We have not yet created any solutions, so none will appear in the \"Analysis &amp; Results\" folder either.  Let's start by creating a random solution and then exporting it back to excel as an example.</p> <pre><code># Generate random solution\ninstance.generate_random_solution()\n\n# Export all data back to excel\ninstance.export_data()\n</code></pre> \ud83d\udcbb Console Output <pre><code>Generating random solution...\nNew Solution Evaluated.\nMeasured exact VFT objective value: 0.4947.\nGlobal Utility Score: 0.4245. 0 / 0 AFSCs fixed. 0 / 0 AFSCs reserved. 0 / 0 alternate list scenarios respected.\nBlocking pairs: 19. Unmatched cadets: 0.\nMatched cadets: 20/20. N^Match: 20. Ineligible cadets: 0.\n\nExporting datasets ['Cadets', 'AFSCs', 'Preferences', 'Goal Programming', 'Value Parameters', 'Solutions', 'Additional', 'Base Solutions', 'Course Solutions']\n</code></pre> <p>If you now look at your Analysis &amp; Results folder, you should have a csv file titled \"Random_1 Solutions.csv\".  This dataset contains a column for the cadet indices (0 through 19 in our case) accompanied by the solution columns  themselves. There could be as many solution columns as desired stored within this dataset. Right now, we have one  solution \"Random\" containing an assortment of randomly selected AFSCs for each cadet.</p> <p> </p> <p>A couple of notes: This is a picture of my randomly generated solution and won't match your output  (it's random, after all)! Additionally, don't confuse the solution name \"Random\" with the instance name  \"Random_1\". We're dealing with a randomly generated problem instance of cadets/AFSCs, and now we've just  introduced our first method of generating a solution: \"Random\"! These are two different random components.  Let's now \"start over\" and re-import the Random_1 problem instance, so we can see how this solution is initially  stored in the <code>CadetCareerProblem</code> object.</p> <pre><code># Re-import \"Random_1\"\ninstance = CadetCareerProblem(\"Random_1\")\n\n# \"Activate\" a particular set of value parameters (since you can have multiple)\ninstance.set_value_parameters(\"VP\")  # There could be \"VP\", \"VP2\", \"VP3\", etc.\n\n# In case you change some parameter that the value parameters depend on\ninstance.update_value_parameters()  # AFSC quotas are a good example here\n\n# Always make sure your data is good to go!\ninstance.parameter_sanity_check()\n</code></pre> \ud83d\udcbb Console Output <pre><code>Importing 'Random_1' instance...\nInstance 'Random_1' initialized.\nSanity checking the instance parameters...\nDone, 0 issues found.\n</code></pre> <p>To hopefully highlight the good practices of working with afccp, I've included the other methods I recommend to have  on here after you import a dataset. This instance now has solution data stored in the Analysis &amp; Results folder,  which is contained in the instance attribute \"solutions\". We have not \"activated\" a solution, however.</p> <pre><code># Showing the names of the solutions we currently have\nprint(\"Names of solutions:\", instance.solutions.keys())\n\n# Contents of the \"Random\" solution\nprint(\"'Random' solution components:\", instance.solutions['Random'].keys())\n\n# Current solution (haven't selected it yet)\nprint(\"Current activated solution components:\", instance.solution)\n</code></pre> \ud83d\udcbb Console Output <pre><code>Names of solutions: dict_keys(['Random'])\n'Random' solution components: dict_keys(['j_array', 'name', 'afsc_array'])\nCurrent activated solution components: None\n</code></pre> <p>You might be wondering why I don't just automatically select \"Random\" as the current solution. When you're doing this  for the real thing, you'll likely be dealing with multiple solutions, and I want you to be sure you know which  solution you're dealing with. That's why I force the analyst to select a specific solution. </p> <pre><code># Select the \"Random\" solution (just like the value parameters)\ninstance.set_solution(\"Random\")  # By default, the first solution is selected if no name is provided\n\n# Current solution\nprint(\"\\nCurrent activated solution components (first 5):\", list(instance.solution.keys())[:5])\n\n# Number of solution components (after evaluating the solution)\nprint(\"Number of solution components:\", len(instance.solution.keys()))\n</code></pre> \ud83d\udcbb Console Output <pre><code>Solution Evaluated: Random.\nMeasured exact VFT objective value: 0.4947.\nGlobal Utility Score: 0.4245. 0 / 0 AFSCs fixed. 0 / 0 AFSCs reserved. 0 / 0 alternate list scenarios respected.\nBlocking pairs: 19. Unmatched cadets: 0.\nMatched cadets: 20/20. N^Match: 20. Ineligible cadets: 0.\n\n\nCurrent activated solution components (first 5): ['j_array', 'name', 'afsc_array', 'x', 'objective_measure']\nNumber of solution components: 76\n</code></pre> <p>When you activate a solution, or generate one for that matter, afccp also evaluates it according to the parameters of  the instance. This is what's happening for the first several lines of output above (before my explicit print statements).  The functions that do this live in <code>afccp.solutions.handling</code>, which I highly encourage you to explore especially if  you're thinking about tracking your own metrics (I already have a lot of them calculated there!). These metrics then  get placed into the solution dictionary, and I've printed the first 5 keys of that dictionary above.  I also highlight the reason I'm only printing the first five by including the total number of solution dictionary  keys right below that!</p> <pre><code># Name of the solution\nprint(\"Name of solution ('name'):\", instance.solution['name'])\n\n# Array of AFSC names that each cadet is assigned to\nprint(\"\\nAFSC names that each cadet is assigned ('afsc_array'):\", instance.solution['afsc_array'])\n\n# Array of AFSC indices that each cadet is assigned to\nprint(\"\\nAFSC indices that each cadet is assigned ('j_array'):\", instance.solution['j_array'])\n\n# Binary X-matrix where the rows are cadets and columns are AFSCs\nprint(\"\\nX-Matrix ('x'):\\n\", instance.solution['x'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>Name of solution ('name'): Random\n\nAFSC names that each cadet is assigned ('afsc_array'): ['R4' 'R4' 'R1' 'R2' 'R4' 'R2' 'R3' 'R2' 'R1' 'R1' 'R1' 'R4' 'R4' 'R3'\n 'R4' 'R1' 'R4' 'R1' 'R4' 'R3']\n\nAFSC indices that each cadet is assigned ('j_array'): [3 3 0 1 3 1 2 1 0 0 0 3 3 2 3 0 3 0 3 2]\n\nX-Matrix ('x'):\n [[0 0 0 1]\n [0 0 0 1]\n [1 0 0 0]\n [0 1 0 0]\n [0 0 0 1]\n [0 1 0 0]\n [0 0 1 0]\n [0 1 0 0]\n [1 0 0 0]\n [1 0 0 0]\n [1 0 0 0]\n [0 0 0 1]\n [0 0 0 1]\n [0 0 1 0]\n [0 0 0 1]\n [1 0 0 0]\n [0 0 0 1]\n [1 0 0 0]\n [0 0 0 1]\n [0 0 1 0]]\n</code></pre> <p>As you can probably tell \"afsc_array\", \"j_array\", and \"x\" all contain the same information just presented in  three different ways. The \"afsc_array\" is what is ultimately stored in the \"Solutions.csv\" file because of its  ease of interpretability. The \"x\" matrix is what optimization models output, and it is how the solution is evaluated  according to the VFT objective hierarchy (which I will describe later). By far my preferred method of representing a  solution, which is used almost everywhere across afccp (outside the two cases I just described), is \"j_array\".  Utilizing the power of numpy indexing allows us to quickly and efficiently extract necessary information from \"j_array\". </p> <pre><code># Array of cadets assigned to each AFSC stored in a dictionary\n{j: np.where(instance.solution['j_array'] == j)[0] for j in instance.parameters['J']}\n</code></pre> \ud83d\udcbb Console Output <pre><code>{0: array([ 2,  8,  9, 10, 15, 17]),\n 1: array([3, 5, 7]),\n 2: array([ 6, 13, 19]),\n 3: array([ 0,  1,  4, 11, 12, 14, 16, 18])}\n</code></pre> <p>I use <code>numpy.where()</code> extensively across <code>afccp</code>, and the above line of code is an example of why I like using  indices. By the way, the above information is already incorporated in the solution dictionary (see below).</p> <pre><code># Array of cadets assigned to each AFSC stored in the \"cadets_assigned\" component\ninstance.solution['cadets_assigned']\n</code></pre> \ud83d\udcbb Console Output <pre><code>{0: array([ 2,  8,  9, 10, 15, 17]),\n 1: array([3, 5, 7]),\n 2: array([ 6, 13, 19]),\n 3: array([ 0,  1,  4, 11, 12, 14, 16, 18])}\n</code></pre> <p>For more information on what specifically the code currently tracks, I again invite you to look at the functions in  <code>afccp.solutions.handling</code>. Specifically, the  <code>evaluate_solution</code> function is the main function that obtains this information. </p> <p>The convention I use when determining solution names is to incorporate both the solution method and iteration.  The only method I've discussed thus far is \"Random\", which is why the current solution is called \"Random\".  I've only generated one random solution too. By default, the first solution you generate through whatever method will  simply be named using that method. If I were to generate a second solution, it would be called \"Random_2\" (see below).</p> <pre><code># Generate another random solution\ninstance.generate_random_solution()\n\n# Current activated solution name\nprint(\"\\nCurrent activated solution name:\", instance.solution['name'])\n\n# Current solutions available\nprint(\"Curretn solutions available:\", instance.solutions.keys())\n</code></pre> \ud83d\udcbb Console Output <pre><code>Generating random solution...\nNew Solution Evaluated.\nMeasured exact VFT objective value: 0.5456.\nGlobal Utility Score: 0.588. 0 / 0 AFSCs fixed. 0 / 0 AFSCs reserved. 0 / 0 alternate list scenarios respected.\nBlocking pairs: 13. Unmatched cadets: 0.\nMatched cadets: 20/20. N^Match: 20. Ineligible cadets: 0.\n\n\nCurrent activated solution name: Random_2\nCurretn solutions available: dict_keys(['Random', 'Random_2'])\n</code></pre> <p>In the same way I check if a set of value parameters is unique, I also make sure a new solution is unique too.  There is a very low probability that two randomly generated solutions are the same, but if that did happen we wouldn't  see a \"Random_2\" solution above. Instead, the code would simply kick back the \"Random\" solution as the current  solution since it is equivalent to the new one. This does play a critical role with the deterministic models/algorithms  you will see soon as I don't want many copies of the same solution being depicted as unique.</p>"},{"location":"user-guide/tutorial_6/#summary","title":"\ud83d\udccc Summary","text":"<p>Tutorial 6 introduces how the <code>afccp</code> framework handles solutions\u2014the assignment of cadets to AFSCs  based on value parameters, optimization criteria, and algorithmic controls. It explains the structure of the  <code>solutions</code> module within <code>afccp</code>, which includes submodules for algorithms, optimization, sensitivity analysis, and  solution handling.</p> <p>The tutorial guides you through:</p> <ul> <li>Generating random solutions and exporting them to Excel.</li> <li>Understanding the format of solution dictionaries (<code>solution</code> and <code>solutions</code>) and their components.</li> <li>Activating and evaluating a solution using the <code>CadetCareerProblem</code> object.</li> <li>Comparing different solution representations: <code>afsc_array</code>, <code>j_array</code>, and the binary assignment matrix <code>x</code>.</li> <li>Exploring how metrics and analytics (like blocking pairs and global utility) are computed and stored.</li> <li>Naming conventions and uniqueness checks for solutions.</li> </ul> <p>You also learn about the role of the <code>\"5. Analysis &amp; Results\"</code> folder for storing evaluated outputs and how to inspect  solution quality programmatically. Continue on to Tutorial 7 to dive into the  algorithms &amp; meta-heuristics of <code>afccp</code>.</p>"},{"location":"user-guide/tutorial_7/","title":"Tutorial 7: Algorithms","text":"<p>Now that we've discussed how a solution is represented in the data and stored within the <code>CadetCareerProblem</code> object,  we can talk about the methods of generating solutions (ones that are hopefully a bit better than throwing darts at the  board with the \"Random\" method). The first series of solution techniques I'll describe are matching algorithms. </p>"},{"location":"user-guide/tutorial_7/#matching-algorithms","title":"Matching Algorithms","text":"<p>Matching algorithms encompass the various methods of assignment by which we don't incorporate any sort of optimization  framework. The first of which is the classic \"Hospital/Residents\" (HR) deferred acceptance algorithm (DAA). </p>"},{"location":"user-guide/tutorial_7/#classic-hr","title":"Classic HR","text":"<p>We formulate the AFSC/Cadet matching problem as a Hospital/Residents problem where each entity possesses an ordinal  preference list for members of the other. It's a simple algorithm, and the function itself is  <code>classic_hr()</code>.</p> <pre><code># Run the \"Classic HR\" algorithm on the \"Random_1\" instance\ns = instance.classic_hr({'ma_printing': True})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Modeling this as an H/R problem and solving with DAA...\n\nIteration 1\nProposals: {'R1': 9, 'R2': 3, 'R3': 6, 'R4': 2}\nMatched {'R1': 9.0, 'R2': 3.0, 'R3': 3.0, 'R4': 2.0}\nRejected {'R1': 0.0, 'R2': 0.0, 'R3': 3.0, 'R4': 0.0}\n\nIteration 2\nProposals: {'R1': 11, 'R2': 3, 'R3': 3, 'R4': 3}\nMatched {'R1': 9.0, 'R2': 3.0, 'R3': 3.0, 'R4': 3.0}\nRejected {'R1': 2.0, 'R2': 0.0, 'R3': 3.0, 'R4': 0.0}\n\nIteration 3\nProposals: {'R1': 9, 'R2': 5, 'R3': 3, 'R4': 3}\nMatched {'R1': 9.0, 'R2': 5.0, 'R3': 3.0, 'R4': 3.0}\nRejected {'R1': 2.0, 'R2': 0.0, 'R3': 3.0, 'R4': 0.0}\nNew Solution Evaluated.\nMeasured exact VFT objective value: 0.8777.\nGlobal Utility Score: 0.8158. 0 / 0 AFSCs fixed. 0 / 0 AFSCs reserved. 0 / 0 alternate list scenarios respected.\nBlocking pairs: 0. Unmatched cadets: 0.\nMatched cadets: 20/20. N^Match: 20. Ineligible cadets: 0.\n</code></pre> <p>The \"ma_printing\" parameter controls whether the algorithm should print iteration-specific information  (it's defaulted to False). As you can see, with 20 cadets and 4 AFSCs this is a pretty short algorithm.  With my particular randomly generated cadets, only three cadets were rejected in iteration 1 (all by R3).  In the second iteration, two of these cadets propose to R1 and one proposes to R4. The two proposing to R1 are then  rejected by R1 while the 1 proposing to R4 is accepted. Finally, in the third iteration those two cadets both propose and are accepted by R2 and the algorithm concludes.</p> <pre><code># Current solution (HR)\nprint(\"Solution Name:\", instance.solution['name'])\nprint(\"Solution Array:\", instance.solution['afsc_array'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>Solution Name: HR\nSolution Array: ['R1' 'R1' 'R2' 'R2' 'R1' 'R1' 'R2' 'R1' 'R1' 'R4' 'R4' 'R2' 'R3' 'R1' 'R2' 'R1' 'R3' 'R3' 'R1' 'R4']\n</code></pre>"},{"location":"user-guide/tutorial_7/#soc-rated-algorithm","title":"SOC Rated Algorithm","text":"<p>One very important solution technique we need to address is the specific rated algorithm we employ to pre-process  cadets into rated career fields in the spirit of the DAA. Although the DAA in its true form does not work for all  career fields across the Air &amp; Space Force (due to degree requirements and popularity issues), it does work really  well if we use it on the rated career fields in a unique way. Pilot, and the other three rated career fields to a  lesser extent, is a very \"political\" career field and one that must be handled with great care. Any kind of matches  are fair game in an optimization model, and people don't always get matched to their desired career fields in order of  merit unless we explicitly enforce it. One huge benefit of the DAA is that it's simple and defendable. It is fair to  all cadets by directly adhering to the career field rankings. Because we want a defendable solution (especially when  it comes to pilot), we apply the DAA to rated cadets from both SOCs to constrain AFSCs for cadets based on what  they would have received as a result of the \"complete\" DAA.</p> <p>As discussed, this algorithm strips out all non-rated AFSC choices and purely looks at the rated choices,  ordered amongst themselves. We then run the DAA, matching cadets to their rated AFSCs from each SOC honoring their  specific rated PGL targets. If the DAA matches a cadet to a rated AFSC that was also their true first choice then that cadet is definitively matched to that AFSC. If the cadet is matched to a rated AFSC but that AFSC was not their  first choice, we reserve that slot for them but allow them to compete in the optimization model for their more  desired AFSCs. To apply this methodology, we run the <code>soc_rated_matching_algorithm()</code> function for each SOC. We'll show this method for ROTC first:</p> <pre><code># Run the SOC rated algorithm for ROTC\ns = instance.soc_rated_matching_algorithm({\"soc\": \"rotc\", \"ma_printing\": True})  # \"s =\" prevents lots of output\n</code></pre> \ud83d\udcbb Console Output <pre><code>Solving the rated matching algorithm for ROTC cadets...\n\nIteration 1\nProposals: {'R2': 6, 'R4': 6}\nMatched {'R2': 4, 'R4': 2}\nRejected {'R2': 2, 'R4': 4}\n\nIteration 2\nProposals: {'R2': 6, 'R4': 4}\nMatched {'R2': 4, 'R4': 2}\nRejected {'R2': 4, 'R4': 6}\n</code></pre> <p>As you can see from the output, we're evaluating three new solutions. I use the solutions dictionary to store my  results from the rated algorithm for both SOCs. One solution contains the information on cadets with reserved slots  for rated AFSCs, one solution contains the information on cadets that were definitively matched to a rated AFSC,  and the last one simply combines the two. You can see these solutions below for ROTC:</p> <pre><code>for s_name in instance.solutions:\n\n    if \"Rated\" in s_name:\n        print(\"Solution name: '\" + s_name + \"'\")\n        print(\"Solution:\", instance.solutions[s_name]['afsc_array'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>Solution name: 'Rated ROTC HR (Reserves)'\nSolution: ['*' '*' '*'  '*' '*' '*' '*' 'R2' '*' '*' '*' 'R2' 'R2' '*' '*' '*' '*' '*' 'R4' '*' ]\nSolution name: 'Rated ROTC HR (Matches)'\nSolution: ['*' '*' 'R2' '*' '*' '*' '*' '*'  '*' '*' '*' '*'  '*'  '*' '*' '*' '*' '*' '*'  'R4']\nSolution name: 'Rated ROTC HR'\nSolution: ['*' '*' 'R2' '*' '*' '*' '*' 'R2' '*' '*' '*' 'R2' 'R2' '*' '*' '*' '*' '*' 'R4' 'R4']\n</code></pre> <p>In my simple \"Random_1\" data example, we have two rated AFSCs: R2 and R4. There are 4 ROTC slots for R2 and 2 ROTC  slots for R4. The cadet at index 2 and the cadet at index 19 both had R2 and R4, respectively, as their first choice  AFSCs. Therefore, they are matched to those AFSCs. The other 4 cadets are reserved for these rated AFSCs. Also in my data example, USAFA has 1 slot for R2 and doesn't have any slots for R4, so that algorithm isn't as useful. We still need to run it to have the required components, however!</p> <pre><code>print(\"USAFA Targets:\", {p['afscs'][j]: p['usafa_quota'][j] for j in p['J']})  # None for R4!\nprint(\"ROTC Targets:\", {p['afscs'][j]: p['rotc_quota'][j] for j in p['J']})  # 2 for R4!\nprint(\"\")  # just adding a space\n\n# Run the USAFA rated algorithm\ns = instance.soc_rated_matching_algorithm({\"soc\": \"usafa\", \"ma_printing\": True})  # \"s =\" prevents lots of output\n</code></pre> \ud83d\udcbb Console Output <pre><code>USAFA Targets: {'R1': 1.0, 'R2': 1.0, 'R3': 0.0, 'R4': 0.0}\nROTC Targets: {'R1': 7.0, 'R2': 4.0, 'R3': 2.0, 'R4': 2.0}\n\nSolving the rated matching algorithm for USAFA cadets...\n\nIteration 1\nProposals: {'R2': 5, 'R4': 2}\nMatched {'R2': 1, 'R4': 0}\nRejected {'R2': 4, 'R4': 2}\n\nIteration 2\nProposals: {'R2': 2, 'R4': 2}\nMatched {'R2': 1, 'R4': 0}\nRejected {'R2': 5, 'R4': 4}\n</code></pre> <p>We've now run these two algorithms (USAFA/ROTC) and can incorporate their information into our instance parameters.  This will be used later on within the optimization models, but worth discussing here. In order to incorporate these  solutions into the parameters, we need to call the  <code>incorporate_rated_results_in_parameters()</code>  function!</p> <pre><code># Integrate the Rated algorithm solutions into \"instance.parameters\" \ninstance.incorporate_rated_algorithm_results()\n</code></pre> \ud83d\udcbb Console Output <pre><code>Incorporating rated algorithm results...\nRated SOC Algorithm Results:\nUSAFA Fixed Cadets: 1, USAFA Reserved Cadets: 0, ROTC Fixed Cadets: 2, ROTC Reserved Cadets: 4\nUSAFA Rated Alternates: 0, ROTC Rated Alternates: 7\n</code></pre> <p>This creates two new dictionaries: \"J^Fixed\" and \"J^Reserved\". They are used to constrain the available AFSCs for  each cadet as a result of the SOC-specific rated DAA described above.</p> <pre><code># 3 cadets are fixed to AFSCs. Ex: Cadet 14 must be matched to the AFSC at index 1 (R2)\nprint(\"'J^Fixed':\", instance.parameters['J^Fixed'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>'J^Fixed': {14: 1, 2: 1, 19: 3}\n</code></pre> <p>\"J^Fixed\" is a dictionary where the keys are the cadets with \"fixed\" AFSCs and the values are the AFSC indices that  they are fixed to. In a similar, but slightly different way, \"J^Reserved\" is a dictionary where the keys are the  cadets with \"reserved\" AFSCs. For each key here, however, the value is an ordered list of the cadet's preferences up  to and including the rated AFSC they're reserved for. This ensures that the cadet receives one of these AFSCs, since  the rated AFSC is reserved for them.</p> <pre><code># Cadet 3 must receive either AFSC 0 (R1), 2 (R3), or 3 (R4) -&gt; R4 is reserved for them\nprint(\"'J^Reserved':\", instance.parameters['J^Reserved'])\n</code></pre> \ud83d\udcbb Console Output <pre><code>'J^Reserved': {7: array([0, 3, 2, 1]), 11: array([0, 1]), 12: array([2, 0, 1]), 18: array([0, 3])}\n</code></pre>"},{"location":"user-guide/tutorial_7/#soc-rated-algorithm-alternates","title":"SOC Rated Algorithm-Alternates","text":"<p>One thing I haven't mentioned yet is how we give even more special attention to rated AFSCs with an  \"alternate list\" idea. The fixed/reserved slot idea works really well to \"protect\" those individuals that would get  rated slots based purely on their rated OM, by giving them a chance to get their more preferred AFSC.  If they don't get that more preferred AFSC, they have their reserved rated AFSC to fall back on. What this current  methodology does not address, however, is who back-fills those reserved slots. To do this, we have to run a separate  algorithm to determine who is on each alternate list for each SOC. Essentially, we want to know who is \"next in line\"  to receive each of the rated AFSCs. These individuals just missed the cutoff to be a reserved/fixed cadet for that AFSC. </p> <p>The SOC rated matching algorithm must be run once, and then every time we execute  <code>instance.incorporate_rated_results_in_parameters()</code>,  the alternate list sets and parameters are added by default. </p> <pre><code># These are the default controls, so alternate lists should always be included unless otherwise specified!\ninstance.incorporate_rated_algorithm_results({'rated_alternates': True,\n                                              'alternate_list_iterations_printing': False})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Incorporating rated algorithm results...\nRated SOC Algorithm Results:\nUSAFA Fixed Cadets: 1, USAFA Reserved Cadets: 0, ROTC Fixed Cadets: 2, ROTC Reserved Cadets: 4\nUSAFA Rated Alternates: 0, ROTC Rated Alternates: 7\n</code></pre> <p>If we want to see the rated alternate algorithm a little more clearly, we can toggle the  \"alternate_list_iterations_printing\" parameter.</p> <pre><code># These are the default controls, so alternate lists should always be included unless otherwise specified!\ninstance.incorporate_rated_algorithm_results({'alternate_list_iterations_printing': True})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Incorporating rated algorithm results...\n\nSOC: USAFA\n\nIteration 0\nPossible {'R2': 0, 'R4': 0}\nMatched {'R2': 1, 'R4': 0}\nReserved {'R2': 0, 'R4': 0}\nAlternates (Hard) {'R2': 0, 'R4': 0}\nAlternates (Soft) {'R2': 0, 'R4': 0}\nIteration 1\nPossible {'R2': 0, 'R4': 0}\nMatched {'R2': 1, 'R4': 0}\nReserved {'R2': 0, 'R4': 0}\nAlternates (Hard) {'R2': 0, 'R4': 0}\nAlternates (Soft) {'R2': 0, 'R4': 0}\n\nSOC: ROTC\n\nIteration 0\nPossible {'R2': 4, 'R4': 6}\nMatched {'R2': 1, 'R4': 1}\nReserved {'R2': 3, 'R4': 1}\nAlternates (Hard) {'R2': 0, 'R4': 0}\nAlternates (Soft) {'R2': 4, 'R4': 6}\nIteration 1\nPossible {'R2': 4, 'R4': 6}\nMatched {'R2': 1, 'R4': 1}\nReserved {'R2': 3, 'R4': 1}\nAlternates (Hard) {'R2': 0, 'R4': 0}\nAlternates (Soft) {'R2': 4, 'R4': 6}\nRated SOC Algorithm Results:\nUSAFA Fixed Cadets: 1, USAFA Reserved Cadets: 0, ROTC Fixed Cadets: 2, ROTC Reserved Cadets: 4\nUSAFA Rated Alternates: 0, ROTC Rated Alternates: 7\n</code></pre> <p>Nothing really happens here as a product of the randomness in this small example. Effectively, the rated alternates' algorithm addition provides the set of cadet-AFSC pairs that must not form blocking pairs. In the optimization models, these cadet-AFSC pairs are provided special blocking pair constraints, enforcing the \"alternate list\" concept.</p>"},{"location":"user-guide/tutorial_7/#rotc-rated-board-original-algorithm","title":"ROTC Rated Board Original Algorithm","text":"<p>This one is not too important anymore, but it is included in the code since it helped my case to convince ROTC that  this new rated algorithm was a good idea. I'm not going to discuss it too much, but it uses the ROTC rated OM  dataset and the rotc rated interest dataset: Random_1 ROTC Rated Interest.csv. Their board then commenced in  different phases and if you're really interested I suggest you read the  <code>rotc_rated_board_original()</code> function and then reach out with questions if it's still unclear!</p> <pre><code># Run the algorithm\ns = instance.rotc_rated_board_original()  # \"s =\" prevents lots of output\n</code></pre> \ud83d\udcbb Console Output <pre><code>Running status quo ROTC rated algorithm...\n\nPhase 1 High OM &amp; High Interest\nR2 Phase Matched: 2   ---&gt;   Total Matched: 2 / 4.0\nR4 Phase Matched: 2   ---&gt;   Total Matched: 2 / 2.0\n\nPhase 2 High OM &amp; Med Interest\nR2 Phase Matched: 2   ---&gt;   Total Matched: 4 / 4.0\nNew Solution Evaluated.\nMeasured exact VFT objective value: 0.3705.\nGlobal Utility Score: 0.6372. 3 / 3 AFSCs fixed. 3 / 4 AFSCs reserved. 6 / 7 alternate list scenarios respected.\nBlocking pairs: 19. Unmatched cadets: 14.\nMatched cadets: 6/20. N^Match: 20. Ineligible cadets: 0.\n</code></pre> <p>Now that we've incorporated the rated algorithm results within our parameters, you'll notice the solution evaluation  output reflects that we should have three cadets with fixed AFSCs and four cadets with reserved AFSCs.  In the original rated board algorithm we just ran, one of those constraints was adequately met and the other wasn't.  Additionally, we have adequately met 6/7 of the alternate cases, meaning there is still one rated cadet-AFSC blocking pair which is in violation of the alternate list concept.</p>"},{"location":"user-guide/tutorial_7/#meta-heuristics","title":"Meta-heuristics","text":"<p>This section describes the meta-heuristics we have to solve the problem. Meta-heuristics refer to solution  techniques that use unconventional algorithms to solve optimization models. They are typically meant for really  complicated optimization models that are too computationally expensive to solve with a conventional \"global\" solver.  Right now, the only meta-heuristic I have in the code is the genetic algorithm (GA). Genetic algorithms are great methods of finding initial solutions that are then \"evolved\" into better and better solutions. This algorithm is  currently used in conjunction with the VFT pyomo model (specifically, the \"Approximate Model\" I discuss in my thesis)  to get closer to the optimal solution since I don't currently have a method of finding the global optimal solution to the VFT \"Exact Model\". If these terms are confusing, please reference section 3.4.1 of my master's thesis.</p>"},{"location":"user-guide/tutorial_7/#vft-genetic-algorithm","title":"VFT Genetic Algorithm","text":"<p>For more information on this algorithm specifically, you can find it here:  <code>vft_genetic_algorithm()</code>.  One big note here is that I haven't found a good way of reconciling the many constraints of the optimization model(s)  with the GA. When we were just solving the NRL process, before combining Rated and USSF for FY2024 (so just for 2023  really), the only constraints I had placed were the AFSC objective constraints and some cadet utility constraints  (top 10%). I will describe how these constraints are handled later on using the \"con_fail_dict\" (constraint fail  dictionary). This is the reason why there are initially a lot of 0s in the initial population of solutions below  (constraint violations result in a fitness score of 0). Since this is a small &amp; simple example, however, we quickly  determine feasible solutions right out the gate.</p> <pre><code># Solve the GA using the VFT objective function as the fitness function\ns = instance.vft_genetic_algorithm({\"initialize\": False, \"ga_max_time\": 20})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Running Genetic Algorithm with no initial solutions (not advised!)...\nInitial Fitness Scores [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n10% complete. Best solution value: 0.7579\nAverage evaluation time for 12 solutions: 0.0143 seconds.\nAverage generation time: 0.0156 seconds.\n20% complete. Best solution value: 0.7794\nAverage evaluation time for 12 solutions: 0.013 seconds.\nAverage generation time: 0.0141 seconds.\n30% complete. Best solution value: 0.7794\nAverage evaluation time for 12 solutions: 0.0128 seconds.\nAverage generation time: 0.0139 seconds.\n40% complete. Best solution value: 0.8029\nAverage evaluation time for 12 solutions: 0.0125 seconds.\nAverage generation time: 0.0136 seconds.\n50% complete. Best solution value: 0.8129\nAverage evaluation time for 12 solutions: 0.0123 seconds.\nAverage generation time: 0.0134 seconds.\n60% complete. Best solution value: 0.8129\nAverage evaluation time for 12 solutions: 0.0125 seconds.\nAverage generation time: 0.0134 seconds.\n70% complete. Best solution value: 0.8129\nAverage evaluation time for 12 solutions: 0.0125 seconds.\nAverage generation time: 0.0136 seconds.\n80% complete. Best solution value: 0.8129\nAverage evaluation time for 12 solutions: 0.0125 seconds.\nAverage generation time: 0.0135 seconds.\n90% complete. Best solution value: 0.8129\nAverage evaluation time for 12 solutions: 0.0123 seconds.\nAverage generation time: 0.0134 seconds.\n100% complete. Best solution value: 0.8129\nAverage evaluation time for 12 solutions: 0.0123 seconds.\nAverage generation time: 0.0134 seconds.\nEnd time reached in 20.01 seconds.\nNew Solution Evaluated.\nMeasured exact VFT objective value: 0.8129.\nGlobal Utility Score: 0.7814. 3 / 3 AFSCs fixed. 4 / 4 AFSCs reserved. 7 / 7 alternate list scenarios respected.\nBlocking pairs: 6. Unmatched cadets: 0.\nMatched cadets: 20/20. N^Match: 20. Ineligible cadets: 0.\n</code></pre>"},{"location":"user-guide/tutorial_7/#genetic-matching-algorithm","title":"Genetic Matching Algorithm","text":"<p>Ian Macdonald had the idea to create a GA in order to iteratively determine the optimal capacities for each AFSC to  find a solution that is as stable as possible. This algorithm works if we have a designated range on the number of  cadets for each AFSC. Essentially, we need a sizeable \"surplus\" of cadets above the PGL targets. For sake of time,  I won't go into too much detail here but the algorithm is shown below.</p> <pre><code># Because this is a small/easy problem, we easily find a stable solution! (GMA isn't necessary)\ns = instance.genetic_matching_algorithm({'gma_printing': True})  # Turns on print statements for the GMA\n</code></pre> \ud83d\udcbb Console Output <pre><code>Generation 0 Fitness [0. 0. 0. 1.]\nFinal capacities: [9. 9. 2. 3.]\nModeling this as an H/R problem and solving with DAA...\nNew Solution Evaluated.\nMeasured exact VFT objective value: 0.8425.\nGlobal Utility Score: 0.7998. 3 / 3 AFSCs fixed. 4 / 4 AFSCs reserved. 7 / 7 alternate list scenarios respected.\nBlocking pairs: 0. Unmatched cadets: 0.\nMatched cadets: 20/20. N^Match: 20. Ineligible cadets: 0.\n</code></pre>"},{"location":"user-guide/tutorial_7/#summary","title":"\ud83d\udccc Summary","text":"<p>Tutorial 7 dives into the algorithmic backbone of how <code>afccp</code> generates cadet-to-AFSC assignments.  It introduces a variety of algorithmic approaches\u2014both matching-based and meta-heuristic\u2014that serve as the  foundation for feasible and defensible solutions before any optimization model is solved.</p> <p>The tutorial walks through:</p> <ul> <li>Classic matching algorithms like Deferred Acceptance (DAA) using the Hospital/Residents (HR) formulation.</li> <li>SOC-specific Rated Matching Algorithms that pre-process cadets into fixed or reserved rated slots to ensure fairness and defendability\u2014particularly for pilot and other rated fields.</li> <li>How to incorporate fixed/reserved/alternate outcomes from the rated matching into the <code>CadetCareerProblem</code> parameters for use in optimization models.</li> <li>The structure and purpose of alternate lists: identifying cadets who just missed a rated assignment.</li> <li>The legacy ROTC Rated Board algorithm used to demonstrate improvements over prior processes.</li> </ul> <p>It then transitions to meta-heuristic methods like:</p> <ul> <li>The <code>vft_genetic_algorithm()</code>\u2014a genetic algorithm designed to navigate complex constraints in the VFT (Value-Focused Thinking) optimization model.</li> <li>The <code>genetic_matching_algorithm()</code>\u2014which uses evolutionary logic to discover AFSC capacities that yield the most stable HR solution.</li> </ul> <p>These methods lay the groundwork for solving more advanced optimization models under real-world constraints.  Continue on to Tutorial 8 to learn how these results integrate into the full optimization pipeline of <code>afccp</code>.</p>"},{"location":"user-guide/tutorial_8/","title":"Optimization","text":"<p>This section is here to describe the various optimization model components we have to solve the <code>CadetCareerProblem</code>.  At the time I'm writing this tutorial, the VFT methodology doesn't work on the current combined classification  problem (Rated, USSF, NRL). The model used now and for the foreseeable future is the GUO model. This is the global utility optimization model that OLEA has advertised, and it's represented in the code as the  \"assignment problem model\". We'll discuss that soon.</p>"},{"location":"user-guide/tutorial_8/#vft-model","title":"VFT Model","text":"<p>For more information on the VFT model, please review my thesis.  It describes in detail the difference between the \"Approximate\" model and the \"Exact\" model. The VFT model was my main focus while at AFIT, and I've summarized that work through this poster:</p> <p> </p> <p>Here, I will solve this random instance using both the \"Approximate\" model and the \"Exact\" model.</p> <pre><code># Solve with the \"Approximate\" model  (These three controls I've added are also the defaults!)\ns = instance.solve_vft_pyomo_model({\"approximate\": True, \"pyomo_max_time\": 10, \"solver_name\": \"cbc\"})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Building VFT Model...\nSolving Approximate VFT Model instance with solver cbc...\nStart Time: June 09 2025 01:56:48 PM.\n\u2705 Solver complete: |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0%              \nModel solved in 7.04 seconds at June 09 2025 01:56:55 PM. Pyomo reported objective value: 0.8883\nNew Solution Evaluated.\nMeasured exact VFT objective value: 0.8969.\nGlobal Utility Score: 0.7988. 3 / 3 AFSCs fixed. 4 / 4 AFSCs reserved. 7 / 7 alternate list scenarios respected.\nBlocking pairs: 2. Unmatched cadets: 0.\nMatched cadets: 20/20. N^Match: 20. Ineligible cadets: 0.\n</code></pre> <pre><code># Solve with the \"Exact\" model (On a small problem, this actually works quite well!)\ns = instance.solve_vft_pyomo_model({\"approximate\": False, \"pyomo_max_time\": 20, \"solver_name\": \"ipopt\"})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Building VFT Model...\nSolving Exact VFT Model instance with solver ipopt...\nStart Time: June 09 2025 01:56:33 PM.\n\u2705 Solver complete: |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0%              \nModel solved in 3.03 seconds at June 09 2025 01:56:36 PM. Pyomo reported objective value: 0.9445\nNew Solution Evaluated.\nMeasured exact VFT objective value: 0.8885.\nGlobal Utility Score: 0.8291. 3 / 3 AFSCs fixed. 4 / 4 AFSCs reserved. 7 / 7 alternate list scenarios respected.\nBlocking pairs: 1. Unmatched cadets: 0.\nMatched cadets: 20/20. N^Match: 20. Ineligible cadets: 0.\n</code></pre> <pre><code>instance.solutions.keys()\n</code></pre> \ud83d\udcbb Console Output <pre><code>dict_keys(['Random', 'Random_2', 'HR', 'Rated ROTC HR (Reserves)', 'Rated ROTC HR (Matches)', 'Rated ROTC HR', 'Rated USAFA HR (Reserves)', 'Rated USAFA HR (Matches)', 'Rated Matches', 'Rated Alternates (Hard)', 'Rated Alternates (Soft)', 'ROTCRatedBoard', 'VFT_Genetic', 'A-VFT', 'E-VFT'])\n</code></pre> <p>We just solved the VFT model twice (once with the \"Approximate Model\" and another with the \"Exact Model\").  As you can probably tell, both solutions are represented from two different methods: \"A-VFT\" and \"E-VFT\".  I'll let you guess which one is which. Since it is a very small problem, they both do exactly what they're  supposed to: the Exact model finds the optimal solution to the \"real\" (Exact) VFT objective function  (beating the Approximate model) and they both produce integer solutions (something that isn't true when the problem  gets bigger). Additionally, these models are deterministic, meaning they will produce the same solution every time.  This is not true for the GA solutions!</p> <p>\ud83d\udca1 Calculations are off</p> <p>When I was working through my thesis, I was very meticulous to ensure all the calculations were correct and my own method of evaluating solutions with the <code>evaluate_solution()</code> function would perfectly match the objective value produced by <code>pyomo</code>. As you can see from above, this does not seem to be the case. To be honest I don't know why the VFT model is not the same but I don't have the time to explore this issue again. I DO know, however, that the GUO values do match up with what pyomo calculates! Just not the VFT one.</p> <p>The next section describes my VFT methodology using the Approximate model.</p>"},{"location":"user-guide/tutorial_8/#vft-main-methodology","title":"VFT Main Methodology","text":"<p>I had this weird \"con_fail_dict\" (constraint fail dictionary) feature of the model to allow some AFSC objective constraints to be broken by AT MOST the amount they were broken as a product of the non-integer pyomo output of the VFT Approximate Model. This will be made more clear in the third bullet below.</p> <p>My current pyomo VFT model does not produce integer solutions using cbc. I really don't understand why this is and it's certainly the motivation for future AFIT research using that model. My methodology that I came up with (only for NRL cadets/AFSCs at the time) is as follows:</p> <ol> <li> <p>[Solve the VFT Model] Solve the VFT Approximate Model for 10 seconds using the cbc solver. The time limit of 10 seconds allows us to find a pretty good solution (not optimal, but close-ish enough) to the Exact Model. As a reminder, the Exact Model is the real objective function using the true number of assigned cadets, whereas the Approximate Model approximates that number (specifically, it uses the \"Estimated\" number of cadets from AFSCs.csv). The optimal solution to the Approximate Model, therefore, is not the optimal solution to the Exact Model. One other reason to cut the Approximate Model short is that we were never going to find the optimal solution to the \"real\" problem anyway! </p> </li> <li> <p>[Round the \\(X\\) variables] Ok, so as a result of stopping it at 10 seconds we don't get integer values for all the variables we need. I therefore have to round them to make sure cadets receive one and only one AFSC. By doing this, I am oftentimes breaking constraints. This was generally ok, however, since constraints were primarily meant as guidelines to ensure quality distributions across AFSCs. The class of 2023 and 2024 were very different problems in many ways, and the fact that we had ~150 extra cadets above the PGL in 2023 allowed for this to be less of an issue. Since we're 4 short in 2024, rounding these variables could have produced other problems.</p> </li> <li> <p>[Create \"con_fail_dict\"] As mentioned previously, this constraint fail dictionary was used to determine the extent to which we broke the AFSC objective constraints from whatever solution(s) pyomo produced. This dictionary is then used in the GA to allow more flexibility when evaluating the solutions (or \"chromosomes\") fitness values. Fitness is based directly on the true (Exact, not Approximate) VFT objective function, and constraint violations result in a fitness score of 0. I played around with providing a tolerance but ultimately decided to aggressively restrict constraint violations. This is why con_fail_dict is so important, since it allows the initial solutions to be feasible. </p> </li> <li> <p>[Initialize GA Population] In my \"real\" solution methodology, I solve the VFT model several different times with slightly different settings on the overall weights for cadets/AFSCs. This essentially creates my initial population of solutions that I use to then create the \"con_fail_dict\" from. These solutions are then fed into the GA.</p> </li> <li> <p>[Run GA] </p> </li> </ol>"},{"location":"user-guide/tutorial_8/#assignment-problem-model-global-utility-optimization-guo","title":"\ud83e\uddee Assignment Problem Model- \"Global Utility Optimization\" (GUO)","text":"<p>The GUO model refers to solving the generalized assignment problem formulation that seeks the optimal assignment of  a set of \\(n\\) workers, \\(\\mathcal{I}\\), to a set of \\(m\\) jobs, \\(\\mathcal{J}\\), such that the total cost is minimized. Let:</p> <ul> <li>\\(c_{ij}\\) = cost of assigning worker \\(i\\) to job \\(j\\)</li> <li>\\(d_j\\) = capacity of job \\(j\\)</li> <li>\\( x_{ij} = \\text{1 if worker } i \\text{ is assigned to job } j; \\text{ 0 otherwise} \\)</li> </ul>"},{"location":"user-guide/tutorial_8/#objective-simplified","title":"Objective (Simplified):","text":"<p>Minimize total cost:</p> \\[ \\min \\sum_{i=1}^{n} \\sum_{j=1}^{m} c_{ij} x_{ij} \\]"},{"location":"user-guide/tutorial_8/#subject-to-simplified","title":"Subject to (Simplified):","text":"<p>Each worker is assigned to exactly one job:</p> \\[ \\sum_{j=1}^{m} x_{ij} = 1 \\quad \\forall i \\in \\{1, \\dots, n\\} \\] <p>Each job does not surpass its capacity:</p> \\[ \\sum_{i=1}^{n} x_{ij} \\leq d_j \\quad \\forall j \\in \\{1, \\dots, m\\} \\] <p>Binary constraints:</p> \\[ x_{ij} \\in \\{0, 1\\} \\quad \\forall i \\in \\mathcal{I}, j \\in \\mathcal{J} \\] <p>Again, this is the \"generalized\" formulation of this academic problem. Like the \"original model\" (the model AFPC used  up until the class of 2023), there are many additional constraints that can be added to this model. The addition of  these constraints is one key difference between \"GUO\" in our context and the generalized framework. Another key  difference is the utility matrix itself. Unlike the original AFPC model, this \"new\" utility matrix is much more direct  with its representation of quality for the career fields. This is the merged cadet/AFSC <code>global_utility</code> matrix  I've referenced in the Data section of this tutorial. Quick note: rather than a \"min cost\" function, it's a  \"max utility\" function. This is a small, but necessary, clarification!</p> <pre><code># Solve the GUO model!\ns = instance.solve_guo_pyomo_model()\n</code></pre> \ud83d\udcbb Console Output <pre><code>Building assignment problem (GUO) model...\nDone. Solving model...\nSolving GUO Model instance with solver cbc...\nStart Time: June 09 2025 03:15:04 PM.\nModel solved in 0.21 seconds at June 09 2025 03:15:05 PM. Pyomo reported objective value: 0.8364\nNew Solution Evaluated.\nMeasured exact VFT objective value: 0.8718.\nGlobal Utility Score: 0.8364. 3 / 3 AFSCs fixed. 4 / 4 AFSCs reserved. 7 / 7 alternate list scenarios respected.\nBlocking pairs: 4. Unmatched cadets: 0.\nMatched cadets: 20/20. N^Match: 20. Ineligible cadets: 0.\n</code></pre> <p>As you can see, it solves very fast on a small problem! On a larger problem, too, it still solves pretty quickly.  Although the value functions and weights from the VFT model aren't used in the GUO model, the constraints certainly are!  The value parameters, therefore, are still very important in this model as they control the constraints applied to the  problem. This model can be found in the  <code>assignment_model_build()</code> function. If you look at that function, you can see an additional  <code>common_optimization_handling()</code>  function that does exactly what it sounds like: handles the features of the pyomo model that are common across all of my  optimization models (VFT, original, GUO). Mostly, this function handles the definition of the \"<code>x</code>\" variable and the  many potential constraints associated with it. This includes the fixed/reserved slot constraints I discussed in the  <code>SOC Rated Algorithm</code> section previously.</p> <pre><code># Run the USAFA/ROTC rated algorithm\ns = instance.soc_rated_matching_algorithm({\"soc\": \"usafa\"})  # \"s =\" prevents lots of output\ns = instance.soc_rated_matching_algorithm({\"soc\": \"rotc\"})  # \"s =\" prevents lots of output\n\n# Integrate the Rated algorithm solutions into \"instance.parameters\" \ninstance.incorporate_rated_algorithm_results()\n\n# Solve the GUO model with the rated algorithm results!\ns = instance.solve_guo_pyomo_model({\"USSF OM\": True})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Solving the rated matching algorithm for USAFA cadets...\nSolving the rated matching algorithm for ROTC cadets...\nIncorporating rated algorithm results...\nRated SOC Algorithm Results:\nUSAFA Fixed Cadets: 1, USAFA Reserved Cadets: 0, ROTC Fixed Cadets: 2, ROTC Reserved Cadets: 4\nUSAFA Rated Alternates: 0, ROTC Rated Alternates: 7\nBuilding assignment problem (GUO) model...\nDone. Solving model...\nSolving GUO Model instance with solver cbc...\nStart Time: June 09 2025 07:44:24 PM.\nModel solved in 0.11 seconds at June 09 2025 07:44:24 PM. Pyomo reported objective value: 0.8324\nNew Solution Evaluated.\nMeasured exact VFT objective value: 0.8753.\nGlobal Utility Score: 0.8324. 3 / 3 AFSCs fixed. 4 / 4 AFSCs reserved. 7 / 7 alternate list scenarios respected.\nBlocking pairs: 2. Unmatched cadets: 0.\nMatched cadets: 20/20. N^Match: 20. Ineligible cadets: 0.\n</code></pre> <p>Quick note: Turning on the \"USSF OM\" constraint above ensures that the overall distribution of OM of the Space Force  is around where it is with the Air Force. When running this officially, you should turn this constraint on like I did  above. The mdl_p control \"ussf_merit_bound\" determines how wide of a range we can have around 50%.  It is defaulted to 0.03, which means that USSF OM can be within 47%-53%.</p> <p>As a reminder, for rated cadet-AFSC matches, the optimization model does not get to decide entirely based on global utility.  We adhere to the rated OM list exclusively! The SOC rated matching algorithm must be run once, and then every time we execute  <code>instance.incorporate_rated_algorithm_results()</code>,  the alternate list sets and parameters are added by default. </p> <pre><code># These are the default controls, so alternate lists should always be included unless otherwise specified!\ninstance.incorporate_rated_algorithm_results({'rated_alternates': True,\n                                              'alternate_list_iterations_printing': False})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Incorporating rated algorithm results...\nRated SOC Algorithm Results:\nUSAFA Fixed Cadets: 1, USAFA Reserved Cadets: 0, ROTC Fixed Cadets: 2, ROTC Reserved Cadets: 4\nUSAFA Rated Alternates: 0, ROTC Rated Alternates: 7\n</code></pre> <p>If we want to see the rated alternate algorithm a little more clearly, we can toggle the  \"alternate_list_iterations_printing\" parameter.</p> <pre><code># These are the default controls, so alternate lists should always be included unless otherwise specified!\ninstance.incorporate_rated_algorithm_results({'alternate_list_iterations_printing': True})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Incorporating rated algorithm results...\n\nSOC: USAFA\n\nIteration 0\nPossible {'R2': 0, 'R4': 0}\nMatched {'R2': 1, 'R4': 0}\nReserved {'R2': 0, 'R4': 0}\nAlternates (Hard) {'R2': 0, 'R4': 0}\nAlternates (Soft) {'R2': 0, 'R4': 0}\nIteration 1\nPossible {'R2': 0, 'R4': 0}\nMatched {'R2': 1, 'R4': 0}\nReserved {'R2': 0, 'R4': 0}\nAlternates (Hard) {'R2': 0, 'R4': 0}\nAlternates (Soft) {'R2': 0, 'R4': 0}\n\nSOC: ROTC\n\nIteration 0\nPossible {'R2': 4, 'R4': 6}\nMatched {'R2': 1, 'R4': 1}\nReserved {'R2': 3, 'R4': 1}\nAlternates (Hard) {'R2': 0, 'R4': 0}\nAlternates (Soft) {'R2': 4, 'R4': 6}\nIteration 1\nPossible {'R2': 4, 'R4': 6}\nMatched {'R2': 1, 'R4': 1}\nReserved {'R2': 3, 'R4': 1}\nAlternates (Hard) {'R2': 0, 'R4': 0}\nAlternates (Soft) {'R2': 4, 'R4': 6}\nRated SOC Algorithm Results:\nUSAFA Fixed Cadets: 1, USAFA Reserved Cadets: 0, ROTC Fixed Cadets: 2, ROTC Reserved Cadets: 4\nUSAFA Rated Alternates: 0, ROTC Rated Alternates: 7\n</code></pre> <p>Again, not much happens here as a result of the small, random dataset. </p> <pre><code># Re-import module and data \nfrom afccp.main import CadetCareerProblem\ninstance = CadetCareerProblem(\"Random_1\")\ninstance.set_value_parameters()\n</code></pre> \ud83d\udcbb Console Output <pre><code>Importing 'Random_1' instance...\nInstance 'Random_1' initialized.\n</code></pre>"},{"location":"user-guide/tutorial_8/#assignment-problem-model-original-afpc-model","title":"Assignment Problem Model- \"Original\" AFPC model","text":"<p>To be true to this problem's history, I have coded up the original AFPC model formulation. However, this isn't  entirely accurate since it relies on my value parameters for constraints and can be solved in an almost identical  manner to GUO. The only difference here is the objective function! We create the original utility matrix that  AFPC used up until 2023 for AFSC NRL classification and solve the model with the same features as GUO. If you  look at the optimization.py script at the assignment_model_build() function, you will notice that I simply have  an \"if\" statement to differentiate the two models. Here it is:</p> <pre><code>s = instance.solve_original_pyomo_model()  # Not recommended in anyway, just here as an artifact!\n</code></pre> \ud83d\udcbb Console Output <pre><code>Building original assignment problem model...\nDone. Solving model...\nSolving Original Model instance with solver cbc...\nStart Time: June 09 2025 07:53:30 PM.\nModel solved in 0.1 seconds at June 09 2025 07:53:30 PM. Pyomo reported objective value: 141.9145\nNew Solution Evaluated.\nMeasured exact VFT objective value: 0.8408.\nGlobal Utility Score: 0.7979. 0 / 0 AFSCs fixed. 0 / 0 AFSCs reserved. 0 / 0 alternate list scenarios respected.\nBlocking pairs: 3. Unmatched cadets: 0.\nMatched cadets: 20/20. N^Match: 20. Ineligible cadets: 0.\n</code></pre>"},{"location":"user-guide/tutorial_8/#goal-programming-model","title":"Goal Programming Model","text":"<p>This section is here to talk about former Lt Rebecca Reynold's optimization model. I have it coded up to follow her  methodology to the best of my ability and it lives in the code as well. Again, this is here primarily for  historical purposes to capture academic contributions to this problem! You are free to look at all the ins and outs  of this model and see how the data is represented and utilized. </p> <p>Quick note, part of the process of running her goal programming model involves translating my parameters &amp;  value parameters into her own specific parameters that she uses. Additionally, when she and I took on the  thesis, we handled AFOCD objectives through the lens of \"Mandatory\", \"Desired\", and \"Permitted\" rather than  \"Tier 1 -&gt; Tier 4\". Her model uses the requirement levels (M, D, P) rather than the tiers in the same way DSY used  that through c/2023. Little nuanced thing but since making this tutorial I have updated the random value  parameter generation function to still generate these objectives (Mandatory, Desired, Permitted) so this translation  function will work. Moral of the story: I just need to regenerate a set of value parameters to include  these objectives which will allow me to translate my parameters to hers, and ultimately solve the model.</p> <pre><code># Generate random set of value parameters (will contain M, D, P objectives)\ninstance.generate_random_value_parameters()\n\n# We now have two sets of value parameters!\nprint(instance.vp_dict.keys())\n</code></pre> \ud83d\udcbb Console Output <pre><code>dict_keys(['VP', 'VP2'])\n</code></pre> <pre><code># Solve the goal-programming model!\ns = instance.solve_gp_pyomo_model({'USSF OM': True})\n\n# Re-activate the first set of value parameters\ninstance.set_value_parameters(\"VP\")  # VP_2 evaluated the model by default (we want VP)\n</code></pre> \ud83d\udcbb Console Output <pre><code>Translating VFT model parameters to Goal Programming Model parameters...\nBuilding GP Model...\nModel built.\nSolving GP Model instance with solver cbc...\nStart Time: June 09 2025 07:55:35 PM.\nModel solved.\nNew Solution Evaluated.\nMeasured exact VFT objective value: 0.8266.\nGlobal Utility Score: 0.7732. 0 / 0 AFSCs fixed. 0 / 0 AFSCs reserved. 0 / 0 alternate list scenarios respected.\nBlocking pairs: 3. Unmatched cadets: 0.\nMatched cadets: 20/20. N^Match: 20. Ineligible cadets: 0.\n\nSolution Evaluated: GP.\nMeasured exact VFT objective value: 0.873.\nGlobal Utility Score: 0.8336. 0 / 0 AFSCs fixed. 0 / 0 AFSCs reserved. 0 / 0 alternate list scenarios respected.\nBlocking pairs: 3. Unmatched cadets: 0.\nMatched cadets: 20/20. N^Match: 20. Ineligible cadets: 0.\n</code></pre> <p>Another note, the \"GP\" model is not bound by any of the same constraints as the other models. This includes the  value parameter constraints and the common optimization handling constraints. This is how her model was formulated and  so it doesn't adhere to any of our \"rules\". This model remains here in case any future researchers want to look at her  work and expand upon it in some capacity to work with the current state of the problem.</p>"},{"location":"user-guide/tutorial_8/#sensitivity","title":"Sensitivity","text":"<p>There are some sensitivity analysis functions within <code>afccp</code>, and this is really the next step of what to do with  this project. I don't have many yet, but the goal is to continue to develop these capabilities in the future.  (I'm skipping this section for now except the one function below).</p> <pre><code># Iteratively solve model activating constraints one at a time to check feasibility\ninstance.solve_for_constraints()\n</code></pre> \ud83d\udcbb Console Output <pre><code>Initializing Assignment Model Constraint Algorithm...\nDone. Solving model with no constraints active...\nDone. New solution objective value: 0.8652\nRunning through 4 total constraint iterations...\n\n------[1] AFSC R4 Objective Combined Quota------------\nConstraint 1 Active Constraints: 1 Validated: 1\nResult: SKIPPED [Measure: 3.0],  Range: (2.0, 3.0)\nActive Objective Measure Constraints: 1\nTotal Failed Constraints: 0\nCurrent Objective Measure: 3.0 Range: 2, 3\n---------- Objective Measure Fails:0-------------------\n\n------[2] AFSC R2 Objective Combined Quota------------\nConstraint 2 Active Constraints: 2 Validated: 2\nResult: SOLVED [Z = 0.8587]\nActive Objective Measure Constraints: 2\nTotal Failed Constraints: 0\nCurrent Objective Measure: 5.0 Range: 5, 9\n---------- Objective Measure Fails:0-------------------\n\n------[3] AFSC R3 Objective Combined Quota------------\nConstraint 3 Active Constraints: 3 Validated: 3\nResult: SOLVED [Z = 0.8364]\nActive Objective Measure Constraints: 3\nTotal Failed Constraints: 0\nCurrent Objective Measure: 3.0 Range: 2, 3\n---------- Objective Measure Fails:0-------------------\n\n------[4] AFSC R1 Objective Combined Quota------------\nConstraint 4 Active Constraints: 4 Validated: 4\nResult: SKIPPED [Measure: 9.0],  Range: (8.0, 9.0)\nActive Objective Measure Constraints: 4\nTotal Failed Constraints: 0\nCurrent Objective Measure: 9.0 Range: 8, 9\n---------- Objective Measure Fails:0-------------------\n</code></pre>"},{"location":"user-guide/tutorial_8/#recommended-model-flow","title":"Recommended Model Flow","text":"<p>The \"Solutions\" section first discussed how solutions are represented in csv format as well as in the code.  Just like the parameters, we have a csv dataframe containing the content which is then pulled into a <code>solutions</code>  dictionary containing the various metrics of one particular solution given all the many parameters to the problem.  The section then discusses the various solution algorithms/models that may be applied to the problem. Below is my  recommended approach to the problem. I start by importing the data and applying the SOC rated algorithms first, and  then exporting it back.</p> <pre><code># Import the \"Random_1\" instance\ninstance = CadetCareerProblem('Random_1')\n\n# \"Activate\" a particular set of value parameters (since you can have multiple)\ninstance.set_value_parameters(\"VP\")  # There could be \"VP\", \"VP2\", \"VP3\", etc.\n\n# In case you change some parameter that the value parameters depend on\ninstance.update_value_parameters()  # AFSC quotas are a good example here\n\n# Always make sure your data is good to go!\ninstance.parameter_sanity_check()\n\n# Run the SOC algorithms!\ninstance.soc_rated_matching_algorithm({\"soc\": \"rotc\", \"ma_printing\": True})\ninstance.soc_rated_matching_algorithm({\"soc\": \"usafa\", \"ma_printing\": True})\n\n# Export data back to csvs\ninstance.export_data()\n</code></pre> \ud83d\udcbb Console Output <pre><code>Importing 'Random_1' instance...\nInstance 'Random_1' initialized.\nSanity checking the instance parameters...\nDone, 0 issues found.\nSolving the rated matching algorithm for ROTC cadets...\n\nIteration 1\nProposals: {'R2': 6, 'R4': 6}\nMatched {'R2': 4, 'R4': 2}\nRejected {'R2': 2, 'R4': 4}\n\nIteration 2\nProposals: {'R2': 6, 'R4': 4}\nMatched {'R2': 4, 'R4': 2}\nRejected {'R2': 4, 'R4': 6}\nSolving the rated matching algorithm for USAFA cadets...\n\nIteration 1\nProposals: {'R2': 5, 'R4': 2}\nMatched {'R2': 1, 'R4': 0}\nRejected {'R2': 4, 'R4': 2}\n\nIteration 2\nProposals: {'R2': 2, 'R4': 2}\nMatched {'R2': 1, 'R4': 0}\nRejected {'R2': 5, 'R4': 4}\nExporting datasets ['Cadets', 'AFSCs', 'Preferences', 'Goal Programming', 'Value Parameters', 'Solutions', 'Additional', 'Base Solutions', 'Course Solutions']\n</code></pre> <p>The reason I have the above code split up from below is because you only need to run the rated SOC algorithms  themselves once, and then from that point on they exist in your \"Solutions.csv\" file, and you can just incorporate them  into the parameters everytime!</p> <pre><code># Import the \"Random_1\" instance\ninstance = CadetCareerProblem('Random_1')\n\n# \"Activate\" a particular set of value parameters (since you can have multiple)\ninstance.set_value_parameters(\"VP\")  # There could be \"VP\", \"VP2\", \"VP3\", etc.\n\n# In case you change some parameter that the value parameters depend on\ninstance.update_value_parameters()  # AFSC quotas are a good example here\n\n# From now on, this becomes one of your \"default\" functions to apply!\ninstance.incorporate_rated_algorithm_results()\n\n# Always make sure your data is good to go!\ninstance.parameter_sanity_check()\n\n# Run GUO!\ninstance.solve_guo_pyomo_model()\n\n# Export data back to csvs\ninstance.export_data()\n</code></pre> \ud83d\udcbb Console Output <pre><code>Importing 'Random_1' instance...\nInstance 'Random_1' initialized.\nIncorporating rated algorithm results...\nRated SOC Algorithm Results:\nUSAFA Fixed Cadets: 1, USAFA Reserved Cadets: 0, ROTC Fixed Cadets: 2, ROTC Reserved Cadets: 4\nUSAFA Rated Alternates: 0, ROTC Rated Alternates: 7\nSanity checking the instance parameters...\nDone, 0 issues found.\nBuilding assignment problem (GUO) model...\nDone. Solving model...\nSolving GUO Model instance with solver cbc...\nStart Time: June 10 2025 10:22:40 AM.\nModel solved in 0.2 seconds at June 10 2025 10:22:40 AM. Pyomo reported objective value: 0.8364\nNew Solution Evaluated.\nMeasured exact VFT objective value: 0.8718.\nGlobal Utility Score: 0.8364. 3 / 3 AFSCs fixed. 4 / 4 AFSCs reserved. 7 / 7 alternate list scenarios respected.\nBlocking pairs: 4. Unmatched cadets: 0.\nMatched cadets: 20/20. N^Match: 20. Ineligible cadets: 0.\n\nExporting datasets ['Cadets', 'AFSCs', 'Preferences', 'Goal Programming', 'Value Parameters', 'Solutions', 'Additional', 'Base Solutions', 'Course Solutions']\n</code></pre> <p>If you've followed along with your own random dataset, then you should have several solutions now in your  \"Random_1 Solutions.csv\" file:</p> <p> </p> <p>We now have the \"GUO\" solution too which we will use to visualize in the next tutorial.</p>"},{"location":"user-guide/tutorial_8/#summary","title":"\ud83d\udccc Summary","text":"<p>Tutorial 8 outlines the core optimization models used to solve the <code>CadetCareerProblem</code>, focusing on how  cadet-to-AFSC assignments are generated using formal decision models. The section presents multiple optimization strategies  that evolved from academic and operational contributions.</p> <p>It covers the following models and methods:</p> <ol> <li> <p>Value-Focused Thinking (VFT) Models \u2013 Includes both Approximate and Exact models, originally developed at AFIT.</p> <ul> <li>Highlights their differences, how they\u2019re solved using Pyomo, and why Approximate models are often preferred in practice.</li> <li>Explains how the <code>con_fail_dict</code> is used to manage constraint violations and guide genetic algorithms.</li> </ul> </li> <li> <p>Global Utility Optimization (GUO) \u2013 The current default assignment model that maximizes a merged cadet-AFSC utility matrix.</p> <ul> <li>Efficient and scalable with accurate Pyomo objective value evaluation.</li> <li>Used with rated cadet integration and the \u201cUSSF OM\u201d constraint when applicable.</li> </ul> </li> <li> <p>Original AFPC Model \u2013 Rebuilt for historical reference, this model mimics the legacy assignment method used through 2023.</p> </li> <li> <p>Goal Programming Model \u2013 Captures Lt. Rebecca Reynold's research contributions using \u201cMandatory/Desired/Permitted\u201d logic instead of value tiers.</p> <ul> <li>The model can be executed after translating value parameters and is unconstrained by <code>afccp</code>'s standard rule set.</li> </ul> </li> <li> <p>Sensitivity Analysis \u2013 An early capability that tests the impact of activating constraints one at a time on solution feasibility.</p> </li> </ol> <p>The tutorial emphasizes how constraints, value parameters, and alternate list logic continue to play a vital role in  each formulation. The GUO model is currently used for official cadet-AFSC classification. All models integrate with the  solution evaluation tools covered in Tutorial 6 and the algorithm controls from  Tutorial 7. Continue on to Tutorial 9 for more information on the visualizations within <code>afccp</code>.</p>"},{"location":"user-guide/tutorial_9/","title":"Visualizations","text":"<p>I've created many visualizations for this problem to view the results from our solutions that we generate.  A very easy way of generating these charts and then saving them back to the \"Analysis &amp; Results\" is with the function  below. This will automatically generate some \"typical\" charts that I like to look at, and then subsequently save them  back to our solution-specific folder. </p> <p>As a reminder from earlier, anytime you want to work with a specific solution that you've generated you need to  \"activate\" it. Additionally, when you run the below function to generate/save the charts for a specific solution  (in this case \"GUO\") a new solution-specific folder is created in the \"Analysis &amp; Results\" folder. The name of the  folder will be the same name as the solution. This is where our charts are saved to. </p> <p>Let's start by loading the data back in using our standard initial methods </p> <pre><code># Import the \"Random_1\" instance\ninstance = CadetCareerProblem('Random_1')\n\n# \"Activate\" a particular set of value parameters (since you can have multiple)\ninstance.set_value_parameters(\"VP\")  # There could be \"VP\", \"VP2\", \"VP3\", etc.\n\n# In case you change some parameter that the value parameters depend on\ninstance.update_value_parameters()  # AFSC quotas are a good example here\n\n# From now on, this becomes one of your \"default\" functions to apply!\ninstance.incorporate_rated_algorithm_results()\n\n# Always make sure your data is good to go!\ninstance.parameter_sanity_check()\n</code></pre> \ud83d\udcbb Console Output <pre><code>Importing 'Random_1' instance...\nInstance 'Random_1' initialized.\nIncorporating rated algorithm results...\nRated SOC Algorithm Results:\nUSAFA Fixed Cadets: 1, USAFA Reserved Cadets: 0, ROTC Fixed Cadets: 2, ROTC Reserved Cadets: 4\nUSAFA Rated Alternates: 0, ROTC Rated Alternates: 7\nSanity checking the instance parameters...\nDone, 0 issues found.\n</code></pre>"},{"location":"user-guide/tutorial_9/#basic-charts","title":"Basic Charts","text":"<p>Now we can activate our solution and save all the normal charts! For this small, fake dataset, I have added the  parameters below to help adjust the mechanics of these charts since I'm used to instances with 2500+ cadets and  ~36 AFSCs. The text, for example should be a bit bigger! And then I have to sort the AFSCs properly for random data.</p> <pre><code># Activate GUO solution\ninstance.set_solution('GUO')  \n\n# Generate the standard charts that I track\ns = instance.display_all_results_graphs({'bar_text_size': 25, 'skip_afscs': False, 'text_size': 25, 'sort_by_pgl': False})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Solution Evaluated: GUO.\nMeasured exact VFT objective value: 0.8718.\nGlobal Utility Score: 0.8364. 3 / 3 AFSCs fixed. 4 / 4 AFSCs reserved. 7 / 7 alternate list scenarios respected.\nBlocking pairs: 4. Unmatched cadets: 0.\nMatched cadets: 20/20. N^Match: 20. Ineligible cadets: 0.\n\nSaving all solution results charts to the corresponding folder...\n&lt;Objective 'Combined Quota' version 'quantity_bar'&gt;\nSaved Random_1 (Default) GUO Combined Quota Measure [quantity_bar] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'Norm Score' version 'quantity_bar_proportion'&gt;\nSaved Random_1 (Default) GUO Norm Score Measure [quantity_bar_proportion] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'Norm Score' version 'bar'&gt;\nSaved Random_1 (Default) GUO Norm Score Measure [bar] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'Norm Score' version 'quantity_bar_choice'&gt;\nSaved Random_1 (Default) GUO Norm Score Measure [quantity_bar_choice] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'Utility' version 'quantity_bar_proportion'&gt;\nSaved Random_1 (Default) GUO Utility Measure [quantity_bar_proportion] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'Utility' version 'quantity_bar_choice'&gt;\nSaved Random_1 (Default) GUO Utility Measure [quantity_bar_choice] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'Merit' version 'bar'&gt;\nSaved Random_1 (Default) GUO Merit Measure [bar] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'USAFA Proportion' version 'quantity_bar_proportion'&gt;\nSaved Random_1 (Default) GUO USAFA Proportion Measure [quantity_bar_proportion] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'USAFA Proportion' version 'preference_chart'&gt;\nSaved Random_1 (Default) GUO USAFA Proportion Measure [preference_chart] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'Extra' version 'SOC Chart'&gt;\nSaved Random_1 (Default) GUO Extra Measure [SOC Chart] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'Extra' version 'SOC Chart_proportion'&gt;\nSaved Random_1 (Default) GUO Extra Measure [SOC Chart_proportion] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Other Charts 'Accessions Group' version 'SOC Chart'&gt;\nSaved Random_1 (Default) GUO Accessions Group [SOC Chart] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n</code></pre> <p>The <code>instance.display_all_results_graphs()</code>  method will generate several useful charts that can help visualize the various metrics and properties of one particular  solution. I have a predefined set of graphs in the  <code>initialize_instance_functional_parameters()</code> function that will be  constructed here. At the time of writing, this snippet is on lines 212-223 of <code>afccp.data.support</code>:</p> <pre><code># Subset of charts I actually really care about\n\"desired_charts\": [(\"Combined Quota\", \"quantity_bar\"),\n                   (\"Norm Score\", \"quantity_bar_proportion\"),\n                   (\"Norm Score\", \"bar\"),\n                   (\"Norm Score\", \"quantity_bar_choice\"),\n                   (\"Utility\", \"quantity_bar_proportion\"),\n                   (\"Utility\", \"quantity_bar_choice\"),\n                   (\"Merit\", \"bar\"),\n                   (\"USAFA Proportion\", \"quantity_bar_proportion\"),\n                   (\"USAFA Proportion\", \"preference_chart\"),\n                   ('Extra', 'SOC Chart'),\n                   ('Extra', 'SOC Chart_proportion')],\n</code></pre> <p>This is part of the initialization of the <code>mdl_p</code> dictionary. I have a weird naming convention that made sense to me at the time but essentially each kind of chart has an \"objective\" its associated with and a \"version\". \"Combined Quota\", for example, is the objective to meet the PGL. The version shown is the \"quantity_bar\" because that was my way of  having the axes be relative to total cadets. Anyway, none of this matters all that much to you, but all these charts will be saved to your \"instances//5. Analysis &amp; Results//\" folder: <p> </p> <p>The first chart I'll show is the standard PGL visualization. AFSCs are sorted by their PGL quantities, and the chart shows the number of people assigned to each AFSC, and whether we met the PGL exactly, went over it, or fell short. Additionally, the AFSCs are colored by \"accessions group\" (Rated, USSF, or NRL). Rated AFSCs are red, USSF is blue, and the remaining non-rated line (NRL) AFSCs are black. In this case, we had four AFSCs with PGLs of 8, 5, 2, and 2. The  total PGL target quantity is 8 + 5 + 2 + 2 = 17, so we have 3 extra people to assign. In this solution, we give one extra person to \"R1\", \"R3\", and \"R4\".</p> <p> </p> <p>To visualize cadet preference, we have a few different ways of doing it. We can bin cadets together into how many  received an AFSC in their top 3 choices, \"next 3\" (4 -&gt; 6) choices, or everything else. For this solution, they all received a top 3 choice AFSC. This is also because there are only 4 AFSCs total!</p> <p> </p> <p>We can get a little more granular and show individual choice by 1st, 2nd, 3rd, ..., 10th, everything else too. Again, this isn't too helpful since there are only 4 AFSCs!</p> <p> </p> <p>For AFSC preference, we can also bin cadets into where they fall in the rankings by top third, middle third, or bottom  third!</p> <p> </p> <p>To be more granular like we did with cadets, we can expand the bins by looking at 10% increments.</p> <p> </p> <p>To visualize source of commissioning (SOC) breakdowns, we can do so here!</p> <p> </p> <p>Lastly, I have a few different charts that visualize the solution by \"accessions group\" (Rated, USSF, NRL). Here  is an example for SOC breakouts:</p> <p> </p> <p>Automating the charts this way is a big step up from the manual, inconsistent excel graphs DSY used to do to report the results. Now we can have a standard method of visualizing results year after year. Additionally, when one analyst comes up with a new way of communicating their results, they can code that into <code>afccp</code> so everyone after them can use that method too. It's all automated, and will work with any problem instance since the data has to be structured the same each year.</p>"},{"location":"user-guide/tutorial_9/#solution-results","title":"Solution Results","text":"<p>Another useful function I have is the <code>export_solution_results()</code>  function, which will export an Excel file containing various stats on a specific solution to this problem. This file tracks many metrics of the entire solution set of cadets-AFSCs but also contains details  on each individual cadet outcome. Feel free to explore the file that is generated from the below code which is also in  the solution-specific folder (\"GUO\" in this case). </p> <pre><code>instance.export_solution_results()\n</code></pre> \ud83d\udcbb Console Output <pre><code>Exporting solution GUO results to instances/Random_1/5. Analysis &amp; Results/GUO/Random_1 GUO (VP).xlsx...\nDone.\n</code></pre> <p>For reference, you can download the \"Random_1 GUO (VP).xlsx\" file created above here \ud83d\udce5.</p>"},{"location":"user-guide/tutorial_9/#bubble-charts","title":"Bubble Charts","text":"<p>Creating <code>afccp</code> has certainly been one of my proudest accomplishments as an analyst. This is how I learned <code>python</code>,  and I've really come to love making interesting things with this programming language! By far my greatest  visualization within this project is the \"Bubble Chart\". The bubble chart is a particularly creative way to visualize a  cadet-AFSC solution, if I do say so myself, and involves formulating and solving another optimization model just to  create it. Now, in order to run this function, you'll need to make sure you have the solver \"cuoenne\" in your  \"solvers\" folder. Without any further ado, here it is:</p> <pre><code># There are many more controls to this chart, but here are a few\ninstance.generate_bubbles_chart({'provide_executable': True, 'redistribute_x': True,\n                                 'focus': \"Cadet Choice\", 'b_legend_title_size': 20,\n                                 'b_legend_marker_size': 20, 'b_legend_size': 20})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Creating Bubbles Chart...\nBubble Chart initialized.\nBubble Chart preprocessed.\nNo Sequence parameters found in solution analysis sub-folder 'GUO'.\nSolving Bubbles Model instance with solver couenne...\nStart Time: June 11 2025 08:36:34 AM.\nBoard parameters 'x' and 'y' determined through pyomo model.\nSequence parameters (J, x, y, n, s) exported to instances/Random_1/5. Analysis &amp; Results/GUO/Board Parameters.csv\nDone.\n</code></pre> <p>In the \"GUO\" folder again, we will find the \"Cadet Choice.png\" image which is the bubble chart we just made:</p> <p> </p> <p>With only 4 AFSCs and 20 cadets, the bubbles chart admittedly may not be too useful. The gray squares above correspond  to the PGL targets for each AFSC. The colors of the \"bubbles\" indicate the choice that the cadet had on that AFSC.  The numbers shown for each AFSC are the normalized score index measuring how well we met the AFSC's preference.</p> <p>Now, when we run the bubble chart for the first time, you will see the line of output that says  <code>No Sequence parameters found in solution analysis sub-folder 'GUO'</code>. The code will look for a  \"Board Parameters.csv\" file inside the solution sub-folder. If it does not find that file, it will know to create one. This is when we trigger the  <code>bubble_chart_configuration_model()</code>  to determine the layout of the \"board\". Once we run the model and determine the <code>x</code>, <code>y</code> coordinates, and the size of  the boxes themselves (<code>s</code>) then we will export the \"Board Parameters.csv\" file. Anytime we want to generate another  bubble chart, it will load in those parameters. If you screw something up or just want to generate that file again for any reason, simply delete the \"Board Parameters.csv\" file and the code will re-run the model like it's the first time. That file looks like this:</p> <p> </p> <p>One thing we can change here is the fontsize and whether the AFSC labels should be on two lines or not.  This comes in handy particularly for real class years when we have small AFSCs with long names (62EXI, for example).  I'll show an example here by first modifying the \"Board Parameters\" to this:</p> <p> </p> <p>And then re-generating the bubble chart, only this time, it'll import the \"Board Parameters\" without re-solving the  optimization models.</p> <pre><code># There are many more controls to this chart, but here are a few\ninstance.generate_bubbles_chart({'provide_executable': True, 'redistribute_x': True,\n                                 'focus': \"Cadet Choice\", 'b_legend_title_size': 20,\n                                 'b_legend_marker_size': 20, 'b_legend_size': 20})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Creating Bubbles Chart...\nBubble Chart initialized.\nBubble Chart preprocessed.\nSequence parameters (J, x, y, n, s) imported from instances/Random_1/5. Analysis &amp; Results/GUO/Board Parameters.csv\nSequence parameters (J, x, y, n, s) exported to instances/Random_1/5. Analysis &amp; Results/GUO/Board Parameters.csv\nDone.\n</code></pre> <p> </p> <p>As you can see, the text above the AFSCs became bigger since the font-size increased from 20 to 30. Additionally, the  last AFSC, R4, has text that spans two lines now. Again, this is useful once you've found a solution worth showing on  a real problem and have created the bubble chart \"board\". Then you can just finesse the AFSC text specs until you  get something that works.</p> <p>If you're wondering while the file name is \"Cadet Choice.png\", that's because that is the \"focus\" of the bubble chart. We can change this setting to \"focus\" on some other aspect of the solution. We can view it from the AFSC's perspective and visualize how well we gave each AFSC cadets they preferred:</p> <pre><code># There are many more controls to this chart, but here are a few\ninstance.generate_bubbles_chart({'provide_executable': True, 'redistribute_x': True,\n                                 'focus': \"AFSC Choice\", 'b_legend_title_size': 20,\n                                 'b_legend_marker_size': 20, 'b_legend_size': 20})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Creating Bubbles Chart...\nBubble Chart initialized.\nBubble Chart preprocessed.\nSequence parameters (J, x, y, n, s) imported from instances/Random_1/5. Analysis &amp; Results/GUO/Board Parameters.csv\nSequence parameters (J, x, y, n, s) exported to instances/Random_1/5. Analysis &amp; Results/GUO/Board Parameters.csv\nDone.\n</code></pre> <p> </p> <p>We can also show the continuous \"Cadet Utility\" metric for each cadet:</p> <pre><code># There are many more controls to this chart, but here are a few\ninstance.generate_bubbles_chart({'provide_executable': True, 'redistribute_x': True,\n                                 'focus': \"Cadet Utility\", 'b_legend_title_size': 20,\n                                 'b_legend_marker_size': 20, 'b_legend_size': 20})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Creating Bubbles Chart...\nBubble Chart initialized.\nBubble Chart preprocessed.\nSequence parameters (J, x, y, n, s) imported from instances/Random_1/5. Analysis &amp; Results/GUO/Board Parameters.csv\nSequence parameters (J, x, y, n, s) exported to instances/Random_1/5. Analysis &amp; Results/GUO/Board Parameters.csv\nDone.\n</code></pre> <p> </p> <p>One other variant of the bubble chart I like to show allows me to focus on one specific AFSC and view the cadets' choice for that AFSC. This is helpful for undesirable career fields and also for career fields that are very hard to fill due to the lack of eligible cadets (62EXE for example). Here is an example showing cadets' choice for the AFSC \"R4\", with unqualified cadets shown in gray.</p> <pre><code># There are many more controls to this chart, but here are a few\ninstance.generate_bubbles_chart({'provide_executable': True, 'redistribute_x': True,\n                                 'focus': \"Specific Choice\", 'b_legend_title_size': 20,\n                                 'b_legend_marker_size': 15, 'b_legend_size': 15, 'afsc': 'R4'})\n</code></pre> \ud83d\udcbb Console Output <pre><code>Creating Bubbles Chart...\nBubble Chart initialized.\nBubble Chart preprocessed.\nSequence parameters (J, x, y, n, s) imported from instances/Random_1/5. Analysis &amp; Results/GUO/Board Parameters.csv\nSequence parameters (J, x, y, n, s) exported to instances/Random_1/5. Analysis &amp; Results/GUO/Board Parameters.csv\nDone.\n</code></pre> <p> </p>"},{"location":"user-guide/tutorial_9/#slides","title":"Slides","text":"<p>Once you've generated your charts and are thinking about putting these all into a PowerPoint, you can do so easily  through one of my functions. I wanted a way to quickly generate slides, so I could communicate results in an effective, automated way. Additionally, the solution-generating process is most certainly an iterative one, and solutions change  constantly. I don't want to have to manually re-generate slides everytime something changes! This method certainly  serves the purpose of initializing a \"final\" slide-deck for a commander out-brief, but more importantly it can help  communicate the quality of the results to the analyst team in a digestible manner with the execution of a single  line of code. This helps facilitate the iterative part of this process!</p> <pre><code># Regenerate the charts, this time to have them in a good format for the slides (figsize adjusted, w/no title shown)\ns = instance.display_all_results_graphs(\n    {'display_title': False, 'figsize': (12.25, 5.5), 'bar_text_size': 25, 'skip_afscs': False, \n     'text_size': 25, 'sort_by_pgl': False})\n\n# This will put the charts that I want in an AFPC slide-deck!\ninstance.generate_results_slides()\n</code></pre> \ud83d\udcbb Console Output <pre><code>Saving all solution results charts to the corresponding folder...\n&lt;Objective 'Combined Quota' version 'quantity_bar'&gt;\nSaved Random_1 (Default) GUO Combined Quota Measure [quantity_bar] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'Norm Score' version 'quantity_bar_proportion'&gt;\nSaved Random_1 (Default) GUO Norm Score Measure [quantity_bar_proportion] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'Norm Score' version 'bar'&gt;\nSaved Random_1 (Default) GUO Norm Score Measure [bar] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'Norm Score' version 'quantity_bar_choice'&gt;\nSaved Random_1 (Default) GUO Norm Score Measure [quantity_bar_choice] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'Utility' version 'quantity_bar_proportion'&gt;\nSaved Random_1 (Default) GUO Utility Measure [quantity_bar_proportion] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'Utility' version 'quantity_bar_choice'&gt;\nSaved Random_1 (Default) GUO Utility Measure [quantity_bar_choice] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'Merit' version 'bar'&gt;\nSaved Random_1 (Default) GUO Merit Measure [bar] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'USAFA Proportion' version 'quantity_bar_proportion'&gt;\nSaved Random_1 (Default) GUO USAFA Proportion Measure [quantity_bar_proportion] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'USAFA Proportion' version 'preference_chart'&gt;\nSaved Random_1 (Default) GUO USAFA Proportion Measure [preference_chart] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'Extra' version 'SOC Chart'&gt;\nSaved Random_1 (Default) GUO Extra Measure [SOC Chart] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Objective 'Extra' version 'SOC Chart_proportion'&gt;\nSaved Random_1 (Default) GUO Extra Measure [SOC Chart_proportion] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n&lt;Other Charts 'Accessions Group' version 'SOC Chart'&gt;\nSaved Random_1 (Default) GUO Accessions Group [SOC Chart] (Results).png Chart to instances/Random_1/5. Analysis &amp; Results/GUO/.\n\nGenerating results slides...\nDone.\n</code></pre> <p>Once you've generated the slides, they'll show up in your \"instances/Random_1/5. Analysis &amp; Results/GUO/\" folder as well! For reference, you can download the slide-deck for my problem instance &amp; solution, \"Random_1 GUO.pptx\", created above here \ud83d\udce5.</p>"}]}