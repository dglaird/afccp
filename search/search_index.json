{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Air Force Cadet Career Problem (afccp) Documentation!","text":"<p>AFCCP is a comprehensive collection of models designed to streamline and automate as much of the cadet-AFSC matching process conducted by the Air Force Personnel Center (AFPC) as possible.</p> <p>This documentation serves to provide clear guidance, technical details, and resources to support both developers and  users in effectively using the afccp module.</p>"},{"location":"#what-you-will-find-here","title":"What You Will Find Here","text":"<ul> <li>Getting Started - Key overviews and installation instructions to get you up and running with afccp.</li> <li>User Guide - Detailed instructions, best practices, and user-friendly guidance to fully leverage afccp features.</li> <li>Developer Guide - Technical documentation, API details, data architecture, and modeling assumptions necessary for developers and analysts.</li> <li>Data - All necessary information in understanding the data and data structure used by afccp.</li> <li>Solutions - Critical details pertaining to the models and algorithms represented by afccp to solve the CadetCareerProblem instance.</li> <li>Visualizations - Insight into the various kinds of data visualizations used to communicate information about a CadetCareerProblem instance.</li> <li>References - Linked journal articles and external resources that provide foundational research and methodological support for the afccp models.</li> <li>FAQs - Answers to frequently asked questions about afccp, addressing common issues, clarifying functionalities, and providing quick solutions.</li> <li>Help - Contact information and resources to assist users with troubleshooting, technical support, and additional guidance on using Castle Suite effectively.</li> </ul>"},{"location":"#need-help","title":"Need Help?","text":"<p>If you have questions or require support, please contact Capt D. Griffen Laird at  griffenlaird007@gmail.com or  daniel.laird.4@us.af.mil, or refer to the Help section.</p>"},{"location":"developer-checklist/","title":"\ud83d\udee0 AFCCP Developer Onboarding Checklist","text":"<p>Welcome to the afccp development team! This checklist will guide you through all required steps to fully  onboard and set up your development environment.</p>"},{"location":"developer-guide/","title":"Developer Guide","text":""},{"location":"developer-guide/#overview","title":"Overview","text":"<p>The AFCCP Developer Guide provides comprehensive information and instructions to assist developers in  understanding, maintaining, and enhancing the afccp module. This guide includes essential details  about the system's architecture, code guidelines, modeling assumptions, and more.  Below is a detailed breakdown of the guide's contents:</p>"},{"location":"faq/","title":"Frequently Asked Questions (FAQs)","text":"<p>Welcome to the AFCCP FAQ section. Here, you\u2019ll find answers to common questions regarding  afccp\u2019s functionality, data processing, and documentation.</p>"},{"location":"getting-started/","title":"\ud83d\udcc4 Overview","text":"<p>Welcome to the AFCCP Overview page. This guide offers a comprehensive introduction to afccp,  detailing its functionalities and benefits.</p>"},{"location":"getting-started/#background-on-afccp","title":"Background on AFCCP","text":"<p>For detailed information on the Air Force Cadet-Career Problem, please reference Capt Laird's master's thesis.  As more papers are published directly using afccp, they will be included here as well.</p> <p>Griffen Laird's Thesis</p>"},{"location":"help/","title":"Help","text":"<p>Welcome to the AFCCP Help page. If you encounter any issues, need clarification,  or require assistance with the afccp module, this guide provides essential support resources.</p>"},{"location":"help/#frequently-asked-questions-faqs","title":"Frequently Asked Questions (FAQs)","text":"<p>Before reaching out for support, check the FAQs section for answers to common issues.</p>"},{"location":"installation/","title":"Installation","text":"<p>Welcome to the Air Force Cadet Career Problem (AFCCP) installation guide.  This guide walks you through cloning the repository, installing dependencies, and running the model.</p>"},{"location":"installation/#1-clone-the-repository","title":"\ud83d\ude80 1. Clone the Repository","text":"<p>First, clone the AFCCP repository from GitHub:</p> <pre><code>git clone https://github.com/dglaird/afccp.git\ncd afccp\n</code></pre> <p>Make sure you have Git installed.</p>"},{"location":"installation/#2-set-up-your-python-environment","title":"\ud83d\udc0d 2. Set Up Your Python Environment","text":"<p>We recommend using <code>conda</code> or <code>venv</code> to isolate your Python environment.</p>"},{"location":"installation/#option-a-using-conda","title":"Option A: Using <code>conda</code>","text":"<pre><code>conda create -n afccp python=3.8 -y\nconda activate afccp\n</code></pre>"},{"location":"installation/#option-b-using-venv","title":"Option B: Using <code>venv</code>","text":"<pre><code>python3 -m venv afccp-env\nsource afccp-env/bin/activate  # On Windows: afccp-env\\Scripts\\activate\n</code></pre>"},{"location":"installation/#3-install-dependencies","title":"\ud83d\udce6 3. Install Dependencies","text":"<p>Install all required Python packages using <code>pip</code>:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>This includes packages like: - <code>pandas</code>, <code>numpy</code> \u2014 for data wrangling - <code>pyomo</code> \u2014 for optimization modeling - <code>matplotlib</code> \u2014 for visualizations - <code>mkdocs</code>, <code>mkdocs-material</code> \u2014 for documentation (optional)</p>"},{"location":"installation/#4-run-an-example","title":"\ud83d\udee0 4. Run an Example","text":"<p>Navigate to the main model script (adjust path if needed):</p> <pre><code>python afccp/main.py\n</code></pre> <p>This should execute a full cadet-to-AFSC assignment using the default input data.</p>"},{"location":"installation/#5-project-structure","title":"\ud83d\udcc1 5. Project Structure","text":"<pre><code>afccp/\n\u251c\u2500\u2500 afccp/                # Core source code\n\u251c\u2500\u2500 docs/                 # MkDocs documentation\n\u251c\u2500\u2500 data/                 # Input instance data\n\u251c\u2500\u2500 requirements.txt      # Python dependencies\n\u251c\u2500\u2500 mkdocs.yml            # MkDocs config file\n\u2514\u2500\u2500 README.md             # Project overview\n</code></pre>"},{"location":"installation/#6-view-the-documentation-locally","title":"\ud83d\udcda 6. View the Documentation Locally","text":"<p>If you want to view the full documentation site locally:</p> <pre><code>mkdocs serve\n</code></pre> <p>Then visit http://127.0.0.1:8000 in your browser.</p>"},{"location":"installation/#7-optional-rebuild-reference-pages","title":"\ud83d\ude80 7. (Optional) Rebuild Reference Pages","text":"<p>To generate API reference pages:</p> <pre><code>python afccp/gen_ref_pages.py\n</code></pre> <p>Be sure to run this from the project root directory, where <code>mkdocs.yml</code> is located.</p>"},{"location":"installation/#8-run-unit-tests-if-available","title":"\ud83e\uddea 8. Run Unit Tests (if available)","text":"<p>If the repo includes tests:</p> <pre><code>pytest tests/\n</code></pre>"},{"location":"installation/#more-info","title":"\ud83e\udde0 More Info","text":"<ul> <li>Full model explanation: Model Overview</li> <li>API reference: API Reference</li> <li>Author: Griffen Laird</li> </ul> <p>Happy modeling! \u2708\ufe0f</p>"},{"location":"user-guide/","title":"Getting Started with AFCCP","text":"<p>Welcome to the Air Force Cadet Career Problem (AFCCP) documentation. This guide walks you through a simple example of how to use the AFCCP model, including inputs, logic, and interpreting results.</p>"},{"location":"user-guide/#1-load-required-packages","title":"\ud83d\udce6 1. Load Required Packages","text":"<pre><code>import numpy as np\nimport pandas as pd\nfrom afccp import CadetCareerProblem\n</code></pre>"},{"location":"user-guide/#2-define-a-simple-example-dataset","title":"\ud83d\udccb 2. Define a Simple Example Dataset","text":"<p>Here we construct a small set of cadets and AFSCs to walk through the core matching logic.</p> <pre><code>cadets = pd.DataFrame({\n    \"name\": [\"Alice\", \"Bob\", \"Charlie\"],\n    \"preferences\": [[\"11X\", \"13X\", \"17X\"],\n                    [\"13X\", \"11X\", \"17X\"],\n                    [\"17X\", \"11X\", \"13X\"]]\n})\n\nafscs = pd.DataFrame({\n    \"afsc\": [\"11X\", \"13X\", \"17X\"],\n    \"slots\": [1, 1, 1]\n})\n</code></pre>"},{"location":"user-guide/#3-run-the-matching-model","title":"\ud83e\udde0 3. Run the Matching Model","text":"<p>The model takes the cadet preferences and available slots and performs an assignment using a merit-based preference system.</p> <pre><code>model = CadetCareerProblem(cadets=cadets, afscs=afscs)\nmodel.solve()\nassignments = model.get_assignments()\nassignments\n</code></pre>"},{"location":"user-guide/#output","title":"\u2705 Output","text":"<pre><code>  name     assigned_afsc\n0  Alice            11X\n1    Bob            13X\n2 Charlie           17X\n</code></pre>"},{"location":"user-guide/#4-visualize-the-results","title":"\ud83d\udd0d 4. Visualize the Results","text":"<p>You can also visualize the match using built-in plotting tools.</p> <pre><code>model.plot_assignments()\n</code></pre> <p>This creates a visual match between cadets and their assigned AFSCs using arrows and preferences.</p>"},{"location":"user-guide/#summary","title":"\ud83d\udccc Summary","text":"<p>In this quickstart: - We initialized a toy dataset of cadets and AFSCs. - We ran the assignment model and viewed the results. - We generated a plot to visualize the match.</p> <p>To run more realistic examples, refer to Model Overview or the API Reference.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>data<ul> <li>adjustments</li> <li>custom_ctgan_constraints</li> <li>generation</li> <li>preferences</li> <li>processing</li> <li>support</li> <li>values</li> </ul> </li> <li>gen_ref_pages</li> <li>globals</li> <li>main</li> <li>research<ul> <li>ots_cadet_additions</li> <li>rotc_rated</li> <li>testing</li> </ul> </li> <li>solutions<ul> <li>algorithms</li> <li>handling</li> <li>optimization</li> <li>sensitivity</li> </ul> </li> <li>visualizations<ul> <li>bubbles</li> <li>charts</li> <li>slides</li> </ul> </li> </ul>"},{"location":"reference/gen_ref_pages/","title":"Gen ref pages","text":""},{"location":"reference/gen_ref_pages/#gen_ref_pages","title":"<code>gen_ref_pages</code>","text":"<p>Generate the code reference pages and structured navigation.</p>"},{"location":"reference/globals/","title":"Globals","text":""},{"location":"reference/globals/#globals","title":"<code>globals</code>","text":""},{"location":"reference/globals/#globals.import_data","title":"<code>import_data(filepath, sheet_name=None, specify_engine=True)</code>","text":"<p>This function is to alleviate issues with importing pandas dataframes since some versions can just import .xlsx files normally but some have to add \", engine= 'openpyxl'\". Pandas versions &gt; 1.2.1 must specify openpyxl as the engine</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <p>excel file path</p> required <code>sheet_name</code> <p>name of the sheet to import</p> <code>None</code> <code>specify_engine</code> <p>issues with pandas \"engine=\"</p> <code>True</code> <p>Returns:</p> Type Description <p>pandas dataframe</p> Source code in <code>afccp/globals.py</code> <pre><code>def import_data(filepath, sheet_name=None, specify_engine=True):\n    \"\"\"\n    This function is to alleviate issues with importing pandas dataframes since some versions can just\n    import .xlsx files normally but some have to add \", engine= 'openpyxl'\". Pandas versions &gt; 1.2.1 must\n    specify openpyxl as the engine\n    :param filepath: excel file path\n    :param sheet_name: name of the sheet to import\n    :param specify_engine: issues with pandas \"engine=\"\n    :return: pandas dataframe\n    \"\"\"\n\n    if specify_engine:\n        if sheet_name is None:\n            df = pd.read_excel(filepath, engine='openpyxl')\n        else:\n            df = pd.read_excel(filepath, sheet_name=sheet_name, engine='openpyxl')\n    else:\n        if sheet_name is None:\n            df = pd.read_excel(filepath)\n        else:\n            df = pd.read_excel(filepath, sheet_name=sheet_name)\n\n    return df\n</code></pre>"},{"location":"reference/globals/#globals.import_csv_data","title":"<code>import_csv_data(filepath)</code>","text":"<p>My own import statement in case I change the way I import data later</p> Source code in <code>afccp/globals.py</code> <pre><code>def import_csv_data(filepath):\n    \"\"\"\n    My own import statement in case I change the way I import data later\n    \"\"\"\n    return pd.read_csv(filepath)  #, encoding='latin-1')\n</code></pre>"},{"location":"reference/main/","title":"Main","text":""},{"location":"reference/main/#main","title":"<code>main</code>","text":""},{"location":"reference/main/#main.CadetCareerProblem","title":"<code>CadetCareerProblem(data_name='Random', data_version='Default', degree_qual_type='Consistent', num_value_function_breakpoints=None, N=1600, M=32, P=6, S=10, generate_extra_components=False, generate_only_nrl=False, ctgan_model_name='CTGAN_Full', ctgan_pilot_sampling=False, printing=True)</code>","text":"<p>Represents the AFSC/Cadet matching problem object.</p> <p>Parameters:     data_name (str): The name of the data set. It can be an existing instance folder name or one of the following:                      \"Random\", \"Perfect\", or \"Realistic\". Defaults to \"Random\".     data_version (str): The version of the data set. It is used to manage different versions of cadets/AFSCs                         and handle NRL vs All cadet scenarios. Defaults to \"Default\".     degree_qual_type (str): The type of degree tier qualifications. It can be \"Binary\", \"Relaxed\", or \"Tiers\".                             Defaults to \"Consistent\".     num_value_function_breakpoints (int, optional): The number of breakpoints to use in the value functions.                                                    If None, the value functions will be loaded with the existing                                                    breakpoints. If an integer is provided, new value functions                                                    will be created. Defaults to None.     N (int): Number of cadets to generate. Defaults to 1600.     M (int): Number of AFSCs to generate. Defaults to 32.     P (int): Number of AFSC preferences to generate for each cadet. Defaults to 6.     S (int): Number of Bases to generate. Defaults to 10.     generate_only_nrl (bool): Whether to generate only NRL AFSCs. Defaults to False.     generate_extra_components (bool): Whether to generate extra components (bases/IST). Defaults to False.     ctgan_model_name (str): Name of the CTGAN model to import     ctgan_pilot_sampling (bool): Whether we should sample cadets in CTGAN based on the pilot preference condition     printing (bool): Whether to print status updates or not. Defaults to True.</p> <p>This class represents the AFSC/Cadet problem object. It can import existing data or generate new instances. The data set can be specified by providing the name of the instance folder or using the predefined data types (\"Random\", \"CTGAN\"). The problem instance includes information about cadets, AFSCs, value parameters, and solutions.</p> <p>Example usage:     instance = CadetCareerProblem(data_name=\"Random\", N=200, M=5, P=5)</p> Source code in <code>afccp/main.py</code> <pre><code>def __init__(self, data_name=\"Random\", data_version=\"Default\", degree_qual_type=\"Consistent\",\n             num_value_function_breakpoints=None, N=1600, M=32, P=6, S=10, generate_extra_components=False,\n             generate_only_nrl=False, ctgan_model_name='CTGAN_Full', ctgan_pilot_sampling=False, printing=True):\n    \"\"\"\n    Represents the AFSC/Cadet matching problem object.\n\n    Parameters:\n        data_name (str): The name of the data set. It can be an existing instance folder name or one of the following:\n                         \"Random\", \"Perfect\", or \"Realistic\". Defaults to \"Random\".\n        data_version (str): The version of the data set. It is used to manage different versions of cadets/AFSCs\n                            and handle NRL vs All cadet scenarios. Defaults to \"Default\".\n        degree_qual_type (str): The type of degree tier qualifications. It can be \"Binary\", \"Relaxed\", or \"Tiers\".\n                                Defaults to \"Consistent\".\n        num_value_function_breakpoints (int, optional): The number of breakpoints to use in the value functions.\n                                                       If None, the value functions will be loaded with the existing\n                                                       breakpoints. If an integer is provided, new value functions\n                                                       will be created. Defaults to None.\n        N (int): Number of cadets to generate. Defaults to 1600.\n        M (int): Number of AFSCs to generate. Defaults to 32.\n        P (int): Number of AFSC preferences to generate for each cadet. Defaults to 6.\n        S (int): Number of Bases to generate. Defaults to 10.\n        generate_only_nrl (bool): Whether to generate only NRL AFSCs. Defaults to False.\n        generate_extra_components (bool): Whether to generate extra components (bases/IST). Defaults to False.\n        ctgan_model_name (str): Name of the CTGAN model to import\n        ctgan_pilot_sampling (bool): Whether we should sample cadets in CTGAN based on the pilot preference condition\n        printing (bool): Whether to print status updates or not. Defaults to True.\n\n    This class represents the AFSC/Cadet problem object. It can import existing data or generate new instances.\n    The data set can be specified by providing the name of the instance folder or using the predefined data types\n    (\"Random\", \"CTGAN\"). The problem instance includes information about cadets, AFSCs, value parameters,\n    and solutions.\n\n    Example usage:\n        instance = CadetCareerProblem(data_name=\"Random\", N=200, M=5, P=5)\n    \"\"\"\n\n    # Shorten the module name so everything fits better\n    afccp_dp = afccp.data.processing\n\n    # Data attributes\n    self.data_version = data_version  # Version of instance (in parentheses of the instance sub-folders)\n    self.import_paths, self.export_paths = None, None  # We initialize these attributes to 'None'\n    self.printing = printing\n\n    # The data variant helps inform how the charts should be constructed\n    if len(data_name) == 1:  # \"A\", \"B\", \"C\", ...\n        self.data_variant = \"Scrubbed\"\n    elif data_name[:4].isdigit():  # \"2016\", \"2017\", \"2018\", ...\n        self.data_variant = \"Year\"\n    else:  # \"Random_1\", \"Random_2\", ...\n        self.data_variant = \"Generated\"\n\n    # Additional instance components (value parameters and solutions)\n    self.value_parameters, self.vp_name = None, None  # Set of weight and value parameters (and the name)\n    self.vp_dict = None  # Dictionary of value_parameters (set of sets)\n    self.solution, self.solution_name = None, None  # Dictionary of solution elements (and the name)\n    self.solutions = None  # Dictionary of solutions and their main attributes (x, j_array, afsc_array, etc.)\n\n    # Parameters from *former* Lt Rebecca Reynold's thesis\n    self.gp_parameters, self.gp_df = None, None\n\n    # Update instances available (for importing)\n    afccp.globals.instances_available = []\n    for other_data_name in os.listdir(afccp.globals.paths[\"instances\"]):\n        if os.path.isdir(afccp.globals.paths[\"instances\"] + other_data_name):\n            afccp.globals.instances_available.append(other_data_name)\n\n    # If we have an instance folder already for the specified instance (we're importing it)\n    if data_name in afccp.globals.instances_available:\n\n        # Gather information about the files we're importing and eventually exporting\n        self.data_name = data_name\n        self.import_paths, self.export_paths = afccp_dp.initialize_file_information(self.data_name,\n                                                                                    self.data_version)\n\n        # Print statement\n        if self.printing:\n            print(\"Importing '\" + data_name + \"' instance...\")\n\n        # Initialize dictionary of instance parameters (Information pertaining to cadets and AFSCs)\n        self.parameters = {\"Qual Type\": degree_qual_type}\n\n        # Import the \"fixed\" parameters (the information about cadets/AFSCs that, for the most part, doesn't change)\n        import_data_functions = [afccp_dp.import_afscs_data, afccp_dp.import_cadets_data,\n                                 afccp_dp.import_afsc_cadet_matrices_data, afccp_dp.import_additional_data]\n        for import_function in import_data_functions:  # Here we're looping through a list of functions!\n            self.parameters = import_function(self.import_paths, self.parameters)  # Python is nice like that...\n\n        # Additional sets and subsets of cadets/AFSCs need to be loaded into the instance parameters\n        self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n\n        # Import the \"Goal Programming\" dataframe (from Lt Rebecca Reynold's thesis)\n        if \"Goal Programming\" in self.import_paths:\n            self.gp_df = afccp.globals.import_csv_data(self.import_paths[\"Goal Programming\"])\n        else:  # Default \"GP\" file\n            self.gp_df = afccp.globals.import_data(\n                afccp.globals.paths[\"files\"] + \"gp_parameters.xlsx\")\n\n        # Import the \"Value Parameters\" data dictionary\n        self.vp_dict = afccp_dp.import_value_parameters_data(self.import_paths, self.parameters,\n                                                             num_value_function_breakpoints)\n\n        # Import the \"Solutions\" data dictionary\n        self.solutions = afccp_dp.import_solutions_data(self.import_paths, self.parameters)\n\n    # This is a new problem instance that we're generating (Should be \"Random\", \"Perfect\", or \"Realistic\")\n    else:\n\n        # Error Handling (Must be valid data generation parameter)\n        if data_name not in [\"Random\", \"CTGAN\"]:\n            raise ValueError(\n                \"Error. Instance name '\" + data_name + \"' is not a valid instance name. Instances must \"\n                                                       \"be either generated or imported. \"\n                                                       \"(Instance not found in folder).\")\n\n        # Determine the name of this instance (Random_1, Random_2, etc.)\n        for data_variant in [\"Random\", \"CTGAN\"]:\n            if data_name == data_variant:\n\n                # Determine name of data based on what instances are already in our \"instances\" folder\n                variant_counter = 1\n                name_determined = False\n                while not name_determined:\n                    check_name = data_variant + \"_\" + str(variant_counter)\n                    if check_name not in afccp.globals.instances_available:\n                        self.data_name = check_name\n                        name_determined = True\n                    else:\n                        variant_counter += 1\n\n        # Print statement\n        if self.printing:\n            print(\"Generating '\" + self.data_name + \"' instance...\")\n\n        # Want to generate a \"valid\" problem instance that meets the conditions below\n        invalid = True\n        while invalid:\n            invalid = False  # \"Innocent until proven guilty\"\n\n            # Generate a \"Random\" problem instance\n            if data_name == 'Random':\n                self.parameters = afccp.data.generation.generate_random_instance(\n                    N, M, P, S, generate_only_nrl=generate_only_nrl, generate_extra=generate_extra_components)\n\n                # Every cadet needs to be eligible for at least one AFSC\n                for i in range(self.parameters['N']):\n                    if np.sum(self.parameters['eligible'][i, :]) == 0:\n                        invalid = True  # Guilty!\n                        break\n\n                # Every AFSC needs to have at least one cadet eligible for it\n                for j in range(self.parameters['M']):\n                    if np.sum(self.parameters['eligible'][:, j]) == 0:\n                        invalid = True  # Guilty!\n                        break\n\n            # Generate a \"CTGAN\" problem instance\n            elif data_name == \"CTGAN\":\n                self.parameters = afccp.data.generation.generate_ctgan_instance(\n                    N, name=ctgan_model_name, pilot_condition=ctgan_pilot_sampling)\n\n            # We don't have that type of data available to generate\n            else:\n                raise ValueError(\"Data type '\" + data_name + \"' currently not a valid method of generating\"\n                                                             \" data.\")\n\n        # Additional sets and subsets of cadets/AFSCs need to be loaded into the instance parameters\n        self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n\n    # Initialize more \"functional\" parameters\n    self.mdl_p = afccp.data.support.initialize_instance_functional_parameters(\n        self.parameters[\"N\"])\n    self.reset_functional_parameters()\n\n    if self.printing:\n        print(\"Instance '\" + self.data_name + \"' initialized.\")\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.reset_functional_parameters","title":"<code>reset_functional_parameters(p_dict={})</code>","text":"<p>Resets the instance functional parameters and updates them with the new values from p_dict.</p> <p>Parameters:     p_dict (dict, optional): A dictionary containing the new parameter values to update. Defaults to an empty dict.</p> <p>This method resets the instance functional parameters of the CadetCareerProblem object to their default values. It then updates the parameters with new values specified in p_dict, if provided.</p> <p>The function first initializes the default functional parameters using the <code>initialize_instance_functional_parameters</code> function. It then iterates over the keys in p_dict and updates the corresponding parameters in self.mdl_p.</p> <p>Note that the update is performed in-place, modifying the self.mdl_p dictionary.</p> <p>If a parameter specified in p_dict does not exist in self.mdl_p, a warning message is printed.</p> <p>Example usage:     instance = CadetCareerProblem()     instance.reset_functional_parameters({'bar_color': 'blue', 'title_size': 18})</p> Source code in <code>afccp/main.py</code> <pre><code>def reset_functional_parameters(self, p_dict={}):\n    \"\"\"\n    Resets the instance functional parameters and updates them with the new values from p_dict.\n\n    Parameters:\n        p_dict (dict, optional): A dictionary containing the new parameter values to update. Defaults to an empty dict.\n\n    This method resets the instance functional parameters of the CadetCareerProblem object to their default values.\n    It then updates the parameters with new values specified in p_dict, if provided.\n\n    The function first initializes the default functional parameters using the `initialize_instance_functional_parameters`\n    function. It then iterates over the keys in p_dict and updates the corresponding parameters in self.mdl_p.\n\n    Note that the update is performed in-place, modifying the self.mdl_p dictionary.\n\n    If a parameter specified in p_dict does not exist in self.mdl_p, a warning message is printed.\n\n    Example usage:\n        instance = CadetCareerProblem()\n        instance.reset_functional_parameters({'bar_color': 'blue', 'title_size': 18})\n    \"\"\"\n\n    # Reset plot parameters and model parameters\n    self.mdl_p = afccp.data.support.initialize_instance_functional_parameters(self.parameters[\"N\"])\n\n    # Update plot parameters and model parameters\n    for key in p_dict:\n\n        if key in self.mdl_p:\n            self.mdl_p[key] = p_dict[key]\n        else:\n            print(\"WARNING. Specified parameter '\" + str(key) + \"' does not exist.\")\n\n    # Copy weight on GUO solution (relative to CASTLE) from \"mdl_p\" to \"parameters\"\n    self.parameters['w^G'] = self.mdl_p['w^G']\n\n    # Add in parameters based on total numbers of OTS accessions and overall accessions\n    if 'ots' in self.parameters['SOCs']:\n\n        # OTS accessions cap\n        if self.mdl_p['ots_accessions'] is None:\n            self.mdl_p['ots_accessions'] = np.sum(self.parameters['ots_quota'])\n\n        # Total numbers of cadets/candidates that we are matching\n        self.parameters['N^Match'] = self.parameters['N'] - \\\n                                     (len(self.parameters['I^OTS']) - self.mdl_p['ots_accessions'])  # OTS Unmatched\n        self.parameters['ots_accessions'] = self.mdl_p['ots_accessions']\n    else:\n        self.parameters['N^Match'] = self.parameters['N']\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.solution_handling","title":"<code>solution_handling(solution, printing=None)</code>","text":"<p>Determines what to do with the generated solution. This is a \"helper method\" and not intended to be called directly by the user.</p> <p>Parameters:     solution (dict): The solution dictionary containing the solution elements.     printing (str): Whether the code should print status updates or not</p> <p>This method takes a solution dictionary as input and performs the following tasks: - Evaluates the solution by calculating additional components. - Adjusts the solution method for VFT models. - Initializes the solutions dictionary if necessary. - Determines a unique name for the solution. - Checks if the solution is already in the solutions dictionary. - Adds the new solution to the solutions dictionary if it's a new solution. - Updates the solution name and assigns it to the instance.</p> Source code in <code>afccp/main.py</code> <pre><code>def solution_handling(self, solution, printing=None):\n    \"\"\"\n    Determines what to do with the generated solution. This is a \"helper method\" and not intended to be called\n    directly by the user.\n\n    Parameters:\n        solution (dict): The solution dictionary containing the solution elements.\n        printing (str): Whether the code should print status updates or not\n\n    This method takes a solution dictionary as input and performs the following tasks:\n    - Evaluates the solution by calculating additional components.\n    - Adjusts the solution method for VFT models.\n    - Initializes the solutions dictionary if necessary.\n    - Determines a unique name for the solution.\n    - Checks if the solution is already in the solutions dictionary.\n    - Adds the new solution to the solutions dictionary if it's a new solution.\n    - Updates the solution name and assigns it to the instance.\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Set the solution attribute to the instance (and calculate additional components)\n    self.solution = afccp.solutions.handling.evaluate_solution(\n        solution, self.parameters, self.value_parameters, re_calculate_x=self.mdl_p['re-calculate x'],\n        printing=printing)\n    self.solution['vp_name'] = self.vp_name  # Name of the value parameters currently evaluating this solution\n\n    # Adjust solution method for VFT models\n    if self.solution['method'] == \"VFT\" and self.mdl_p[\"approximate\"]:\n        self.solution['method'] = \"A-VFT\"\n    elif self.solution['method'] == \"VFT\" and not self.mdl_p[\"approximate\"]:\n        self.solution['method'] = \"E-VFT\"\n\n    # Initialize solutions dictionary if necessary\n    if self.solutions is None:\n        self.solutions = {}\n\n    # Determine solution name\n    if self.solution['method'] not in self.solutions:\n        solution_name = self.solution['method']\n    else:\n        count = 2\n        solution_name = self.solution['method'] + '_' + str(count)\n        while solution_name in self.solutions:\n            count += 1\n            solution_name = self.solution['method'] + '_' + str(count)\n\n    # Check if this solution is a new solution\n    new = True\n    for s_name in self.solutions:\n        p_i = afccp.solutions.handling.compare_solutions(self.solutions[s_name]['j_array'],\n                                                         self.solution['j_array'])\n\n        # Set the name of this solution to be the name of its equivalent that is already in the dictionary\n        if p_i == 1:\n\n            # If this is an array of unmatched cadets, we count it as unique since it's likely a SOC algorithm\n            if len(np.unique(self.solution['j_array'])) == 1 and self.parameters['M'] in self.solution['j_array']:\n                pass\n\n            else:\n                new = False\n                self.solution_name = s_name\n                self.solution['name'] = s_name\n                break\n\n    # If it is new, we add it to the dictionary and adjust the name of the activated instance solution\n    if new:\n        self.solutions[solution_name] = copy.deepcopy(self.solution)\n        self.solution_name = solution_name\n        self.solution['name'] = solution_name\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.error_checking","title":"<code>error_checking(test='None')</code>","text":"<p>This method is here to test different conditions and raise errors where conditions are not met.</p> Source code in <code>afccp/main.py</code> <pre><code>def error_checking(self, test=\"None\"):\n    \"\"\"\n    This method is here to test different conditions and raise errors where conditions are not met.\n    \"\"\"\n\n    # Nested function to test if value parameters are specified\n    def check_value_parameters():\n        if self.value_parameters is None:\n            if self.vp_dict is None:\n                raise ValueError(\n                    \"Error. No value parameters detected. You need to import the defaults first by using\"\n                    \"'instance.import_default_value_parameters()' as you currently do not have a \"\n                    \"'vp_dict' either.\")\n            else:\n                raise ValueError(\"Error. No value parameters set. You currently do have a 'vp_dict' and so all you \"\n                                 \"need to do is run 'instance.set_value_parameters()'. \")\n\n    if test == \"Value Parameters\":\n        check_value_parameters()\n    elif test == \"Pyomo Model\":\n        check_value_parameters()\n\n        # We don't have Pyomo\n        if not afccp.globals.use_pyomo:\n            raise ValueError(\"Error. Pyomo is not currently installed and is required to run pyomo models. Please\"\n                             \"install this library.\")\n\n        # No Base/Training components\n        if self.mdl_p['solve_extra_components'] and 'B' not in self.parameters:\n            raise ValueError(\"Error. No base/training components found in parameters. Cannot solve \"\n                             \"without the extra components.\")\n\n    elif test == 'Solutions':\n        if self.solutions is None:\n            raise ValueError(\"Error. No solutions dictionary detected. You need to solve this problem first.\")\n        else:\n            check_value_parameters()\n    elif test == 'Solution':\n        if self.solution is None:\n            if self.solutions is None:\n                raise ValueError(\"Error. No solutions dictionary detected. You need to solve this problem first.\")\n            else:\n                raise ValueError(\"Error. Solutions dictionary detected but you haven't actually initialized a \"\n                                 \"solution yet. You can do so by running 'instance.set_solution()'.\")\n        else:\n            check_value_parameters()\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.manage_solution_folder","title":"<code>manage_solution_folder()</code>","text":"<p>This method creates a solution folder in the Analysis &amp; Results directory if it doesn't already exist and returns a list of files in that folder.</p> <p>Returns:     List of filenames in the solution folder.</p> <p>This method is used to manage solution folders for organizing analysis and result files.</p> Source code in <code>afccp/main.py</code> <pre><code>def manage_solution_folder(self):\n    \"\"\"\n    This method creates a solution folder in the Analysis &amp; Results directory if it doesn't already exist and\n    returns a list of files in that folder.\n\n    Returns:\n        List of filenames in the solution folder.\n\n    This method is used to manage solution folders for organizing analysis and result files.\n    \"\"\"\n\n    # Make solution folder if it doesn't already exist\n    folder_path = self.export_paths['Analysis &amp; Results'] + self.solution_name\n    if self.solution_name not in os.listdir(self.export_paths['Analysis &amp; Results']):\n        os.mkdir(folder_path)\n\n    # Return list of files in the solution folder\n    return os.listdir(folder_path)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.evaluate_all_solutions","title":"<code>evaluate_all_solutions(solution_names=None)</code>","text":"<p>Evaluates all the solutions in the dictionary to acquire necessary metrics</p> Source code in <code>afccp/main.py</code> <pre><code>def evaluate_all_solutions(self, solution_names=None):\n    \"\"\"\n    Evaluates all the solutions in the dictionary to acquire necessary metrics\n    \"\"\"\n\n    if solution_names is None:\n        solution_names = list(self.solutions.keys())\n\n    if self.printing:\n        print('Evaluating solutions in this list:', solution_names)\n    for solution_name in solution_names:\n        self.solutions[solution_name] = afccp.solutions.handling.evaluate_solution(\n            self.solutions[solution_name], self.parameters, self.value_parameters, printing=False,\n            re_calculate_x=self.mdl_p['re-calculate x'])\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.calculate_qualification_matrix","title":"<code>calculate_qualification_matrix(printing=None)</code>","text":"<p>This procedure re-runs the CIP to Qual function to generate or update the qualification matrix. The qualification matrix determines whether cadets are eligible for specific AFSCs.</p> <p>Args: printing (bool, optional): If True, print messages about the process. Defaults to the class's <code>printing</code> attribute.</p> <p>Raises: ValueError: Raised when there are no CIP codes provided.</p> <p>This method recalculates the qualification matrix based on CIP (Career Intermission Program) codes and AFSCs. It updates the matrix and related parameters within the class.</p> Source code in <code>afccp/main.py</code> <pre><code>def calculate_qualification_matrix(self, printing=None):\n    \"\"\"\n    This procedure re-runs the CIP to Qual function to generate or update the qualification matrix.\n    The qualification matrix determines whether cadets are eligible for specific AFSCs.\n\n    Args:\n    printing (bool, optional): If True, print messages about the process. Defaults to the class's `printing` attribute.\n\n    Raises:\n    ValueError: Raised when there are no CIP codes provided.\n\n    This method recalculates the qualification matrix based on CIP (Career Intermission Program) codes and\n    AFSCs. It updates the matrix and related parameters within the class.\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print('Adjusting qualification matrix...')\n    parameters = copy.deepcopy(self.parameters)\n\n    # Generate new matrix\n    if \"cip1\" in parameters:\n        if \"cip2\" in parameters:\n            qual_matrix = afccp.data.support.cip_to_qual_tiers(\n                parameters[\"afscs\"][:parameters[\"M\"]], parameters['cip1'], cip2=parameters['cip2'])\n        else:\n            qual_matrix = afccp.data.support.cip_to_qual_tiers(\n                parameters[\"afscs\"][:parameters[\"M\"]], parameters['cip1'])\n    else:\n        raise ValueError(\"Error. Need to update the degree tier qualification matrix to include tiers \"\n                         \"('M1' instead of 'M' for example) but don't have CIP codes. Please incorporate this.\")\n\n    # Load data back into parameters\n    parameters[\"qual\"] = qual_matrix\n    parameters[\"qual_type\"] = \"Tiers\"\n    parameters[\"ineligible\"] = (np.core.defchararray.find(qual_matrix, \"I\") != -1) * 1\n    parameters[\"eligible\"] = (parameters[\"ineligible\"] == 0) * 1\n    parameters[\"exception\"] = (np.core.defchararray.find(qual_matrix, \"E\") != -1) * 1\n    for t in [1, 2, 3, 4]:\n        parameters[\"tier \" + str(t)] = (np.core.defchararray.find(qual_matrix, str(t)) != -1) * 1\n    parameters = afccp.data.adjustments.parameter_sets_additions(parameters)\n    self.parameters = copy.deepcopy(parameters)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.convert_to_scrubbed_instance","title":"<code>convert_to_scrubbed_instance(new_letter, printing=None)</code>","text":"<p>This method scrubs the AFSC names by sorting them by their PGL targets and creates a translated problem instance</p> <p>Parameters:</p> Name Type Description Default <code>printing</code> <p>If we should print status update</p> <code>None</code> <code>new_letter</code> <p>New letter to assign to this problem instance</p> required Source code in <code>afccp/main.py</code> <pre><code>def convert_to_scrubbed_instance(self, new_letter, printing=None):\n    \"\"\"\n    This method scrubs the AFSC names by sorting them by their PGL targets and creates a translated problem instance\n    :param printing: If we should print status update\n    :param new_letter: New letter to assign to this problem instance\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Converting problem instance '\" + self.data_name + \"' to new instance '\" + new_letter + \"'...\")\n\n    return afccp.data.adjustments.convert_instance_to_from_scrubbed(self, new_letter, translation_dict=None)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.convert_back_to_real_instance","title":"<code>convert_back_to_real_instance(translation_dict, data_name, printing=None)</code>","text":"<p>This method scrubs the AFSC names by sorting them by their PGL targets and creates a translated problem instance</p> <p>Parameters:</p> Name Type Description Default <code>printing</code> <p>If we should print status update</p> <code>None</code> <code>translation_dict</code> <p>Dictionary generated from the scrubbed instance method</p> required <code>data_name</code> <p>Data Name of the new instance</p> required Source code in <code>afccp/main.py</code> <pre><code>def convert_back_to_real_instance(self, translation_dict, data_name, printing=None):\n    \"\"\"\n    This method scrubs the AFSC names by sorting them by their PGL targets and creates a translated problem instance\n    :param printing: If we should print status update\n    :param translation_dict: Dictionary generated from the scrubbed instance method\n    :param data_name: Data Name of the new instance\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Converting problem instance '\" + self.data_name + \"' back to instance '\" + data_name + \"'...\")\n\n    return afccp.data.adjustments.convert_instance_to_from_scrubbed(\n        self, translation_dict=translation_dict, data_name=data_name)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.fix_generated_data","title":"<code>fix_generated_data(printing=None)</code>","text":"<p>NOTE: ONLY DO THIS FOR GENERATED DATA</p> Source code in <code>afccp/main.py</code> <pre><code>def fix_generated_data(self, printing=None):\n    \"\"\"\n    NOTE: ONLY DO THIS FOR GENERATED DATA\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Get \"c_pref_matrix\" from cadet preferences\n    self.convert_utilities_to_preferences(cadets_as_well=True)\n\n    # Generate AFSC preferences for this problem instance\n    self.generate_fake_afsc_preferences()\n\n    # Generate rated data (Separate datasets for each SOC)\n    self.generate_rated_data()\n\n    # Update qualification matrix from AFSC preferences (treating CFM lists as \"gospel\" except for Rated/USSF)\n    self.update_qualification_matrix_from_afsc_preferences()\n\n    # Removes ineligible cadets from all 3 matrices: degree qualifications, cadet preferences, AFSC preferences\n    self.remove_ineligible_choices(printing=printing)\n\n    # Take the preferences dictionaries and update the matrices from them (using cadet/AFSC indices)\n    self.update_preference_matrices()  # 1, 2, 4, 6, 7 -&gt; 1, 2, 3, 4, 5 (preference lists need to omit gaps)\n\n    # Convert AFSC preferences to percentiles (0 to 1)\n    self.convert_afsc_preferences_to_percentiles()  # 1, 2, 3, 4, 5 -&gt; 1, 0.8, 0.6, 0.4, 0.2\n\n    # The \"cadet columns\" are located in Cadets.csv and contain the utilities/preferences in order of preference\n    self.update_cadet_columns_from_matrices()  # We haven't touched \"c_preferences\" and \"c_utilities\" until now\n\n    # Generate fake (random) set of value parameters\n    self.generate_random_value_parameters()\n\n    # Sanity check the parameters to make sure it all looks good! (No issues found.)\n    self.parameter_sanity_check()\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.update_qualification_matrix_from_afsc_preferences","title":"<code>update_qualification_matrix_from_afsc_preferences(printing=None)</code>","text":"<p>This method updates the qualification matrix to reflect cadet eligibility for AFSCs based on their preferences.</p> <p>It performs the following steps: 1. Checks if there is an AFSC preference matrix ('a_pref_matrix') in the parameters. If not, it raises a ValueError. 2. Iterates through each AFSC ('afscs') in the parameters. 3. Determines cadet eligibility and ineligibility for each AFSC based on both AFSC preferences and degree qualifications. 4. If cadet eligibility differs between preference and qualification lists, it prints a message indicating the mismatch. 5. For Rated or USSF AFSCs, it updates the qualification matrix, making more cadets ineligible based on CFM lists. 6. For NRL AFSCs, it handles cadets eligible based on CFM lists but not the AFOCD by giving them exceptions. 7. For NRL AFSCs, it also handles cadets eligible based on the AFOCD but not the CFM lists by marking them as a warning. 8. Updates the qualification matrix with these changes and updates additional sets and subsets in the parameters.</p> <p>This method helps ensure that the qualification matrix aligns with cadet preferences and the AFOCD.</p> <p>Args:     self: The class instance containing the qualification matrix and parameters.</p> <p>Returns:     None</p> <p>Raises:     ValueError: If there is no AFSC preference matrix ('a_pref_matrix') in the parameters.     :param printing: print status updates</p> Source code in <code>afccp/main.py</code> <pre><code>def update_qualification_matrix_from_afsc_preferences(self, printing=None):\n    \"\"\"\n    This method updates the qualification matrix to reflect cadet eligibility for AFSCs based on their preferences.\n\n    It performs the following steps:\n    1. Checks if there is an AFSC preference matrix ('a_pref_matrix') in the parameters. If not, it raises a ValueError.\n    2. Iterates through each AFSC ('afscs') in the parameters.\n    3. Determines cadet eligibility and ineligibility for each AFSC based on both AFSC preferences and degree qualifications.\n    4. If cadet eligibility differs between preference and qualification lists, it prints a message indicating the mismatch.\n    5. For Rated or USSF AFSCs, it updates the qualification matrix, making more cadets ineligible based on CFM lists.\n    6. For NRL AFSCs, it handles cadets eligible based on CFM lists but not the AFOCD by giving them exceptions.\n    7. For NRL AFSCs, it also handles cadets eligible based on the AFOCD but not the CFM lists by marking them as a warning.\n    8. Updates the qualification matrix with these changes and updates additional sets and subsets in the parameters.\n\n    This method helps ensure that the qualification matrix aligns with cadet preferences and the AFOCD.\n\n    Args:\n        self: The class instance containing the qualification matrix and parameters.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If there is no AFSC preference matrix ('a_pref_matrix') in the parameters.\n        :param printing: print status updates\n\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Shorthand\n    p = self.parameters\n\n    if 'a_pref_matrix' not in p:\n        raise ValueError(\"No AFSC preference matrix.\")\n\n    # Loop through each AFSC\n    for j, afsc in enumerate(p['afscs'][:p['M']]):\n\n        # Eligible &amp; Ineligible cadets based on the CFM preference lists\n        preference_eligible_cadets = np.where(p['a_pref_matrix'][:, j] &gt; 0)[0]\n        preference_ineligible_cadets = np.where(p['a_pref_matrix'][:, j] == 0)[0]\n\n        # Eligible cadets based on their degree qualifications (and later using exceptions)\n        qual_eligible_cadets = np.where(p['eligible'][:, j])[0]\n\n        # There's a difference between the two\n        if len(preference_eligible_cadets) != len(qual_eligible_cadets) and printing:\n            print(j, \"AFSC '\" + afsc + \"' has\", len(preference_eligible_cadets),\n                  \"eligible cadets according to the AFSC preference matrix but\",\n                  len(qual_eligible_cadets), \"according to the qual matrix.\")\n\n        # If this is a Rated or USSF AFSC, we have to make more cadets ineligible based on CFM lists\n        if p['acc_grp'][j] in ['Rated', 'USSF']:\n\n            # Only do this if we have ineligible cadets here\n            if len(preference_ineligible_cadets) &gt; 0:\n\n                # If there's already an ineligible tier in this AFSC, we use it\n                if \"I = 0\" in p['Deg Tiers'][j]:\n                    val = \"I\" + str(p['t_count'][j])\n                else:\n                    val = \"I\" + str(p['t_count'][j] + 1)\n                    if printing:\n                        print(j, \"AFSC '\" + afsc + \"' doesn't have an ineligible tier in the Deg Tiers section\"\n                                                \" of the AFSCs.csv file. Please add one.\")\n\n                # Update qual matrix if needed\n                if len(preference_ineligible_cadets) &gt; 0 and printing:\n                    print(j, \"Making\", len(preference_ineligible_cadets), \"cadets ineligible for '\" + afsc +\n                          \"' by altering their qualification to '\" + val + \"'. \")\n                    self.parameters['qual'][preference_ineligible_cadets, j] = val\n\n        # NRL AFSC\n        else:\n\n            # Cadets that are \"eligible\" for the AFSC based on the CFM lists but not the AFOCD\n            exception_cadets = np.array([i for i in preference_eligible_cadets if i not in qual_eligible_cadets])\n\n            # Only do this if we have exception cadets here\n            if len(exception_cadets) &gt; 0:\n\n                # If there's an ineligible tier, we use this tier for the cadets with the exception\n                if \"I = 0\" in p['Deg Tiers'][j]:\n                    val = \"E\" + str(p['t_count'][j])\n                else:\n                    val = \"E\" + str(p['t_count'][j] + 1)\n\n                # Update qual matrix\n                if printing:\n                    print(j, \"Giving\", len(exception_cadets), \"cadets an exception for '\" + afsc +\n                          \"' by altering their qualification to '\" + val + \"'. \")\n                self.parameters['qual'][exception_cadets, j] = val\n\n            # Cadets that are eligible for the AFSC based on the AFOCD but not the CFM lists\n            mistake_cadets = np.array([i for i in qual_eligible_cadets if i not in preference_eligible_cadets])\n\n            if len(mistake_cadets) &gt; 0 and printing:\n                print(j, 'WARNING. There are', len(mistake_cadets), 'cadets that are eligible for AFSC', afsc,\n                      ' according to the AFOCD but not the CFM lists. These are the cadets at indices',\n                      mistake_cadets)\n\n    # Update qual stuff\n    self.parameters[\"ineligible\"] = (np.core.defchararray.find(self.parameters['qual'], \"I\") != -1) * 1\n    self.parameters[\"eligible\"] = (self.parameters[\"ineligible\"] == 0) * 1\n    self.parameters[\"exception\"] = (np.core.defchararray.find(self.parameters['qual'], \"E\") != -1) * 1\n\n    # Update the additional sets and subsets for the parameters\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.convert_utilities_to_preferences","title":"<code>convert_utilities_to_preferences(cadets_as_well=False)</code>","text":"<p>Convert Utility Matrices to Preference Matrices.</p> <p>This method converts utility matrices into preference matrices for AFSC assignments. It provides the option to convert cadet utility matrices and, if necessary, cadet rankings as well.</p> <p>Parameters: - cadets_as_well (bool, optional): If True, both cadet and AFSC utility matrices are converted to preferences.   If False (default), only AFSC utility matrices are converted.</p> <p>Description: Utility matrices contain numerical values that represent the desirability or quality of a cadet's assignment to a particular AFSC. Converting these utility values into preferences is essential for the assignment process. Preferences are often represented as rankings or ordered lists, with higher values indicating higher preferences.</p> <p>This method ensures that both cadet and AFSC utility matrices are properly transformed into preferences, making them suitable for use in the assignment algorithm.</p> Source code in <code>afccp/main.py</code> <pre><code>def convert_utilities_to_preferences(self, cadets_as_well=False):\n    \"\"\"\n    Convert Utility Matrices to Preference Matrices.\n\n    This method converts utility matrices into preference matrices for AFSC assignments. It provides the option to\n    convert cadet utility matrices and, if necessary, cadet rankings as well.\n\n    Parameters:\n    - cadets_as_well (bool, optional): If True, both cadet and AFSC utility matrices are converted to preferences.\n      If False (default), only AFSC utility matrices are converted.\n\n    Description:\n    Utility matrices contain numerical values that represent the desirability or quality of a cadet's assignment\n    to a particular AFSC. Converting these utility values into preferences is essential for the assignment process.\n    Preferences are often represented as rankings or ordered lists, with higher values indicating higher preferences.\n\n    This method ensures that both cadet and AFSC utility matrices are properly transformed into preferences, making\n    them suitable for use in the assignment algorithm.\n    \"\"\"\n\n    # Rest of your method code here\n\n    self.parameters = afccp.data.preferences.convert_utility_matrices_preferences(self.parameters,\n                                                                                  cadets_as_well)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.generate_fake_afsc_preferences","title":"<code>generate_fake_afsc_preferences(fix_cadet_eligibility=False)</code>","text":"<p>Generate Simulated AFSC Preferences using Value Focussed Thinking (VFT) Parameters.</p> <p>This method generates simulated AFSC preferences for cadets based on the VFT parameters. These preferences are useful for testing and analysis purposes and can be used as inputs to the assignment algorithm.</p> <p>Parameters: - fix_cadet_eligibility (bool, optional): If True, it fixes cadet eligibility based on VFT parameters before generating preferences. If False (default), preferences are generated without modifying eligibility. Use this option to create preferences for a specific scenario where cadet eligibility should be controlled.</p> <p>Description: Simulated preferences are created by modeling cadet choices using the VFT parameters. These preferences are essential for conducting experiments and evaluating the performance of the assignment algorithm under various conditions.</p> <p>This method allows you to generate preferences for a specific scenario by controlling cadet eligibility or generate preferences without modifying eligibility, providing flexibility for testing and analysis.</p> Source code in <code>afccp/main.py</code> <pre><code>def generate_fake_afsc_preferences(self, fix_cadet_eligibility=False):\n    \"\"\"\n    Generate Simulated AFSC Preferences using Value Focussed Thinking (VFT) Parameters.\n\n    This method generates simulated AFSC preferences for cadets based on the VFT parameters.\n    These preferences are useful for testing and analysis purposes and can be used as inputs to the assignment algorithm.\n\n    Parameters:\n    - fix_cadet_eligibility (bool, optional): If True, it fixes cadet eligibility based on VFT parameters before\n    generating preferences. If False (default), preferences are generated without modifying eligibility. Use this\n    option to create preferences for a specific scenario where cadet eligibility should be controlled.\n\n    Description:\n    Simulated preferences are created by modeling cadet choices using the VFT parameters.\n    These preferences are essential for conducting experiments and evaluating the performance of the assignment\n    algorithm under various conditions.\n\n    This method allows you to generate preferences for a specific scenario by controlling cadet eligibility or\n    generate preferences without modifying eligibility, providing flexibility for testing and analysis.\n    \"\"\"\n    self.parameters = afccp.data.preferences.generate_fake_afsc_preferences(\n        self.parameters, self.value_parameters, fix_cadet_eligibility=fix_cadet_eligibility)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.convert_afsc_preferences_to_percentiles","title":"<code>convert_afsc_preferences_to_percentiles(printing=None)</code>","text":"<p>Convert AFSC Preference Lists to Normalized Percentiles.</p> <p>This method takes the AFSC preference lists (a_pref_matrix) for each cadet and converts them into normalized percentiles based on the provided preferences. The resulting percentiles represent how each cadet ranks AFSCs compared to their peers.</p> <p>The percentiles are stored in the 'afsc_utility' on AFSCs Utility.csv. This conversion can be helpful for analyzing cadet preferences and running assignment algorithms.</p> Source code in <code>afccp/main.py</code> <pre><code>def convert_afsc_preferences_to_percentiles(self, printing=None):\n    \"\"\"\n    Convert AFSC Preference Lists to Normalized Percentiles.\n\n    This method takes the AFSC preference lists (a_pref_matrix) for each cadet and converts them into normalized percentiles\n    based on the provided preferences. The resulting percentiles represent how each cadet ranks AFSCs compared to their peers.\n\n    The percentiles are stored in the 'afsc_utility' on AFSCs Utility.csv. This conversion can be helpful for analyzing cadet\n    preferences and running assignment algorithms.\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Converting AFSC preferences (a_pref_matrix) into percentiles (afsc_utility on AFSCs Utility.csv)...\")\n    self.parameters = afccp.data.preferences.convert_afsc_preferences_to_percentiles(self.parameters)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.remove_ineligible_choices","title":"<code>remove_ineligible_choices(printing=None)</code>","text":"<p>Remove Ineligible Choices Based on Qualification.</p> <p>This method utilizes the qualification matrix (qual) to remove ineligible choices from both AFSC preferences (a_pref_matrix) and cadet preferences (c_pref_matrix). Ineligible choices are determined based on the qualification requirements, and this process helps ensure that the final assignments meet the qualification criteria.</p> <p>Parameters: - printing (bool, optional): If True, print progress and debug information. If None (default), it uses the class-level 'printing' attribute.</p> Source code in <code>afccp/main.py</code> <pre><code>def remove_ineligible_choices(self, printing=None):\n    \"\"\"\n    Remove Ineligible Choices Based on Qualification.\n\n    This method utilizes the qualification matrix (qual) to remove ineligible choices from both AFSC preferences (a_pref_matrix)\n    and cadet preferences (c_pref_matrix). Ineligible choices are determined based on the qualification requirements, and\n    this process helps ensure that the final assignments meet the qualification criteria.\n\n    Parameters:\n    - printing (bool, optional): If True, print progress and debug information. If None (default), it uses the class-level 'printing' attribute.\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Removing ineligible cadets based on any of the three eligibility sources \"\n              \"(c_pref_matrix, a_pref_matrix, qual)...\")\n\n    self.parameters = afccp.data.preferences.remove_ineligible_cadet_choices(self.parameters, printing=printing)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.update_cadet_columns_from_matrices","title":"<code>update_cadet_columns_from_matrices(printing=None)</code>","text":"<p>Update Cadet Columns from Preference Matrix.</p> <p>This method updates the preference and utility columns for cadets based on the preference matrix (c_pref_matrix). The preferences are converted to preference columns, and the utility values are extracted and stored in their respective columns.</p> Source code in <code>afccp/main.py</code> <pre><code>def update_cadet_columns_from_matrices(self, printing=None):\n    \"\"\"\n    Update Cadet Columns from Preference Matrix.\n\n    This method updates the preference and utility columns for cadets based on the preference matrix (c_pref_matrix).\n    The preferences are converted to preference columns, and the utility values are extracted and stored in their respective columns.\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print('Updating cadet columns (Cadets.csv...c_utilities, c_preferences) from the preference matrix '\n              '(c_pref_matrix)...')\n\n    # Update parameters\n    self.parameters['c_preferences'], self.parameters['c_utilities'] = \\\n        afccp.data.preferences.get_utility_preferences_from_preference_array(self.parameters)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.update_preference_matrices","title":"<code>update_preference_matrices(printing=None)</code>","text":"<p>Update Preference Matrices from Preference Arrays.</p> <p>This method reconstructs the cadet preference matrices from the preference arrays by renumbering preferences to eliminate gaps. In preference lists, gaps may exist due to unranked choices, and this method ensures preferences are sequentially numbered.</p> Source code in <code>afccp/main.py</code> <pre><code>def update_preference_matrices(self, printing=None):\n    \"\"\"\n    Update Preference Matrices from Preference Arrays.\n\n    This method reconstructs the cadet preference matrices from the preference arrays by renumbering preferences to eliminate gaps.\n    In preference lists, gaps may exist due to unranked choices, and this method ensures preferences are sequentially numbered.\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Updating cadet preference matrices from the preference dictionaries. \"\n              \"ie. 1, 2, 4, 6, 7 -&gt; 1, 2, 3, 4, 5 (preference lists need to omit gaps)\")\n\n    # Update parameters\n    self.parameters = afccp.data.preferences.update_preference_matrices(self.parameters)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.update_cadet_utility_matrices_from_cadets_data","title":"<code>update_cadet_utility_matrices_from_cadets_data(printing=None)</code>","text":"<p>Update Cadet Utility Matrices from Cadets Data.</p> <p>This method updates the utility matrices ('utility' and 'cadet_utility') by extracting data from the \"Util_1 -&gt; Util_P\" columns in Cadets.csv.</p> Source code in <code>afccp/main.py</code> <pre><code>def update_cadet_utility_matrices_from_cadets_data(self, printing=None):\n    \"\"\"\n    Update Cadet Utility Matrices from Cadets Data.\n\n    This method updates the utility matrices ('utility' and 'cadet_utility') by extracting data from the \"Util_1 -&gt; Util_P\" columns in Cadets.csv.\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Updating cadet utility matrices ('utility' and 'cadet_utility') from the 'c_utilities' matrix\")\n\n    # Update parameters\n    self.parameters = afccp.data.preferences.update_cadet_utility_matrices(self.parameters)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.fill_remaining_afsc_choices","title":"<code>fill_remaining_afsc_choices(printing=None)</code>","text":"<p>Returns:</p> Type Description Source code in <code>afccp/main.py</code> <pre><code>def fill_remaining_afsc_choices(self, printing=None):\n    \"\"\"\n\n    :return:\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Filling remaining cadet preferences arbitrarily with the exception of the bottom choices\")\n\n    # Update parameters\n    self.parameters = afccp.data.preferences.fill_remaining_preferences(self.parameters)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.create_final_utility_matrix_from_new_formula","title":"<code>create_final_utility_matrix_from_new_formula(printing=None)</code>","text":"Source code in <code>afccp/main.py</code> <pre><code>def create_final_utility_matrix_from_new_formula(self, printing=None):\n    \"\"\"\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Creating 'Final' cadet utility matrix from the new formula with different conditions...\")\n\n    # Update parameters\n    self.parameters = afccp.data.preferences.create_final_cadet_utility_matrix_from_new_formula(self.parameters)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.generate_rated_data","title":"<code>generate_rated_data()</code>","text":"<p>This method generates Rated data for USAFA and ROTC if it doesn't already exist. This data can then also be exported back as a csv for reference.</p> Source code in <code>afccp/main.py</code> <pre><code>def generate_rated_data(self):\n    \"\"\"\n    This method generates Rated data for USAFA and ROTC if it doesn't already exist. This data can then also be\n    exported back as a csv for reference.\n    \"\"\"\n\n    # Generate Rated Data\n    self.parameters = afccp.data.preferences.generate_rated_data(self.parameters)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.construct_rated_preferences_from_om_by_soc","title":"<code>construct_rated_preferences_from_om_by_soc(printing=None)</code>","text":"<p>This method takes the two OM Rated matrices (from both SOCs) and then zippers them together to create a combined \"1-N\" list for the Rated AFSCs. The AFSC preference matrix is updated as well as the AFSC preference lists</p> Source code in <code>afccp/main.py</code> <pre><code>def construct_rated_preferences_from_om_by_soc(self, printing=None):\n    \"\"\"\n    This method takes the two OM Rated matrices (from both SOCs) and then zippers them together to\n    create a combined \"1-N\" list for the Rated AFSCs. The AFSC preference matrix is updated as well as the\n    AFSC preference lists\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Integrating rated preferences from OM matrices for each SOC...\")\n\n    # Generate Rated Preferences\n    self.parameters = afccp.data.preferences.construct_rated_preferences_from_om_by_soc(self.parameters)\n    self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.set_value_parameters","title":"<code>set_value_parameters(vp_name=None)</code>","text":"<p>Sets the current instance value parameters to a specified set based on the vp_name. This vp_name must be in the value parameter dictionary</p> Source code in <code>afccp/main.py</code> <pre><code>def set_value_parameters(self, vp_name=None):\n    \"\"\"\n    Sets the current instance value parameters to a specified set based on the vp_name. This vp_name must be\n    in the value parameter dictionary\n    \"\"\"\n    if self.vp_dict is None:\n        raise ValueError(\"Error. No sets of value parameters (vp_dict) detected. You need to import the \"\n                         \"defaults first by using 'instance.import_default_value_parameters()'.\")\n    else:\n        if vp_name is None:  # Name not specified\n            self.vp_name = list(self.vp_dict.keys())[0]  # Take the first set in the dictionary\n            self.value_parameters = copy.deepcopy(self.vp_dict[self.vp_name])\n        else:  # Name specified\n            if vp_name not in self.vp_dict:\n                raise ValueError(vp_name + ' set not in value parameter dictionary. Available sets are:',\n                                 self.vp_dict.keys())\n            else:\n                self.value_parameters = copy.deepcopy(self.vp_dict[vp_name])\n                self.vp_name = vp_name\n\n        if self.solution is not None:\n            self.measure_solution()\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.update_value_parameters","title":"<code>update_value_parameters(num_breakpoints=24)</code>","text":"<p>Simple method to take the current set of value parameters and update their sets and subsets and all that. This method also updates the set of value parameters in the dictionary</p> <p>Parameters:</p> Name Type Description Default <code>num_breakpoints</code> <p>Number of breakpoints to use when building the value functions</p> <code>24</code> Source code in <code>afccp/main.py</code> <pre><code>def update_value_parameters(self, num_breakpoints=24):\n    \"\"\"\n    Simple method to take the current set of value parameters and update their sets and subsets and all that.\n    This method also updates the set of value parameters in the dictionary\n    :param num_breakpoints: Number of breakpoints to use when building the value functions\n    \"\"\"\n\n    # Module shorthand\n    afccp_vp = afccp.data.values\n\n    # Update the value functions and cadet/AFSC weights\n    self.value_parameters = afccp_vp.update_value_and_weight_functions(self, num_breakpoints)\n\n    # \"Condense\" the value functions by removing unnecessary zeros in the breakpoints\n    self.value_parameters = afccp_vp.condense_value_functions(self.parameters, self.value_parameters)\n\n    # Add indexed sets and subsets of AFSCs and AFSC objectives\n    self.value_parameters = afccp_vp.value_parameters_sets_additions(self.parameters, self.value_parameters)\n\n    # Update the set of value parameters in the dictionary (vp_dict attribute)\n    self.update_value_parameters_in_dict()\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.save_new_value_parameters_to_dict","title":"<code>save_new_value_parameters_to_dict(value_parameters=None)</code>","text":"<p>Adds the set of value parameters to a dictionary as a new set (if it is a unique set)</p> Source code in <code>afccp/main.py</code> <pre><code>def save_new_value_parameters_to_dict(self, value_parameters=None):\n    \"\"\"\n    Adds the set of value parameters to a dictionary as a new set (if it is a unique set)\n    \"\"\"\n    # Grab the value parameters\n    if value_parameters is None:\n        value_parameters = self.value_parameters\n\n    # Make sure this is a valid dictionary of value parameters\n    if value_parameters is not None:\n        if self.vp_dict is None:\n            self.vp_dict, self.vp_name = {\"VP\": copy.deepcopy(value_parameters)}, \"VP\"\n        else:\n\n            # Determine new value parameters name\n            vp_name, v = \"VP2\", 2\n            while vp_name in self.vp_dict:\n                v += 1\n                vp_name = \"VP\" + str(v)\n\n            # Check if this new set is unique or not to get the name of the set\n            unique = self.check_unique_value_parameters()\n            if unique is True: # If it's unique, we save this new set of value parameters to the dictionary\n                self.vp_dict[vp_name], self.vp_name = copy.deepcopy(value_parameters), vp_name\n            else:  # If it's not unique, then \"unique\" is the name of the matching set of value parameters\n                self.vp_name = unique\n\n    else:\n        raise ValueError(\"Error. No value parameters set. You currently do have a 'vp_dict' and so all you \"\n                                 \"need to do is run 'instance.set_value_parameters()'. \")\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.update_value_parameters_in_dict","title":"<code>update_value_parameters_in_dict(vp_name=None)</code>","text":"<p>Updates a set of value parameters in the dictionary using the current instance value parameters</p> <p>Parameters:</p> Name Type Description Default <code>vp_name</code> <p>name of the set of value parameters to update (default current vp_name)</p> <code>None</code> Source code in <code>afccp/main.py</code> <pre><code>def update_value_parameters_in_dict(self, vp_name=None):\n    \"\"\"\n    Updates a set of value parameters in the dictionary using the current instance value parameters\n    :param vp_name: name of the set of value parameters to update (default current vp_name)\n    \"\"\"\n    if self.value_parameters is not None:\n        if self.vp_dict is None:\n            raise ValueError('No value parameter dictionary detected')\n        else:\n            if vp_name is None:\n                vp_name = self.vp_name\n\n            # Set attributes\n            self.vp_dict[vp_name] = copy.deepcopy(self.value_parameters)\n            self.vp_name = vp_name\n\n    else:\n        raise ValueError('No instance value parameters detected')\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.check_unique_value_parameters","title":"<code>check_unique_value_parameters(value_parameters=None, vp_name1=None, vp_name2=None, printing=False)</code>","text":"<p>Take in a new set of value parameters and see if this set is in the dictionary already. Return True if the the set of parameters is unique, or return the name of the matching set otherwise</p> Source code in <code>afccp/main.py</code> <pre><code>def check_unique_value_parameters(self, value_parameters=None, vp_name1=None, vp_name2=None, printing=False):\n    \"\"\"\n    Take in a new set of value parameters and see if this set is in the dictionary already. Return True if the\n    the set of parameters is unique, or return the name of the matching set otherwise\n    \"\"\"\n\n    # If we specify this name, we want to compare the value parameters against this one\n    if vp_name2 is not None:\n        value_parameters = self.vp_dict[vp_name2]\n        vp_name1 = vp_name2\n\n    # If we don't specify \"vp_name2\", we check the other conditions\n    else:\n        if value_parameters is None:\n            value_parameters = self.value_parameters\n            vp_name1 = self.vp_name\n\n        if vp_name1 is None:\n            vp_name1 = \"VP (Unspecified)\"\n\n    # Assume the new set is unique until proven otherwise\n    unique = True\n    for vp_name in self.vp_dict:\n        identical = afccp.data.values.compare_value_parameters(\n            self.parameters, value_parameters, self.vp_dict[vp_name], vp_name1, vp_name, printing=printing)\n        if identical:\n            unique = vp_name\n            break\n    return unique\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.generate_random_value_parameters","title":"<code>generate_random_value_parameters(num_breakpoints=24, vp_weight=100, printing=None)</code>","text":"<p>Generates value parameters for a given problem instance from scratch</p> Source code in <code>afccp/main.py</code> <pre><code>def generate_random_value_parameters(self, num_breakpoints=24, vp_weight=100, printing=None):\n    \"\"\"\n    Generates value parameters for a given problem instance from scratch\n    \"\"\"\n\n    # Print Statement\n    if printing is None:\n        printing = self.printing\n\n    # Generate random set of value parameters\n    value_parameters = afccp.data.generation.generate_random_value_parameters(\n        self.parameters, num_breakpoints=num_breakpoints)\n\n    # Module shorthand\n    afccp_vp = afccp.data.values\n\n    # \"Condense\" the value functions by removing unnecessary zeros\n    value_parameters = afccp_vp.condense_value_functions(self.parameters, value_parameters)\n\n    # Add indexed sets and subsets of AFSCs and AFSC objectives\n    value_parameters = afccp_vp.value_parameters_sets_additions(self.parameters, value_parameters)\n\n    # Weight of the value parameters as a whole\n    value_parameters['vp_weight'] = vp_weight\n\n    # Set value parameters to instance attribute\n    if self.mdl_p[\"set_to_instance\"]:\n        self.value_parameters = value_parameters\n\n    # Save new set of value parameters to dictionary\n    if self.mdl_p[\"add_to_dict\"]:\n        self.save_new_value_parameters_to_dict(value_parameters)\n\n    return value_parameters\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.import_default_value_parameters","title":"<code>import_default_value_parameters(no_constraints=False, num_breakpoints=24, generate_afsc_weights=True, vp_weight=100, printing=None, vp_defaults_filename=None)</code>","text":"<p>Import default value parameter settings and generate value parameters for this instance.</p> Source code in <code>afccp/main.py</code> <pre><code>def import_default_value_parameters(self, no_constraints=False, num_breakpoints=24,\n                                    generate_afsc_weights=True, vp_weight=100, printing=None,\n                                    vp_defaults_filename=None):\n    \"\"\"\n    Import default value parameter settings and generate value parameters for this instance.\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Folder/Files information\n    folder_path = afccp.globals.paths[\"support\"] + \"value parameters defaults/\"\n    vp_defaults_folder = os.listdir(folder_path)\n\n    if vp_defaults_filename is None:\n        vp_defaults_filename = \"Value_Parameters_Defaults_\" + self.data_name + \".xlsx\"\n\n    # Determine the path to the default value parameters we need to import\n    if vp_defaults_filename in vp_defaults_folder:\n        filename = vp_defaults_filename\n    elif len(self.data_name) == 4:\n        filename = \"Value_Parameters_Defaults.xlsx\"\n    elif \"Perfect\" in self.data_name:\n        filename = \"Value_Parameters_Defaults_Perfect.xlsx\"\n    else:\n        filename = \"Value_Parameters_Defaults_Generated.xlsx\"\n    filepath = folder_path + filename\n\n    # Module shorthand\n    afccp_vp = afccp.data.values\n\n    # Import \"default value parameters\" from excel\n    dvp = afccp_vp.default_value_parameters_from_excel(filepath, num_breakpoints=num_breakpoints, printing=printing)\n\n    # Generate this instance's value parameters from the defaults\n    value_parameters = afccp_vp.generate_value_parameters_from_defaults(\n        self.parameters, generate_afsc_weights=generate_afsc_weights, default_value_parameters=dvp)\n\n    # Add some additional components to the value parameters\n    if no_constraints:\n        value_parameters['constraint_type'] = np.zeros([self.parameters['M'], value_parameters['O']])\n\n    # \"Condense\" the value functions by removing unnecessary zeros\n    value_parameters = afccp_vp.condense_value_functions(self.parameters, value_parameters)\n\n    # Add indexed sets and subsets of AFSCs and AFSC objectives\n    value_parameters = afccp_vp.value_parameters_sets_additions(self.parameters, value_parameters)\n\n    # Weight of the value parameters as a whole\n    value_parameters['vp_weight'] = vp_weight\n\n    # Set value parameters to instance attribute\n    if self.mdl_p[\"set_to_instance\"]:\n        self.value_parameters = value_parameters\n        if self.solution is not None:\n            self.solution = afccp.solutions.handling.evaluate_solution(\n                self.solution, self.parameters, self.value_parameters, printing=printing)\n\n    # Save new set of value parameters to dictionary\n    if self.mdl_p[\"add_to_dict\"]:\n        self.save_new_value_parameters_to_dict(value_parameters)\n\n    if self.printing:\n        print('Imported.')\n\n    return value_parameters\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.calculate_afocd_value_parameters","title":"<code>calculate_afocd_value_parameters()</code>","text":"<p>This method calculates the AFOCD value parameters using my own methodology on determining the weights and uses the AFSCs.csv dataset for the targets and constraints.</p> Source code in <code>afccp/main.py</code> <pre><code>def calculate_afocd_value_parameters(self):\n    \"\"\"\n    This method calculates the AFOCD value parameters using my own methodology on determining the\n    weights and uses the AFSCs.csv dataset for the targets and constraints.\n    \"\"\"\n\n    # Determine the AFOCD value parameters\n    self.value_parameters = afccp.data.values.generate_afocd_value_parameters(\n        self.parameters, self.value_parameters)\n\n    # Update the value parameters\n    self.update_value_parameters()\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.export_value_parameters_as_defaults","title":"<code>export_value_parameters_as_defaults(filename=None, printing=None)</code>","text":"<p>This method exports the current set of instance value parameters to a new excel file in the \"default\" value parameter format</p> Source code in <code>afccp/main.py</code> <pre><code>def export_value_parameters_as_defaults(self, filename=None, printing=None):\n    \"\"\"\n    This method exports the current set of instance value parameters to a new excel file in the \"default\"\n    value parameter format\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if self.value_parameters is None:\n        raise ValueError('No instance value parameters detected.')\n\n    # Export value parameters\n    if filename is None:  # I add the \"_New\" just so we make sure we don't accidentally overwrite the old one\n        filename = \"Value_Parameters_Defaults_\" + self.data_name + \"_New.xlsx\"\n    filepath = afccp.globals.paths[\"support\"] + \"value parameters defaults/\" + filename\n    afccp.data.values.model_value_parameters_to_defaults(self, filepath=filepath, printing=printing)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.change_weight_function","title":"<code>change_weight_function(cadets=True, function=None)</code>","text":"<p>Changes the weight function on either cadets or AFSCs</p> <p>Parameters:</p> Name Type Description Default <code>cadets</code> <p>if this is for cadets (True) or AFSCs (False)</p> <code>True</code> <code>function</code> <p>new weight function to use</p> <code>None</code> Source code in <code>afccp/main.py</code> <pre><code>def change_weight_function(self, cadets=True, function=None):\n    \"\"\"\n    Changes the weight function on either cadets or AFSCs\n    :param cadets: if this is for cadets (True) or AFSCs (False)\n    :param function: new weight function to use\n    \"\"\"\n\n    if cadets:\n        if function is None:\n            function = 'Linear'\n\n        if \"merit_all\" in self.parameters:  # The cadets' real order of merit\n            merit = self.parameters[\"merit_all\"]\n        else:  # The cadets' scaled order of merit (based solely on Non-Rated cadets)\n            merit = self.parameters[\"merit\"]\n\n        # Update weight function\n        self.value_parameters['cadet_weight_function'] = function\n\n        # Update weights\n        self.value_parameters[\"cadet_weight\"] = \\\n            afccp.data.values.cadet_weight_function(merit, function)\n\n    else:\n        if function is None:\n            function = \"Curve_2\"\n\n        if \"pgl\" in self.parameters:  # The actual PGL target\n            quota = self.parameters[\"pgl\"]\n        else:  # The \"Real\" Target based on surplus and such\n            quota = self.parameters[\"quota\"]\n\n        # Update weight function\n        self.value_parameters['afsc_weight_function'] = function\n\n        # Update weights\n        self.value_parameters[\"afsc_weight\"] = \\\n            afccp.data.values.afsc_weight_function(quota, function)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.parameter_sanity_check","title":"<code>parameter_sanity_check()</code>","text":"<p>This method performs a comprehensive sanity check on the parameters and value parameters to ensure the data is in a valid and correct state before running the model.</p> <p>It examines various parameters and their values within the class instance to identify and address any issues or discrepancies. The checks are designed to ensure that the data is consistent, within valid ranges, and suitable for use in the model.</p> <p>While the exact details of these checks are implemented in an external function or module, this method serves as the entry point for conducting these checks.</p> <p>It is essential to run this method before executing the model to guarantee the integrity of the input data and to prevent potential errors or unexpected behavior during the modeling process.</p> <p>This method is part of an object-oriented programming structure and uses 'self' to access the class instance's attributes and data.</p> <p>Note: The specific details of the sanity checks are defined in an external function or module called 'afccp.core.data.adjustments.parameter_sanity_check.'</p> Source code in <code>afccp/main.py</code> <pre><code>def parameter_sanity_check(self):\n    \"\"\"\n    This method performs a comprehensive sanity check on the parameters and value parameters\n    to ensure the data is in a valid and correct state before running the model.\n\n    It examines various parameters and their values within the class instance to identify and\n    address any issues or discrepancies. The checks are designed to ensure that the data is consistent,\n    within valid ranges, and suitable for use in the model.\n\n    While the exact details of these checks are implemented in an external function or module,\n    this method serves as the entry point for conducting these checks.\n\n    It is essential to run this method before executing the model to guarantee the integrity\n    of the input data and to prevent potential errors or unexpected behavior during the modeling process.\n\n    This method is part of an object-oriented programming structure and uses 'self' to access\n    the class instance's attributes and data.\n\n    Note: The specific details of the sanity checks are defined in an external function\n    or module called 'afccp.core.data.adjustments.parameter_sanity_check.'\n    \"\"\"\n\n    # Call the function\n    afccp.data.adjustments.parameter_sanity_check(self)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.vft_to_gp_parameters","title":"<code>vft_to_gp_parameters(p_dict={}, printing=None)</code>","text":"<p>Translate VFT Model Parameters to former Lt Rebecca Reynold's Goal Programming Model Parameters.</p> <p>This method is responsible for translating various parameters and settings used in the Value Focussed Thinking (VFT) model into parameters suitable for the Goal Programming (GP) model. It facilitates the conversion between different modeling frameworks.</p> <p>Args:     p_dict (dict, optional): A dictionary of additional parameters that can be provided to fine-tune the translation process.         These parameters may include specific weights or settings required for the GP model. Defaults to an empty dictionary.</p> <pre><code>printing (bool, optional): A flag to control whether to print progress information during the translation process.\n    If True, it will print status updates; if False, it will run silently. Defaults to None.\n</code></pre> <p>Returns:     None</p> <p>The method updates the internal representation of parameters and settings in the instance to match the requirements of the Goal Programming (GP) model. It translates preference scores, rewards, and penalties according to the GP model's specifications, making the instance ready for goal-based optimization.</p> <p>Note: - The method may apply normalization to ensure that rewards and penalties are consistent with the GP model's expectations. - If the 'get_new_rewards_penalties' flag is set to True in the model parameters, the method may compute new rewards   and penalties based on the instance data and preferences, creating a fresh set of values for optimization.</p> Source code in <code>afccp/main.py</code> <pre><code>def vft_to_gp_parameters(self, p_dict={}, printing=None):\n    \"\"\"\n    Translate VFT Model Parameters to *former* Lt Rebecca Reynold's Goal Programming Model Parameters.\n\n    This method is responsible for translating various parameters and settings used in the Value Focussed Thinking (VFT) model\n    into parameters suitable for the Goal Programming (GP) model. It facilitates the conversion between different modeling\n    frameworks.\n\n    Args:\n        p_dict (dict, optional): A dictionary of additional parameters that can be provided to fine-tune the translation process.\n            These parameters may include specific weights or settings required for the GP model. Defaults to an empty dictionary.\n\n        printing (bool, optional): A flag to control whether to print progress information during the translation process.\n            If True, it will print status updates; if False, it will run silently. Defaults to None.\n\n    Returns:\n        None\n\n    The method updates the internal representation of parameters and settings in the instance to match the requirements\n    of the Goal Programming (GP) model. It translates preference scores, rewards, and penalties according to the GP model's\n    specifications, making the instance ready for goal-based optimization.\n\n    Note:\n    - The method may apply normalization to ensure that rewards and penalties are consistent with the GP model's expectations.\n    - If the 'get_new_rewards_penalties' flag is set to True in the model parameters, the method may compute new rewards\n      and penalties based on the instance data and preferences, creating a fresh set of values for optimization.\n\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Print statement\n    if printing:\n        print('Translating VFT model parameters to Goal Programming Model parameters...')\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    # Get basic parameters (May or may not include penalty/reward parameters\n    self.gp_parameters = afccp.data.values.translate_vft_to_gp_parameters(self)\n\n    # Get list of constraints\n    con_list = copy.deepcopy(self.gp_parameters['con'])\n    con_list.append(\"S\")\n    num_constraints = len(con_list)\n\n    # Convert gp_df to dictionary of numpy arrays (\"gc\" = \"gp_df columns\")\n    gc = {col: np.array(self.gp_df[col]) for col in self.gp_df}\n\n    # Do we want to create new rewards/penalties for this problem instance by iterating with the model?\n    if self.mdl_p[\"get_new_rewards_penalties\"]:\n\n        gc[\"Raw Reward\"], gc[\"Raw Penalty\"] = afccp.solutions.optimization.calculate_rewards_penalties(\n            self, printing=printing)\n        min_p = min([penalty for penalty in gc[\"Raw Penalty\"] if penalty != 0])\n        min_r = min(gc[\"Raw Reward\"])\n        gc[\"Normalized Penalty\"] = np.array([min_p / penalty if penalty != 0 else 0 for penalty in gc[\"Raw Penalty\"]])\n        gc[\"Normalized Reward\"] = np.array([min_r / reward for reward in gc[\"Raw Reward\"]])\n\n    # Rewards/Penalties used in the model \"run\"\n    gc[\"Run Penalty\"] = np.array(\n        [gc[\"Penalty Weight\"][c] /\n         gc[\"Normalized Penalty\"][c] if gc[\"Normalized Penalty\"][c] != 0 else 0 for c in range(num_constraints)])\n    gc[\"Run Reward\"] = np.array([gc[\"Reward Weight\"][c] / gc[\"Normalized Reward\"][c] for c in range(num_constraints)])\n\n    # Convert back to pandas dataframe using numpy array dictionary\n    self.gp_df = pd.DataFrame(gc)\n\n    # Update the \"mu\" and \"lam\" parameters with our new Reward/Penalty terms\n    self.gp_parameters = afccp.data.values.translate_vft_to_gp_parameters(self)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.generate_random_solution","title":"<code>generate_random_solution(p_dict={}, printing=None)</code>","text":"<p>Generate random solution by assigning cadets to AFSCs that they're eligible for</p> Source code in <code>afccp/main.py</code> <pre><code>def generate_random_solution(self, p_dict={}, printing=None):\n    \"\"\"\n    Generate random solution by assigning cadets to AFSCs that they're eligible for\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print('Generating random solution...')\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    # Generate solution\n    solution = {'method': 'Random',\n        'j_array': np.array([np.random.choice(self.parameters['J^E'][i]) for i in self.parameters['I']])}\n\n    # Determine what to do with the solution\n    self.solution_handling(solution)\n\n    return solution\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.soc_rated_matching_algorithm","title":"<code>soc_rated_matching_algorithm(p_dict={}, printing=None)</code>","text":"<p>This is the Hospitals/Residents algorithm that matches or reserves cadets to their Rated AFSCs depending on the source of commissioning (SOCs).</p> Source code in <code>afccp/main.py</code> <pre><code>def soc_rated_matching_algorithm(self, p_dict={}, printing=None):\n    \"\"\"\n    This is the Hospitals/Residents algorithm that matches or reserves cadets to their Rated AFSCs depending on the\n    source of commissioning (SOCs).\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    # Get the solution and solution iterations we need\n    combined, reserves, matches = afccp.solutions.algorithms.soc_rated_matching_algorithm(\n        self, soc=self.mdl_p['soc'], printing=printing)\n\n    # Determine what to do with the solution(s)\n    for solution in [reserves, matches, combined]:\n        self.solution_handling(solution, printing=False)  # Don't want print updates for this\n\n    return solution\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.classic_hr","title":"<code>classic_hr(p_dict={}, printing=None)</code>","text":"<p>This method solves the problem instance using the classical \"Hospital/Residents\" algorithm</p> Source code in <code>afccp/main.py</code> <pre><code>def classic_hr(self, p_dict={}, printing=None):\n    \"\"\"\n    This method solves the problem instance using the classical \"Hospital/Residents\" algorithm\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    # Get the solution we need\n    solution = afccp.solutions.algorithms.classic_hr(self, printing=printing)\n\n    # Determine what to do with the solution\n    self.solution_handling(solution)\n\n    return solution\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.solve_vft_pyomo_model","title":"<code>solve_vft_pyomo_model(p_dict={}, printing=None)</code>","text":"<p>Solve the VFT model using Pyomo, an optimization modeling library.</p> <p>This method is responsible for solving the Value Focussed Thinking (VFT) model using Pyomo. The VFT model is a specific type of optimization model. It conducts the necessary preparation, builds the model, solves it, and handles the resulting solution. The goal is to find optimal solutions for the VFT problem.</p> <p>Args:     p_dict (dict): A dictionary of parameters used for the model. It allows for customization of the model's         input parameters.     printing (bool, None): A flag to control whether to print information during the model-solving process. If set to         True, the method will print progress and debugging information. If set to False, it will suppress printing.         If None, the method will use the default printing setting from the class instance.</p> <p>Returns:     solution: The solution of the VFT model, which contains the optimal values for the decision variables and other         relevant information.</p> <p>Notes: - Before using this method, it's important to ensure that the class instance contains valid and appropriate data. - This method uses external functions for building and solving the Pyomo model, and the specifics of those functions   are located in the 'afccp.core.solutions.optimization' module.</p> Source code in <code>afccp/main.py</code> <pre><code>def solve_vft_pyomo_model(self, p_dict={}, printing=None):\n    \"\"\"\n    Solve the VFT model using Pyomo, an optimization modeling library.\n\n    This method is responsible for solving the Value Focussed Thinking (VFT) model using Pyomo. The VFT model is a specific\n    type of optimization model. It conducts the necessary preparation, builds the model, solves it, and handles the\n    resulting solution. The goal is to find optimal solutions for the VFT problem.\n\n    Args:\n        p_dict (dict): A dictionary of parameters used for the model. It allows for customization of the model's\n            input parameters.\n        printing (bool, None): A flag to control whether to print information during the model-solving process. If set to\n            True, the method will print progress and debugging information. If set to False, it will suppress printing.\n            If None, the method will use the default printing setting from the class instance.\n\n    Returns:\n        solution: The solution of the VFT model, which contains the optimal values for the decision variables and other\n            relevant information.\n\n    Notes:\n    - Before using this method, it's important to ensure that the class instance contains valid and appropriate data.\n    - This method uses external functions for building and solving the Pyomo model, and the specifics of those functions\n      are located in the 'afccp.core.solutions.optimization' module.\n    \"\"\"\n    self.error_checking(\"Pyomo Model\")\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    # Build the model and then solve it\n    model, q = afccp.solutions.optimization.vft_model_build(self, printing=printing)\n    solution = afccp.solutions.optimization.solve_pyomo_model(self, model, \"VFT\", q=q, printing=printing)\n\n    # Determine what to do with the solution\n    self.solution_handling(solution)\n\n    # Return the solution\n    return solution\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.solve_original_pyomo_model","title":"<code>solve_original_pyomo_model(p_dict={}, printing=None)</code>","text":"<p>Solve the original AFPC model using pyomo</p> Source code in <code>afccp/main.py</code> <pre><code>def solve_original_pyomo_model(self, p_dict={}, printing=None):\n    \"\"\"\n    Solve the original AFPC model using pyomo\n    \"\"\"\n    self.error_checking(\"Pyomo Model\")\n    if printing is None:\n        printing = self.printing\n\n    # One little \"switch\" to get the original model objective function\n    p_dict['assignment_model_obj'] = \"Original Utility\"\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    # Build the model and then solve it\n    model = afccp.solutions.optimization.assignment_model_build(self, printing=printing)\n    solution = afccp.solutions.optimization.solve_pyomo_model(self, model, \"Original\", printing=printing)\n\n    # Determine what to do with the solution\n    self.solution_handling(solution)\n\n    # Return the solution\n    return solution\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.solve_guo_pyomo_model","title":"<code>solve_guo_pyomo_model(p_dict={}, printing=None)</code>","text":"<p>Solve the \"generalized assignment problem\" model with the new global utility matrix constructed from the AFSC and Cadet Utility matrices. This is the \"GUO\" model.</p> Source code in <code>afccp/main.py</code> <pre><code>def solve_guo_pyomo_model(self, p_dict={}, printing=None):\n    \"\"\"\n    Solve the \"generalized assignment problem\" model with the new global utility matrix constructed\n    from the AFSC and Cadet Utility matrices. This is the \"GUO\" model.\n    \"\"\"\n    # One little \"switch\" to get the new assignment model objective function\n    p_dict['assignment_model_obj'] = \"Global Utility\"\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    # Error handling\n    self.error_checking(\"Pyomo Model\")\n    if printing is None:\n        printing = self.printing\n\n    # Determine solution method\n    if self.mdl_p['solution_method'] is None:\n        solution_method = 'GUO'\n    else:\n        solution_method = self.mdl_p['solution_method']\n\n    # Build the model and then solve it\n    model = afccp.solutions.optimization.assignment_model_build(self, printing=printing)\n    solution = afccp.solutions.optimization.solve_pyomo_model(self, model, solution_method, printing=printing)\n\n    # Determine what to do with the solution\n    self.solution_handling(solution)\n\n    # Return the solution\n    return solution\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.solve_gp_pyomo_model","title":"<code>solve_gp_pyomo_model(p_dict={}, printing=None)</code>","text":"<p>Solve the Goal Programming Model (Created by Lt. Reynolds)</p> Source code in <code>afccp/main.py</code> <pre><code>def solve_gp_pyomo_model(self, p_dict={}, printing=None):\n    \"\"\"\n    Solve the Goal Programming Model (Created by Lt. Reynolds)\n    \"\"\"\n    self.error_checking(\"Pyomo Model\")\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    # Convert VFT parameters to Goal Programming (\"gp\") parameters\n    if self.gp_parameters is None:\n        self.vft_to_gp_parameters(self.mdl_p)\n\n    # Build the model and then solve it\n    model = afccp.solutions.optimization.gp_model_build(self, printing=printing)\n    solution = afccp.solutions.optimization.solve_pyomo_model(self, model, \"GP\", printing=printing)\n\n    # Determine what to do with the solution\n    self.solution_handling(solution)\n\n    # Return the solution\n    return solution\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.solve_vft_main_methodology","title":"<code>solve_vft_main_methodology(p_dict={}, printing=None)</code>","text":"<p>This is the main method to solve the problem instance. We first determine an initial population of solutions. We then evolve the solutions further using the GA.</p> Source code in <code>afccp/main.py</code> <pre><code>def solve_vft_main_methodology(self, p_dict={}, printing=None):\n    \"\"\"\n    This is the main method to solve the problem instance. We first determine an initial population of solutions.\n    We then evolve the solutions further using the GA.\n    \"\"\"\n    self.error_checking(\"Pyomo Model\")\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    # Determine population for the genetic algorithm\n    if self.mdl_p['population_generation_model'] == 'Assignment':\n        self.mdl_p[\"initial_solutions\"] = \\\n            afccp.solutions.sensitivity.populate_initial_ga_solutions_from_assignment_model(self, printing)\n    else:\n        self.mdl_p[\"initial_solutions\"] = \\\n            afccp.solutions.sensitivity.populate_initial_ga_solutions_from_vft_model(self, printing)\n\n    # Add additional solutions if necessary\n    if self.mdl_p[\"solution_names\"] is not None:\n\n        # In case the user specifies \"Solution\" instead of [\"Solution\"]\n        if type(self.mdl_p[\"solution_names\"]) == str:\n            self.mdl_p[\"solution_names\"] = [self.mdl_p[\"solution_names\"]]\n\n        # Add additional solutions\n        for solution_name in self.mdl_p[\"solution_names\"]:\n            solution = self.solutions[solution_name]\n            self.mdl_p[\"initial_solutions\"] = np.vstack((self.mdl_p[\"initial_solutions\"], solution))\n\n    self.mdl_p[\"initialize\"] = True  # Force the initialize parameter to be true\n\n    if printing:\n        now = datetime.datetime.now()\n        print('Solving Genetic Algorithm for ' + str(self.mdl_p[\"ga_max_time\"]) + ' seconds at ' +\n              now.strftime('%H:%M:%S') + '...')\n    self.vft_genetic_algorithm(self.mdl_p, printing=self.mdl_p[\"ga_printing\"])\n    if printing:\n        print('Solution value of ' + str(round(self.solution['z'], 4)) + ' obtained.')\n\n    # Return solution\n    return self.solution\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.vft_genetic_algorithm","title":"<code>vft_genetic_algorithm(p_dict={}, printing=None)</code>","text":"<p>This is the genetic algorithm. The hyper-parameters to the algorithm can be tuned, and this is meant to be solved in conjunction with the pyomo model solution. Use that as the initial solution, and then we evolve from there</p> Source code in <code>afccp/main.py</code> <pre><code>def vft_genetic_algorithm(self, p_dict={}, printing=None):\n    \"\"\"\n    This is the genetic algorithm. The hyper-parameters to the algorithm can be tuned, and this is meant to be\n    solved in conjunction with the pyomo model solution. Use that as the initial solution, and then we evolve\n    from there\n    \"\"\"\n    self.error_checking(\"Value Parameters\")\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    # Dictionary of failed constraints across all solutions (phased out since we're using APM as initial population)\n    con_fail_dict = None\n\n    # Get a starting population of solutions if applicable!\n    if self.mdl_p[\"initialize\"]:\n\n        if self.mdl_p[\"initial_solutions\"] is None:\n\n            if self.solutions is None:\n                raise ValueError(\"Error. No solutions in dictionary.\")\n\n            else:\n                if self.mdl_p[\"solution_names\"] is None:\n\n                    # Get list of initial solutions\n                    initial_solutions = np.array(\n                        [self.solutions[solution_name]['j_array'] for solution_name in self.solutions])\n                    solution_names = list(self.solutions.keys())\n\n                else:\n\n                    # If we just pass \"Solution\" instead of [\"Solution\"]\n                    if type(self.mdl_p[\"solution_names\"]) == str:\n                        self.mdl_p[\"solution_names\"] = [self.mdl_p[\"solution_names\"]]\n\n                    # Get list of initial solutions\n                    initial_solutions = np.array(\n                        [self.solutions[solution_name]['j_array'] for solution_name in self.mdl_p[\"solution_names\"]])\n                    solution_names = self.mdl_p[\"solution_names\"]\n\n                if printing:\n                    print(\"Running Genetic Algorithm with initial solutions:\", solution_names)\n\n        else:\n\n            # Get list of initial solutions\n            initial_solutions = self.mdl_p[\"initial_solutions\"]\n            if printing:\n                print(\"Running Genetic Algorithm with\", len(initial_solutions), \"initial solutions...\")\n\n    else:\n\n        if printing:\n            print(\"Running Genetic Algorithm with no initial solutions (not advised!)...\")\n        initial_solutions = None\n\n    # Generate the solution\n    solution, time_eval_df = afccp.solutions.algorithms.vft_genetic_algorithm(\n        self, initial_solutions, con_fail_dict, printing=printing)\n\n    # Determine what to do with the solution\n    self.solution_handling(solution)\n\n    # Return the final solution and maybe the time evaluation dataframe if needed\n    if self.mdl_p[\"time_eval\"]:\n        return time_eval_df, solution\n    else:\n        return solution\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.genetic_matching_algorithm","title":"<code>genetic_matching_algorithm(p_dict={}, printing=None)</code>","text":"<p>This method solves the problem instance using \"Genetic Matching Algorithm\"</p> Source code in <code>afccp/main.py</code> <pre><code>def genetic_matching_algorithm(self, p_dict={}, printing=None):\n    \"\"\"\n    This method solves the problem instance using \"Genetic Matching Algorithm\"\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    # Force solution iteration collection to be turned off\n    self.mdl_p['collect_solution_iterations'] = False\n\n    # Get the capacities\n    capacities = afccp.solutions.algorithms.genetic_matching_algorithm(self, printing=printing)\n\n    # Update capacities in parameters (quota_max or quota_min)\n    self.parameters[self.mdl_p['capacity_parameter']] = capacities\n\n    # Run the matching algorithm with these capacities\n    solution = afccp.solutions.algorithms.classic_hr(self, printing=printing)\n\n    # Determine what to do with the solution\n    self.solution_handling(solution)\n\n    return solution\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.incorporate_rated_algorithm_results","title":"<code>incorporate_rated_algorithm_results(p_dict={}, printing=None)</code>","text":"<p>Takes the two sets of Rated Matches and Reserves and adds that into the parameters (J^Fixed and J^Reserved)</p> Source code in <code>afccp/main.py</code> <pre><code>def incorporate_rated_algorithm_results(self, p_dict={}, printing=None):\n    \"\"\"\n    Takes the two sets of Rated Matches and Reserves and adds that into the parameters (J^Fixed and J^Reserved)\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    self.parameters = afccp.solutions.handling.incorporate_rated_results_in_parameters(\n        self, printing=printing)\n\n    # Shorthand\n    p = self.parameters\n\n    # Temporary stuff\n    if self.mdl_p['create_new_rated_solutions']:\n\n        name_dict = {'Rated Matches': 'J^Fixed', 'Rated Reserves': 'J^Reserved',\n                     'Rated Alternates (Hard)': 'J^Alternates (Hard)',\n                     'Rated Alternates (Soft)': 'J^Alternates (Soft)'}\n        new_solutions = {}\n        for s_name, s_param in name_dict.items():\n            new_solutions[s_name] = {'method': s_name,\n                                     'j_array': np.array([p['M'] for _ in p['I']]),\n                                     'afsc_array': np.array(['*' for _ in p['I']])}\n\n            # Create this solution array\n            for i in p['I']:\n                if i in p[s_param]:\n                    if s_param == 'J^Reserved':\n                        j = p['J^Reserved'][i][len(p['J^Reserved'][i]) - 1]\n                    else:\n                        j = p[s_param][i]\n                    new_solutions[s_name]['j_array'][i] = j\n                    new_solutions[s_name]['afsc_array'][i] = p['afscs'][j]\n\n            # Integrate this solution\n            self.solution_handling(new_solutions[s_name], printing=False)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.find_ineligible_cadets","title":"<code>find_ineligible_cadets(solution_name=None, fix_it=True)</code>","text":"<p>Prints out the ID's of ineligible pairs of cadets/AFSCs</p> Source code in <code>afccp/main.py</code> <pre><code>def find_ineligible_cadets(self, solution_name=None, fix_it=True):\n    \"\"\"\n    Prints out the ID's of ineligible pairs of cadets/AFSCs\n    \"\"\"\n\n    if solution_name is None:\n        if self.solution is None:\n            raise ValueError(\"No solution activated.\")\n        else:\n            solution = self.solution['j_array']\n    else:\n        solution = self.solutions[solution_name]['j_array']\n\n    # Loop through each cadet to see if they're ineligible for the AFSC they're assigned to\n    total_ineligible = 0\n    for i, j in enumerate(solution):\n        cadet, afsc = self.parameters['cadets'][i], self.parameters['afscs'][j]\n\n        # Unmatched AFSC\n        if j == self.parameters['M']:\n            continue\n\n        # Cadet is not in the set of eligible cadets for this AFSC\n        if i not in self.parameters['I^E'][j]:\n            total_ineligible += 1\n\n            # Do we do anything about it yet?\n            if fix_it:\n                print('Cadet', cadet, 'assigned to AFSC', afsc, 'but is ineligible for it. Adjusting qual matrix to'\n                                                                ' allow this exception.')\n\n                # Add exception in different parameters\n                self.parameters['qual'][i, j] = \"E\" + str(self.parameters['t_count'][j])\n                self.parameters['ineligible'][i, j] = 0\n                self.parameters['eligible'][i, j] = 1\n\n            else:\n                print('Cadet', cadet, 'assigned to AFSC', afsc, 'but is ineligible for it.')\n\n    # Printing statement\n    if total_ineligible == 0:\n        print(\"No cadets assigned to AFSCs that they're ineligible for in the current solution.\")\n    else:\n        print(total_ineligible, \"total cadets assigned to AFSCs that they're ineligible for in the current solution.\")\n\n    # Adjust sets and subsets of cadets to reflect change\n    if fix_it and total_ineligible &gt; 0:\n        self.parameters = afccp.data.adjustments.parameter_sets_additions(self.parameters)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.set_solution","title":"<code>set_solution(solution_name=None, printing=None)</code>","text":"<p>Set the current instance object's solution to a solution from the dictionary</p> Source code in <code>afccp/main.py</code> <pre><code>def set_solution(self, solution_name=None, printing=None):\n    \"\"\"\n    Set the current instance object's solution to a solution from the dictionary\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if self.solutions is None:\n        raise ValueError('No solution dictionary initialized')\n    else:\n        if solution_name is None:\n            solution_name = list(self.solutions.keys())[0]\n        else:\n            if solution_name not in self.solutions:\n                raise ValueError('Solution ' + solution_name + ' not in solution dictionary')\n\n        self.solution = self.solutions[solution_name]\n        self.solution_name = solution_name\n        if self.value_parameters is not None:\n            self.measure_solution(printing=printing)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.add_solution","title":"<code>add_solution(j_array: np.ndarray = None, afsc_array: np.ndarray = None, method: str = None)</code>","text":"<p>Takes a numpy array of AFSCs and adds this new solution into the solution dictionary</p> Source code in <code>afccp/main.py</code> <pre><code>def add_solution(self, j_array: np.ndarray = None, afsc_array: np.ndarray = None, method: str = None):\n    \"\"\"\n    Takes a numpy array of AFSCs and adds this new solution into the solution dictionary\n    \"\"\"\n\n    # Determine AFSC solution information\n    if j_array is not None:\n        afsc_array = np.array([self.parameters['afscs'][j] for j in j_array])\n    elif afsc_array is not None:\n        j_array = np.array([np.where(self.parameters['afscs'] == afsc)[0][0] for afsc in afsc_array])\n    else:\n        raise ValueError(f'Error. No AFSC solution array specified')\n    if method is None:\n        method = 'Added'\n\n    # Create solution dictionary\n    solution = {'j_array': j_array, 'method': method, 'afsc_array': afsc_array}\n\n    # Determine what to do with the solution\n    self.solution_handling(solution)\n\n    # Return the solution\n    return solution\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.compute_similarity_matrix","title":"<code>compute_similarity_matrix(solution_names=None)</code>","text":"<p>Generates the similarity matrix for a given set of solutions</p> Source code in <code>afccp/main.py</code> <pre><code>def compute_similarity_matrix(self, solution_names=None):\n    \"\"\"\n    Generates the similarity matrix for a given set of solutions\n    \"\"\"\n\n    if 'Similarity Solutions.csv' in os.listdir(self.export_paths['Analysis &amp; Results']):\n        solution_df = afccp.globals.import_csv_data(\n            self.export_paths['Analysis &amp; Results'] + 'Similarity Solutions.csv')\n    else:\n        raise ValueError(\"Error. No 'Similarity Solutions.csv' dataframe found in the 'Analysis &amp; Results' folder. \"\n                         \"Please create it.\")\n\n    # \"Starting\" Solutions: Extract solutions from dataframe and then convert to \"j_array\"\n    solutions = {solution_name: np.array(solution_df[solution_name]) for solution_name in solution_df}\n    solutions = {solution_name: np.array([np.where(\n        self.parameters['afscs'] == afsc)[0][0] for afsc in solutions[solution_name]]) for solution_name in solutions}\n\n    # If we want to add solutions to highlight in the chart\n    if solution_names is not None:\n        extra_solutions = {\n            solution_name: self.solutions[solution_name]['j_array'] for solution_name in solution_names}\n        for solution_name in extra_solutions:\n            solutions[solution_name] = extra_solutions[solution_name]\n\n    # Create the matrix\n    num_solutions = len(solutions.keys())\n    similarity_matrix = np.zeros((num_solutions, num_solutions))\n    for row, sol_1_name in enumerate(solutions.keys()):\n        for col, sol_2_name in enumerate(solutions.keys()):\n            sol_1 = solutions[sol_1_name]\n            sol_2 = solutions[sol_2_name]\n            similarity_matrix[row, col] = np.sum(sol_1 == sol_2) / self.parameters[\"N\"]  # % similarity!\n\n    # Export similarity_matrix\n    similarity_df = pd.DataFrame({solution: similarity_matrix[:, s] for s, solution in enumerate(solutions.keys())})\n    similarity_df.to_csv(self.export_paths['Analysis &amp; Results'] + 'Similarity Matrix.csv', index=False)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.measure_solution","title":"<code>measure_solution(approximate=False, printing=None)</code>","text":"<p>Evaluate a solution using the VFT objective hierarchy</p> Source code in <code>afccp/main.py</code> <pre><code>def measure_solution(self, approximate=False, printing=None):\n    \"\"\"\n    Evaluate a solution using the VFT objective hierarchy\n    \"\"\"\n    # Error checking, solution setting\n    if self.solution is None or self.value_parameters is None:\n        raise ValueError(\"Error. Solution and value parameters needed to evaluate solution.\")\n\n    # Print statement\n    if printing is None:\n        printing = self.printing\n\n    # Copy weight on GUO solution (relative to CASTLE) from \"mdl_p\" to \"parameters\"\n    self.parameters['w^G'] = self.mdl_p['w^G']\n\n    # Calculate solution metrics\n    self.solution = afccp.solutions.handling.evaluate_solution(\n        self.solution, self.parameters, self.value_parameters, approximate=approximate, printing=printing,\n        re_calculate_x=self.mdl_p['re-calculate x'])\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.measure_fitness","title":"<code>measure_fitness(printing=None)</code>","text":"<p>This is the fitness function method (could be slightly different depending on how the constraints are handled)</p> <p>Returns:</p> Type Description <p>fitness score</p> Source code in <code>afccp/main.py</code> <pre><code>def measure_fitness(self, printing=None):\n    \"\"\"\n    This is the fitness function method (could be slightly different depending on how the constraints are handled)\n    :return: fitness score\n    \"\"\"\n    # Error checking, solution setting\n    if self.solution is None or self.value_parameters is None:\n        raise ValueError(\"Error. Solution and value parameters needed to evaluate solution.\")\n\n    # Printing statement\n    if printing is None:\n        printing = self.printing\n\n    # Get the solution metrics if necessary\n    if \"z\" not in self.solution:\n        self.solution = self.measure_solution(printing=False)\n\n    # Calculate fitness value\n    z = afccp.solutions.handling.fitness_function(self.solution['j_array'], self.parameters,\n                                                  self.value_parameters, self.mdl_p,\n                                                  con_fail_dict=self.solution['con_fail_dict'])\n\n    # Print and return fitness value\n    if printing:\n        print(\"Fitness value calculated to be\", round(z, 4))\n    return z\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.export_solution_iterations","title":"<code>export_solution_iterations(printing=None)</code>","text":"<p>Exports iterations of a matching algorithm to excel</p> Source code in <code>afccp/main.py</code> <pre><code>def export_solution_iterations(self, printing=None):\n    \"\"\"\n    Exports iterations of a matching algorithm to excel\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    # Error handling\n    if 'iterations' not in self.solution:\n        raise ValueError(\"Error. No solution iterations detected.\")\n\n    # Update the solution iterations dictionary\n    if 'sequence' not in self.solution['iterations']:\n        self.manage_bubbles_parameters()\n\n    # 'Sequence' Folder\n    folder_path = self.export_paths['Analysis &amp; Results'] + 'Cadet Board/'\n    if self.solution['iterations']['sequence'] not in os.listdir(folder_path):\n        os.mkdir(folder_path + self.solution['iterations']['sequence'])\n\n    # Create proposals dataframe\n    if 'proposals' in self.solution['iterations']:\n        proposals_df = pd.DataFrame({'Cadet': self.parameters['cadets']})\n        for s in self.solution['iterations']['proposals']:\n            solution = self.solution['iterations']['proposals'][s]\n            afsc_solution = [self.parameters['afscs'][j] for j in solution]\n            proposals_df['Iteration ' + str(s + 1)] = afsc_solution\n\n        # Export file\n        filepath = folder_path + self.solution['iterations']['sequence'] + '/Solution Iterations (Proposals).csv'\n        proposals_df.to_csv(filepath, index=False)\n\n        if printing:\n            print('Proposal iterations exported to', filepath)\n\n    # Create matches dataframe\n    if 'matches' in self.solution['iterations']:\n        solutions_df = pd.DataFrame({'Cadet': self.parameters['cadets']})\n        for s in self.solution['iterations']['matches']:\n            solution = self.solution['iterations']['matches'][s]\n            afsc_solution = [self.parameters['afscs'][j] for j in solution]\n            solutions_df['Iteration ' + str(s + 1)] = afsc_solution\n\n        # Export file\n        filepath = folder_path + self.solution['iterations']['sequence'] + '/Solution Iterations (Matches).csv'\n        solutions_df.to_csv(filepath, index=False)\n\n        if printing:\n            print('Solution iterations exported to', filepath)\n\n    if printing:\n        print('Done.')\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.import_solution_iterations","title":"<code>import_solution_iterations(sequence_name, printing=None)</code>","text":"<p>Exports iterations of a matching algorithm to excel</p> Source code in <code>afccp/main.py</code> <pre><code>def import_solution_iterations(self, sequence_name, printing=None):\n    \"\"\"\n    Exports iterations of a matching algorithm to excel\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    # 'Sequence' Folder\n    folder_path = self.export_paths['Analysis &amp; Results'] + 'Cadet Board/'\n    if sequence_name not in os.listdir(folder_path):\n        raise ValueError(\"Error. Sequence '\" + str(sequence_name) + \"' not found in 'Cadet Board' figure.\")\n    sequence_folder_path = self.export_paths['Analysis &amp; Results'] + 'Cadet Board/' + sequence_name\n    sequence_folder = os.listdir(sequence_folder_path)\n    self.solution['iterations'] = {'type': sequence_name.split(',')[2].strip()}\n\n    # Current solution should match the sequence name\n    if self.solution_name not in sequence_name:\n        raise ValueError(\"Error. Current solution is '\" + self.solution_name +\n                         \"' which is not found in the provided sequence name of '\" + sequence_name + \"'.\")\n\n    # Get proposals if applicable\n    if 'Solution Iterations (Proposals).csv' in sequence_folder:\n        filepath = sequence_folder_path + '/Solution Iterations (Proposals).csv'\n        proposals_df = afccp.globals.import_csv_data(filepath)\n        self.solution['iterations']['proposals'] = {}\n        for s, col in enumerate(proposals_df.columns[1:]):\n            afsc_solution = np.array(proposals_df[col])\n            solution = np.array([np.where(self.parameters['afscs'] == afsc)[0][0] for afsc in afsc_solution])\n            self.solution['iterations']['proposals'][s] = solution\n\n        if printing:\n            print('Proposal iterations imported from', filepath)\n\n    # Get matches if applicable\n    if 'Solution Iterations (Matches).csv' in sequence_folder:\n        filepath = sequence_folder_path + '/Solution Iterations (Matches).csv'\n        matches_df = afccp.globals.import_csv_data(filepath)\n        self.solution['iterations']['matches'] = {}\n        self.solution['iterations']['names'] = {}\n        for s, col in enumerate(matches_df.columns[1:]):\n            afsc_solution = np.array(matches_df[col])\n            solution = np.array(\n                [np.where(self.parameters['afscs'] == afsc)[0][0] for afsc in afsc_solution])\n            self.solution['iterations']['matches'][s] = solution\n            self.solution['iterations']['names'][s] = \"Iteration \" + str(s + 1)\n\n        # Last solution iteration\n        self.solution['iterations']['last_s'] = s\n\n        if printing:\n            print('Solution iterations imported from', filepath)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.manage_bubbles_parameters","title":"<code>manage_bubbles_parameters(p_dict={})</code>","text":"<p>Handles the solution iterations that we should already have as an attribute of the problem instance</p> Source code in <code>afccp/main.py</code> <pre><code>def manage_bubbles_parameters(self, p_dict={}):\n    \"\"\"\n    Handles the solution iterations that we should already have as an attribute of the problem instance\n    \"\"\"\n\n    # Error Checking\n    self.error_checking(\"Solution\")\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    # Cadets/AFSCs solved for is by default \"All\"\n    if \"cadets_solved_for\" not in self.solution:\n        self.solution['cadets_solved_for'] = \"All\"\n    if \"afscs_solved_for\" not in self.solution:\n        self.solution['afscs_solved_for'] = \"All\"\n    self.mdl_p['afscs_solved_for'] = self.solution['afscs_solved_for']  # Update AFSCs solved for in mdl_p\n\n    # Determine which AFSCs to show in this visualization\n    self.mdl_p = afccp.data.support.determine_afscs_in_image(self.parameters, self.mdl_p)\n\n    # Determine what kind of cadet/AFSC board figure and/or animation we're building\n    if 'iterations' in self.solution:\n\n        # Adjust certain elements for Rated stuff\n        if 'Rated' in self.solution['iterations']['type']:\n            self.solution['afscs_solved_for'] = 'Rated'\n            if \"USAFA\" in self.solution_name:\n                self.solution['cadets_solved_for'] = 'USAFA Rated'\n            elif \"ROTC\" in self.solution_name:\n                self.solution['cadets_solved_for'] = 'ROTC Rated'\n            elif \"OTS\" in self.solution_name:\n                self.solution['cadets_solved_for'] = 'OTS Rated'\n\n        # Determine name of this BubbleChart sequence\n        self.solution['iterations']['sequence'] = \\\n            self.data_name + ', ' + self.solution['cadets_solved_for'] + ' Cadets, ' + \\\n            self.solution['iterations']['type'] + ', ' + self.solution['afscs_solved_for'] + \\\n            ' AFSCs' + ', ' + self.solution['name']\n        if self.data_version != 'Default':\n            self.solution['iterations']['sequence'] += ' (' + self.data_version + ')'\n        self.solution['iterations']['sequence'] += ' ' + str(self.mdl_p['M']) + \" AFSCs Displayed\"\n\n    # Single solution\n    else:\n\n        # Create solution folder if necessary\n        self.manage_solution_folder()\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.display_data_graph","title":"<code>display_data_graph(p_dict={}, printing=None)</code>","text":"<p>This method plots different aspects of the fixed parameters of the problem instance.</p> Source code in <code>afccp/main.py</code> <pre><code>def display_data_graph(self, p_dict={}, printing=None):\n    \"\"\"\n    This method plots different aspects of the fixed parameters of the problem instance.\n    \"\"\"\n\n    # Print statement\n    if printing is None:\n        printing = self.printing\n\n    # Adjust instance plot parameters\n    self.reset_functional_parameters(p_dict)\n    self.mdl_p = afccp.data.support.determine_afsc_plot_details(self)\n\n    # Initialize the AFSC Chart object\n    afsc_chart = afccp.visualizations.charts.AFSCsChart(self)\n\n    # Construct the specific chart\n    return afsc_chart.build(printing=printing)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.display_all_data_graphs","title":"<code>display_all_data_graphs(p_dict={}, printing=None)</code>","text":"<p>This method runs through all the different versions of graphs we have and saves them to the corresponding folder.</p> Source code in <code>afccp/main.py</code> <pre><code>def display_all_data_graphs(self, p_dict={}, printing=None):\n    \"\"\"\n    This method runs through all the different versions of graphs we have and saves\n    them to the corresponding folder.\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Saving all data graphs to the corresponding folder...\")\n\n    # Regular Charts\n    charts = []\n    for graph in [\"Average Utility\", \"USAFA Proportion\", \"Average Merit\", \"AFOCD Data\", \"Eligible Quota\"]:\n        p_dict[\"data_graph\"] = graph\n        charts.append(self.display_data_graph(p_dict, printing=printing))\n\n    # Cadet Preference Analysis Charts\n    p_dict[\"data_graph\"] = \"Cadet Preference Analysis\"\n    for version in range(1, 8):\n        p_dict[\"version\"] = str(version)\n        charts.append(self.display_data_graph(p_dict, printing=printing))\n\n    return charts\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.show_value_function","title":"<code>show_value_function(p_dict={}, printing=None)</code>","text":"<p>This method plots a specific AFSC objective value function</p> Source code in <code>afccp/main.py</code> <pre><code>def show_value_function(self, p_dict={}, printing=None):\n    \"\"\"\n    This method plots a specific AFSC objective value function\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Shorthand\n    p, vp = self.parameters, self.value_parameters\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n    self.mdl_p = afccp.data.support.determine_afsc_plot_details(self)\n    ip = self.mdl_p  # More shorthand\n\n    if printing:\n        print('Creating value function chart for objective ' + ip['objective'] + ' for AFSC ' + ip['afsc'])\n\n    # Determine AFSC and objective shown in this chart\n    j, k = np.where(p[\"afscs\"] == ip[\"afsc\"])[0][0], np.where(vp[\"objectives\"] == ip[\"objective\"])[0][0]\n\n    # ValueFunctionChart specific parameters\n    vfc = ip['ValueFunctionChart']\n    vfc['x_label'] = afccp.globals.obj_label_dict[ip['objective']]  # Get x label for this objective\n\n    # Value Function specific coordinates to plot\n    if vfc['x_pt'] is not None:\n        vfc['y_pt'] = afccp.solutions.handling.value_function(vp['a'][j][k], vp['f^hat'][j][k], vp['r'][j][k],\n                                                              vfc[\"x_pt\"])\n\n    # Determine x and y arrays\n    if ip['smooth_value_function']:\n        x_arr = (np.arange(1001) / 1000) * vp['a'][j][k][vp['r'][j][k] - 1]\n        y_arr = np.array([afccp.solutions.handling.value_function(\n            vp['a'][j][k], vp['f^hat'][j][k], vp['r'][j][k], x) for x in x_arr])\n    else:\n        x_arr, y_arr = vp['a'][j][k], vp['f^hat'][j][k]\n\n    # Title and filepath for this value function!\n    vfc['title'] = ip['afsc'] + ' ' + ip['objective'] + ' Value Function'\n    vfc['filepath'] = self.export_paths['Analysis &amp; Results'] + \\\n                      'Value Functions/' + self.data_name + ' ' + vfc['title'] + ' (' + self.vp_name + ').png'\n\n    # Create and return the chart\n    return afccp.visualizations.charts.ValueFunctionChart(x_arr, y_arr, vfc)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.display_weight_function","title":"<code>display_weight_function(p_dict={}, printing=None)</code>","text":"<p>This method plots the weight function used for either cadets or AFSCs</p> Source code in <code>afccp/main.py</code> <pre><code>def display_weight_function(self, p_dict={}, printing=None):\n    \"\"\"\n    This method plots the weight function used for either cadets or AFSCs\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n    self.mdl_p = afccp.data.support.determine_afsc_plot_details(self)\n\n    # Make the folder\n    if 'Value Parameters' not in os.listdir(self.export_paths['Analysis &amp; Results']):\n        os.mkdir(self.export_paths['Analysis &amp; Results'] + 'Value Parameters')\n\n    if printing:\n        if self.mdl_p[\"cadets_graph\"]:\n            print(\"Creating cadet weight chart...\")\n        else:\n            print(\"Creating AFSC weight chart...\")\n\n    # Build the chart\n    chart = afccp.visualizations.charts.individual_weight_graph(self)\n\n    if printing:\n        chart.show()\n\n    return chart\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.display_all_results_graphs","title":"<code>display_all_results_graphs(p_dict={}, printing=None)</code>","text":"<p>Saves all charts for the current solution and for the solutions in the solution names list if specified</p> Source code in <code>afccp/main.py</code> <pre><code>def display_all_results_graphs(self, p_dict={}, printing=None):\n    \"\"\"\n    Saves all charts for the current solution and for the solutions in the solution names list if specified\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Create solution folder if necessary\n    self.manage_solution_folder()\n\n    # Determine what kind of results charts we're creating\n    if 'solution_names' not in p_dict:  # Regular Solution Charts\n        desired_charts = 'desired_charts'\n        if printing:\n            print(\"Saving all solution results charts to the corresponding folder...\")\n\n    else:  # Solution Comparison Charts\n        desired_charts = 'desired_comparison_charts'\n        p_dict['results_graph'] = 'Solution Comparison'\n        if printing:\n            print(\"Saving all solution comparison charts to the corresponding folder...\")\n\n        # Evaluate the solutions to get metrics\n        self.evaluate_all_solutions(p_dict['solution_names'])\n\n    # Loop through the subset of AFSC charts that I actually care about\n    charts = []\n    for obj, version in self.mdl_p[desired_charts]:\n        if printing:\n            print(\"&lt;Objective '\" + obj + \"' version '\" + version + \"'&gt;\")\n\n        # Build the figure\n        if obj in self.value_parameters['objectives'] or obj == 'Extra':\n            p_dict[\"objective\"] = obj\n            p_dict[\"version\"] = version\n            p_dict['macro_chart_kind'] = 'AFSC Chart'\n            charts.append(self.display_results_graph(p_dict))\n        else:\n            if printing:\n                print(\"Objective '\" + obj + \"' passed since it isn't in our set of objectives.\")\n\n    # Loop through the subset of \"other charts\" that I care about\n    if self.mdl_p['results_graph'] != \"Solution Comparison\":  # Only for a solution-specific chart\n        for kind, version in self.mdl_p['desired_other_charts']:\n            if printing:\n                print(\"&lt;Other Charts '\" + kind + \"' version '\" + version + \"'&gt;\")\n\n            # Build the figure\n            p_dict['objective'] = \"Extra\"\n            p_dict[\"version\"] = version\n            p_dict['macro_chart_kind'] = 'Accessions Group'\n            charts.append(self.display_results_graph(p_dict))\n\n\n    return charts\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.display_cadet_individual_utility_graph","title":"<code>display_cadet_individual_utility_graph(p_dict={}, printing=None)</code>","text":"<p>Builds the cadet utility graph for a particular cadet</p> Source code in <code>afccp/main.py</code> <pre><code>def display_cadet_individual_utility_graph(self, p_dict={}, printing=None):\n    \"\"\"\n    Builds the cadet utility graph for a particular cadet\n    \"\"\"\n\n    # Print statement\n    if printing is None:\n        printing = self.printing\n\n    # Adjust instance plot parameters\n    self.reset_functional_parameters(p_dict)\n\n    # Build the chart\n    afccp.visualizations.charts.CadetUtilityGraph(self)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.display_results_graph","title":"<code>display_results_graph(p_dict={}, printing=None)</code>","text":"<p>Builds the AFSC Results graphs</p> Source code in <code>afccp/main.py</code> <pre><code>def display_results_graph(self, p_dict={}, printing=None):\n    \"\"\"\n    Builds the AFSC Results graphs\n    \"\"\"\n\n    # Print statement\n    if printing is None:\n        printing = self.printing\n\n    # Adjust instance plot parameters\n    self.reset_functional_parameters(p_dict)\n    self.mdl_p = afccp.data.support.determine_afsc_plot_details(self, results_chart=True)\n\n    # Error handling\n    if self.mdl_p['results_graph'] == 'Solution Comparison':\n        self.error_checking('Solutions')\n        chart_type = 'Comparison'\n    else:\n        self.error_checking('Solution')\n        chart_type = 'Solution'\n\n    # Determine which chart to create\n    if self.mdl_p[\"macro_chart_kind\"] == \"AFSC Chart\":\n\n        print('wow')\n\n        # Initialize the AFSC Chart object\n        afsc_chart = afccp.visualizations.charts.AFSCsChart(self)\n\n        # Construct the specific chart\n        return afsc_chart.build(chart_type=chart_type, printing=printing)\n\n    elif self.mdl_p[\"macro_chart_kind\"] == \"Accessions Group\":\n\n        # Initialize the AFSC Chart object\n        acc_chart = afccp.visualizations.charts.AccessionsGroupChart(self)\n\n        # Construct the specific chart\n        return acc_chart.build(chart_type=chart_type, printing=printing)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.generate_results_slides","title":"<code>generate_results_slides(p_dict={}, printing=None)</code>","text":"<p>Method to generate the results slides for a particular problem instance with solution</p> Source code in <code>afccp/main.py</code> <pre><code>def generate_results_slides(self, p_dict={}, printing=None):\n    \"\"\"\n    Method to generate the results slides for a particular problem instance with solution\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Generating results slides...\")\n\n    # Adjust instance plot parameters\n    self.reset_functional_parameters(p_dict)\n    self.error_checking('Solution')\n\n    # Call the function to generate the slides\n    if afccp.globals.use_pptx:\n        afccp.visualizations.slides.generate_results_slides(self)\n    else:\n        print('PPTX library not installed.')\n\n    if printing:\n        print('Done.')\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.generate_comparison_slides","title":"<code>generate_comparison_slides(p_dict={}, printing=None)</code>","text":"<p>Method to generate the results slides for a particular problem instance with solution</p> Source code in <code>afccp/main.py</code> <pre><code>def generate_comparison_slides(self, p_dict={}, printing=None):\n    \"\"\"\n    Method to generate the results slides for a particular problem instance with solution\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Generating comparison slides...\")\n\n    if 'Comparison Charts' not in os.listdir(self.export_paths['Analysis &amp; Results']):\n        raise ValueError(\"Error. No 'Comparison Charts' folder found in the 'Analysis &amp; Results' folder. You need to\"\n                         \" put all charts you'd like to compile into a slide-deck in this folder.\")\n\n    # Adjust instance plot parameters\n    self.reset_functional_parameters(p_dict)\n    self.error_checking('Solutions')\n\n    # Call the function to generate the slides\n    if afccp.globals.use_pptx:\n        afccp.visualizations.slides.generate_comparison_slides(self)\n    else:\n        print('PPTX library not installed.')\n\n    if printing:\n        print('Done.')\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.generate_animation_slides","title":"<code>generate_animation_slides(p_dict={}, printing=None)</code>","text":"<p>Method to generate the animation slides for a particular problem instance and solution iterations</p> Source code in <code>afccp/main.py</code> <pre><code>def generate_animation_slides(self, p_dict={}, printing=None):\n    \"\"\"\n    Method to generate the animation slides for a particular problem instance and solution iterations\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Generating animation slides...\")\n\n    # Manage the solution iterations\n    self.manage_bubbles_parameters(p_dict)\n\n    # Call the function to generate the slides\n    if afccp.globals.use_pptx:\n        afccp.visualizations.slides.create_animation_slides(self)\n    else:\n        print('PPTX library not installed.')\n\n    if printing:\n        print('Done.')\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.generate_comparison_slide_components","title":"<code>generate_comparison_slide_components(p_dict={}, printing=None)</code>","text":"<p>Method to do all the steps of generating the specific solution comparison charts I want</p> Source code in <code>afccp/main.py</code> <pre><code>def generate_comparison_slide_components(self, p_dict={}, printing=None):\n    \"\"\"\n    Method to do all the steps of generating the specific solution comparison charts I want\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if \"solution_names\" not in p_dict:\n        raise ValueError(\"Error. In order to run this comparison method, the argument 'solution_names' must be \"\n                         \"passed within 'p_dict'. This needs to be a list of solution names.\")\n\n    if printing:\n        print(\"Generating comparison charts for the solutions:\", p_dict['solution_names'])\n\n    # Create the comparison charts folder if necessary\n    if 'Comparison Charts' not in os.listdir(self.export_paths['Analysis &amp; Results']):\n        os.mkdir(self.export_paths['Analysis &amp; Results'] + 'Comparison Charts')\n\n    # Adjust instance plot parameters\n    self.reset_functional_parameters(p_dict)\n    self.error_checking('Solutions')\n\n    # Save all solution comparison charts to the \"Comparison Charts\" folder\n    self.display_all_results_graphs(p_dict, printing)\n\n    # Cadet Utility Histogram\n    self.display_utility_histogram(p_dict, folder='Comparison Charts')\n\n    # Create pareto frontier plots\n    self.show_pareto_chart(folder='Comparison Charts')  # without solutions\n    self.show_pareto_chart(p_dict, folder='Comparison Charts',\n                           solution_names=p_dict['solution_names'])  # with solutions\n\n    # Compute similarity matrix and then calculate the similarity plot between all the solutions\n    self.compute_similarity_matrix(solution_names=p_dict['solution_names'])\n    self.similarity_plot(p_dict, folder='Comparison Charts')\n\n    if printing:\n        print('Done.')\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.generate_bubbles_chart","title":"<code>generate_bubbles_chart(p_dict={}, printing=None)</code>","text":"<p>Method to generate the \"BubbleChart\" figure by calling the BubbleChart class and applying the parameters as specified in the ccp helping functions.</p> Source code in <code>afccp/main.py</code> <pre><code>def generate_bubbles_chart(self, p_dict={}, printing=None):\n    \"\"\"\n    Method to generate the \"BubbleChart\" figure by calling the BubbleChart class and applying the parameters\n    as specified in the ccp helping functions.\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Manage the solution iterations\n    self.manage_bubbles_parameters(p_dict)\n\n    # Print updates\n    if printing:\n        print('Creating Bubbles Chart...')\n\n    # Call the figure object\n    bubble_chart = afccp.visualizations.bubbles.BubbleChart(self, printing=printing)\n    bubble_chart.main()\n\n    # Only build the animation slides if we're saving iteration frames\n    if self.mdl_p['save_iteration_frames']:\n\n        # Generate the slides to go with this\n        self.generate_animation_slides(p_dict, printing)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.display_utility_histogram","title":"<code>display_utility_histogram(p_dict={}, printing=None, folder='Results Charts')</code>","text":"<p>This method plots the cadet utility histogram</p> Source code in <code>afccp/main.py</code> <pre><code>def display_utility_histogram(self, p_dict={}, printing=None, folder=\"Results Charts\"):\n    \"\"\"\n    This method plots the cadet utility histogram\n    \"\"\"\n\n    # Print statement\n    if printing is None:\n        printing = self.printing\n    if printing:\n        print(\"Creating cadet utility histogram...\")\n\n    # Adjust instance plot parameters\n    self.reset_functional_parameters(p_dict)\n    self.mdl_p = afccp.data.support.determine_afsc_plot_details(self, results_chart=True)\n\n    # Evaluate the solutions to get metrics\n    if self.mdl_p['solution_names'] is not None:\n        self.evaluate_all_solutions(self.mdl_p['solution_names'])\n\n    # Filepath for plot\n    filepath = self.export_paths['Analysis &amp; Results'] + folder + \"/\"\n\n    # Construct the chart\n    return afccp.visualizations.charts.cadet_utility_histogram(self, filepath=filepath)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.solve_cadet_board_model_direct","title":"<code>solve_cadet_board_model_direct(filepath)</code>","text":"<p>This method runs the cadet board model directly from the parameters in the csv at the specified filepath. We read and write back to this filepath</p> Source code in <code>afccp/main.py</code> <pre><code>def solve_cadet_board_model_direct(self, filepath):\n    \"\"\"\n    This method runs the cadet board model directly from the parameters in the csv at the specified\n    filepath. We read and write back to this filepath\n    \"\"\"\n\n    # Run function\n    afccp.solutions.optimization.solve_cadet_board_model_direct_from_board_parameters(self, filepath)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.similarity_plot","title":"<code>similarity_plot(p_dict={}, printing=None, folder='Results Charts')</code>","text":"<p>Creates the solution similarity plot for the solutions specified</p> Source code in <code>afccp/main.py</code> <pre><code>def similarity_plot(self, p_dict={}, printing=None, folder=\"Results Charts\"):\n    \"\"\"\n    Creates the solution similarity plot for the solutions specified\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Creating solution similarity plot...\")\n\n    # Adjust instance plot parameters\n    self.reset_functional_parameters(p_dict)\n    self.mdl_p = afccp.data.support.determine_afsc_plot_details(self, results_chart=True)\n\n    # Import similarity matrix\n    if 'Similarity Solutions.csv' in os.listdir(self.export_paths['Analysis &amp; Results']):\n        similarity_df = afccp.globals.import_csv_data(\n            self.export_paths['Analysis &amp; Results'] + 'Similarity Matrix.csv')\n    else:\n        raise ValueError(\"Error. No 'Similarity Matrix.csv' dataframe found in the 'Analysis &amp; Results' folder. \"\n                         \"Please create it.\")\n\n    # Extract similarity matrix information\n    solution_names = np.array(similarity_df.keys())\n    similarity_matrix = np.array(similarity_df)\n\n    # Get coordinates\n    coords = afccp.solutions.handling.similarity_coordinates(similarity_matrix)\n\n    # Filepath for plot\n    filepath = self.export_paths['Analysis &amp; Results'] + folder + \"/\"\n\n    # Plot similarity\n    return afccp.visualizations.charts.solution_similarity_graph(self, coords, solution_names,\n                                                                 filepath=filepath)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.solve_for_constraints","title":"<code>solve_for_constraints(p_dict={})</code>","text":"<p>This method iteratively adds constraints to the model to find which ones should be included based on feasibility and in order of importance</p> Source code in <code>afccp/main.py</code> <pre><code>def solve_for_constraints(self, p_dict={}):\n    \"\"\"\n    This method iteratively adds constraints to the model to find which ones should be included based on\n    feasibility and in order of importance\n    \"\"\"\n    self.error_checking(\"Pyomo Model\")\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    # If no constraints are turned on right now...\n    if np.sum(self.value_parameters[\"constraint_type\"]) == 0:\n        raise ValueError(\"No active constraints to search for, \"\n                         \"make sure the current set of value parameters has active constraints.\")\n\n    # Run the function!\n    constraint_type, solutions_df, report_df = afccp.solutions.sensitivity.determine_model_constraints(self)\n\n    # Build constraint type dataframe\n    constraint_type_df = pd.DataFrame({'AFSC': self.parameters['afscs'][:self.parameters[\"M\"]]})\n    for k, objective in enumerate(self.value_parameters['objectives']):\n        constraint_type_df[objective] = constraint_type[:, k]\n\n    # Export to excel\n    filepath = self.export_paths['Analysis &amp; Results'] + self.data_name + \" \" + self.vp_name + \\\n               \" Constraint Report (\" + self.data_version + \").xlsx\"\n    with pd.ExcelWriter(filepath) as writer:\n        report_df.to_excel(writer, sheet_name=\"Report\", index=False)\n        constraint_type_df.to_excel(writer, sheet_name=\"Constraints\", index=False)\n        solutions_df.to_excel(writer, sheet_name=\"Solutions\", index=False)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.initial_overall_weights_pareto_analysis","title":"<code>initial_overall_weights_pareto_analysis(p_dict={}, printing=None)</code>","text":"<p>Takes the current set of value parameters and solves the VFT approximate model solution multiple times given different overall weights on AFSCs and cadets. Once these solutions are determined, we can then run the other method \"final overall_weights_pareto_analysis\" to evolve all the solutions together given the different overall weights on cadets</p> <p>Parameters:</p> Name Type Description Default <code>p_dict</code> <p>more model parameters</p> <code>{}</code> <code>printing</code> <p>whether to print something</p> <code>None</code> Source code in <code>afccp/main.py</code> <pre><code>def initial_overall_weights_pareto_analysis(self, p_dict={}, printing=None):\n    \"\"\"\n    Takes the current set of value parameters and solves the VFT approximate model solution multiple times\n    given different overall weights on AFSCs and cadets. Once these solutions are determined, we can then\n    run the other method \"final overall_weights_pareto_analysis\" to evolve all the solutions together\n    given the different overall weights on cadets\n    :param p_dict: more model parameters\n    :param printing: whether to print something\n    \"\"\"\n    self.error_checking(\"Pyomo Model\")\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    if printing:\n        print(\"Conducting pareto analysis on problem...\")\n\n    # Initialize arrays\n    num_points = int(100 / self.mdl_p[\"pareto_step\"] + 1)\n    cadet_overall_values = np.zeros(num_points)\n    afsc_overall_values = np.zeros(num_points)\n    cadet_overall_weights = np.arange(1, 0, -(self.mdl_p[\"pareto_step\"] / 100))\n    cadet_overall_weights = np.append(cadet_overall_weights, 0)\n    solutions = {}\n\n    # Iterate over the number of points needed for the Pareto Chart\n    for point in range(num_points):\n        self.value_parameters['cadets_overall_weight'] = cadet_overall_weights[point]\n        self.value_parameters['afscs_overall_weight'] = 1 - cadet_overall_weights[point]\n\n        if printing:\n            print(\"Calculating point \" + str(point + 1) + \" out of \" + str(num_points) + \"...\")\n\n        # Build the model and then solve it\n        model, q = afccp.solutions.optimization.vft_model_build(self, printing=printing)\n        solution = afccp.solutions.optimization.solve_pyomo_model(self, model, \"VFT\", q=q, printing=printing)\n        solution = afccp.solutions.handling.evaluate_solution(solution, self.parameters, self.value_parameters)\n        solution_name = str(round(cadet_overall_weights[point], 4))\n\n        # Extract solution information\n        solutions[solution_name] = solution['afsc_array']\n        cadet_overall_values[point] = solution['cadets_overall_value']\n        afsc_overall_values[point] = solution['afscs_overall_value']\n\n        if printing:\n            print('For an overall weight on cadets of ' + str(cadet_overall_weights[point]) +\n                  ', calculated value on cadets: ' + str(round(cadet_overall_values[point], 2)) +\n                  ', value on afscs: ' + str(round(afsc_overall_values[point], 2)) +\n                  ', and a Z of ' + str(round(solution['z'], 2)) + '.')\n\n    # Obtain Dataframes\n    pareto_df = pd.DataFrame(\n        {'Weight on Cadets': cadet_overall_weights, 'Value on Cadets': cadet_overall_values,\n         'Value on AFSCs': afsc_overall_values})\n    solutions_df = pd.DataFrame(solutions)\n\n    # File we import and export to\n    filepath = self.export_paths['Analysis &amp; Results'] + self.data_name + \" \" + self.vp_name + \" (\" + \\\n               self.data_version + \") Pareto Analysis.xlsx\"\n    with pd.ExcelWriter(filepath) as writer:  # Export to excel\n        pareto_df.to_excel(writer, sheet_name=\"Approximate Pareto Results\", index=False)\n        solutions_df.to_excel(writer, sheet_name=\"Initial Solutions\", index=False)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.castle_pareto_analysis","title":"<code>castle_pareto_analysis(p_dict={}, printing=None)</code>","text":"<p>Takes the current set of value parameters and solves the GUO-Castle model with different weights on CASTLE and GUO.</p> <p>Parameters:</p> Name Type Description Default <code>p_dict</code> <p>more model parameters</p> <code>{}</code> <code>printing</code> <p>whether to print something</p> <code>None</code> Source code in <code>afccp/main.py</code> <pre><code>def castle_pareto_analysis(self, p_dict={}, printing=None):\n    \"\"\"\n    Takes the current set of value parameters and solves the GUO-Castle model with different weights on CASTLE\n    and GUO.\n    :param p_dict: more model parameters\n    :param printing: whether to print something\n    \"\"\"\n    self.error_checking(\"Pyomo Model\")\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    p_dict['solve_castle_guo'] = True  # Just in case we didn't put that in ;)\n    self.reset_functional_parameters(p_dict)\n\n    if printing:\n        print(\"Conducting CASTLE-MARKET pareto analysis on problem...\")\n\n    # Initialize arrays\n    num_points = int(100 / self.mdl_p[\"pareto_step\"] + 1)\n    castle_values = np.zeros(num_points)\n    guo_values = np.zeros(num_points)\n    castle_weights = np.arange(1, 0, -(self.mdl_p[\"pareto_step\"] / 100))\n    castle_weights = np.append(castle_weights, 0)\n    solutions = {}\n\n    # Iterate over the number of points needed for the Pareto Chart\n    for point in range(num_points):\n        self.mdl_p['w^G'] = 1 - castle_weights[point]\n\n        if printing:\n            print(\"Calculating point \" + str(point + 1) + \" out of \" + str(num_points) + \"...\")\n\n        # Build the model and then solve it\n        model = afccp.solutions.optimization.assignment_model_build(self, printing=printing)\n        solution = afccp.solutions.optimization.solve_pyomo_model(self, model, \"GUO\", printing=printing)\n        solution = afccp.solutions.handling.evaluate_solution(solution, self.parameters, self.value_parameters)\n        solution_name = str(round(cadet_overall_weights[point], 4))\n\n        # Extract solution information\n        solutions[solution_name] = solution['afsc_array']\n        castle_values[point] = solution['z^CASTLE (Values)']\n        guo_values[point] = solution['z^gu']\n\n        if printing:\n            print('For an overall weight on CASTLE of ' + str(castle_weights[point]) +\n                  ', calculated value on CASTLE: ' + str(round(castle_values[point], 2)) +\n                  ', value on GUO: ' + str(round(guo_values[point], 2)) +\n                  ', and a Z^CASTLE-MARKET of ' + str(round(solution['z^CASTLE'], 2)) + '.')\n\n    # Obtain Dataframes\n    pareto_df = pd.DataFrame(\n        {'Weight on CASTLE': castle_weights, 'Value on CASTLE': castle_values,\n         'Value on GUO': guo_values})\n    solutions_df = pd.DataFrame(solutions)\n\n    # File we import and export to\n    filepath = self.export_paths['Analysis &amp; Results'] + self.data_name + \" \" + self.vp_name + \" (\" + \\\n               self.data_version + \") Pareto Analysis (CASTLE).xlsx\"\n    with pd.ExcelWriter(filepath) as writer:  # Export to excel\n        pareto_df.to_excel(writer, sheet_name=\"CASTLE Results\", index=False)\n        solutions_df.to_excel(writer, sheet_name=\"Initial Solutions\", index=False)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.genetic_overall_weights_pareto_analysis","title":"<code>genetic_overall_weights_pareto_analysis(p_dict={}, printing=None)</code>","text":"<p>Takes the current set of value parameters and loads in a dataframe of solutions found using the VFT Approximate model. These solutions are the initial population for the GA that evolves them all together using different sets of value parameters (different overall weights on cadets)</p> <p>Parameters:</p> Name Type Description Default <code>p_dict</code> <p>more model parameters</p> <code>{}</code> <code>printing</code> <p>whether to print something</p> <code>None</code> Source code in <code>afccp/main.py</code> <pre><code>def genetic_overall_weights_pareto_analysis(self, p_dict={}, printing=None):\n    \"\"\"\n    Takes the current set of value parameters and loads in a dataframe of solutions found using the VFT Approximate\n    model. These solutions are the initial population for the GA that evolves them all together using different sets\n    of value parameters (different overall weights on cadets)\n    :param p_dict: more model parameters\n    :param printing: whether to print something\n    \"\"\"\n\n    # File we import and export to\n    filepath = self.export_paths['Analysis &amp; Results'] + self.data_name + \" \" + self.vp_name + \" (\" + \\\n               self.data_version + \") Pareto Analysis.xlsx\"\n\n    self.error_checking(\"Pyomo Model\")\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    if printing:\n        print(\"Conducting 'final' pareto analysis on problem...\")\n\n    # Solutions Dataframe\n    solutions_df = afccp.globals.import_data(filepath, sheet_name='Initial Solutions')\n    approximate_results_df = afccp.globals.import_data(filepath, sheet_name='Approximate Pareto Results')\n\n    # Load in the initial solutions\n    initial_afsc_solutions = np.array([np.array(solutions_df[col]) for col in solutions_df])\n    initial_solutions = np.array([])\n    for i, afsc_solution in enumerate(initial_afsc_solutions):\n        solution = np.array([np.where(self.parameters[\"afscs\"] == afsc)[0][0] for afsc in afsc_solution])\n        if i == 0:\n            initial_solutions = solution\n        else:\n            initial_solutions = np.vstack((initial_solutions, solution))\n\n    # Initialize arrays\n    num_points = int(100 / self.mdl_p[\"pareto_step\"] + 1)\n    cadet_overall_values = np.zeros(num_points)\n    afsc_overall_values = np.zeros(num_points)\n    cadet_overall_weights = np.arange(1, 0, -(self.mdl_p[\"pareto_step\"] / 100))\n    cadet_overall_weights = np.append(cadet_overall_weights, 0)\n    solutions = {}\n\n    # Iterate over the number of points needed for the Pareto Chart\n    for point in range(num_points):\n\n        # Change Overall Weights\n        self.value_parameters['cadets_overall_weight'] = cadet_overall_weights[point]\n        self.value_parameters['afscs_overall_weight'] = 1 - cadet_overall_weights[point]\n\n        if printing:\n            print(\"Calculating point \" + str(point + 1) + \" out of \" + str(num_points) + \"...\")\n\n        # Solve the genetic algorithm\n        solution, time_eval_df = afccp.solutions.algorithms.vft_genetic_algorithm(\n            self, initial_solutions, printing=printing)\n        solution = afccp.solutions.handling.evaluate_solution(solution, self.parameters, self.value_parameters)\n        solution_name = str(round(cadet_overall_weights[point], 4))\n\n        # Extract solution information\n        solutions[solution_name] = solution['afsc_array']\n        cadet_overall_values[point] = solution['cadets_overall_value']\n        afsc_overall_values[point] = solution['afscs_overall_value']\n\n        # We add this solution to our initial solutions too\n        initial_solutions = np.vstack((initial_solutions, solution['j_array']))\n\n        if printing:\n            print('For an overall weight on cadets of ' + str(cadet_overall_weights[point]) +\n                  ', calculated value on cadets: ' + str(round(cadet_overall_values[point], 2)) +\n                  ', value on afscs: ' + str(round(afsc_overall_values[point], 2)) +\n                  ', and a Z of ' + str(round(solution['z'], 2)) + '.')\n\n    # Obtain Dataframes\n    pareto_df = pd.DataFrame(\n        {'Weight on Cadets': cadet_overall_weights, 'Value on Cadets': cadet_overall_values,\n         'Value on AFSCs': afsc_overall_values})\n    ga_solutions_df = pd.DataFrame(solutions)\n\n    with pd.ExcelWriter(filepath) as writer:  # Export to excel\n        approximate_results_df.to_excel(writer, sheet_name=\"Approximate Pareto Results\", index=False)\n        solutions_df.to_excel(writer, sheet_name=\"Initial Solutions\", index=False)\n        pareto_df.to_excel(writer, sheet_name=\"GA Pareto Results\", index=False)\n        ga_solutions_df.to_excel(writer, sheet_name=\"GA Solutions\", index=False)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.overall_weights_pareto_analysis_utility","title":"<code>overall_weights_pareto_analysis_utility(p_dict={}, printing=None)</code>","text":"<p>Conduct pareto analysis on the \"global utility\" function using the assignment problem model</p> Source code in <code>afccp/main.py</code> <pre><code>def overall_weights_pareto_analysis_utility(self, p_dict={}, printing=None):\n    \"\"\"\n    Conduct pareto analysis on the \"global utility\" function using the assignment problem model\n    \"\"\"\n\n    self.error_checking(\"Pyomo Model\")\n    if printing is None:\n        printing = self.printing\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    if printing:\n        print(\"Conducting 'utility' pareto analysis on problem...\")\n\n    # Force the correct objective function\n    self.mdl_p['assignment_model_obj'] = 'Global Utility'\n\n    # Initialize arrays\n    num_points = int(100 / self.mdl_p[\"pareto_step\"] + 1)\n    cadet_overall_utilities = np.zeros(num_points)\n    afsc_overall_utilities = np.zeros(num_points)\n    cadet_overall_weights = np.arange(1, 0, -(self.mdl_p[\"pareto_step\"] / 100))\n    cadet_overall_weights = np.append(cadet_overall_weights, 0)\n    solutions = {}\n\n    # Iterate over the number of points needed for the Pareto Chart\n    for point in range(num_points):\n        w = cadet_overall_weights[point]\n\n        # Update global utility matrix\n        self.value_parameters['global_utility'] = np.zeros([self.parameters['N'], self.parameters['M'] + 1])\n        for j in self.parameters['J']:\n            self.value_parameters['global_utility'][:, j] = w * self.parameters['cadet_utility'][:, j] + \\\n                                                            (1 - w) * self.parameters['afsc_utility'][:, j]\n\n        if printing:\n            print(\"Calculating point \" + str(point + 1) + \" out of \" + str(num_points) + \"...\")\n\n        # Build &amp; solve the model\n        model = afccp.solutions.optimization.assignment_model_build(self)\n        solution = afccp.solutions.optimization.solve_pyomo_model(self, model, \"Assignment\", printing=False)\n        solution = afccp.solutions.handling.evaluate_solution(solution, self.parameters, self.value_parameters)\n        solution_name = str(round(cadet_overall_weights[point], 4))\n\n        # Extract solution information\n        solutions[solution_name] = solution['afsc_array']\n        cadet_overall_utilities[point] = solution['cadet_utility_overall']\n        afsc_overall_utilities[point] = solution['afsc_utility_overall']\n\n        if printing:\n            print('For an overall weight on cadets of ' + str(cadet_overall_weights[point]) +\n                  ', calculated utility on cadets: ' + str(round(cadet_overall_utilities[point], 2)) +\n                  ', utility on afscs: ' + str(round(afsc_overall_utilities[point], 2)) +\n                  ', and a global utility (z^gu) of ' + str(round(solution['z^gu'], 2)) + '.')\n\n    # Obtain Dataframes\n    pareto_df = pd.DataFrame(\n        {'Weight on Cadets': cadet_overall_weights, 'Utility on Cadets': cadet_overall_utilities,\n         'Utility on AFSCs': afsc_overall_utilities})\n    solutions_df = pd.DataFrame(solutions)\n\n    # File we import and export to\n    filepath = self.export_paths['Analysis &amp; Results'] + self.data_name + \" \" + self.vp_name + \" (\" + \\\n               self.data_version + \") Pareto Analysis (Utility).xlsx\"\n    with pd.ExcelWriter(filepath) as writer:  # Export to excel\n        pareto_df.to_excel(writer, sheet_name=\"Utility Pareto Results\", index=False)\n        solutions_df.to_excel(writer, sheet_name=\"Initial Solutions\", index=False)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.show_pareto_chart","title":"<code>show_pareto_chart(printing=None, utility_version=True, solution_names=None, folder='Results Charts')</code>","text":"<p>Saves the pareto chart to the figures folder</p> Source code in <code>afccp/main.py</code> <pre><code>def show_pareto_chart(self, printing=None, utility_version=True, solution_names=None, folder=\"Results Charts\"):\n    \"\"\"\n    Saves the pareto chart to the figures folder\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    if printing:\n        print(\"Creating Pareto Chart...\")\n\n    if utility_version:\n        l_word = 'Utility'\n\n        # File we import and export to\n        filepath = self.export_paths['Analysis &amp; Results'] + self.data_name + \" \" + self.vp_name + \" (\" + \\\n                   self.data_version + \") Pareto Analysis (Utility).xlsx\"\n\n        pareto_df = afccp.globals.import_data(filepath, sheet_name='Utility Pareto Results')\n    else:\n        l_word = 'Value'\n\n        # File we import and export to\n        filepath = self.export_paths['Analysis &amp; Results'] + self.data_name + \" \" + self.vp_name + \" (\" + \\\n                   self.data_version + \") Pareto Analysis.xlsx\"\n\n        try:\n            pareto_df = afccp.globals.import_data(filepath, sheet_name='GA Pareto Results')\n        except:\n            try:\n                pareto_df = afccp.globals.import_data(filepath, sheet_name='Approximate Pareto Results')\n            except:\n                raise ValueError(\"No Pareto Data found for instance '\" + self.data_name + \"'\")\n\n    return afccp.visualizations.charts.pareto_graph(self, pareto_df, l_word=l_word, solution_names=solution_names,\n                                                    filepath=self.export_paths['Analysis &amp; Results'] + folder + '/')\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.what_if_analysis","title":"<code>what_if_analysis(p_dict={}, printing=None)</code>","text":"<p>This method takes in an AFSC/cadet problem instance and performs some \"What If\" analysis based on the items listed in \"What If List.csv\". We manipulate the \"value parameters\" to meet these pre-defined conditions and then evaluate the model with the new constraints. We can then create a pareto frontier by modifying the weights on cadets/AFSCs. These results are all exported to a sub-folder called \"What If\" in the Analysis &amp; Results folder.</p> Source code in <code>afccp/main.py</code> <pre><code>def what_if_analysis(self, p_dict={}, printing=None):\n    \"\"\"\n    This method takes in an AFSC/cadet problem instance and performs some \"What If\" analysis based on the items listed\n    in \"What If List.csv\". We manipulate the \"value parameters\" to meet these pre-defined conditions and then evaluate\n    the model with the new constraints. We can then create a pareto frontier by modifying the weights on cadets/AFSCs.\n    These results are all exported to a sub-folder called \"What If\" in the Analysis &amp; Results folder.\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    self.error_checking(\"Pyomo Model\")\n\n    # Reset instance model parameters\n    self.reset_functional_parameters(p_dict)\n\n    if \"What If List.csv\" not in os.listdir(self.export_paths['Analysis &amp; Results']):\n        raise ValueError(\"Error. File 'What If List.csv' required for this analysis. It needs to be located\"\n                         \" in the 'Analysis &amp; Results' folder.\")\n\n    if printing:\n        print(\"Conducting 'What If?' analysis on this problem instance...\")\n\n    # Run the \"what if\" analysis function\n    afccp.solutions.sensitivity.optimization_what_if_analysis(self, printing)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.solve_pgl_capacity_sensitivity","title":"<code>solve_pgl_capacity_sensitivity(p_dict={}, printing=None)</code>","text":"<p>Docstring</p> Source code in <code>afccp/main.py</code> <pre><code>def solve_pgl_capacity_sensitivity(self, p_dict={}, printing=None):\n    \"\"\"\n    Docstring\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    self.error_checking(\"Pyomo Model\")\n\n    # Adjust instance plot parameters\n    self.reset_functional_parameters(p_dict)\n    self.mdl_p = afccp.data.support.determine_afsc_plot_details(self, results_chart=True)\n\n    # Run the function\n    afccp.solutions.sensitivity.solve_pgl_capacity_sensitivity(self, p_dict, printing)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.generate_pgl_capacity_charts","title":"<code>generate_pgl_capacity_charts(p_dict={}, printing=None)</code>","text":"<p>Docstring</p> Source code in <code>afccp/main.py</code> <pre><code>def generate_pgl_capacity_charts(self, p_dict={}, printing=None):\n    \"\"\"\n    Docstring\n    \"\"\"\n\n    if printing is None:\n        printing = self.printing\n\n    # Adjust instance plot parameters\n    self.reset_functional_parameters(p_dict)\n    self.mdl_p = afccp.data.support.determine_afsc_plot_details(self, results_chart=True)\n\n    # Run the function\n    afccp.solutions.sensitivity.generate_pgl_capacity_charts(self, p_dict, printing)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.export_data","title":"<code>export_data(datasets=None, printing=None)</code>","text":"<p>Exports the desired problem instance datasets back to csvs.</p> <p>Parameters: datasets (list of str): List of datasets to export. By default, the method exports the \"Value Parameters\" and     \"Solutions\" datasets, as these are the ones that are likely to change the most. Other possible datasets are     \"AFSCs\", \"Cadets\", \"Preferences\", and \"Goal Programming\". printing (bool): Whether to print status updates or not. If not specified, the value of <code>self.printing</code> will     be used.</p> <p>Returns: None</p> <p>This method exports the specified datasets using the <code>export_&lt;dataset_name&gt;_data</code> functions from the <code>afccp.core.data.processing</code> module. The exported csvs are saved in the paths specified in the <code>self.export_paths</code> dictionary.</p> <p>If the <code>self.import_paths</code> and <code>self.export_paths</code> attributes are not set, this method will call the <code>afccp_dp.initialize_file_information</code> function to create the necessary directories and set the paths.</p> <p>If the \"Goal Programming\" dataset is included in the <code>datasets</code> parameter and the <code>gp_df</code> attribute is not None, the method exports the <code>gp_df</code> dataframe to a csv using the file path specified in the <code>export_paths</code> dictionary.</p> Source code in <code>afccp/main.py</code> <pre><code>def export_data(self, datasets=None, printing=None):\n    \"\"\"\n    Exports the desired problem instance datasets back to csvs.\n\n    Parameters:\n    datasets (list of str): List of datasets to export. By default, the method exports the \"Value Parameters\" and\n        \"Solutions\" datasets, as these are the ones that are likely to change the most. Other possible datasets are\n        \"AFSCs\", \"Cadets\", \"Preferences\", and \"Goal Programming\".\n    printing (bool): Whether to print status updates or not. If not specified, the value of `self.printing` will\n        be used.\n\n    Returns:\n    None\n\n    This method exports the specified datasets using the `export_&lt;dataset_name&gt;_data` functions from the\n    `afccp.core.data.processing` module. The exported csvs are saved in the paths specified in the\n    `self.export_paths` dictionary.\n\n    If the `self.import_paths` and `self.export_paths` attributes are not set, this method will call the\n    `afccp_dp.initialize_file_information` function to create the necessary directories and set the paths.\n\n    If the \"Goal Programming\" dataset is included in the `datasets` parameter and the `gp_df` attribute is not None,\n    the method exports the `gp_df` dataframe to a csv using the file path specified in the `export_paths` dictionary.\n    \"\"\"\n\n    # Parameter initialization\n    if datasets is None:\n        datasets = [\"Cadets\", \"AFSCs\", \"Preferences\", \"Goal Programming\", \"Value Parameters\",\n                    \"Solutions\", \"Additional\", \"Base Solutions\", \"Course Solutions\"]\n    if printing is None:\n        printing = self.printing\n\n    # Print statement\n    if printing:\n        print(\"Exporting datasets\", datasets)\n\n    # Shorten module name\n    afccp_dp = afccp.data.processing\n\n    # Check to make sure we have file data information\n    for attribute in [self.import_paths, self.export_paths]:\n\n        # If we don't have this information, that means this is a new instance to export\n        if attribute is None:\n            self.import_paths, self.export_paths = afccp_dp.initialize_file_information(self.data_name,\n                                                                                        self.data_version)\n            break\n\n    # Export various data using the different functions\n    dataset_function_dict = {\"AFSCs\": afccp_dp.export_afscs_data,\n                             \"Cadets\": afccp_dp.export_cadets_data,\n                             \"Preferences\": afccp_dp.export_afsc_cadet_matrices_data,\n                             \"Value Parameters\": afccp_dp.export_value_parameters_data,\n                             \"Solutions\": afccp_dp.export_solutions_data,\n                             \"Additional\": afccp_dp.export_additional_data}\n    for dataset in dataset_function_dict:\n        if dataset in datasets:\n            dataset_function_dict[dataset](self)\n\n    # Goal Programming dataframe is an easy export (dataframe is already constructed)\n    if \"Goal Programming\" in datasets and self.gp_df is not None:\n        self.gp_df.to_csv(self.export_paths[\"Goal Programming\"], index=False)\n</code></pre>"},{"location":"reference/main/#main.CadetCareerProblem.export_solution_results","title":"<code>export_solution_results(printing=None)</code>","text":"<p>This function exports the metrics for one solution back to excel for review</p> Source code in <code>afccp/main.py</code> <pre><code>def export_solution_results(self, printing=None):\n    \"\"\"\n    This function exports the metrics for one solution back to excel for review\n    \"\"\"\n    if printing is None:\n        printing = self.printing\n\n    # Make sure we have a solution\n    self.error_checking('Solution')\n\n    # Create solution folder if necessary\n    self.manage_solution_folder()\n\n    # Filepath to export to\n    filename = self.data_name + \" \" + self.solution_name + \" (\" + self.vp_name + \").xlsx\"\n    filepath = self.export_paths['Analysis &amp; Results'] + self.solution_name + '/' + filename\n\n    # Print statement\n    if printing:\n        print(\"Exporting solution\", self.solution_name, \"results to \" + filepath + \"...\")\n\n    # Export results\n    afccp.data.processing.export_solution_results_excel(self, filepath)\n\n    if printing:\n        print(\"Done.\")\n</code></pre>"},{"location":"reference/data/__init__/","title":"Overview","text":""},{"location":"reference/data/__init__/#data","title":"<code>data</code>","text":""},{"location":"reference/data/adjustments/","title":"Adjustments","text":""},{"location":"reference/data/adjustments/#data.adjustments","title":"<code>data.adjustments</code>","text":""},{"location":"reference/data/adjustments/#data.adjustments.gather_degree_tier_qual_matrix","title":"<code>gather_degree_tier_qual_matrix(cadets_df, parameters)</code>","text":"<p>This function takes in the cadets dataframe and the dictionary of parameters (p) to determine what kind of degree tier qual matrix we'll be dealing with and if we have to generate one ourselves, we will do that here. This function handles most degree tier qualification information.</p> <p>Returns:</p> Type Description <p>instance parameters</p> Source code in <code>afccp/data/adjustments.py</code> <pre><code>def gather_degree_tier_qual_matrix(cadets_df, parameters):\n    \"\"\"\n    This function takes in the cadets dataframe and the dictionary of parameters (p) to determine what kind of degree\n    tier qual matrix we'll be dealing with and if we have to generate one ourselves, we will do that here. This function\n    handles most degree tier qualification information.\n    :return: instance parameters\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Determine if there is already a qualification matrix in the Cadets dataframe, and what \"type\" it is\n    afsc_1, afsc_M = p[\"afscs\"][0], p[\"afscs\"][p[\"M\"] - 1]\n    current_qual_type = \"None\"  # If there is no qualification matrix, we'll have to generate it\n    if cadets_df is not None:\n        if \"qual_\" + afsc_1 in cadets_df:\n            qual = np.array(cadets_df.loc[:, \"qual_\" + afsc_1: \"qual_\" + afsc_M]).astype(str)\n            test_qual = str(qual[0, 0])  # Variable to determine if we need to alter the qualification matrix\n\n            # Determine the type of qual matrix we *currently* have\n            if len(test_qual) == 1:\n                if test_qual in [\"1\", \"0\"]:\n                    current_qual_type = \"Binary\"\n                else:\n                    current_qual_type = \"Relaxed\"\n            else:\n                current_qual_type = \"Tiers\"\n\n    # If the current qualification matrix matches the one we want, then we don't need to do anything\n    generate_qual_matrix = False\n    if p[\"Qual Type\"] != current_qual_type:\n\n        # We don't have a qual matrix at all (We will generate the \"Tiers\" qual matrix!)\n        if current_qual_type == \"None\":\n            generate_qual_matrix = True\n\n        # We have a qual matrix and have specified that we want to keep it the way it is (Don't need to generate it)\n        elif p[\"Qual Type\"] == \"Consistent\":\n            p[\"Qual Type\"] = current_qual_type\n\n        # We have a qual matrix, but want to generate the \"Tiers\" qual matrix\n        elif p[\"Qual Type\"] == \"Tiers\":\n            generate_qual_matrix = True\n\n        else:\n            generate_qual_matrix = True\n            print(\"WARNING. The degree_qual_type parameter '\" + p[\"Qual Type\"] +\n                  \" specified but current qual matrix is of type '\" + current_qual_type +\n                  \"'. We no longer generate that kind of qual matrix. We will generate a 'Tiers' qual matrix.\")\n\n    # If we're going to generate a qual matrix, it'll be a \"Tiers\" matrix\n    if generate_qual_matrix:\n        p[\"Qual Type\"] = \"Tiers\"\n\n        if \"cip1\" in p:\n            if \"cip2\" in p:\n                qual = afccp.data.support.cip_to_qual_tiers(\n                    p[\"afscs\"][:p[\"M\"]], p['cip1'], cip2=p['cip2'])\n            else:\n                qual = afccp.data.support.cip_to_qual_tiers(\n                    p[\"afscs\"][:p[\"M\"]], p['cip1'])\n        else:\n            raise ValueError(\"Error. Need to update the degree tier qualification matrix to include tiers \"\n                             \"('M1' instead of 'M' for example) but don't have CIP codes. Please incorporate this.\")\n\n    # Determine the binary matrices for cadets based on their degree tiers and/or eligibility\n    if p[\"Qual Type\"] == \"Tiers\":\n\n        # NxM matrices with various features\n        p[\"ineligible\"] = (np.core.defchararray.find(qual, \"I\") != -1) * 1\n        p[\"eligible\"] = (p[\"ineligible\"] == 0) * 1\n        for t in [1, 2, 3, 4]:\n            p[\"tier \" + str(t)] = (np.core.defchararray.find(qual, str(t)) != -1) * 1\n        p[\"mandatory\"] = (np.core.defchararray.find(qual, \"M\") != -1) * 1\n        p[\"desired\"] = (np.core.defchararray.find(qual, \"D\") != -1) * 1\n        p[\"permitted\"] = (np.core.defchararray.find(qual, \"P\") != -1) * 1\n\n        # NEW: Exception to degree qualification based on CFM ranks\n        p[\"exception\"] = (np.core.defchararray.find(qual, \"E\") != -1) * 1\n\n        # Error Handling\n        if \"Deg Tiers\" not in p:\n            raise ValueError(\"Error. Degree qualification matrix is 'Tiers' category ('M1' instead of 'M' for example)\"\n                             \" and 'Deg Tier X' columns not found in 'AFSCs' dataframe. Please correct this issue.\")\n\n    elif p[\"Qual Type\"] == \"Relaxed\":\n        p['ineligible'] = (qual == 'I') * 1\n        p['eligible'] = (p['ineligible'] == 0) * 1\n        p['mandatory'] = (qual == 'M') * 1\n        p['desired'] = (qual == 'D') * 1\n        p['permitted'] = (qual == 'P') * 1\n\n        # NEW: Exception to degree qualification based on CFM ranks\n        p['exception'] = (qual == 'E') * 1\n\n    else:  # 'Binary'\n        p['ineligible'] = (qual == 0) * 1\n        p['eligible'] = qual\n\n    # Force string type!\n    p['Deg Tiers'][pd.isnull(p[\"Deg Tiers\"])] = ''\n    p['Deg Tiers'] = p['Deg Tiers'].astype(str)\n\n    # Load in Degree Tier information for each AFSC\n    if p[\"Qual Type\"] == \"Tiers\":\n\n        # Initialize information for AFSC degree tiers\n        p[\"t_count\"] = np.zeros(p['M']).astype(int)\n        p[\"t_proportion\"] = np.zeros([p['M'], 4])\n        p[\"t_leq\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"&lt;\") != -1) * 1\n        p[\"t_geq\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"&gt;\") != -1) * 1\n        p[\"t_eq\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"=\") != -1) * 1\n        p[\"t_mandatory\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"M\") != -1) * 1\n        p[\"t_desired\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"D\") != -1) * 1\n        p[\"t_permitted\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"P\") != -1) * 1\n\n        # Loop through each AFSC\n        for j, afsc in enumerate(p[\"afscs\"][:p['M']]):\n\n            # Loop through each potential degree tier\n            for t in range(4):\n                val = p[\"Deg Tiers\"][j, t]\n\n                # Empty degree tier\n                if val in [\"nan\", \"\"] or pd.isnull(val):\n                    t -= 1\n                    break\n\n                # Degree Tier Proportion\n                p[\"t_proportion\"][j, t] = val.split(\" \")[2]\n\n            # Num tiers\n            p[\"t_count\"][j] = t + 1\n\n    # Save qual matrix and return the instance p\n    p[\"qual\"] = qual\n    return p\n</code></pre>"},{"location":"reference/data/adjustments/#data.adjustments.parameter_sets_additions","title":"<code>parameter_sets_additions(parameters)</code>","text":"<p>Add Indexed Sets and Subsets to the Problem Instance Parameters.</p> <p>This function enhances the problem instance parameters by creating indexed sets and subsets for both AFSCs and cadets. It helps organize the data for efficient processing and optimization. These indexed sets and subsets include:</p> <ul> <li>Cadet Indexed Sets: <code>I</code>, <code>J</code>, <code>J^E</code>, <code>I^Choice</code>, <code>Choice Count</code>, and specific demographic subsets.</li> <li>AFSC Indexed Sets: <code>I^E</code> and counts of eligible cadets for each AFSC.</li> <li>Demographic Sets: Sets related to specific demographics such as USAFA cadets, minority cadets, male cadets, and   associated proportions.</li> </ul> <p>Additionally, it handles other tasks like adjusting the utility matrix for unmatched cadets, calculating the sum of cadet merits, differentiating USAFA and ROTC cadets, identifying fixed and reserved cadets, and managing cadet preferences and rated cadets.</p> <p>Args:     parameters: The problem instance parameters.</p> <p>Returns:     The updated problem instance parameters with added indexed sets and subsets.</p> <p>Example: <pre><code>import your_module\n\n# Create a problem instance\nparameters = your_module.create_instance()\n\n# Add indexed sets and subsets\nupdated_parameters = your_module.parameter_sets_additions(parameters)\n</code></pre></p> Source code in <code>afccp/data/adjustments.py</code> <pre><code>def parameter_sets_additions(parameters):\n    \"\"\"\n    Add Indexed Sets and Subsets to the Problem Instance Parameters.\n\n    This function enhances the problem instance parameters by creating indexed sets and subsets for both AFSCs and cadets.\n    It helps organize the data for efficient processing and optimization. These indexed sets and subsets include:\n\n    - Cadet Indexed Sets: `I`, `J`, `J^E`, `I^Choice`, `Choice Count`, and specific demographic subsets.\n    - AFSC Indexed Sets: `I^E` and counts of eligible cadets for each AFSC.\n    - Demographic Sets: Sets related to specific demographics such as USAFA cadets, minority cadets, male cadets, and\n      associated proportions.\n\n    Additionally, it handles other tasks like adjusting the utility matrix for unmatched cadets, calculating the sum of\n    cadet merits, differentiating USAFA and ROTC cadets, identifying fixed and reserved cadets, and managing cadet preferences\n    and rated cadets.\n\n    Args:\n        parameters: The problem instance parameters.\n\n    Returns:\n        The updated problem instance parameters with added indexed sets and subsets.\n\n    Example:\n    ```python\n    import your_module\n\n    # Create a problem instance\n    parameters = your_module.create_instance()\n\n    # Add indexed sets and subsets\n    updated_parameters = your_module.parameter_sets_additions(parameters)\n    ```\n\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Cadet Indexed Sets\n    p['I'] = np.arange(p['N'])\n    p['J'] = np.arange(p['M'])\n    p['J^E'] = [np.where(p['eligible'][i, :])[0] for i in p['I']]  # set of AFSCs that cadet i is eligible for\n\n    # AFSC Indexed Sets\n    p['I^E'] = [np.where(p['eligible'][:, j])[0] for j in p['J']]  # set of cadets that are eligible for AFSC j\n\n    # Number of eligible cadets for each AFSC\n    p[\"num_eligible\"] = np.array([len(p['I^E'][j]) for j in p['J']])\n\n    # More cadet preference sets if we have the \"cadet preference columns\"\n    if \"c_preferences\" in p:\n        p[\"I^Choice\"] = {choice: [np.where(\n            p[\"c_preferences\"][:, choice] == afsc)[0] for afsc in p[\"afscs\"][:p[\"M\"]]] for choice in range(p[\"P\"])}\n        p[\"Choice Count\"] = {choice: np.array(\n            [len(p[\"I^Choice\"][choice][j]) for j in p[\"J\"]]) for choice in range(p[\"P\"])}\n\n    # Add demographic sets if they're included\n    p['I^D'] = {}\n    if 'usafa' in p:\n        usafa = np.where(p['usafa'] == 1)[0]  # set of usafa cadets\n        p['usafa_proportion'] = np.mean(p['usafa'])\n        p['I^D']['USAFA Proportion'] = [np.intersect1d(p['I^E'][j], usafa) for j in p['J']]\n    if 'mandatory' in p:  # Qual Type = \"Old\"\n        p['I^D']['Mandatory'] = [np.where(p['mandatory'][:, j])[0] for j in p['J']]\n        p['I^D']['Desired'] = [np.where(p['desired'][:, j])[0] for j in p['J']]\n        p['I^D']['Permitted'] = [np.where(p['permitted'][:, j])[0] for j in p['J']]\n    if \"tier 1\" in p:  # Qual Type = \"Tiers\"\n        for t in ['1', '2', '3', '4']:\n            p['I^D']['Tier ' + t] = [np.where(p['tier ' + t][:, j])[0] for j in p['J']]\n\n        # Get arrays of unique degree tier values\n        p['Deg Tier Values'] = {j: np.unique(p['qual'][:, j]) for j in p['J']}\n\n    if 'male' in p:\n        male = np.where(p['male'] == 1)[0]  # set of male cadets\n        p['male_proportion'] = np.mean(p['male'])\n        p['I^D']['Male'] = [np.intersect1d(p['I^E'][j], male) for j in p['J']]\n    if 'minority' in p:\n        minority = np.where(p['minority'] == 1)[0]  # set of minority cadets\n        p['minority_proportion'] = np.mean(p['minority'])\n        p['I^D']['Minority'] = [np.intersect1d(p['I^E'][j], minority) for j in p['J']]\n\n    # Add an extra column to the utility matrix for cadets who are unmatched (if it hasn't already been added)\n    zeros_vector = np.array([[0] for _ in range(p[\"N\"])])\n    if np.shape(p['utility']) == (p['N'], p['M']):\n        p[\"utility\"] = np.hstack((p[\"utility\"], zeros_vector))\n\n    # Merit\n    if 'merit' in p:\n        p['sum_merit'] = p['merit'].sum()  # should be close to N/2\n\n    # USAFA/ROTC/OTS cadets\n    if 'SOCs' not in p:  # If it's just a \"USAFA\" column, we assume it's only USAFA/ROTC\n        p['rotc'] = (p['usafa'] == 0) * 1\n        p['usafa_cadets'] = np.where(p['usafa'])[0]\n        p['rotc_cadets'] = np.where(p['rotc'])[0]\n        p['usafa_eligible_count'] = np.array([len(np.intersect1d(p['I^E'][j], p['usafa_cadets'])) for j in p['J']])\n        p['rotc_eligible_count'] = np.array([len(np.intersect1d(p['I^E'][j], p['rotc_cadets'])) for j in p['J']])\n        p['SOCs'] = ['usafa', 'rotc']\n    else:\n        for soc in p['SOCs']:\n            p[soc] = (p['soc'] == soc.upper()) * 1\n            p[f'{soc}_cadets'] = np.where(p[soc])[0]\n            p[f'{soc}_eligible_count'] = np.array([len(np.intersect1d(p['I^E'][j], p[f'{soc}_cadets'])) for j in p['J']])\n\n    # Initialize empty dictionaries of matched/reserved cadets\n    p[\"J^Fixed\"] = {}\n    p[\"J^Reserved\"] = {}\n\n    # If we have the \"Assigned\" column in Cadets.csv, we can check to see if anyone is \"fixed\" in this solution\n    if \"assigned\" in p:\n\n        for i, afsc in enumerate(p[\"assigned\"]):\n            j = np.where(p[\"afscs\"] == afsc)[0]  # AFSC index\n\n            # Check if the cadet is actually assigned an AFSC already (it's not blank)\n            if len(j) != 0:\n                j = int(j[0])  # Actual index\n\n                # Check if the cadet is assigned to an AFSC they're not eligible for\n                if j not in p[\"J^E\"][i]:\n                    cadet = str(p['cadets'][i])\n                    raise ValueError(\"Cadet \" + cadet + \" assigned to '\" +\n                                     afsc + \"' but is not eligible for it. Adjust the qualification matrix!\")\n                else:\n                    p[\"J^Fixed\"][i] = j\n\n    # Cadet preference/rated cadet set additions\n    p = more_parameter_additions(p)\n\n    # Base/Training set additions\n    if \"bases\" in p:\n        p = base_training_parameter_additions(p)\n\n    return p\n</code></pre>"},{"location":"reference/data/adjustments/#data.adjustments.more_parameter_additions","title":"<code>more_parameter_additions(parameters)</code>","text":"<p>Enhance the problem instance parameters by adding additional parameter sets and subsets.</p> <p>This function extends the 'parameters' dictionary by adding various parameter sets and subsets, improving the organization of data for optimization. These additions include:</p> <ul> <li>Cadet Preferences: Sets cadet preferences and counts the number of cadet choices.</li> <li>AFSC Preferences: Sets AFSC preferences.</li> <li>AFSCs by Accessions Group: Categorizes AFSCs into accessions groups such as Rated, USSF, and NRL.</li> <li>Constrained Cadets: Identifies cadets constrained to specific accessions groups.</li> <li>PGL Totals for USSF: Calculates totals for USAFA and ROTC PGL (Projected Gain/Loss) within USSF.</li> <li>Rated Cadets: Identifies rated cadets, sets their preferences, and counts their choices.</li> <li>Cadet Utility Matrix: Constructs a utility matrix based on cadet preferences.</li> <li>Sets for cadets who have preferences and are eligible for specific AFSCs, and vice versa.</li> <li>Race and Ethnicity Categories: Organizes cadets based on race and ethnicity categories.</li> <li>SOC and Gender Categories: Organizes cadets into categories like USAFA, ROTC, male, female, etc.</li> <li>STEM Cadets: Identifies STEM cadets and related AFSCs.</li> </ul> <p>Args:     parameters: The problem instance parameters.</p> <p>Returns:     The updated problem instance parameters with added parameter sets and subsets.</p> Source code in <code>afccp/data/adjustments.py</code> <pre><code>def more_parameter_additions(parameters):\n    \"\"\"\n    Enhance the problem instance parameters by adding additional parameter sets and subsets.\n\n    This function extends the 'parameters' dictionary by adding various parameter sets and subsets, improving the organization\n    of data for optimization. These additions include:\n\n    - Cadet Preferences: Sets cadet preferences and counts the number of cadet choices.\n    - AFSC Preferences: Sets AFSC preferences.\n    - AFSCs by Accessions Group: Categorizes AFSCs into accessions groups such as Rated, USSF, and NRL.\n    - Constrained Cadets: Identifies cadets constrained to specific accessions groups.\n    - PGL Totals for USSF: Calculates totals for USAFA and ROTC PGL (Projected Gain/Loss) within USSF.\n    - Rated Cadets: Identifies rated cadets, sets their preferences, and counts their choices.\n    - Cadet Utility Matrix: Constructs a utility matrix based on cadet preferences.\n    - Sets for cadets who have preferences and are eligible for specific AFSCs, and vice versa.\n    - Race and Ethnicity Categories: Organizes cadets based on race and ethnicity categories.\n    - SOC and Gender Categories: Organizes cadets into categories like USAFA, ROTC, male, female, etc.\n    - STEM Cadets: Identifies STEM cadets and related AFSCs.\n\n    Args:\n        parameters: The problem instance parameters.\n\n    Returns:\n        The updated problem instance parameters with added parameter sets and subsets.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Create Cadet preferences\n    if 'c_pref_matrix' in p:\n        p['cadet_preferences'] = {}\n        p['num_cadet_choices'] = np.zeros(p['N'])\n        for i in p['I']:\n\n            # Sort the cadet preferences\n            cadet_sorted_preferences = np.argsort(p['c_pref_matrix'][i, :])\n            p['cadet_preferences'][i] = []\n\n            # Loop through each AFSC in order of preference and add it to the cadet's list\n            for j in cadet_sorted_preferences:\n\n                # Only add AFSCs that the cadet is eligible for and expressed a preference for\n                if 'last_afsc' not in p:\n                    if j in p['J^E'][i] and p['c_pref_matrix'][i, j] != 0:\n                        p['cadet_preferences'][i].append(j)\n\n                # Only add AFSCs that the cadet expressed a preference for\n                else:\n                    if p['c_pref_matrix'][i, j] != 0:\n                        p['cadet_preferences'][i].append(j)\n\n            p['cadet_preferences'][i] = np.array(p['cadet_preferences'][i])  # Convert to numpy array\n            p['num_cadet_choices'][i] = len(p['cadet_preferences'][i])\n\n    # Create AFSC preferences\n    if 'a_pref_matrix' in p:\n        p['afsc_preferences'] = {}\n        for j in p['J']:\n\n            # Sort the AFSC preferences\n            afsc_sorted_preferences = np.argsort(p['a_pref_matrix'][:, j])\n            p['afsc_preferences'][j] = []\n\n            # Loop through each cadet in order of preference and add them to the AFSC's list\n            for i in afsc_sorted_preferences:\n\n                # Only add cadets that are eligible for this AFSC and expressed a preference for it\n                if i in p['I^E'][j] and p['a_pref_matrix'][i, j] != 0:\n                    p['afsc_preferences'][j].append(i)\n\n            p['afsc_preferences'][j] = np.array(p['afsc_preferences'][j])  # Convert to numpy array\n\n    # Determine AFSCs by Accessions Group\n    p['afscs_acc_grp'] = {}\n    if 'acc_grp' in p:\n        for acc_grp in ['Rated', 'USSF', 'NRL']:\n            p['J^' + acc_grp] = np.where(p['acc_grp'] == acc_grp)[0]\n            p['afscs_acc_grp'][acc_grp] = p['afscs'][p['J^' + acc_grp]]\n    else:  # Previously, we've only assigned NRL cadets so we assume that's what we're dealing with here\n        p['acc_grp'] = np.array(['NRL' for _ in p['J']])\n        p['afscs_acc_grp']['NRL'] = p['afscs']\n        p['J^NRL'] = p['J']\n\n    # If we have the \"Accessions Group\" column in Cadets.csv, we can check to see if anyone is fixed to a group here\n    if 'acc_grp_constraint' in p:\n\n        # Loop through each Accession group and get the cadets that are constrained to be in this \"group\"\n        for acc_grp in p['afscs_acc_grp']:  # This should really only ever apply to USSF, but we're generalizing it\n\n            # Constrained cadets for each Accession group (don't confuse with I^*acc_grp* in the \"solutions\" dictionary!)\n            p['I^' + acc_grp] = np.where(p['acc_grp_constraint'] == acc_grp)[0]\n\n    # PGL Totals per SOC for USSF\n    if 'USSF' in p['afscs_acc_grp']:\n        p['ussf_usafa_pgl'] = np.sum(p['usafa_quota'][j] for j in p['J^USSF'])\n        p['ussf_rotc_pgl'] = np.sum(p['rotc_quota'][j] for j in p['J^USSF'])\n\n    # We already have \"J^USSF\" defined above; now we want one for USAF (NRL + Rated)\n    if 'USSF' in p['afscs_acc_grp']:\n        p['J^USAF'] = np.array([j for j in p['J'] if j not in p['J^USSF']])\n\n    # Determine eligible Rated cadets for both SOCs (cadets that are considered by the board)\n    cadets_dict = {soc: f'{soc[0]}r_om_cadets' for soc in p['SOCs']}\n    p[\"Rated Cadets\"] = {}\n    p[\"Rated Cadet Index Dict\"] = {}\n    p['Rated Choices'] = {}  # Dictionary of Rated cadet choices (only Rated AFSCs) by SOC\n    p['Num Rated Choices'] = {}  # Number of Rated cadet choices by SOC\n    for soc in cadets_dict:\n\n        # If we already have the array of cadets from the dataset\n        if cadets_dict[soc] in p:\n            p[\"Rated Cadets\"][soc] = p[cadets_dict[soc]]\n            p[\"Rated Cadet Index Dict\"][soc] = {i: idx for idx, i in enumerate(p[\"Rated Cadets\"][soc])}\n\n        # If we don't have this dataset, we check to see if we have Rated AFSCs\n        elif 'Rated' in p['afscs_acc_grp']:\n\n            # Add Rated cadets in order to each SOC list\n            p[\"Rated Cadets\"][soc] = []\n            for i in p[soc + '_cadets']:\n                for j in p['J^Rated']:\n                    if j in p['J^E'][i]:\n                        p[\"Rated Cadets\"][soc].append(i)\n                        break\n\n            # Convert to numpy array and get translation dictionary\n            p[\"Rated Cadets\"][soc] = np.array(p[\"Rated Cadets\"][soc])\n            p[\"Rated Cadet Index Dict\"][soc] = {i: idx for idx, i in enumerate(p[\"Rated Cadets\"][soc])}\n\n        # Get Rated preferences (where we strip out all NRL/USSF choices\n        if soc in p['Rated Cadets'] and 'cadet_preferences' in p:\n            p['Rated Choices'][soc] = {}\n            p['Num Rated Choices'][soc] = {i: 0 for i in p[\"Rated Cadets\"][soc]}\n            for i in p[\"Rated Cadets\"][soc]:\n                rated_order = []\n                for j in p['cadet_preferences'][i]:\n                    if j in p['J^Rated']:\n                        rated_order.append(j)\n                        p['Num Rated Choices'][soc][i] += 1\n                p['Rated Choices'][soc][i] = np.array(rated_order)\n\n    # If we haven't already created the \"cadet_utility\" matrix, we do that here (only one time)\n    if 'cadet_utility' not in p:\n\n        # Build out cadet_utility using cadet preferences\n        p['cadet_utility'] = np.around(copy.deepcopy(p['utility']), 4)\n\n    # set of AFSCs that cadet i has placed a preference for and is also eligible for\n    non_zero_utils_j = [np.where(p['cadet_utility'][i, :] &gt; 0)[0] for i in p['I']]\n    p[\"J^P\"] = [np.intersect1d(p['J^E'][i], non_zero_utils_j[i]) for i in p['I']]\n\n    # set of cadets that have placed a preference for AFSC j and are eligible for AFSC j\n    non_zero_utils_i = [np.where(p['cadet_utility'][:, j] &gt; 0)[0] for j in p['J']]\n    p[\"I^P\"] = [np.intersect1d(p['I^E'][j], non_zero_utils_i[j]) for j in p['J']]\n\n    # Race categories\n    if 'race' in p:\n        p['race_categories'] = np.unique(p['race'])\n        for race in p['race_categories']:\n            p['I^' + race] = np.where(p['race'] == race)[0]\n\n        # Calculate simpson index for overall class as a baseline\n        p['baseline_simpson_index'] = round(1 - np.sum([(len(\n            p['I^' + race]) * (len(p['I^' + race]) - 1)) / (p['N'] * (p['N'] - 1)) for race in p['race_categories']]), 2)\n\n    # Ethnicity categories\n    if 'ethnicity' in p:\n        p['ethnicity_categories'] = np.unique(p['ethnicity'])\n        for eth in p['ethnicity_categories']:\n            p['I^' + eth] = np.where(p['ethnicity'] == eth)[0]\n\n        # Calculate simpson index for overall class as a baseline\n        p['baseline_simpson_index_eth'] = round(1 - np.sum([(len(\n            p['I^' + eth]) * (len(p['I^' + eth]) - 1)) / (p['N'] * (p['N'] - 1)) for eth in\n                                                        p['ethnicity_categories']]), 2)\n\n    # SOC and Gender cadets standardized like above\n    if 'SOCs' in p:\n        for soc in p['SOCs']:\n            p[f'I^{soc.upper()}'] = np.where(p[soc])[0]\n    if 'male' in p:\n        p['I^Male'] = np.where(p['male'])[0]\n        p['I^Female'] = np.where(p['male'] == 0)[0]\n\n    # STEM cadets\n    if 'stem' in p:\n        p['I^STEM'] = np.where(p['stem'])[0]\n\n        if 'afscs_stem' in p:\n            p['J^STEM'] = np.where(p['afscs_stem'] == 'Yes')[0]\n            p['J^Not STEM'] = np.where(p['afscs_stem'] == 'No')[0]\n            p['J^Hybrid'] = np.where(p['afscs_stem'] == 'Hybrid')[0]\n\n    # Selected AFSCs\n    if 'c_selected_matrix' in p:\n        p['J^Selected'] = {}\n        for i in p['I']:\n            p['J^Selected'][i] = np.where(p['c_selected_matrix'][i])[0]\n\n    # Last/Second to Last AFSCs\n    if 'last_afsc' in p and 'second_to_last_afscs' in p:\n        p['J^Bottom 2 Choices'] = {}\n        p['J^Last Choice'] = {}\n\n        # Loop through each cadet\n        for i in p['I']:\n\n            # Get a list of AFSC indices of the bottom 2 choices (but not last choice)\n            if type(p['second_to_last_afscs'][i]) == str:\n                afsc_list = p['second_to_last_afscs'][i].split(',')\n            else:\n                afsc_list = [\"\"]\n\n            p['J^Bottom 2 Choices'][i] = []\n            for afsc in afsc_list:\n                afsc = afsc.strip()\n                if afsc in p['afscs']:\n                    j = np.where(p['afscs'] == afsc)[0][0]\n                    p['J^Bottom 2 Choices'][i].append(j)\n            p['J^Bottom 2 Choices'][i] = np.array(p['J^Bottom 2 Choices'][i])\n\n            # Get the last AFSC choice index\n            p['J^Last Choice'][i] = p['M']  # Unmatched AFSC (*)\n            if p['last_afsc'][i] in p['afscs']:\n                p['J^Last Choice'][i] = np.where(p['afscs'] == p['last_afsc'][i])[0][0]\n\n    return p\n</code></pre>"},{"location":"reference/data/adjustments/#data.adjustments.base_training_parameter_additions","title":"<code>base_training_parameter_additions(parameters)</code>","text":"<p>This function takes in our set of parameters and adds more components to address the base/training model components as an \"expansion\" of the afccp functionality. This model performs base assignments and schedules cadets for training courses simultaneously.</p> Source code in <code>afccp/data/adjustments.py</code> <pre><code>def base_training_parameter_additions(parameters):\n    \"\"\"\n    This function takes in our set of parameters and adds more components to address the base/training model\n    components as an \"expansion\" of the afccp functionality. This model performs base assignments and schedules\n    cadets for training courses simultaneously.\n    \"\"\"\n\n    # Helpful function to extract the datetime object from a specific string containing date information\n    def parse_date(date_str):\n        for fmt in ('%m/%d/%y', '%Y-%m-%d'):\n            try:\n                return datetime.strptime(date_str, fmt).date()\n            except ValueError:\n                pass\n        return None  # Return None if no format matches\n\n    # Shorthand\n    p = parameters\n\n    # Sets of bases and courses\n    p['B'] = np.arange(p['S'])\n    p['C'] = {j: np.arange(p['T'][j]) for j in p['J']}\n\n    # Set of AFSCs that assign cadets to bases\n    p['J^B'] = np.where(p['afsc_assign_base'])[0]\n\n    # Set of bases that AFSC j may assign cadets to\n    p['B^A'] = {j: np.where(p['base_max'][:, j] &gt; 0)[0] for j in p['J']}\n\n    # Set of bases that cadet i may be assigned to (based on the union of all eligible bases from AFSCs in J^E_i)\n    p['B^E'] = {i: reduce(np.union1d, (p['B^A'][j] for j in np.intersect1d(p['J^E'][i], p['J^B']))) for i in p['I']}\n\n    # Sets/Parameters for AFSC outcome states for each cadet\n    p['D'] = {}  # Set of all AFSC outcome states that cadet i has designated\n    p['Cadet Objectives'] = {}  # Set of cadet objectives included for each cadet and each state\n    p['J^State'] = {}  # Set of AFSCs that, if assigned, would put cadet i into state d\n    p['w^A'] = {}  # the weight that cadet i places on AFSCs in state d\n    p['w^B'] = {}  # the weight that cadet i places on bases in state d\n    p['w^C'] = {}  # the weight that cadet i places on courses in state d\n    p['u^S'] = {}  # the maximum utility that cadet i receives from state d (based on best AFSC)\n    p['B^State'] = {}  # Set of bases that cadet i can be assigned to in state d (According to J^State_id)\n\n    # Determine the \"states\" for each cadet based on the differences of AFSC outcomes\n    for i in p['I']:\n\n        # Base/Training Thresholds (Shorthand)\n        bt, tt = p['base_threshold'][i], p['training_threshold'][i]\n\n        # Determine \"primary\" set of AFSCs and states based on thresholds\n        if bt &lt; tt:\n            afscs = {1: p['cadet_preferences'][i][:bt],\n                      2: p['cadet_preferences'][i][bt: tt],\n                      3: p['cadet_preferences'][i][tt:]}\n            included = {1: ['afsc'], 2: ['afsc', 'base'], 3: ['afsc', 'base', 'course']}\n        elif tt &lt; bt:\n            afscs = {1: p['cadet_preferences'][i][:tt],\n                      2: p['cadet_preferences'][i][tt: bt],\n                      3: p['cadet_preferences'][i][bt:]}\n            included = {1: ['afsc'], 2: ['afsc', 'course'], 3: ['afsc', 'base', 'course']}\n        else:  # They're equal!\n            afscs = {1: p['cadet_preferences'][i][:bt],\n                      2: p['cadet_preferences'][i][bt:]}\n            included = {1: ['afsc'], 2: ['afsc', 'base', 'course']}\n\n        # Sets/Parameters for AFSC outcome states for each cadet\n        p['D'][i] = []  # Set of all AFSC outcome states that cadet i has designated\n        p['Cadet Objectives'][i] = {}  # Set of cadet objectives included for each cadet and each state\n        p['J^State'][i] = {}  # Set of AFSCs that, if assigned, would put cadet i into state d\n        p['w^A'][i] = {}  # the weight that cadet i places on AFSCs in state d\n        p['w^B'][i] = {}  # the weight that cadet i places on bases in state d\n        p['w^C'][i] = {}  # the weight that cadet i places on courses in state d\n        p['u^S'][i] = {}  # the maximum utility that cadet i receives from state d (based on best AFSC)\n        p['B^State'][i] = {}  # Set of bases that cadet i can be assigned to in state d (According to J^State_id)\n\n        # Loop through each \"primary\" state to get \"final\" states (Split up states based on base assignment AFSCs)\n        d = 1\n        for state in included:\n\n            # Empty state!\n            if len(afscs[state]) == 0:\n                continue\n\n            # Split up the AFSCs into two groups if they assign cadets to bases or not\n            sets = {'Assigned': np.intersect1d(p['J^B'], afscs[state]),\n                    'Not Assigned': np.array([j for j in afscs[state] if j not in p['J^B']])}\n\n            # Loop through both sets and create a new state if the set contains AFSCs\n            for set_name, afscs_in_set in sets.items():\n                if len(afscs_in_set) != 0:\n\n                    # Add information to this state\n                    p['D'][i].append(d)\n                    p['Cadet Objectives'][i][d] = included[state]\n                    p['J^State'][i][d] = afscs_in_set\n                    p['u^S'][i][d] = p['cadet_utility'][i, afscs[state][0]]  # Utility of the top preferred AFSC\n\n                    # Weights and set of bases are differentiated by if this is a set containing J^B AFSCs or not\n                    if set_name == \"Assigned\":\n\n                        # Re-scale weights based on the objectives included in this state\n                        p['w^A'][i][d] = p['weight_afsc'][i] / sum(p['weight_' + obj][i] for obj in included[state])\n                        p['w^C'][i][d] = p['weight_course'][i] / sum(p['weight_' + obj][i] for obj in included[state]) \\\n                                         * ('course' in included[state])\n                        p['w^B'][i][d] = p['weight_base'][i] / sum(p['weight_' + obj][i] for obj in included[state]) \\\n                                         * ('base' in included[state])\n\n                        # Union of bases that this cadet could be assigned to in this state according to J^State_id\n                        p['B^State'][i][d] = reduce(np.union1d, (p['B^A'][j] for j in p['J^State'][i][d]))\n\n                    else:\n\n                        # Re-scale weights based on the objectives included in this state\n                        p['w^A'][i][d] = p['weight_afsc'][i] / \\\n                                         sum(p['weight_' + obj][i] for obj in included[state] if obj != \"base\")\n                        p['w^C'][i][d] = ('course' in included[state]) * p['weight_course'][i] / \\\n                                         sum(p['weight_' + obj][i] for obj in included[state] if obj != \"base\")\n                        p['w^B'][i][d] = 0\n                        p['B^State'][i][d] = np.array([])  # Empty array (no bases)\n\n                    # Next state\n                    d += 1\n\n        # Print statement for specific cadet\n        if i == 10 and False:  # Meant for debugging and sanity checking this logic!\n            print('Cadet', i)\n            for d in p['D'][i]:\n                print('\\n\\n')\n                print('State', d)\n                print('Objectives', p['Cadet Objectives'][i][d])\n                print('J^State', p['afscs'][p['J^State'][i][d]])\n                if len(p['B^State'][i][d]) &gt; 0:\n                    print('B^State', p['bases'][p['B^State'][i][d]])\n                else:\n                    print('B^State', [])\n                print('Weight (AFSC)', round(p['w^A'][i][d], 3))\n                print('Weight (Base)', round(p['w^B'][i][d], 3))\n                print('Weight (Course)', round(p['w^C'][i][d], 3))\n                print('Utility (State)', round(p['u^S'][i][d], 3))\n\n    # Adjust AFSC, base, course weights to give slight bump to ensure all are considered in each applicable state\n    max_afsc_weight = max([p['w^A'][i][d] for i in p['I'] for d in p['D'][i] if p['w^A'][i][d] != 1])\n    max_afsc_weight += (1 - max_afsc_weight) / 2\n    for i in p['I']:\n        for d in p['D'][i]:\n\n            # Take some weight from AFSCs\n            p['w^A'][i][d] = p['w^A'][i][d] * max_afsc_weight\n\n            # Redistribute the weight to Base/Courses depending on existence of J^B AFSCs\n            if len(p['B^State'][i][d]) &gt; 0:\n                p['w^B'][i][d] = p['w^B'][i][d] * max_afsc_weight + (1 - max_afsc_weight) / 2\n                p['w^C'][i][d] = p['w^C'][i][d] * max_afsc_weight + (1 - max_afsc_weight) / 2\n            else:\n                p['w^C'][i][d] = p['w^C'][i][d] * max_afsc_weight + (1 - max_afsc_weight)\n\n    # Sets pertaining to courses for each AFSC\n    p['C^E'] = {}  # Set of courses that cadet i is available to take with AFSC j\n    p['I^A'] = {}  # Set of cadets that are available to take course c with AFSC j\n\n    # Calculate course utility for each cadet, AFSC, course tuple\n    p['course_days_cadet'] = {}\n    p['course_utility'] = {}\n    for i in p['I']:\n\n        # Initialize information for this cadet\n        p['course_days_cadet'][i] = {}\n        p['course_utility'][i] = {}\n        p['C^E'][i] = {}\n\n        # Loop through each AFSC and course to determine days between cadet start and course start\n        for j in p['J^E'][i]:\n            p['course_days_cadet'][i][j] = {}\n            for c in p['C'][j]:\n\n                # Convert str format to datetime format if necessary\n                if type(p['course_start'][j][c]) == str:\n                    course_start = parse_date(p['course_start'][j][c])\n                    cadet_start = parse_date(p['training_start'][i])\n                else:\n                    course_start = p['course_start'][j][c]\n                    cadet_start = p['training_start'][i]\n\n                # Calculate days between\n                days_between = (course_start - cadet_start).days\n                if days_between &gt;= 0:  # If the cadet is available to take the course before it starts\n                    p['course_days_cadet'][i][j][c] = days_between\n\n            # Get subset of courses that this cadet can take for this AFSC\n            p['C^E'][i][j] = np.array([c for c in p['course_days_cadet'][i][j]])\n\n        # Get course wait times and determine min and max\n        course_waits = [p['course_days_cadet'][i][j][c] for j in p['J^E'][i] for c in p['C^E'][i][j]]\n        max_wait, min_wait = max(course_waits), min(course_waits)\n\n        # Loop through each AFSC and course again to calculate utility (normalize the wait times)\n        for j in p['J^E'][i]:\n            p['course_utility'][i][j] = {}\n            for c in p['C^E'][i][j]:\n                if p['training_preferences'][i] == 'Early':\n                    p['course_utility'][i][j][c] = 1 - (p['course_days_cadet'][i][j][c] - min_wait) / \\\n                                                   (max_wait - min_wait)\n                elif p['training_preferences'][i] == 'Late':\n                    p['course_utility'][i][j][c] = (p['course_days_cadet'][i][j][c] - min_wait) / \\\n                                                   (max_wait - min_wait)\n                else:  # No preference\n                    p['course_utility'][i][j][c] = 0\n\n                if i == 0 and False:  # Meant for debugging and sanity checking this logic!\n                    print(i, j, c, \"Dates\", course_start, cadet_start, \"DAYS\", p['course_days_cadet'][i][j][c],\n                          \"Utility\", p['course_utility'][i][j][c])\n\n    # Determine set of cadets that are available to take course c with AFSC j\n    for j in p['J']:\n        p['I^A'][j] = {}\n        for c in p['C'][j]:\n            p['I^A'][j][c] = np.array([i for i in p['I^E'][j] if c in p['C^E'][i][j]])\n\n    # Get minimum and maximum quantities for bases\n    p['lo^B'], p['hi^B'] = {}, {}\n    for j in p['J^B']:\n        p['lo^B'][j], p['hi^B'][j] = {}, {}\n        for b in p['B^A'][j]:\n            p['lo^B'][j][b], p['hi^B'][j][b] = p['base_min'][b, j], p['base_max'][b, j]\n\n    # Get minimum and maximum quantities for courses\n    p['lo^C'], p['hi^C'] = p['course_min'], p['course_max']\n\n    return p\n</code></pre>"},{"location":"reference/data/adjustments/#data.adjustments.convert_instance_to_from_scrubbed","title":"<code>convert_instance_to_from_scrubbed(instance, new_letter=None, translation_dict=None, data_name='Unknown')</code>","text":"<p>This function takes in a problem instance and scrubs the AFSC names by sorting them by their PGL targets.</p> Source code in <code>afccp/data/adjustments.py</code> <pre><code>def convert_instance_to_from_scrubbed(instance, new_letter=None, translation_dict=None, data_name='Unknown'):\n    \"\"\"\n    This function takes in a problem instance and scrubs the AFSC names by sorting them by their PGL targets.\n    \"\"\"\n\n    # Load parameters\n    p = copy.deepcopy(instance.parameters)\n\n    # Initialize AFSC information\n    current_afscs_unsorted = p[\"afscs\"][:p[\"M\"]]\n    new_p = copy.deepcopy(p)\n\n    # We're going from original to scrubbed\n    if new_letter is not None:\n        data_name = new_letter\n\n        # Sort current list of AFSCs by PGL\n        t_indices = np.argsort(p[\"pgl\"])[::-1]  # Indices that word sort the list -&gt; used a lot below!\n        current_afscs = copy.deepcopy(current_afscs_unsorted[t_indices])\n\n        # Construct new list of AFSCS\n        new_p['afscs'] = np.array([' ' * 10 for _ in p['J']])\n        for j, afsc in enumerate(current_afscs):\n            new_p['afscs'][j] = new_letter + str(j + 1)\n\n            # Adjust new AFSC by adding \"_U\" or \"_R\" extension if necessary\n            for ext in [\"_R\", \"_U\"]:\n                if ext in afsc:\n                    new_p['afscs'][j] += ext\n                    break\n\n        # Translate AFSCs to the new list\n        translation_dict = {}\n        for afsc in current_afscs_unsorted:\n            j = np.where(current_afscs == afsc)[0][0]\n            translation_dict[afsc] = new_p['afscs'][j]  # Save this AFSC to the translation dictionary\n        new_p[\"afscs\"] = np.hstack((new_p[\"afscs\"], \"*\"))  # Add \"unmatched\" AFSC\n\n    # We're going from scrubbed to original\n    else:\n\n        # Translate AFSCs (Really weird sorting going on...sorry)\n        new_p[\"afscs\"] = np.array(list(translation_dict.keys()))\n        new_p[\"afscs\"] = np.hstack((new_p[\"afscs\"], \"*\"))  # Add \"unmatched\" AFSC\n        flipped_translation_dict = {translation_dict[afsc]: afsc for afsc in translation_dict}\n        real_order_scrubbed_afscs = np.array(list(flipped_translation_dict.keys()))\n        scrubbed_order_indices = np.array(\n            [np.where(real_order_scrubbed_afscs==afsc)[0][0] for afsc in current_afscs_unsorted])\n        scrubbed_order_real_afscs = new_p['afscs'][scrubbed_order_indices]\n        current_afscs = real_order_scrubbed_afscs\n\n        # Get sorted indices\n        t_indices = np.array([np.where(scrubbed_order_real_afscs==afsc)[0][0] for afsc in new_p[\"afscs\"][:p[\"M\"]]])\n\n    # Loop through each key in the parameter dictionary to translate it\n    for key in p:\n\n        # If it's a one dimensional array of length M, we translate it accordingly\n        if np.shape(p[key]) == (p[\"M\"], ) and \"^\" not in key:  # Sets/Subsets will be adjusted later\n            new_p[key] = p[key][t_indices]\n\n        # If it's a two-dimensional array of shape Mx4, we translate it accordingly\n        elif np.shape(p[key]) == (p[\"M\"], 4):\n            new_p[key] = p[key][t_indices, :]\n\n        # If it's a two-dimensional array of shape (NxM), we translate it accordingly\n        elif np.shape(p[key]) == (p[\"N\"], p[\"M\"]) and key not in ['c_preferences', 'c_utilities']:\n            new_p[key] = p[key][:, t_indices]\n\n        # If it's a two-dimensional array of shape (NxM+1), we translate it accordingly (leave unmatched AFSC alone)\n        elif np.shape(p[key]) == (p[\"N\"], p[\"M\"] + 1):\n            new_p[key] = copy.deepcopy(p[key])\n            new_p[key][:, :p['M']] = p[key][:, t_indices]\n\n    # Get assigned AFSC vector\n    for i, real_afsc in enumerate(p[\"assigned\"]):\n        if real_afsc in current_afscs:\n            j = np.where(current_afscs == real_afsc)[0][0]\n            new_p[\"assigned\"][i] = new_p[\"afscs\"][j]\n\n    # Set additions, and add to the instance\n    instance.parameters = parameter_sets_additions(new_p)\n\n    # Translate value parameters\n    if instance.vp_dict is not None:\n        new_vp_dict = {}\n        for vp_name in instance.vp_dict:\n            vp = copy.deepcopy(instance.vp_dict[vp_name])\n            new_vp = copy.deepcopy(vp)\n\n            for key in vp:\n\n                # If it's a one dimensional array of length M, we translate it accordingly\n                if np.shape(vp[key]) == (p[\"M\"],):\n                    new_vp[key] = vp[key][t_indices]\n\n                # If it's a two-dimensional array of shape (NxM), we translate it accordingly\n                elif np.shape(vp[key]) == (p[\"N\"], p[\"M\"]):\n                    new_vp[key] = vp[key][:, t_indices]\n\n                # If it's a two-dimensional array of shape (MxO), we translate it accordingly\n                elif np.shape(vp[key]) == (vp[\"M\"], vp[\"O\"]) and key not in [\"a\", \"f^hat\"]:\n                    new_vp[key] = vp[key][t_indices, :]\n\n            for j, old_j in enumerate(t_indices):\n                for k in vp[\"K\"]:\n                    for key in [\"a\", \"f^hat\"]:\n                        new_vp[key][j][k] = vp[key][old_j][k]\n\n            # Set value parameters to dict\n            new_vp_dict[vp_name] = new_vp\n\n        # Set it to the instance\n        instance.vp_dict = new_vp_dict\n\n        # Loop through each set of value parameters again\n        for vp_name in instance.vp_dict:\n\n            # Set additions\n            instance.vp_dict[vp_name] = \\\n                afccp.data.values.value_parameters_sets_additions(instance.parameters, instance.vp_dict[vp_name])\n\n    else:\n        instance.vp_dict = None\n\n    # Translate solutions\n    if instance.solutions is not None:\n        new_solutions_dict = {}\n\n        # Loop through each solution\n        for solution_name in instance.solutions:\n            real_solution = copy.deepcopy(instance.solutions[solution_name])\n            new_solutions_dict[solution_name] = copy.deepcopy(real_solution)\n\n            # Loop through each assigned AFSC for the cadets\n            for i, j in enumerate(real_solution['j_array']):\n                if j != p[\"M\"]:\n                    real_afsc = p[\"afscs\"][j]\n                    j = np.where(current_afscs == real_afsc)[0][0]\n                    new_solutions_dict[solution_name]['j_array'][i] = j\n\n        # Save solutions dictionary\n        instance.solutions = new_solutions_dict\n\n    else:\n        instance.solutions = None\n\n    # Convert \"c_preferences\" array\n    if \"c_preferences\" in p:\n        for i in p[\"I\"]:\n            for pref in range(p[\"P\"]):\n                real_afsc = p[\"c_preferences\"][i, pref]\n                if real_afsc in current_afscs:\n                    j = np.where(current_afscs == real_afsc)[0][0]\n                    new_p[\"c_preferences\"][i, pref] = new_p[\"afscs\"][j]\n\n    # Instance Attributes\n    instance.data_name, instance.data_version = data_name, \"Default\"\n    instance.import_paths, instance.export_paths = None, None\n\n    return instance, translation_dict\n</code></pre>"},{"location":"reference/data/adjustments/#data.adjustments.parameter_sanity_check","title":"<code>parameter_sanity_check(instance)</code>","text":"<p>Perform a Sanity Check on Problem Instance Parameters.</p> <p>This function rigorously checks the validity of various parameters and configurations within the given problem instance. It's an essential step to ensure the consistency and feasibility of the problem definition before running any optimization.</p> <p>Args:     instance: The problem instance to be checked.</p> <p>Raises:     ValueError: If the provided instance doesn't have value parameters (vp).</p> <p>The function examines a range of parameters and configurations within the problem instance. It checks for issues in the following categories:</p> <ol> <li>Constraint Type: It ensures that the 'constraint_type' matrix doesn't contain deprecated values (3 or 4).</li> <li>AFSC Quota Constraints: Verifies the validity of quota constraints, such as minimum and maximum quotas for AFSCs.</li> <li>Objective Targets: Validates that the 'quota_d' value matches the objective target for Combined Quota.</li> <li>Degree Tiers: Checks if objectives related to degree tiers have a proper number of eligible cadets.</li> <li>Qualification Levels: Ensures that qualification levels specified in the 'qual' matrix are coherent with value parameters.</li> <li>Constrained Objectives: Verifies that constrained objectives have appropriate constraints defined.</li> <li>Value Functions: Validates value functions, including the format of value function strings and breakpoints.</li> <li>Cadet Preferences: Ensures that cadet preferences align with preference matrices (c_preferences and c_pref_matrix).</li> <li>Monotonically Decreasing Utility: Checks that the cadet-reported utility matrix 'utility' is monotonically decreasing.</li> <li>Strictly Decreasing Cadet Utility: Verifies that the constructed cadet utility matrix 'cadet_utility' is strictly decreasing.</li> <li>Objective Targets Null Values: Checks for null values in the objective target array.</li> <li>USSF OM Constraint: Ensures that the USSF OM constraint is not set if no USSF AFSCs are defined.</li> <li>Rated Preferences: Verifies that rated cadets have at least one rated preference.</li> <li>Total Minimum and Maximum Capacities: Checks that the total sum of minimum and maximum capacities is feasible.</li> </ol> <p>This function provides detailed information about issues, if any, found within the problem instance. It is a crucial step in guaranteeing the reliability and accuracy of the optimization process.</p> Source code in <code>afccp/data/adjustments.py</code> <pre><code>def parameter_sanity_check(instance):\n    \"\"\"\n    Perform a Sanity Check on Problem Instance Parameters.\n\n    This function rigorously checks the validity of various parameters and configurations within the given problem instance.\n    It's an essential step to ensure the consistency and feasibility of the problem definition before running any optimization.\n\n    Args:\n        instance: The problem instance to be checked.\n\n    Raises:\n        ValueError: If the provided instance doesn't have value parameters (vp).\n\n    The function examines a range of parameters and configurations within the problem instance. It checks for issues in the\n    following categories:\n\n    1. **Constraint Type**: It ensures that the 'constraint_type' matrix doesn't contain deprecated values (3 or 4).\n    2. **AFSC Quota Constraints**: Verifies the validity of quota constraints, such as minimum and maximum quotas for AFSCs.\n    3. **Objective Targets**: Validates that the 'quota_d' value matches the objective target for Combined Quota.\n    4. **Degree Tiers**: Checks if objectives related to degree tiers have a proper number of eligible cadets.\n    5. **Qualification Levels**: Ensures that qualification levels specified in the 'qual' matrix are coherent with value parameters.\n    6. **Constrained Objectives**: Verifies that constrained objectives have appropriate constraints defined.\n    7. **Value Functions**: Validates value functions, including the format of value function strings and breakpoints.\n    8. **Cadet Preferences**: Ensures that cadet preferences align with preference matrices (c_preferences and c_pref_matrix).\n    9. **Monotonically Decreasing Utility**: Checks that the cadet-reported utility matrix 'utility' is monotonically decreasing.\n    10. **Strictly Decreasing Cadet Utility**: Verifies that the constructed cadet utility matrix 'cadet_utility' is strictly decreasing.\n    11. **Objective Targets Null Values**: Checks for null values in the objective target array.\n    12. **USSF OM Constraint**: Ensures that the USSF OM constraint is not set if no USSF AFSCs are defined.\n    13. **Rated Preferences**: Verifies that rated cadets have at least one rated preference.\n    14. **Total Minimum and Maximum Capacities**: Checks that the total sum of minimum and maximum capacities is feasible.\n\n    This function provides detailed information about issues, if any, found within the problem instance. It is a crucial step\n    in guaranteeing the reliability and accuracy of the optimization process.\n    \"\"\"\n\n    # Shorthand\n    p, vp = instance.parameters, instance.value_parameters\n\n    if vp is None:\n        raise ValueError(\"Cannot sanity check parameters without specifying which value_parameters to use.\")\n\n    # Initialization\n    print(\"Sanity checking the instance parameters...\")\n    issue = 0\n\n    # Check constraint type matrix (I discontinued \"3\"s and \"4\"s in favor of just doing \"1\"s and \"2\"s\n    if 3 in vp['constraint_type'] or 4 in vp['constraint_type']:\n        issue += 1\n        print(issue, \"ISSUE: 'constraint_type' matrix contains 3s and/or 4s instead of 1s and 2s. I discontinued the\"\n                     \"use of the former in favor of the latter so please adjust it.\")\n\n    # Loop through each AFSC to check various elements\n    for j, afsc in enumerate(p[\"afscs\"][:p[\"M\"]]):\n\n        if p[\"num_eligible\"][j] &lt; p[\"quota_min\"][j]:\n            issue += 1\n            print(issue, \"ISSUE: AFSC '\" + afsc + \"' quota constraint invalid. \" + str(p[\"quota_min\"][j]) +\n                  \" (min) &gt; \" + str(p[\"num_eligible\"][j]) + \" (number of eligible cadets).\")\n        elif p[\"num_eligible\"][j] == p[\"quota_min\"][j]:\n            issue += 1\n            print(issue, \"WARNING: AFSC '\" + afsc +\n                  \"' has a lower quota that is the same as its number of eligible cadets (\" +\n                  str(p[\"quota_min\"][j]) + \"). All eligible cadets for this AFSC will be assigned to it.\")\n\n        if p[\"quota_min\"][j] &gt; p[\"quota_max\"][j]:\n            issue += 1\n            print(issue, \"ISSUE: AFSC '\" + afsc + \"' quota constraint invalid. \" + str(p[\"quota_min\"][j]) +\n                  \" (min) &gt; \" + str(p[\"quota_max\"][j]) + \" (max).\")\n\n        quota_k = np.where(vp[\"objectives\"] == \"Combined Quota\")[0][0]\n        if p[\"quota_d\"][j] != vp[\"objective_target\"][j, quota_k]:\n            issue += 1\n            print(issue, \"ISSUE: AFSC '\" + afsc + \"' quota desired target of \" + str(p[\"quota_d\"][j]) +\n                  \" from AFSCs Fixed does not match its objective target (\" + str(vp[\"objective_target\"][j, quota_k]) +\n                  \") in the value parameters.\")\n\n        if p[\"quota_d\"][j] &lt; p[\"quota_min\"][j] or p[\"quota_d\"][j] &gt; p[\"quota_max\"][j]:\n            issue += 1\n            print(issue, \"ISSUE: AFSC '\" + afsc + \"' quota desired target of \" + str(p[\"quota_d\"][j]) +\n                  \" is outside the specified range on the number of cadets (\" + str(p[\"quota_min\"][j]) + \", \" +\n                  str(p[\"quota_max\"][j]) + \").\")\n\n        # If we have the AFSC preference lists, we validate certain features\n        if 'a_pref_matrix' in p:\n\n            cfm_list = np.where(p['a_pref_matrix'][:, j])[0]  # Cadets on the AFSC preference list\n\n            # Cadets that are both on the CFM preference list and are eligible for the AFSC (qual matrix)\n            both_lists = np.intersect1d(cfm_list, p['I^E'][j])  # SHOULD contain the same cadets\n            num_cfm, num_qual = len(cfm_list), len(p['I^E'][j])  # SHOULD be the same number of cadets\n\n            # If the numbers aren't equal\n            if len(both_lists) != num_qual:\n                issue += 1\n                cfm_not_qual = [cadet for cadet in cfm_list if cadet not in p['I^E'][j]]\n                qual_not_cfm = [cadet for cadet in p['I^E'][j] if cadet not in cfm_list]\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' CFM preference list ('a_pref_matrix') does not match the qual\"\n                                                      \"matrix. \\nThere are \" + str(num_cfm) +\n                      \" cadets that are on the preference list (non-zero ranks) but there are \"\n                      + str(num_qual) + \" 'eligible' cadets (qual matrix). There are \" + str(len(both_lists)) +\n                      \" cadets in both sets. \\nCFM list but not qual cadets:\", cfm_not_qual,\n                      \"\\nQual but not CFM list cadets:\", qual_not_cfm)\n\n            # Make sure that all eligibility pairs line up\n            if 'c_pref_matrix' in p:\n\n                for i, cadet in enumerate(p['cadets']):\n\n                    on_afsc_list = p['a_pref_matrix'][i, j] &gt; 0\n                    on_cadet_list = p['c_pref_matrix'][i, j] &gt; 0\n\n                    if on_cadet_list and not on_afsc_list:\n                        issue += 1\n                        print(issue, \"ISSUE: AFSC '\" + afsc + \"' is on cadet '\" + str(cadet) + \"' (index=\" +\n                              str(i) + \")'s preference list (c_pref_matrix) but the cadet is not on their preference \"\n                                       \"list (a_pref_matrix).\")\n                    elif on_afsc_list and not on_cadet_list:\n                        issue += 1\n                        print(issue, \"ISSUE: Cadet '\" + str(cadet) + \"' (index=\" + str(i) + \") is on AFSC '\" + afsc +\n                              \"'s preference list (a_pref_matrix) but the AFSC is not on their preference list (c_pref_matrix).\")\n\n        # Validate AFOCD tier objectives\n        for objective in [\"Mandatory\", \"Desired\", \"Permitted\", \"Tier 1\", \"Tier 2\", \"Tier 3\", \"Tier 4\"]:\n\n            # Make sure this is a valid objective for this problem instance\n            if objective not in vp[\"objectives\"]:\n                continue  # goes to the next objective\n\n            # Get index\n            k = np.where(vp[\"objectives\"] == objective)[0][0]\n\n            # Check if the AFSC is constraining this objective\n            if k not in vp[\"K^C\"][j]:\n                continue\n\n            # Make sure there are cadets that are in this degree tier\n            if len(p[\"I^D\"][objective][j]) == 0:\n                issue += 1\n                if \"Tier\" in objective:\n                    print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                          \"' is empty. No cadets have degrees that fit in this tier for this class year.\")\n                else:\n                    print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                          \"'-Tier is empty. No cadets have degrees that fit in this tier for this class year.\")\n\n            # Make sure objective has valid target\n            if vp[\"objective_target\"][j, k] == 0:\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                      \"'-Tier target cannot be 0 when it has a nonzero weight.\")\n\n        # Validate AFOCD Tier objectives\n        levels = []\n        for t, objective in enumerate([\"Tier 1\", \"Tier 2\", \"Tier 3\", \"Tier 4\"]):\n\n            # Make sure this is a valid objective for this problem instance\n            if objective not in vp[\"objectives\"]:\n                continue  # goes to the next objective\n\n            # Get index\n            k = np.where(vp[\"objectives\"] == objective)[0][0]\n\n            # Make sure that this is a valid tier for this AFSC\n            if k not in vp['K^A'][j]:\n                continue  # goes to the next objective\n\n            level = \"I\" + str(t + 1)\n            requirement_dict = {'t_mandatory': 'M', 't_desired': 'D', 't_permitted': 'P'}\n            for r_level in requirement_dict:\n                if p[r_level][j, t]:\n                    level = requirement_dict[r_level] + str(t + 1)\n            levels.append(level)\n\n            # Make sure this requirement/qualification level is present with the cadets\n            if level not in p['qual'][:, j]:\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                      \"' expected cadet qualification level is '\" + level + \"' but this is not in the qual matrix.\")\n\n        unique_levels = np.unique(p['qual'][:, j])\n        for level in unique_levels:\n            if level not in levels and 'E' not in level and 'I' not in level:\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' qualification level '\" + level +\n                      \"' found within the cadet qual matrix but this is not defined within the value\"\n                      \" parameters.\" )\n\n        # Make sure all constrained objectives have appropriate constraints\n        for k in vp[\"K^C\"][j]:\n            objective = vp[\"objectives\"][k]\n\n            # Check constraint type to see if something doesn't check out\n            if vp[\"constraint_type\"][j, k] == 1:\n\n                # If the minimum is zero, we know this is an \"at MOST\" constraint (0 to 0.3, for example)\n                if vp['objective_min'][j, k] == 0:\n                    issue += 1\n                    print(issue, \"WARNING: AFSC '\" + afsc + \"' objective '\" + objective +\n                          \"' has an 'at most' constraint of '\" + vp['objective_value_min'][j, k] +\n                          \"'. The constraint_type is 1, indicating an approximate constraint but this is not recommended. \"\n                          \"Instead, use the constraint_type '2' to indicate an exact constraint since this is the easiest\"\n                          \" way to meet an 'at most' constraint.\")\n\n            # Make sure constrained objectives have valid constraint types\n            if vp['constraint_type'][j, k] not in [1, 2]:\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                      \"' is in set of constrained objectives: vp['K^C'][j] but has a constraint_type of '\" +\n                      str(vp['constraint_type'][j, k]) + \"'. This is not a valid active constraint.\",\n                      \"Please update the set of value parameters using 'instance.update_value_parameters()'.\")\n\n            # Check valid 'objective_value_min' constraint range\n            try:\n                lb = float(vp[\"objective_value_min\"][j, k].split(\",\")[0])\n                ub = float(vp[\"objective_value_min\"][j, k].split(\",\")[1])\n                assert lb &lt;= ub\n            except:\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                      \"' constraint range (objective_value_min) '\" + vp[\"objective_value_min\"][j, k] +\n                      \"' is invalid. This constraint is currently activated.\")\n\n        # Make sure value functions are valid\n        for k in vp[\"K^A\"][j]:\n            objective = vp[\"objectives\"][k]\n            vf_string_start = vp[\"value_functions\"][j, k].split(\"|\")[0]\n\n            # VF String validation\n            if vf_string_start not in [\"Min Increasing\", \"Min Decreasing\", \"Balance\", \"Quota_Direct\",\n                                       \"Quota_Normal\"]:\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective + \"' value function string '\" +\n                      vp[\"value_functions\"][j, k] + \"' is invalid.\")\n\n            # Validate number of breakpoints\n            if vp[\"r\"][j, k] == 0:\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                      \"' does not have any value function breakpoints. 'a':\", vp[\"a\"][j][k])\n                continue\n\n            # Value function should have same number of x and y coordinates\n            if len(vp[\"a\"][j][k]) != len(vp[\"f^hat\"][j][k]):\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                      \"' value function breakpoint coordinates do not align. 'a' has length of \" + len(vp[\"a\"][j][k]) +\n                      \" while 'f^hat' has length of \" + len(vp[\"f^hat\"][j][k]) + \".\")\n                continue\n\n            # Ensure that the breakpoint \"x\" coordinates are always getting bigger\n            current_x = -1\n            valid_x_bps = True\n            for l in vp[\"L\"][j][k]:\n                if vp[\"a\"][j][k][l] &lt; current_x:\n                    valid_x_bps = False\n                    break\n                else:\n                    current_x = vp[\"a\"][j][k][l]\n\n            if not valid_x_bps:\n                issue += 1\n                print(issue, \"ISSUE: AFSC '\" + afsc + \"' objective '\" + objective +\n                      \"' value function x coordinates do not continuously increase along x-axis. 'a':\", vp[\"a\"][j][k],\n                      \"'vf_string':\", vp[\"value_functions\"][j, k])\n\n        # Check all the objectives to see if the user missed something\n        for k, objective in enumerate(vp['objectives']):\n\n            if vp['constraint_type'][j, k] in [1, 2] and k not in vp['K^C'][j]:\n                issue += 1\n                print(issue, \"WARNING: AFSC '\" + afsc + \"' objective '\" + objective +\n                      \"' has a constraint_type of '\" + str(vp['constraint_type'][j, k]) +\n                      \"' but is not in set of constrained objectives: vp['K^C'][j]. This is a mistake so\",\n                      \"please update the set of value parameters using 'instance.update_value_parameters()'.\")\n\n    # Loop through each cadet to check preferences and utility values\n    invalid_utility, invalid_cadet_utility = 0, 0\n    invalid_utility_cadets, invalid_cadet_utility_cadets = [], []\n    for i in p['I']:\n        if 'c_preferences' in p and 'c_pref_matrix' in p:\n            for choice in range(p['P']):\n                afsc = p['c_preferences'][i, choice]\n                if afsc in p['afscs']:\n                    j = np.where(p['afscs'] == afsc)[0][0]\n                    if p['c_pref_matrix'][i, j] != choice + 1:\n                        issue += 1\n                        print(issue, \"ISSUE: Cadet\", p['cadets'][i], \"has AFSC '\" + afsc + \"' in position '\"\n                              + str(choice + 1) + \"' in the Cadets.csv file, but it is ranked '\" +\n                              str(p['c_pref_matrix'][i, j]) + \"' from the Cadets Preferences.csv file.\")\n                        break  # Don't need to check the rest of the cadet's preferences\n\n            # If this cadet does not have any preferences, we skip them (must be an OTS candidate)\n            if len(p['cadet_preferences'][i]) == 0:\n                issue += 1\n                print(issue, f\"WARNING: Cadet {i} has no preferences and is therefore eligible for nothing.\")\n                continue\n\n            # Make sure \"utility\" array is monotonically decreasing and the \"cadet_utility\" array is strictly decreasing\n            arr_1 = p['utility'][i, p['cadet_preferences'][i]]\n            arr_2 = p['cadet_utility'][i, p['cadet_preferences'][i]]\n            if not all(arr_1[idx] &gt;= arr_1[idx + 1] for idx in range(len(arr_1) - 1)):\n                invalid_utility += 1\n                invalid_utility_cadets.append(i)\n            if not all(arr_2[idx] &gt; arr_2[idx + 1] for idx in range(len(arr_2) - 1)):\n                invalid_cadet_utility += 1\n                invalid_cadet_utility_cadets.append(i)\n\n    # Report issues with decreasing cadet utility values\n    if invalid_utility &gt; 0:\n        issue += 1\n        print(issue, \"ISSUE: The cadet-reported utility matrix 'utility', located in 'Cadets Utility.csv'\\nand in the \"\n                     \"'Util' columns of 'Cadets.csv', does not incorporate monotonically\\ndecreasing utility values for \"\n                     \"\" + str(invalid_utility) + \" cadets. Please adjust.\")\n        if invalid_utility &lt; 100:\n            print('These are the cadets at indices', invalid_utility_cadets)\n    if invalid_cadet_utility &gt; 0 and 'last_afsc' not in p:  # There IS indifference with the new method of utilities\n        issue += 1\n        print(issue, \"ISSUE: The constructed cadet utility matrix 'cadet_utility', located in 'Cadets Utility (Final).\"\n                     \"csv',\\ndoes not incorporate strictly decreasing utility values for \"\n                     \"\" + str(invalid_cadet_utility) + \" cadets. Please adjust.\")\n        if invalid_cadet_utility &lt; 40:\n            print('These are the cadets at indices', invalid_cadet_utility_cadets)\n\n    # Loop through each objective to see if there are any null values in the objective target array\n    for k, objective in enumerate(vp[\"objectives\"]):\n        num_null = pd.isnull(vp[\"objective_target\"][:, k]).sum()\n        if num_null &gt; 0:\n            issue += 1\n            print(issue, \"ISSUE: Objective '\" + objective + \"' contains \" +\n                  str(num_null) + \" null target values ('objective_target').\")\n\n    # USSF OM Constraint rules\n    if instance.mdl_p['USSF OM'] is True and \"USSF\" not in p['afscs_acc_grp']:\n        issue += 1\n        print(issue, \"ISSUE: Space Force OM constraint specified in controls (USSF OM = True) but no USSF\"\n                     \" AFSCS found in the instance.\")\n\n    # At least one rated preference for rated eligible\n    for soc in p['SOCs']:\n        if soc in p['Rated Cadets']:\n            for i in p['Rated Cadets'][soc]:\n                if len(p['Rated Choices'][soc][i]) == 0:\n                    issue += 1\n                    print(issue,\n                          \"ISSUE: Cadet '\" + str(p['cadets'][i]) + \"' is on \" + soc.upper() +\n                          \"'s Rated list (\" + soc.upper() + \" Rated OM.csv) but is not eligible for any Rated AFSCs. \"\n                                                            \"You need to remove their row from the csv.\")\n\n    # Make sure all cadets eligible for at least one rated AFSC are in their SOC's rated OM list\n    for soc in p['SOCs']:\n        if 'J^Rated' in p:  # Make sure we have rated AFSCs\n\n            # Loop through each cadet from this SOC\n            for i in p[soc + '_cadets']:\n\n                # Check if they're eligible for at least one rated AFSC\n                if np.sum(p['eligible'][i][p['J^Rated']]) &gt;= 1:\n\n                    # If they're eligible for a Rated AFSC but aren't in the \"Rated OM.csv\" file, that's a problem\n                    if i not in p['Rated Cadets'][soc]:\n                        rated_afscs_eligible = p['afscs'][np.intersect1d(p['J^Rated'], p['J^E'][i])]\n                        issue += 1\n                        print(issue, \"ISSUE: Cadet '\" + str(p['cadets'][i]) + \"' is not on \" + soc.upper() +\n                              \"'s Rated list (\" + soc.upper() + \" Rated OM.csv), but is on the preference lists for\",\n                              rated_afscs_eligible, \"Please add a row in 'Rated OM.csv' for this cadet reflecting their \"\n                                                    \"OM.\")\n\n    # Validate that the \"totals\" for minimums/maximums work\n    if np.sum(p['pgl']) &gt; p['N']:\n        issue += 1\n        print(issue, \"ISSUE: Total sum of PGL targets is\", int(np.sum(p['pgl'])),\n              \" while 'N' is \" + str(p['N']) + \". This is infeasible since we don't have enough cadets.\")\n    if np.sum(p['quota_min']) &gt; p['N']:\n        issue += 1\n        print(issue, \"ISSUE: Total sum of minimum constrained capacities (quota_min) is\", int(np.sum(p['quota_min'])),\n              \" while 'N' is \" + str(p['N']) + \". This is infeasible since we don't have enough cadets.\")\n    if (np.sum(p['quota_max']) &lt; p['N']) and 'ots' not in p['SOCs']:  # OTS candidates can go unmatched\n        issue += 1\n        print(issue, \"ISSUE: Maximum constrained capacities (quota_max) is\", int(np.sum(p['quota_max'])),\n              \" while 'N' is \" + str(p['N']) + \". This is infeasible; we don't have enough positions for cadets to fill.\")\n\n    # Print statement\n    print('Done,', issue, \"issues found.\")\n</code></pre>"},{"location":"reference/data/custom_ctgan_constraints/","title":"Custom ctgan constraints","text":""},{"location":"reference/data/custom_ctgan_constraints/#data.custom_ctgan_constraints","title":"<code>data.custom_ctgan_constraints</code>","text":""},{"location":"reference/data/custom_ctgan_constraints/#data.custom_ctgan_constraints.is_valid_rotc","title":"<code>is_valid_rotc(column_names, data)</code>","text":"<p>Is valid function used to ensure ROTC cadets don't have USAFA pilot preferences</p> Source code in <code>afccp/data/custom_ctgan_constraints.py</code> <pre><code>def is_valid_rotc(column_names, data):\n    \"\"\"\n    Is valid function used to ensure ROTC cadets don't have USAFA pilot preferences\n    \"\"\"\n    boolean_column = column_names[0]  # \"SOC\"\n    numerical_column = column_names[1]  # \"11XX_U_Cadet\"\n\n    # if the first column is True, the second must be 0\n    true_values = (data[boolean_column] == \"ROTC\") &amp; (data[numerical_column] == 0)\n\n    # if the first is False, then the second can be anything\n    false_values = (data[boolean_column] == \"USAFA\")\n\n    return (true_values) | (false_values)\n</code></pre>"},{"location":"reference/data/custom_ctgan_constraints/#data.custom_ctgan_constraints.is_valid_usafa","title":"<code>is_valid_usafa(column_names, data)</code>","text":"<p>Is valid function used to ensure USAFA cadets don't have ROTC pilot preferences</p> Source code in <code>afccp/data/custom_ctgan_constraints.py</code> <pre><code>def is_valid_usafa(column_names, data):\n    \"\"\"\n    Is valid function used to ensure USAFA cadets don't have ROTC pilot preferences\n    \"\"\"\n    boolean_column = column_names[0]  # \"SOC\"\n    numerical_column = column_names[1]  # \"11XX_R_Cadet\"\n\n    # if the first column is True, the second must be 0\n    true_values = (data[boolean_column] == \"USAFA\") &amp; (data[numerical_column] == 0)\n\n    # if the first is False, then the second can be anything\n    false_values = (data[boolean_column] == \"ROTC\")\n\n    return (true_values) | (false_values)\n</code></pre>"},{"location":"reference/data/generation/","title":"Generation","text":""},{"location":"reference/data/generation/#data.generation","title":"<code>data.generation</code>","text":""},{"location":"reference/data/generation/#data.generation.generate_random_instance","title":"<code>generate_random_instance(N=1600, M=32, P=6, S=6, generate_only_nrl=False, generate_extra=False)</code>","text":"<p>This procedure takes in the specified parameters (defined below) and then simulates new random \"fixed\" cadet/AFSC input parameters. These parameters are then returned and can be used to solve the VFT model.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>number of cadets</p> <code>1600</code> <code>M</code> <p>number of AFSCs</p> <code>32</code> <code>P</code> <p>number of preferences allowed</p> <code>6</code> <code>S</code> <p>number of Bases</p> <code>6</code> <code>generate_only_nrl</code> <p>Only generate NRL AFSCs (default to False)</p> <code>False</code> <code>generate_extra</code> <p>Whether to generate extra components (bases/IST). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>model fixed parameters</p> Source code in <code>afccp/data/generation.py</code> <pre><code>def generate_random_instance(N=1600, M=32, P=6, S=6, generate_only_nrl=False, generate_extra=False):\n    \"\"\"\n    This procedure takes in the specified parameters (defined below) and then simulates new random \"fixed\" cadet/AFSC\n    input parameters. These parameters are then returned and can be used to solve the VFT model.\n    :param N: number of cadets\n    :param M: number of AFSCs\n    :param P: number of preferences allowed\n    :param S: number of Bases\n    :param generate_only_nrl: Only generate NRL AFSCs (default to False)\n    :param generate_extra: Whether to generate extra components (bases/IST). Defaults to False.\n    :return: model fixed parameters\n    \"\"\"\n\n    # Initialize parameter dictionary\n    # noinspection PyDictCreation\n    p = {'N': N, 'P': P, 'M': M, 'num_util': P, 'cadets': np.arange(N),\n         'minority': np.random.choice([0, 1], size=N, p=[1 / 3, 2 / 3]),\n         'male': np.random.choice([0, 1], size=N, p=[1 / 3, 2 / 3]),\n         'usafa': np.random.choice([0, 1], size=N, p=[2 / 3, 1 / 3]), 'merit': np.random.rand(N)}\n\n    # Generate various features of the cadets\n    p['merit_all'] = p['merit']\n    p['assigned'] = np.array(['' for _ in range(N)])\n\n    # Calculate quotas for each AFSC\n    p['pgl'], p['usafa_quota'], p['rotc_quota'] = np.zeros(M), np.zeros(M), np.zeros(M)\n    p['quota_min'], p['quota_max'] = np.zeros(M), np.zeros(M)\n    p['quota_e'], p['quota_d'] = np.zeros(M), np.zeros(M)\n    for j in range(M):\n\n        # Get PGL target\n        p['pgl'][j] = max(10, np.random.normal(1000 / M, 100))\n\n    # Scale PGL and force integer values and minimum of 1\n    p['pgl'] = np.around((p['pgl'] / np.sum(p['pgl'])) * N * 0.8)\n    indices = np.where(p['pgl'] == 0)[0]\n    p['pgl'][indices] = 1\n\n    # Sort PGL by size\n    p['pgl'] = np.sort(p['pgl'])[::-1]\n\n    # USAFA/ROTC Quotas\n    p['usafa_quota'] = np.around(np.random.rand(M) * 0.3 + 0.1 * p['pgl'])\n    p['rotc_quota'] = p['pgl'] - p['usafa_quota']\n\n    # Min/Max\n    p['quota_min'], p['quota_max'] = p['pgl'], np.around(p['pgl'] * (1 + np.random.rand(M) * 0.9))\n\n    # Target is a random integer between the minimum and maximum targets\n    target = np.around(p['quota_min'] + np.random.rand(M) * (p['quota_max'] - p['quota_min']))\n    p['quota_e'], p['quota_d'] = target, target\n\n    # Generate AFSCs\n    p['afscs'] = np.array(['R' + str(j + 1) for j in range(M)])\n\n    # Determine what \"accessions group\" each AFSC is in\n    if generate_only_nrl:\n        p['acc_grp'] = np.array([\"NRL\" for _ in range(M)])\n    else:\n\n        # If there are 3 or more AFSCs, we want all three accessions groups represented\n        if M &gt;= 3:\n            invalid = True\n            while invalid:\n                p['acc_grp'] = np.array([np.random.choice(['NRL', 'Rated', 'USSF']) for _ in range(M)])\n\n                # Make sure we have at least one AFSC from each accession's group\n                invalid = False  # \"Innocent until proven guilty\"\n                for grp in ['NRL', 'Rated', 'USSF']:\n                    if grp not in p['acc_grp']:\n                        invalid = True\n                        break\n\n        # If we only have one or two AFSCs, they'll all be NRL\n        else:\n            p['acc_grp'] = np.array([\"NRL\" for _ in range(M)])\n\n    # Add an \"*\" to the list of AFSCs to be considered the \"Unmatched AFSC\"\n    p[\"afscs\"] = np.hstack((p[\"afscs\"], \"*\"))\n\n    # Add degree tier qualifications to the set of parameters\n    def generate_degree_tier_qualifications():\n        \"\"\"\n        I made this nested function, so I could have a designated section to generate degree qualifications and such\n        \"\"\"\n\n        # Determine degree tiers and qualification information\n        p['qual'] = np.array([['P1' for _ in range(M)] for _ in range(N)])\n        p['Deg Tiers'] = np.array([[' ' * 10 for _ in range(4)] for _ in range(M)])\n        for j in range(M):\n\n            if p['acc_grp'][j] == 'Rated':  # All Degrees eligible for Rated\n                p['qual'][:, j] = np.array(['P1' for _ in range(N)])\n                p['Deg Tiers'][j, :] = ['P = 1', 'I = 0', '', '']\n\n                # Pick 20% of the cadets at random to be ineligible for this Rated AFSC\n                indices = random.sample(list(np.arange(N)), k=int(0.2 * N))\n                p['qual'][indices, j] = 'I2'\n            else:\n                # Determine what tiers to use on this AFSC\n                if N &lt; 100:\n                    random_number = np.random.rand()\n                    if random_number &lt; 0.2:\n                        tiers = ['M1', 'I2']\n                        p['Deg Tiers'][j, :] = ['M = 1', 'I = 0', '', '']\n                    elif 0.2 &lt; random_number &lt; 0.4:\n                        tiers = ['D1', 'P2']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['D &gt; ' + str(target_num), 'P &lt; ' + str(1 - target_num), '', '']\n                    elif 0.4 &lt; random_number &lt; 0.6:\n                        tiers = ['P1']\n                        p['Deg Tiers'][j, :] = ['P = 1', '', '', '']\n                    else:\n                        tiers = ['M1', 'P2']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num), 'P &lt; ' + str(1 - target_num), '', '']\n                else:\n                    random_number = np.random.rand()\n                    if random_number &lt; 0.1:\n                        tiers = ['M1', 'I2']\n                        p['Deg Tiers'][j, :] = ['M = 1', 'I = 0', '', '']\n                    elif 0.1 &lt; random_number &lt; 0.2:\n                        tiers = ['D1', 'P2']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['D &gt; ' + str(target_num), 'P &lt; ' + str(1 - target_num), '', '']\n                    elif 0.2 &lt; random_number &lt; 0.3:\n                        tiers = ['P1']\n                        p['Deg Tiers'][j, :] = ['P = 1', '', '', '']\n                    elif 0.3 &lt; random_number &lt; 0.4:\n                        tiers = ['M1', 'P2']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num), 'P &lt; ' + str(1 - target_num), '', '']\n                    elif 0.4 &lt; random_number &lt; 0.5:\n                        tiers = ['M1', 'D2', 'P3']\n                        target_num_1 = round(np.random.rand() * 0.7, 2)\n                        target_num_2 = round(np.random.rand() * (1 - target_num_1) * 0.8, 2)\n                        target_num_3 = round(1 - target_num_1 - target_num_2, 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num_1), 'D &gt; ' + str(target_num_2),\n                                                'P &lt; ' + str(target_num_3), '']\n                    elif 0.5 &lt; random_number &lt; 0.6:\n                        tiers = ['D1', 'D2', 'P3']\n                        target_num_1 = round(np.random.rand() * 0.7, 2)\n                        target_num_2 = round(np.random.rand() * (1 - target_num_1) * 0.8, 2)\n                        target_num_3 = round(1 - target_num_1 - target_num_2, 2)\n                        p['Deg Tiers'][j, :] = ['D &gt; ' + str(target_num_1), 'D &gt; ' + str(target_num_2),\n                                                'P &lt; ' + str(target_num_3), '']\n                    elif 0.6 &lt; random_number &lt; 0.7:\n                        tiers = ['M1', 'D2', 'I3']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num), 'D &lt; ' + str(1 - target_num), 'I = 0', '']\n                    elif 0.7 &lt; random_number &lt; 0.8:\n                        tiers = ['M1', 'P2', 'I3']\n                        target_num = round(np.random.rand(), 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num), 'P &lt; ' + str(1 - target_num), 'I = 0', '']\n                    else:\n                        tiers = ['M1', 'D2', 'P3', 'I4']\n                        target_num_1 = round(np.random.rand() * 0.7, 2)\n                        target_num_2 = round(np.random.rand() * (1 - target_num_1) * 0.8, 2)\n                        target_num_3 = round(1 - target_num_1 - target_num_2, 2)\n                        p['Deg Tiers'][j, :] = ['M &gt; ' + str(target_num_1), 'D &gt; ' + str(target_num_2),\n                                                'P &lt; ' + str(target_num_3), 'I = 0']\n\n                # Generate the tiers for the cadets\n                c_tiers = np.random.randint(0, len(tiers), N)\n                p['qual'][:, j] = np.array([tiers[c_tiers[i]] for i in range(N)])\n\n        # NxM qual matrices with various features\n        p[\"ineligible\"] = (np.core.defchararray.find(p['qual'], \"I\") != -1) * 1\n        p[\"eligible\"] = (p[\"ineligible\"] == 0) * 1\n        for t in [1, 2, 3, 4]:\n            p[\"tier \" + str(t)] = (np.core.defchararray.find(p['qual'], str(t)) != -1) * 1\n        p[\"mandatory\"] = (np.core.defchararray.find(p['qual'], \"M\") != -1) * 1\n        p[\"desired\"] = (np.core.defchararray.find(p['qual'], \"D\") != -1) * 1\n        p[\"permitted\"] = (np.core.defchararray.find(p['qual'], \"P\") != -1) * 1\n\n        # NEW: Exception to degree qualification based on CFM ranks\n        p[\"exception\"] = (np.core.defchararray.find(p['qual'], \"E\") != -1) * 1\n\n        # Initialize information for AFSC degree tiers\n        p[\"t_count\"] = np.zeros(p['M']).astype(int)\n        p[\"t_proportion\"] = np.zeros([p['M'], 4])\n        p[\"t_leq\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"&lt;\") != -1) * 1\n        p[\"t_geq\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"&gt;\") != -1) * 1\n        p[\"t_eq\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"=\") != -1) * 1\n        p[\"t_mandatory\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"M\") != -1) * 1\n        p[\"t_desired\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"D\") != -1) * 1\n        p[\"t_permitted\"] = (np.core.defchararray.find(p[\"Deg Tiers\"], \"P\") != -1) * 1\n\n        # Loop through each AFSC\n        for j, afsc in enumerate(p[\"afscs\"][:p['M']]):\n\n            # Loop through each potential degree tier\n            for t in range(4):\n                val = p[\"Deg Tiers\"][j, t]\n\n                # Empty degree tier\n                if 'M' not in val and 'D' not in val and 'P' not in val and 'I' not in val:\n                # if val in [\"nan\", \"\", ''] or pd.isnull(val):\n                    t -= 1\n                    break\n\n                # Degree Tier Proportion\n                p[\"t_proportion\"][j, t] = val.split(\" \")[2]\n\n            # Num tiers\n            p[\"t_count\"][j] = t + 1\n\n        return p   # Return updated parameters\n    p = generate_degree_tier_qualifications()\n\n    # Cadet preferences\n    utility = np.random.rand(N, M)  # random utility matrix\n    max_util = np.max(utility, axis=1)\n    p['utility'] = np.around(utility / np.array([[max_util[i]] for i in range(N)]), 2)\n    p['c_preferences'], p['c_utilities'] = afccp.data.preferences.get_utility_preferences(p)\n    p['c_preferences'] = p['c_preferences'][:, :P]\n    p['c_utilities'] = p['c_utilities'][:, :P]\n\n    # Get cadet preferences\n    p[\"c_pref_matrix\"] = np.zeros([p[\"N\"], p[\"M\"]]).astype(int)\n    for i in range(p['N']):\n\n        # Sort the utilities to get the preference list\n        utilities = p[\"utility\"][i, :p[\"M\"]]\n        sorted_indices = np.argsort(utilities)[::-1]\n        preferences = np.argsort(\n            sorted_indices) + 1  # Add 1 to change from python index (at 0) to rank (start at 1)\n        p[\"c_pref_matrix\"][i, :] = preferences\n\n    # If we want to generate extra components to match with, we do so here\n    if generate_extra:\n        p['S'] = S\n        p = generate_extra_components(p)\n\n    # Update set of parameters\n    p = afccp.data.adjustments.parameter_sets_additions(p)\n\n    return p  # Return updated parameters\n</code></pre>"},{"location":"reference/data/generation/#data.generation.generate_random_value_parameters","title":"<code>generate_random_value_parameters(parameters, num_breakpoints=24)</code>","text":"<p>Generates value parameters for a given problem instance from scratch</p> Source code in <code>afccp/data/generation.py</code> <pre><code>def generate_random_value_parameters(parameters, num_breakpoints=24):\n    \"\"\"\n    Generates value parameters for a given problem instance from scratch\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Objective to parameters lookup dictionary (if the parameter is in \"p\", we include the objective)\n    objective_lookups = {'Norm Score': 'a_pref_matrix', 'Merit': 'merit', 'USAFA Proportion': 'usafa',\n                         'Combined Quota': 'quota_d', 'USAFA Quota': 'usafa_quota', 'ROTC Quota': 'rotc_quota',\n                         'Utility': 'utility', 'Male': 'male', 'Minority': 'minority', 'Mandatory': 'mandatory',\n                         'Desired': 'desired', 'Permitted': 'permitted'}\n    for t in [\"1\", \"2\", \"3\", \"4\"]:  # Add in AFOCD Degree tiers\n        objective_lookups[\"Tier \" + t] = \"tier \" + t\n\n    # Add the AFSC objectives that are included in this instance (check corresponding parameters using dict above)\n    objectives = np.array([objective for objective in objective_lookups if objective_lookups[objective] in p])\n\n    # Initialize set of value parameters\n    vp = {'objectives': objectives, 'cadets_overall_weight': np.random.rand(), 'O': len(objectives),\n          'K': np.arange(len(objectives)), 'num_breakpoints': num_breakpoints, 'cadets_overall_value_min': 0,\n          'afscs_overall_value_min': 0}\n    vp['afscs_overall_weight'] = 1- vp['cadets_overall_weight']\n\n    # Generate AFSC and cadet weights\n    weight_functions = ['Linear', 'Direct', 'Curve_1', 'Curve_2', 'Equal']\n    vp['cadet_weight_function'] = np.random.choice(weight_functions)\n    vp['afsc_weight_function'] = np.random.choice(weight_functions)\n    vp['cadet_weight'] = afccp.data.values.cadet_weight_function(p['merit_all'], func= vp['cadet_weight_function'])\n    vp['afsc_weight'] = afccp.data.values.afsc_weight_function(p['pgl'], func = vp['afsc_weight_function'])\n\n    # Stuff that doesn't matter here\n    vp['cadet_value_min'], vp['afsc_value_min'] = np.zeros(p['N']), np.zeros(p['N'])\n    vp['USAFA-Constrained AFSCs'], vp['Cadets Top 3 Constraint'] = '', ''\n    vp['USSF OM'] = False\n\n    # Initialize arrays\n    vp['objective_weight'], vp['objective_target'] = np.zeros([p['M'], vp['O']]), np.zeros([p['M'], vp['O']])\n    vp['constraint_type'] = np.zeros([p['M'], vp['O']])\n    vp['objective_value_min'] = np.array([[' ' * 20 for _ in vp['K']] for _ in p['J']])\n    vp['value_functions'] = np.array([[' ' * 200 for _ in vp['K']] for _ in p['J']])\n\n    # Initialize breakpoints\n    vp['a'] = [[[] for _ in vp['K']] for _ in p[\"J\"]]\n    vp['f^hat'] = [[[] for _ in vp['K']] for _ in p[\"J\"]]\n\n    # Initialize objective set\n    vp['K^A'] = {}\n\n    # Get AFOCD Tier objectives\n    vp = afccp.data.values.generate_afocd_value_parameters(p, vp)\n    vp['constraint_type'] = np.zeros([p['M'], vp['O']])  # Turn off all the constraints again\n\n    # Loop through all AFSCs\n    for j in p['J']:\n\n        # Loop through all AFSC objectives\n        for k, objective in enumerate(vp['objectives']):\n\n            maximum, minimum, actual = None, None, None\n            if objective == 'Norm Score':\n                vp['objective_weight'][j, k] = (np.random.rand() * 0.2 + 0.3) * 100  # Scale up to 100\n                vp['value_functions'][j, k] = 'Min Increasing|0.3'\n                vp['objective_target'][j, k] = 1\n\n            if objective == 'Merit':\n                vp['objective_weight'][j, k] = (np.random.rand() * 0.4 + 0.05) * 100\n                vp['value_functions'][j, k] = 'Min Increasing|-0.3'\n                vp['objective_target'][j, k] = p['sum_merit'] / p['N']\n                actual = np.mean(p['merit'][p['I^E'][j]])\n\n            elif objective == 'USAFA Proportion':\n                vp['objective_weight'][j, k] = (np.random.rand() * 0.3 + 0.05) * 100\n                vp['value_functions'][j, k] = 'Balance|0.15, 0.15, 0.1, 0.08, 0.08, 0.1, 0.6'\n                vp['objective_target'][j, k] = p['usafa_proportion']\n                actual = len(p['I^D'][objective][j]) / len(p['I^E'][j])\n\n            elif objective == 'Combined Quota':\n                vp['objective_weight'][j, k] = (np.random.rand() * 0.8 + 0.2) * 100\n                vp['value_functions'][j, k] = 'Quota_Normal|0.2, 0.25, 0.2'\n                vp['objective_target'][j, k] = p['quota_d'][j]\n\n                # Get bounds and turn on this constraint\n                minimum, maximum = p['quota_min'][j], p['quota_max'][j]\n                vp['objective_value_min'][j, k] = str(int(minimum)) + \", \" + str(int(maximum))\n                vp['constraint_type'][j, k] = 2\n\n            elif objective == 'USAFA Quota':\n                vp['objective_weight'][j, k] = 0\n                vp['value_functions'][j, k] = 'Min Increasing|0.3'\n                vp['objective_target'][j, k] = p['usafa_quota'][j]\n\n                # Bounds on this constraint (but leave it off)\n                vp['objective_value_min'][j, k] = str(int(p['usafa_quota'][j])) + \", \" + \\\n                                                  str(int(p['quota_max'][j]))\n\n            elif objective == 'ROTC Quota':\n                vp['objective_weight'][j, k] = 0\n                vp['value_functions'][j, k] = 'Min Increasing|0.3'\n                vp['objective_target'][j, k] = p['rotc_quota'][j]\n\n                # Bounds on this constraint (but leave it off)\n                vp['objective_value_min'][j, k] = str(int(p['rotc_quota'][j])) + \", \" + \\\n                                                  str(int(p['quota_max'][j]))\n\n            elif objective == 'Male':\n                vp['objective_weight'][j, k] = (np.random.rand() * 0.25) * 100\n                vp['value_functions'][j, k] = 'Balance|0.15, 0.15, 0.1, 0.08, 0.08, 0.1, 0.6'\n                vp['objective_target'][j, k] = p['male_proportion']\n                actual = len(p['I^D'][objective][j]) / len(p['I^E'][j])\n\n            elif objective == 'Minority':\n                vp['objective_weight'][j, k] = (np.random.rand() * 0.25) * 100\n                vp['value_functions'][j, k] = 'Balance|0.15, 0.15, 0.1, 0.08, 0.08, 0.1, 0.6'\n                vp['objective_target'][j, k] = p['minority_proportion']\n                actual = len(p['I^D'][objective][j]) / len(p['I^E'][j])\n\n            # If we care about this objective, we load in its value function breakpoints\n            if vp['objective_weight'][j, k] != 0:\n\n                # Create the non-linear piecewise exponential segment dictionary\n                segment_dict = afccp.data.values.create_segment_dict_from_string(\n                    vp['value_functions'][j, k], vp['objective_target'][j, k],\n                    minimum=minimum, maximum=maximum, actual=actual)\n\n                # Linearize the non-linear function using the specified number of breakpoints\n                vp['a'][j][k], vp['f^hat'][j][k] = afccp.data.values.value_function_builder(\n                    segment_dict, num_breakpoints=num_breakpoints)\n\n        # Scale the objective weights for this AFSC, so they sum to 1\n        vp['objective_weight'][j] = vp['objective_weight'][j] / sum(vp['objective_weight'][j])\n        vp['K^A'][j] = np.where(vp['objective_weight'][j] != 0)[0]\n\n    return vp\n</code></pre>"},{"location":"reference/data/generation/#data.generation.generate_extra_components","title":"<code>generate_extra_components(parameters)</code>","text":"<p>If we generate extra components (such as bases and IST) for the CadetCareerProblem instance</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <p>instance parameters</p> required <p>Returns:</p> Type Description <p>updated parameters</p> Source code in <code>afccp/data/generation.py</code> <pre><code>def generate_extra_components(parameters):\n    \"\"\"\n    If we generate extra components (such as bases and IST) for the CadetCareerProblem instance\n    :param parameters: instance parameters\n    :return: updated parameters\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Get list of ordered letters (based on Excel column names)\n    alphabet = list(string.ascii_uppercase)\n    excel_columns = copy.deepcopy(alphabet)\n    for letter in alphabet:\n        for letter_2 in alphabet:\n            excel_columns.append(letter + letter_2)\n\n    # Determine which AFSCs we assign bases for\n    p['afsc_assign_base'] = np.zeros(p['M']).astype(int)\n    for j in range(p['M']):\n        if p['acc_grp'][j] != \"Rated\" and np.random.rand() &gt; 0.3:\n            p['afsc_assign_base'][j] = 1\n\n    # Name the bases according to the Excel columns (just a method of generating unique ordered letters)\n    p['bases'] = np.array([\"Base \" + excel_columns[b] for b in range(p['S'])])\n\n    # Get capacities for each AFSC at each base\n    p['base_min'] = np.zeros((p['S'], p['M'])).astype(int)\n    p['base_max'] = np.zeros((p['S'], p['M'])).astype(int)\n    afscs_with_base_assignments = np.where(p['afsc_assign_base'])[0]\n    for j in afscs_with_base_assignments:\n        total_max = p['pgl'][j] * 1.5\n        base_max = np.array([np.random.rand() for _ in range(p['S'])])\n        base_max = (base_max / np.sum(base_max)) * total_max\n        p['base_max'][:, j] = base_max.astype(int)\n        p['base_min'][:, j] = (base_max * 0.4).astype(int)\n\n    # Generate random cadet preferences for bases\n    bases = copy.deepcopy(p['bases'])\n    p['base_preferences'] = {}\n    p['b_pref_matrix'] = np.zeros((p['N'], p['S'])).astype(int)\n    p['base_utility'] = np.zeros((p['N'], p['S']))\n    for i in range(p['N']):\n        random.shuffle(bases)\n        num_base_pref = np.random.choice(np.arange(2, p['S'] + 1))\n        p['base_preferences'][i] = np.array([np.where(p['bases'] == base)[0][0] for base in bases[:num_base_pref]])\n\n        # Convert to base preference matrix\n        p['b_pref_matrix'][i, p['base_preferences'][i]] = np.arange(1, len(p['base_preferences'][i]) + 1)\n\n        utilities = np.around(np.random.rand(num_base_pref), 2)\n        p['base_utility'][i, p['base_preferences'][i]] = np.sort(utilities)[::-1]\n        p['base_utility'][i, p['base_preferences'][i][0]] = 1.0  # First choice is always utility of 1!\n\n    # Get the baseline starting date (January 1st of the year we're classifying)\n    next_year = datetime.datetime.now().year + 1\n    p['baseline_date'] = datetime.date(next_year, 1, 1)\n\n    # Generate training preferences for each cadet\n    p['training_preferences'] = np.array(\n        [random.choices(['Early', 'Late'], weights=[0.9, 0.1])[0] for _ in range(p['N'])])\n\n    # Generate base/training \"thresholds\" for when these preferences kick in (based on preferences for AFSCs)\n    p['training_threshold'] = np.array([np.random.choice(np.arange(p['M'] + 1)) for _ in range(p['N'])])\n    p['base_threshold'] = np.array([np.random.choice(np.arange(p['M'] + 1)) for _ in range(p['N'])])\n\n    # Generate weights for AFSCs, bases, and courses\n    p['weight_afsc'], p['weight_base'], p['weight_course'] = np.zeros(p['N']), np.zeros(p['N']), np.zeros(p['N'])\n    for i in range(p['N']):\n\n        # Force some percentage of cadets to make their threshold the last possible AFSC (this means these don't matter)\n        if np.random.rand() &gt; 0.8:\n            p['base_threshold'][i] = p['M']\n        if np.random.rand() &gt; 0.7:\n            p['training_threshold'][i] = p['M']\n\n        # Generate weights for bases, training (courses), and AFSCs\n        if p['base_threshold'][i] == p['M']:\n            w_b = 0\n        else:\n            w_b = np.random.triangular(0, 50, 100)\n        if p['training_threshold'][i] == p['M']:\n            w_c = 0\n        else:\n            w_c = np.random.triangular(0, 20, 100)\n        w_a = np.random.triangular(0, 90, 100)\n\n        # Scale weights so that they sum to one and load into arrays\n        p['weight_afsc'][i] = w_a / (w_a + w_b + w_c)\n        p['weight_base'][i] = w_b / (w_a + w_b + w_c)\n        p['weight_course'][i] = w_c / (w_a + w_b + w_c)\n\n    # Generate training start dates for each cadet\n    p['training_start'] = []\n    for i in range(p['N']):\n\n        # If this cadet is a USAFA cadet\n        if p['usafa'][i]:\n\n            # Make it May 28th of this year\n            p['training_start'].append(datetime.date(next_year, 5, 28))\n\n        # If it's an ROTC cadet, we sample from two different distributions (on-time and late grads)\n        else:\n\n            # 80% should be in spring\n            if np.random.rand() &lt; 0.8:\n                dt = datetime.date(next_year, 4, 15) + datetime.timedelta(int(np.random.triangular(0, 30, 60)))\n                p['training_start'].append(dt)\n\n            # 20% should be after\n            else:\n                dt = datetime.date(next_year, 6, 1) + datetime.timedelta(int(np.random.triangular(0, 30*5, 30*6)))\n                p['training_start'].append(dt)\n    p['training_start'] = np.array(p['training_start'])\n\n    # Generate training courses for each AFSC\n    p['courses'], p['course_start'], p['course_min'], p['course_max'] = {}, {}, {}, {}\n    p['course_count'] = np.zeros(p['M'])\n    for j in range(p['M']):\n\n        # Determine total number of training slots to divide up\n        total_max = p['pgl'][j] * 1.5\n\n        # Determine number of courses to generate\n        if total_max &lt;= 3:\n            T = 1\n        elif total_max &lt;= 10:\n            T = np.random.choice([1, 2])\n        elif total_max &lt; 25:\n            T = np.random.choice([2, 3])\n        elif total_max &lt; 100:\n            T = np.random.choice([3, 4, 5])\n        else:\n            T = np.random.choice([4, 5, 6, 7, 8, 9])\n\n        # Course minimums and maximums\n        random_nums = np.random.rand(T)\n        p['course_max'][j] = np.around(total_max * (random_nums / np.sum(random_nums))).astype(int)\n        p['course_min'][j] = np.zeros(T).astype(int)\n\n        # Generate course specific information\n        p['courses'][j], p['course_start'][j] = [], []\n        current_date = p['baseline_date'] + datetime.timedelta(int(np.random.triangular(30*5, 30*9, 30*11)))\n        for _ in range(T):\n\n            # Course names (random strings of letters)\n            num_letters = random.choice(np.arange(4, 10))\n            p['courses'][j].append(''.join(random.choices(alphabet, k=num_letters)))\n\n            # Course start date\n            p['course_start'][j].append(current_date)\n\n            # Get next course start date\n            current_date += datetime.timedelta(int(np.random.triangular(30, 30*4, 30*6)))\n\n        # Convert to numpy arrays\n        for param in ['courses', 'course_start', 'course_max', 'course_min']:\n            p[param][j] = np.array(p[param][j])\n\n    # Number of training courses per AFSC\n    p['T'] = np.array([len(p['courses'][j]) for j in range(p['M'])])\n\n    # Return updated parameters\n    return p\n</code></pre>"},{"location":"reference/data/generation/#data.generation.safe_round","title":"<code>safe_round(data, decimals=0, axis=-1)</code>","text":"<p>Round <code>data</code> to <code>decimals</code> decimals along <code>axis</code>, preserving the sum of each slice (to <code>decimals</code>), using a \"difference\" style strategy.</p> Source code in <code>afccp/data/generation.py</code> <pre><code>def safe_round(data, decimals=0, axis=-1):\n    \"\"\"\n    Round `data` to `decimals` decimals along `axis`, preserving the sum of each\n    slice (to `decimals`), using a \"difference\" style strategy.\n    \"\"\"\n    data_type = type(data)\n    constructor = {}\n\n    # 1) Scale by 10^decimals\n    scale = 10.0 ** decimals\n    scaled = data * scale\n\n    # 2) Naively round each element to the nearest integer\n    rounded = np.rint(scaled)\n\n    # 3) Compute how many integer \"units\" the sum *should* have in each slice\n    sum_rounded = np.sum(rounded, axis=axis, keepdims=True)\n    sum_desired = np.rint(np.sum(scaled, axis=axis, keepdims=True))\n    difference = sum_desired - sum_rounded\n\n    n = data.shape[axis]\n    leftover_div = np.floor_divide(difference, n)\n    leftover_mod = difference - leftover_div * n\n    rounded += leftover_div\n\n    # 5) Select elements to tweak\n    difference = scaled - rounded\n    leftover_sign = np.sign(leftover_mod)\n    difference_sign = np.sign(difference)\n    candidate_mask = (difference_sign == leftover_sign) &amp; (difference_sign != 0)\n    sort_key = np.where(candidate_mask, -np.abs(difference), np.inf)\n    sorted_idx = np.argsort(sort_key, axis=axis, kind='stable')\n\n    ranks = np.empty_like(sorted_idx)\n    shape_for_r = [1] * data.ndim\n    shape_for_r[axis] = n\n    r_array = np.arange(n, dtype=sorted_idx.dtype).reshape(shape_for_r)\n    np.put_along_axis(ranks, sorted_idx, r_array, axis=axis)\n\n    leftover_mod_int = np.abs(leftover_mod).astype(int)\n    choose_mask = ranks &lt; leftover_mod_int\n    rounded += leftover_sign * choose_mask\n\n    result = rounded / scale\n\n    if data_type is np.ndarray:\n        return result\n\n    return data_type(result.squeeze(), **constructor)\n</code></pre>"},{"location":"reference/data/generation/#data.generation.train_ctgan","title":"<code>train_ctgan(epochs=1000, printing=True, name='CTGAN_24_25')</code>","text":"<p>Train CTGAN to produce realistic data based on the current \"ctgan_data\" file in the support sub-folder. This function then saves the \".pkl\" file back to the support sub-folder</p> Source code in <code>afccp/data/generation.py</code> <pre><code>def train_ctgan(epochs=1000, printing=True, name='CTGAN_24_25'):\n    \"\"\"\n    Train CTGAN to produce realistic data based on the current \"ctgan_data\" file in the support sub-folder. This\n    function then saves the \".pkl\" file back to the support sub-folder\n    \"\"\"\n\n    # Import data\n    data = afccp.globals.import_csv_data(afccp.globals.paths['support'] + 'data/ctgan_data.csv')\n    data = data[[col for col in data.columns if col not in ['YEAR']]]\n    metadata = SingleTableMetadata()  # SDV requires this now\n    metadata.detect_from_dataframe(data=data)  # get the metadata from dataframe\n\n    # Create the synthesizer model\n    model = CTGANSynthesizer(metadata, epochs=epochs, verbose=True)\n\n    # List of constraints for CTGAN\n    constraints = []\n\n    # Get list of columns that must be between 0 and 1\n    zero_to_one_columns = [\"Merit\"]\n    for col in data.columns:\n        if \"_Cadet\" in col or \"_AFSC\" in col:\n            zero_to_one_columns.append(col)\n\n    # Create the \"zero to one\" constraints and add them to our list of constraints\n    for col in zero_to_one_columns:\n        zero_to_one_constraint = {\"constraint_class\": \"ScalarRange\",\n                                  \"constraint_parameters\": {\n                                      'column_name': col,\n                                      'low_value': 0,\n                                      'high_value': 1,\n                                      'strict_boundaries': False\n                                  }}\n        constraints.append(zero_to_one_constraint)\n\n    # Add the constraints to the model\n    model.add_constraints(constraints)\n\n    # Train the model\n    if printing:\n        print(\"Training the model...\")\n    model.fit(data)\n\n    # Save the model\n    filepath = afccp.globals.paths[\"support\"] + name + '.pkl'\n    model.save(filepath)\n    if printing:\n        print(\"Model saved to\", filepath)\n</code></pre>"},{"location":"reference/data/generation/#data.generation.generate_ctgan_instance","title":"<code>generate_ctgan_instance(N=1600, name='CTGAN_24_25', pilot_condition=False, degree_qual_type='Consistent')</code>","text":"<p>This procedure takes in the specified number of cadets and then generates a representative problem instance using CTGAN that has been trained from a real class year of cadets</p> <p>Parameters:</p> Name Type Description Default <code>pilot_condition</code> <p>If we want to sample cadets according to pilot preferences (make this more representative)</p> <code>False</code> <code>name</code> <p>Name of the CTGAN model to import</p> <code>'CTGAN_24_25'</code> <code>N</code> <p>number of cadets</p> <code>1600</code> <p>Returns:</p> Type Description <p>model fixed parameters</p> Source code in <code>afccp/data/generation.py</code> <pre><code>def generate_ctgan_instance(N=1600, name='CTGAN_24_25', pilot_condition=False, degree_qual_type='Consistent'):\n    \"\"\"\n    This procedure takes in the specified number of cadets and then generates a representative problem\n    instance using CTGAN that has been trained from a real class year of cadets\n    :param pilot_condition: If we want to sample cadets according to pilot preferences\n    (make this more representative)\n    :param name: Name of the CTGAN model to import\n    :param N: number of cadets\n    :return: model fixed parameters\n    \"\"\"\n\n    # Load in the model\n    filepath = afccp.globals.paths[\"support\"] + name + '.pkl'\n    model = CTGANSynthesizer.load(filepath)\n\n    # Split up the number of ROTC/USAFA cadets\n    N_usafa = round(np.random.triangular(0.25, 0.33, 0.4) * N)\n    N_rotc = N - N_usafa\n\n    # Pilot is by far the #1 desired career field, let's make sure this is represented here\n    N_usafa_pilots = round(np.random.triangular(0.3, 0.4, 0.43) * N_usafa)\n    N_usafa_generic = N_usafa - N_usafa_pilots\n    N_rotc_pilots = round(np.random.triangular(0.25, 0.3, 0.33) * N_rotc)\n    N_rotc_generic = N_rotc - N_rotc_pilots\n\n    # Condition the data generated to produce the right composition of pilot first choice preferences\n    usafa_pilot_first_choice = Condition(num_rows = N_usafa_pilots, column_values={'SOC': 'USAFA', '11XX_Cadet': 1})\n    usafa_generic_cadets = Condition(num_rows=N_usafa_generic, column_values={'SOC': 'USAFA'})\n    rotc_pilot_first_choice = Condition(num_rows=N_rotc_pilots, column_values={'SOC': 'ROTC', '11XX_Cadet': 1})\n    rotc_generic_cadets = Condition(num_rows=N_rotc_generic, column_values={'SOC': 'ROTC'})\n\n    # Sample data  (Sampling from conditions may take too long!)\n    if pilot_condition:\n        data = model.sample_from_conditions(conditions=[usafa_pilot_first_choice, usafa_generic_cadets,\n                                                        rotc_pilot_first_choice, rotc_generic_cadets])\n    else:\n        data = model.sample(N)\n\n    # Load in AFSCs data\n    filepath = afccp.globals.paths[\"support\"] + 'data/afscs_data.csv'\n    afscs_data = afccp.globals.import_csv_data(filepath)\n\n    # Get list of AFSCs\n    afscs = np.array(afscs_data['AFSC'])\n\n    # Initialize parameter dictionary\n    p = {'afscs': afscs, 'N': N, 'P': len(afscs), 'M': len(afscs), 'merit': np.array(data['Merit']),\n         'cadets': np.arange(N), 'usafa': np.array(data['SOC'] == 'USAFA') * 1,\n         'cip1': np.array(data['CIP1']), 'cip2': np.array(data['CIP2']), 'num_util': 10,  # 10 utilities taken\n         'rotc': np.array(data['SOC'] == 'ROTC'), 'I': np.arange(N), 'J': np.arange(len(afscs))}\n\n    # Clean up degree columns (remove the leading \"c\" I put there if it's there)\n    for i in p['I']:\n        if p['cip1'][i][0] == 'c':\n            p['cip1'][i] = p['cip1'][i][1:]\n        if p['cip2'][i][0] == 'c':\n            p['cip2'][i] = p['cip2'][i][1:]\n\n    # Fix percentiles for USAFA and ROTC\n    re_scaled_om = p['merit']\n    for soc in ['usafa', 'rotc']:\n        indices = np.where(p[soc])[0]  # Indices of these SOC-specific cadets\n        percentiles = p['merit'][indices]  # The percentiles of these cadets\n        N = len(percentiles)  # Number of cadets from this SOC\n        sorted_indices = np.argsort(percentiles)[::-1]  # Sort these percentiles (descending)\n        new_percentiles = (np.arange(N)) / (N - 1)  # New percentiles we want to replace these with\n        magic_indices = np.argsort(sorted_indices)  # Indices that let us put the new percentiles in right place\n        new_percentiles = new_percentiles[magic_indices]  # Put the new percentiles back in the right place\n        np.put(re_scaled_om, indices, new_percentiles)  # Put these new percentiles in combined SOC OM spot\n\n    # Replace merit\n    p['merit'] = re_scaled_om\n\n    # Add AFSC features to parameters\n    p['acc_grp'] = np.array(afscs_data['Accessions Group'])\n    p['Deg Tiers'] = np.array(afscs_data.loc[:, 'Deg Tier 1': 'Deg Tier 4'])\n    p['Deg Tiers'][pd.isnull(p[\"Deg Tiers\"])] = ''  # TODO\n\n    # Determine AFSCs by Accessions Group\n    p['afscs_acc_grp'] = {}\n    if 'acc_grp' in p:\n        for acc_grp in ['Rated', 'USSF', 'NRL']:\n            p['J^' + acc_grp] = np.where(p['acc_grp'] == acc_grp)[0]\n            p['afscs_acc_grp'][acc_grp] = p['afscs'][p['J^' + acc_grp]]\n\n    # Useful data elements to help us generate PGL targets\n    usafa_prop, rotc_prop, pgl_prop = np.array(afscs_data['USAFA Proportion']), \\\n                                      np.array(afscs_data['ROTC Proportion']), \\\n                                      np.array(afscs_data['PGL Proportion'])\n\n    # Total targets needed to distribute\n    total_targets = int(p['N'] * min(0.95, np.random.normal(0.93, 0.08)))\n\n    # PGL targets\n    p['pgl'] = np.zeros(p['M']).astype(int)\n    p['usafa_quota'] = np.zeros(p['M']).astype(int)\n    p['rotc_quota'] = np.zeros(p['M']).astype(int)\n    for j in p['J']:\n\n        # Create the PGL target by sampling from the PGL proportion triangular distribution\n        p_min = max(0, 0.8 * pgl_prop[j])\n        p_max = 1.2 * pgl_prop[j]\n        prop = np.random.triangular(p_min, pgl_prop[j], p_max)\n        p['pgl'][j] = int(max(1, prop * total_targets))\n\n        # Get the ROTC proportion of this PGL target to allocate\n        if rotc_prop[j] in [1, 0]:\n            prop = rotc_prop[j]\n        else:\n            rotc_p_min = max(0, 0.8 * rotc_prop[j])\n            rotc_p_max = min(1, 1.2 * rotc_prop[j])\n            prop = np.random.triangular(rotc_p_min, rotc_prop[j], rotc_p_max)\n\n        # Create the SOC-specific targets\n        p['rotc_quota'][j] = int(prop * p['pgl'][j])\n        p['usafa_quota'][j] = p['pgl'][j] - p['rotc_quota'][j]\n\n    # Initialize the other pieces of information here\n    for param in ['quota_e', 'quota_d', 'quota_min', 'quota_max']:\n        p[param] = p['pgl']\n\n    # Break up USSF and 11XX AFSC by SOC\n    for afsc in ['USSF', '11XX']:\n        for col in ['Cadet', 'AFSC']:\n            for soc in ['USAFA', 'ROTC']:\n                data[f'{afsc}_{soc[0]}_{col}'] = 0\n                data.loc[data['SOC'] == soc, f'{afsc}_{soc[0]}_{col}'] = data.loc[data['SOC'] == soc, f'{afsc}_{col}']\n\n    c_pref_cols = [f'{afsc}_Cadet' for afsc in afscs]\n    util_original = np.around(np.array(data[c_pref_cols]), 2)\n\n    # Initialize cadet preference information\n    p['c_utilities'] = np.zeros((p['N'], 10))\n    p['c_preferences'] = np.array([[' ' * 6 for _ in range(p['M'])] for _ in range(p['N'])])\n    p['cadet_preferences'] = {}\n    p['c_pref_matrix'] = np.zeros((p['N'], p['M'])).astype(int)\n    p['utility'] = np.zeros((p['N'], p['M']))\n\n    # Loop through each cadet to tweak their preferences\n    for i in p['cadets']:\n\n        # Manually fix 62EXE preferencing from eligible cadets\n        ee_j = np.where(afscs == '62EXE')[0][0]\n        if '1410' in data.loc[i, 'CIP1'] or '1447' in data.loc[i, 'CIP1']:\n            if np.random.rand() &gt; 0.6:\n                util_original[i, ee_j] = np.around(max(util_original[i, ee_j], min(1, np.random.normal(0.8, 0.18))),\n                                                   2)\n\n        # Fix rated/USSF volunteer situation\n        for acc_grp in ['Rated', 'USSF']:\n            if data.loc[i, f'{acc_grp} Vol']:\n                if np.max(util_original[i, p[f'J^{acc_grp}']]) &lt; 0.6:\n                    util_original[i, p[f'J^{acc_grp}']] = 0\n                    data.loc[i, f'{acc_grp} Vol'] = False\n            else:  # Not a volunteer\n\n                # We have a higher preference for these kinds of AFSCs\n                if np.max(util_original[i, p[f'J^{acc_grp}']]) &gt;= 0.6:\n                    data.loc[i, f'{acc_grp} Vol'] = True  # Make them a volunteer now\n\n        # Was this the last choice AFSC? Remove from our lists\n        ordered_list = np.argsort(util_original[i])[::-1]\n        last_choice = data.loc[i, 'Last Choice']\n        if last_choice in afscs:\n            j = np.where(afscs == last_choice)[0][0]\n            ordered_list = ordered_list[ordered_list != j]\n\n        # Add the \"2nd least desired AFSC\" to list\n        second_last_choice = data.loc[i, '2nd-Last Choice']\n        bottom = []\n        if second_last_choice in afscs and afsc != last_choice:  # Check if valid and not in bottom choices\n            j = np.where(afscs == second_last_choice)[0][0]  # Get index of AFSC\n            ordered_list = ordered_list[ordered_list != j]  # Remove index from preferences\n            bottom.append(second_last_choice)  # Add it to the list of bottom choices\n\n        # If it's a valid AFSC that isn't already in the bottom choices\n        third_last_choice = data.loc[i, '3rd-Last Choice']  # Add the \"3rd least desired AFSC\" to list\n        if third_last_choice in afscs and afsc not in [last_choice, second_last_choice]:\n            j = np.where(afscs == third_last_choice)[0][0]  # Get index of AFSC\n            ordered_list = ordered_list[\n                ordered_list != j]  # Reordered_list = np.argsort(util_original[i])[::-1]move index from preferences\n            bottom.append(third_last_choice)  # Add it to the list of bottom choices\n\n        # If we have an AFSC in the bottom choices, but NOT the LAST choice, move one to the last choice\n        if len(bottom) &gt; 0 and pd.isnull(last_choice):\n            afsc = bottom.pop(0)\n            data.loc[i, 'Last Choice'] = afsc\n        data.loc[i, 'Second Least Desired AFSCs'] = ', '.join(bottom)  # Put it in the dataframe\n\n        # Save cadet preference information\n        num_pref = 10 if np.random.rand() &gt; 0.1 else int(np.random.triangular(11, 15, 26))\n        p['c_utilities'][i] = util_original[i, ordered_list[:10]]\n        p['cadet_preferences'][i] = ordered_list[:num_pref]\n        p['c_preferences'][i, :num_pref] = afscs[p['cadet_preferences'][i]]\n        p['c_pref_matrix'][i, p['cadet_preferences'][i]] = np.arange(1, len(p['cadet_preferences'][i]) + 1)\n        p['utility'][i, p['cadet_preferences'][i][:10]] = p['c_utilities'][i]\n\n    # Get qual matrix information\n    p['Qual Type'] = degree_qual_type\n    p = afccp.data.adjustments.gather_degree_tier_qual_matrix(cadets_df=None, parameters=p)\n\n    # Get the qual matrix to know what people are eligible for\n    ineligible = (np.core.defchararray.find(p['qual'], \"I\") != -1) * 1\n    eligible = (ineligible == 0) * 1\n    I_E = [np.where(eligible[:, j])[0] for j in p['J']]  # set of cadets that are eligible for AFSC j\n\n    # Modify AFSC utilities based on eligibility\n    a_pref_cols = [f'{afsc}_AFSC' for afsc in afscs]\n    p['afsc_utility'] = np.around(np.array(data[a_pref_cols]), 2)\n    for acc_grp in ['Rated', 'USSF']:\n        for j in p['J^' + acc_grp]:\n            volunteer_col = np.array(data['Rated Vol'])\n            volunteers = np.where(volunteer_col)[0]\n            not_volunteers = np.where(volunteer_col == False)[0]\n            ranked = np.where(p['afsc_utility'][:, j] &gt; 0)[0]\n            unranked = np.where(p['afsc_utility'][:, j] == 0)[0]\n\n            # Fill in utility values with OM for rated folks who don't have an AFSC score\n            volunteer_unranked = np.intersect1d(volunteers, unranked)\n            p['afsc_utility'][volunteer_unranked, j] = p['merit'][volunteer_unranked]\n\n            # If the cadet didn't actually volunteer, they should have utility of 0\n            non_volunteer_ranked = np.intersect1d(not_volunteers, ranked)\n            p['afsc_utility'][non_volunteer_ranked, j] = 0\n\n    # Remove cadets from this AFSC's preferences if the cadet is not eligible\n    for j in p['J^NRL']:\n\n        # Get appropriate sets of cadets\n        eligible_cadets = I_E[j]\n        ineligible_cadets = np.where(ineligible[:, j])[0]\n        ranked_cadets = np.where(p['afsc_utility'][:, j] &gt; 0)[0]\n        unranked_cadets = np.where(p['afsc_utility'][:, j] == 0)[0]\n\n        # Fill in utility values with OM for eligible folks who don't have an AFSC score\n        eligible_unranked = np.intersect1d(eligible_cadets, unranked_cadets)\n        p['afsc_utility'][eligible_unranked, j] = p['merit'][eligible_unranked]\n\n        # If the cadet isn't actually eligible, they should have utility of 0\n        ineligible_ranked = np.intersect1d(ineligible_cadets, ranked_cadets)\n        p['afsc_utility'][ineligible_ranked, j] = 0\n\n    # Collect AFSC preference information\n    p['afsc_preferences'] = {}\n    p['a_pref_matrix'] = np.zeros((p['N'], p['M'])).astype(int)\n    for j in p['J']:\n\n        # Sort the utilities to get the preference list\n        utilities = p[\"afsc_utility\"][:, j]\n        ineligible_indices = np.where(utilities == 0)[0]\n        sorted_indices = np.argsort(utilities)[::-1][:p['N'] - len(ineligible_indices)]\n        p['afsc_preferences'][j] = sorted_indices\n\n        # Since 'afsc_preferences' is an array of AFSC indices, we can do this\n        p['a_pref_matrix'][p['afsc_preferences'][j], j] = np.arange(1, len(p['afsc_preferences'][j]) + 1)\n\n    # Needed information for rated OM matrices\n    dataset_dict = {'rotc': 'rr_om_matrix', 'usafa': 'ur_om_matrix'}\n    cadets_dict = {'rotc': 'rr_om_cadets', 'usafa': 'ur_om_cadets'}\n    p[\"Rated Cadets\"] = {}\n\n    # Create rated OM matrices for each SOC\n    for soc in ['usafa', 'rotc']:\n\n        # Rated AFSCs for this SOC\n        if soc == 'rotc':\n            rated_J_soc = np.array([j for j in p['J^Rated'] if '_U' not in p['afscs'][j]])\n        else:  # usafa\n            rated_J_soc = np.array([j for j in p['J^Rated'] if '_R' not in p['afscs'][j]])\n\n        # Cadets from this SOC\n        soc_cadets = np.where(p[soc])[0]\n\n        # Determine which cadets are eligible for at least one rated AFSC\n        p[\"Rated Cadets\"][soc] = np.array([i for i in soc_cadets if np.sum(p['c_pref_matrix'][i, rated_J_soc]) &gt; 0])\n        p[cadets_dict[soc]] = p[\"Rated Cadets\"][soc]\n\n        # Initialize OM dataset\n        p[dataset_dict[soc]] = np.zeros([len(p[\"Rated Cadets\"][soc]), len(rated_J_soc)])\n\n        # Create OM dataset\n        for col, j in enumerate(rated_J_soc):\n\n            # Get the maximum rank someone had\n            max_rank = np.max(p['a_pref_matrix'][p[\"Rated Cadets\"][soc], j])\n\n            # Loop through each cadet to convert rank to percentile\n            for row, i in enumerate(p[\"Rated Cadets\"][soc]):\n                rank = p['a_pref_matrix'][i, j]\n                if rank == 0:\n                    p[dataset_dict[soc]][row, col] = 0\n                else:\n                    p[dataset_dict[soc]][row, col] = (max_rank - rank + 1) / max_rank\n\n    # Return parameters\n    return p\n</code></pre>"},{"location":"reference/data/preferences/","title":"Preferences","text":""},{"location":"reference/data/preferences/#data.preferences","title":"<code>data.preferences</code>","text":""},{"location":"reference/data/preferences/#data.preferences.get_utility_preferences","title":"<code>get_utility_preferences(parameters)</code>","text":"<p>Converts utility matrix into two arrays of preferences and utilities (NxP for each)</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <p>fixed cadet/afsc data</p> required <p>Returns:</p> Type Description <p>preference matrix and utilities matrix</p> Source code in <code>afccp/data/preferences.py</code> <pre><code>def get_utility_preferences(parameters):\n    \"\"\"\n    Converts utility matrix into two arrays of preferences and utilities (NxP for each)\n    :param parameters: fixed cadet/afsc data\n    :return: preference matrix and utilities matrix\n    \"\"\"\n    preferences = np.array([[\" \" * 10 for _ in range(parameters['P'])] for _ in range(parameters['N'])])\n    utilities_array = np.zeros([parameters['N'], parameters['P']])\n    for i in range(parameters['N']):\n\n        # Sort indices of nonzero utilities\n        indices = parameters['utility'][i, :].nonzero()[0]\n        sorted_init = np.argsort(parameters['utility'][i, :][indices])[::-1]\n        sorted_indices = indices[sorted_init][:parameters['P']]  # Take the top \"P\" preferences (all preferences)\n\n        # Put the utilities and preferences in the correct spots\n        np.put(utilities_array[i, :], np.arange(len(sorted_indices)), parameters['utility'][i, :][sorted_indices])\n        np.put(preferences[i, :], np.arange(len(sorted_indices)), parameters['afscs'][sorted_indices])\n\n    return preferences, utilities_array\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.get_utility_preferences_from_preference_array","title":"<code>get_utility_preferences_from_preference_array(parameters)</code>","text":"<p>Convert cadet preference matrix to preference columns of AFSC names and calculate utility columns.</p> <p>This function takes the cadet preference matrix (NxM) where cadet \"ranks\" are specified and converts it to preference columns (NxP) of AFSC names, where P is the number of AFSC preferences for each cadet. It uses this preference information alongside the utility dataframe (NxP) to extract the utility columns (NxP) as well.</p> <p>Args:     parameters (dict): A dictionary containing the following elements:         - \"c_pref_matrix\" (numpy.ndarray): Cadet preference matrix (NxM) with cadet ranks.         - \"P\" (int): Number of AFSC preferences for each cadet.         - \"N\" (int): Total number of cadets.         - \"I\" (list): List of cadet indices.         - \"M\" (int): Total number of AFSCs.         - \"afscs\" (numpy.ndarray): Array of AFSC names.         - \"num_util\" (int): Number of utility values to extract.         - \"utility\" (numpy.ndarray): Utility dataframe (NxM) containing utility values for cadets and AFSCs.</p> <p>Returns:     tuple: A tuple containing two elements:         - preferences (numpy.ndarray): Cadet preference columns (NxP) with AFSC names.         - utilities_array (numpy.ndarray): Utility columns (NxP) for each cadet and AFSC preference.</p> Source code in <code>afccp/data/preferences.py</code> <pre><code>def get_utility_preferences_from_preference_array(parameters):\n    \"\"\"\n    Convert cadet preference matrix to preference columns of AFSC names and calculate utility columns.\n\n    This function takes the cadet preference matrix (NxM) where cadet \"ranks\" are specified and converts it to\n    preference columns (NxP) of AFSC names, where P is the number of AFSC preferences for each cadet. It uses\n    this preference information alongside the utility dataframe (NxP) to extract the utility columns (NxP) as well.\n\n    Args:\n        parameters (dict): A dictionary containing the following elements:\n            - \"c_pref_matrix\" (numpy.ndarray): Cadet preference matrix (NxM) with cadet ranks.\n            - \"P\" (int): Number of AFSC preferences for each cadet.\n            - \"N\" (int): Total number of cadets.\n            - \"I\" (list): List of cadet indices.\n            - \"M\" (int): Total number of AFSCs.\n            - \"afscs\" (numpy.ndarray): Array of AFSC names.\n            - \"num_util\" (int): Number of utility values to extract.\n            - \"utility\" (numpy.ndarray): Utility dataframe (NxM) containing utility values for cadets and AFSCs.\n\n    Returns:\n        tuple: A tuple containing two elements:\n            - preferences (numpy.ndarray): Cadet preference columns (NxP) with AFSC names.\n            - utilities_array (numpy.ndarray): Utility columns (NxP) for each cadet and AFSC preference.\n\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Initialize data\n    preference_matrix = copy.deepcopy(p[\"c_pref_matrix\"])\n    preferences = np.array([[\" \" * 10 for _ in range(p['P'])] for _ in range(p['N'])])\n    utilities_array = np.zeros([p['N'], p['P']])\n    for i in p['I']:\n\n        # Eliminate AFSCs that weren't in the cadet's preference list (Change the choice to a large #)\n        zero_indices = np.where(preference_matrix[i, :] == 0)[0]\n        preference_matrix[i, zero_indices] = 100\n\n        # Get the ordered list of AFSCs\n        indices = np.argsort(preference_matrix[i, :])  # [::-1]  #.nonzero()[0]\n        ordered_afscs = p[\"afscs\"][indices][:p[\"M\"] - len(zero_indices)][:p[\"P\"]]\n        ordered_utilities = p[\"utility\"][i, indices][:p[\"M\"] - len(zero_indices)][:p[\"num_util\"]]\n\n        # Put the utilities and preferences in the correct spots\n        np.put(utilities_array[i, :], np.arange(len(ordered_utilities)), ordered_utilities)\n        np.put(preferences[i, :], np.arange(len(ordered_afscs)), ordered_afscs)\n\n    return preferences, utilities_array\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.convert_utility_matrices_preferences","title":"<code>convert_utility_matrices_preferences(parameters, cadets_as_well=False)</code>","text":"<p>This function converts the cadet and AFSC utility matrices into the preference dataframes</p> Source code in <code>afccp/data/preferences.py</code> <pre><code>def convert_utility_matrices_preferences(parameters, cadets_as_well=False):\n    \"\"\"\n    This function converts the cadet and AFSC utility matrices into the preference dataframes\n    \"\"\"\n    p = parameters\n\n    # Loop through each AFSC to get their preferences\n    if 'afsc_utility' in p:\n        p[\"a_pref_matrix\"] = np.zeros([p[\"N\"], p[\"M\"]]).astype(int)\n        for j in p[\"J\"]:\n\n            # Sort the utilities to get the preference list\n            utilities = p[\"afsc_utility\"][:, j]\n            sorted_indices = np.argsort(utilities)[::-1]\n            preferences = np.argsort(sorted_indices)\n            p[\"a_pref_matrix\"][:, j] = preferences\n\n    # Loop through each cadet to get their preferences\n    if cadets_as_well:\n        p[\"c_pref_matrix\"] = np.zeros([p[\"N\"], p[\"M\"]]).astype(int)\n        for i in p[\"I\"]:\n\n            # Sort the utilities to get the preference list\n            utilities = p[\"cadet_utility\"][i, :p[\"M\"]]\n            sorted_indices = np.argsort(utilities)[::-1]\n            preferences = np.argsort(\n                sorted_indices) + 1  # Add 1 to change from python index (at 0) to rank (start at 1)\n            p[\"c_pref_matrix\"][i, :] = preferences\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.generate_fake_afsc_preferences","title":"<code>generate_fake_afsc_preferences(parameters, value_parameters=None, fix_cadet_eligibility=False)</code>","text":"<p>This function generates fake AFSC utilities/preferences using AFOCD, merit, cadet preferences etc.</p> <p>Parameters:</p> Name Type Description Default <code>fix_cadet_eligibility</code> <p>if we want to fix the cadet preferences based on eligibility</p> <code>False</code> <code>value_parameters</code> <p>set of cadet/AFSC weight and value parameters</p> <code>None</code> <code>parameters</code> <p>cadet/AFSC fixed data</p> required <p>Returns:</p> Type Description <p>parameters</p> Source code in <code>afccp/data/preferences.py</code> <pre><code>def generate_fake_afsc_preferences(parameters, value_parameters=None, fix_cadet_eligibility=False):\n    \"\"\"\n    This function generates fake AFSC utilities/preferences using AFOCD, merit, cadet preferences etc.\n    :param fix_cadet_eligibility: if we want to fix the cadet preferences based on eligibility\n    :param value_parameters: set of cadet/AFSC weight and value parameters\n    :param parameters: cadet/AFSC fixed data\n    :return: parameters\n    \"\"\"\n    # Shorthand\n    p, vp = parameters, value_parameters\n\n    # Create AFSC Utility Matrix\n    p[\"afsc_utility\"] = np.zeros([p[\"N\"], p[\"M\"]])\n    if vp is None:\n\n        # If we don't have a set of value_parameters, we just make some assumptions\n        weights = {\"Merit\": 80, \"Tier 1\": 100, \"Tier 2\": 50, \"Tier 3\": 30, \"Tier 4\": 0, \"Utility\": 60}\n        for objective in weights:\n            if objective.lower() in p:\n\n                if objective == \"Merit\":\n                    merit = np.tile(p['merit'], [p[\"M\"], 1]).T\n                    p[\"afsc_utility\"] += merit * weights[objective]\n                else:\n                    p[\"afsc_utility\"] += p[objective.lower()][:, :p[\"M\"]] * weights[objective]\n    else:\n\n        # If we do have a set of value_parameters, we incorporate them\n        for objective in ['Merit', 'Tier 1', 'Tier 2', 'Tier 3', 'Tier 4', 'Utility']:\n            if objective in vp['objectives']:\n\n                k = np.where(vp['objectives'] == objective)[0][0]\n                if objective == \"Merit\":\n                    merit = np.tile(p['merit'], [p[\"M\"], 1]).T\n                    p[\"afsc_utility\"] += merit * vp['objective_weight'][:, k].T\n                else:\n                    p[\"afsc_utility\"] += p[objective.lower()][:, :p[\"M\"]] * vp['objective_weight'][:, k].T\n    p[\"afsc_utility\"] *= p[\"eligible\"]  # They have to be eligible!\n\n    if fix_cadet_eligibility:  # We just start over from scratch with cadet preferences\n        p['c_pref_matrix'] = np.zeros([p[\"N\"], p[\"M\"]]).astype(int)\n        p['cadet_preferences'] = {}\n\n        # Add a column to the eligible matrix for the unmatched AFSC (just to get the below multiplication to work)\n        eligible = copy.deepcopy(p['eligible'])\n        eligible = np.hstack((eligible, np.array([[0] for _ in range(p[\"N\"])])))\n        p['cadet_utility'] *= eligible  # They have to be eligible!\n        for i in p[\"I\"]:\n\n            # Sort the utilities to get the preference list\n            utilities = p[\"cadet_utility\"][i, :p[\"M\"]]\n            ineligible_indices = np.where(eligible[i, :p[\"M\"]] == 0)[0]\n            sorted_indices = np.argsort(utilities)[::-1][:p['M'] - len(ineligible_indices)]\n            p['cadet_preferences'][i] = sorted_indices\n\n            # Since 'cadet_preferences' is an array of AFSC indices, we can do this\n            p['c_pref_matrix'][i, p['cadet_preferences'][i]] = np.arange(1, len(p['cadet_preferences'][i]) + 1)\n\n    # Create AFSC Preferences\n    p[\"a_pref_matrix\"] = np.zeros([p[\"N\"], p[\"M\"]]).astype(int)\n    p['afsc_preferences'] = {}\n    for j in p[\"J\"]:\n\n        # Loop through each cadet one more time to fix them on the AFSC list\n        for i in p['I']:\n            if p['c_pref_matrix'][i, j] == 0:\n                p['afsc_utility'][i, j] = 0\n\n        # Sort the utilities to get the preference list\n        utilities = p[\"afsc_utility\"][:, j]\n        ineligible_indices = np.where(utilities == 0)[0]\n        sorted_indices = np.argsort(utilities)[::-1][:p['N'] - len(ineligible_indices)]\n        p['afsc_preferences'][j] = sorted_indices\n\n        # Since 'afsc_preferences' is an array of AFSC indices, we can do this\n        p['a_pref_matrix'][p['afsc_preferences'][j], j] = np.arange(1, len(p['afsc_preferences'][j]) + 1)\n\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.convert_afsc_preferences_to_percentiles","title":"<code>convert_afsc_preferences_to_percentiles(parameters)</code>","text":"<p>This method takes the AFSC preference lists and turns them into normalized percentiles for each cadet for each AFSC.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <p>cadet/AFSC fixed data</p> required <p>Returns:</p> Type Description <p>parameters</p> Source code in <code>afccp/data/preferences.py</code> <pre><code>def convert_afsc_preferences_to_percentiles(parameters):\n    \"\"\"\n    This method takes the AFSC preference lists and turns them into normalized percentiles for each cadet for each\n    AFSC.\n    :param parameters: cadet/AFSC fixed data\n    :return: parameters\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Get normalized percentiles (Average of 0.5)\n    p[\"afsc_utility\"] = np.zeros([p['N'], p['M']])\n    for j in p['J']:\n        p['afsc_utility'][p['afsc_preferences'][j], j] = \\\n            np.arange(1, len(p['afsc_preferences'][j]) + 1)[::-1] / len(p['afsc_preferences'][j])\n\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.generate_rated_data","title":"<code>generate_rated_data(parameters)</code>","text":"<p>This function generates a dataset of ROTC Rated \"interest\" and OM data and also USAFA Rated OM data</p> Source code in <code>afccp/data/preferences.py</code> <pre><code>def generate_rated_data(parameters):\n    \"\"\"\n    This function generates a dataset of ROTC Rated \"interest\" and OM data and also USAFA Rated OM data\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n    if 'usafa' not in p['Rated Cadets']:\n        return p  # No Rated AFSCs to add\n\n    # ROTC Rated Interest Matrix (Only generate random data if we don't already have it)\n    if 'rr_interest_matrix' not in p:\n        p['rr_interest_matrix'] = np.array(\n            [[np.random.choice(['High', 'Med', 'Low', 'None']) for _ in\n              p['afscs_acc_grp']['Rated']] for _ in range(len(p['Rated Cadets']['rotc']))])\n\n    # Loop through each SOC to generate OM data (based on AFSC preferences) if we don't already have it\n    dataset_dict = {soc: f'{soc[0]}r_om_matrix' for soc in p['SOCs']}\n    for soc in dataset_dict:\n        dataset = dataset_dict[soc]  # SOC specific dataset name for Rated OM data\n\n        # Collect useful information on the Rated cadets (for this SOC) and the Rated AFSCs\n        rated_cadets, rated_afscs = p['Rated Cadets'][soc], p['afscs_acc_grp']['Rated']\n        num_rated_cadets, num_rated_afscs = len(rated_cadets), len(rated_afscs)\n        if dataset not in p:  # Only generate data if we don't already have it\n\n            # Loop through each Rated AFSC to construct their OM data\n            p[dataset] = np.zeros([num_rated_cadets, num_rated_afscs])\n            for afsc_index, afsc in enumerate(p['afscs_acc_grp']['Rated']):\n                j = np.where(p['afscs'] == afsc)[0][0]\n\n                # Percentiles sorted from top (1) to bottom (0)\n                rated_afsc_eligible_cadets = np.intersect1d(p['I^E'][j], rated_cadets)\n                percentiles = \\\n                    ((np.arange(len(rated_afsc_eligible_cadets)) + 1) / (len(rated_afsc_eligible_cadets)))[::-1]\n\n                # Loop through each cadet in order of preference and give them the highest percentile based on SOC\n                count = 0\n                for i in p['afsc_preferences'][j]:\n                    if i in rated_afsc_eligible_cadets:\n                        cadet_index = p['Rated Cadet Index Dict'][soc][i]\n                        p[dataset][cadet_index, afsc_index] = percentiles[count]\n                        count += 1\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.construct_rated_preferences_from_om_by_soc","title":"<code>construct_rated_preferences_from_om_by_soc(parameters)</code>","text":"<p>This method takes the two OM Rated matrices (from both SOCs) and then zippers them together to create a combined \"1-N\" list for the Rated AFSCs. The AFSC preference matrix is updated as well as the AFSC preference lists</p> Source code in <code>afccp/data/preferences.py</code> <pre><code>def construct_rated_preferences_from_om_by_soc(parameters):\n    \"\"\"\n    This method takes the two OM Rated matrices (from both SOCs) and then zippers them together to\n    create a combined \"1-N\" list for the Rated AFSCs. The AFSC preference matrix is updated as well as the\n    AFSC preference lists\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Loop through all the parameters we need and make sure we have everything\n    for key in ['rr_om_matrix', 'ur_om_matrix', 'afsc_preferences', 'a_pref_matrix']:\n        if key not in p:\n            raise ValueError(\"Error. Parameter '\" + key + \"' not in the parameter dictionary. Please make sure you have\"\n                                                          \"AFSC preferences and Rated preferences from both sources \"\n                                                          \"of commissioning.\")\n\n    # Need to construct a \"combined Rated OM\" matrix with ALL cadets which also contains 0 if the cadet is ineligible\n    all_rated_afscs = p['afscs_acc_grp'][\"Rated\"]\n    dataset_dict = {soc: f'{soc[0]}r_om_matrix' for soc in p['SOCs']}\n    cadets_dict = {soc: f'{soc[0]}r_om_cadets' for soc in p['SOCs']}\n    combined_rated_om = {afsc: np.zeros(p['N']) for afsc in all_rated_afscs}\n\n    # Loop through all sources of commissioning\n    rated_cadets, rated_cadet_index_dict = {}, {}\n    for soc in p['SOCs']:\n\n        # Rated AFSCs for this SOC\n        rated_afscs = determine_soc_rated_afscs(soc, all_rated_afscs)\n\n        # Rated cadets for this SOC\n        rated_cadets[soc] = p[cadets_dict[soc]]\n\n        # Loop through SOC-specific rated AFSCs\n        for afsc_index, afsc in enumerate(rated_afscs):\n\n            # Need to re-normalize OM to make it fair across SOCs\n            nonzero_indices_in_soc_dataset = np.where(p[dataset_dict[soc]][:, afsc_index] != 0)[0]\n            num_eligible = len(nonzero_indices_in_soc_dataset)\n            sorted_eligible_indices = np.argsort(p[dataset_dict[soc]][:, afsc_index])[::-1][:num_eligible]\n            ordered_cadets = rated_cadets[soc][sorted_eligible_indices]\n            combined_rated_om[afsc][ordered_cadets] = np.arange(1, num_eligible + 1)[::-1] / (num_eligible + 1)\n\n    # Sort the OM to convert it into a 1-N\n    for afsc in all_rated_afscs:\n        j = np.where(p['afscs'] == afsc)[0][0]\n\n        # Get AFSC preferences (list of cadet indices in order)\n        ineligibles = np.where(combined_rated_om[afsc] == 0)[0]\n        num_ineligible = len(ineligibles)  # Ineligibles are going to be at the bottom of the list (and we remove them)\n        p['afsc_preferences'][j] = np.argsort(combined_rated_om[afsc])[::-1][:p['N'] - num_ineligible]\n\n        # Reset this AFSC's \"preference matrix\" column\n        p['a_pref_matrix'][:, j] = np.zeros(p['N'])\n\n        # Since 'afsc_preferences' is an array of cadet indices, we can do this\n        p['a_pref_matrix'][p['afsc_preferences'][j], j] = np.arange(1, len(p['afsc_preferences'][j]) + 1)\n\n    return p  # Return updated parameters\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.remove_ineligible_cadet_choices","title":"<code>remove_ineligible_cadet_choices(parameters, printing=False)</code>","text":"<p>This function removes ineligible choices from the cadets and from the AFSCs based on the qualification matrix</p> Source code in <code>afccp/data/preferences.py</code> <pre><code>def remove_ineligible_cadet_choices(parameters, printing=False):\n    \"\"\"\n    This function removes ineligible choices from the cadets and from the AFSCs based on the qualification matrix\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # This is my final correction for preferences to make it all match up\n    num_removals = 0\n    lines = []\n    for i in p['I']:\n        for j in p['J']:\n            afsc = p['afscs'][j]  # AFSC name\n\n            # Cadet not eligible based on degree qualification matrix\n            if i not in p['I^E'][j]:\n\n                # AFSC is currently in the cadet's preference list\n                if p['c_pref_matrix'][i, j] != 0:\n                    p['c_pref_matrix'][i, j] = 0\n                    num_removals += 1\n                    lines.append('Edit ' + str(num_removals) + ': Cadet ' + str(i) + ' not eligible for ' + afsc +\n                                 ' based on degree qualification matrix but the AFSC was in the cadet preference list. '\n                                 'c_pref_matrix position (' + str(i) + \", \" + str(j) + ') set to 0.')\n\n                # Cadet is currently in the AFSC's preference list\n                if p['a_pref_matrix'][i, j] != 0:\n                    p['a_pref_matrix'][i, j] = 0\n                    num_removals += 1\n                    lines.append('Edit ' + str(num_removals) + ': Cadet ' + str(i) + ' not eligible for ' + afsc +\n                                 ' based on degree qualification matrix but the cadet was in the AFSC preference list. '\n                                 'a_pref_matrix position (' + str(i) + \", \" + str(j) + ') set to 0.')\n\n            # Cadet is currently eligible based on degree qualification matrix\n            else:\n\n                # If there's already an ineligible tier in this AFSC, we use it in case we need to adjust qual matrix\n                if \"I = 0\" in p['Deg Tiers'][j]:\n                    val = \"I\" + str(p['t_count'][j])\n                else:\n                    val = \"I\" + str(p['t_count'][j] + 1)\n\n                # The cadet is not in the AFSC's preference list\n                if p['a_pref_matrix'][i, j] == 0:\n\n                    # The AFSC is in the cadet's preference list\n                    if p['c_pref_matrix'][i, j] != 0:\n                        p['c_pref_matrix'][i, j] = 0\n                        num_removals += 1\n                        lines.append('Edit ' + str(num_removals) + ': Cadet ' + str(i) + ' eligible for ' + afsc +\n                                     ' based on degree qualification matrix but the cadet was not in the AFSC preference list. '\n                                     'c_pref_matrix position (' + str(i) + \", \" + str(j) +\n                                     ') set to 0 and qual position adjusted to ' + val + \".\")\n\n                    # The AFSC is not in the cadet's preference list\n                    else:\n                        num_removals += 1\n                        lines.append('Edit ' + str(num_removals) + ': Cadet ' + str(i) + ' eligible for ' + afsc +\n                                     ' based on degree qualification matrix but the cadet/afsc pairing was in neither '\n                                     'matrix (a_pref_matrix or c_pref_matrix). Both a_pref_matrix and c_pref_matrix '\n                                     'position (' + str(i) + \", \" + str(j) + ') were already 0 so only qual position was '\n                                                                             'adjusted to ' + val + \".\")\n\n                    # Force ineligibility in the qual matrix as well\n                    p['qual'][i, j] = val\n                    p['eligible'][i, j] = 0\n                    p['ineligible'][i, j] = 0\n\n                # The AFSC is not in the cadet's preference list\n                if p['c_pref_matrix'][i, j] == 0:\n\n                    # The cadet is in the AFSC's preference list\n                    if p['a_pref_matrix'][i, j] != 0:\n                        p['a_pref_matrix'][i, j] = 0\n                        num_removals += 1\n                        lines.append('Edit ' + str(num_removals) + ': Cadet ' + str(i) + ' eligible for ' + afsc +\n                                     ' based on degree qualification matrix but the AFSC was not in the cadet preference list. '\n                                     'a_pref_matrix position (' + str(i) + \", \" + str(j) +\n                                     ') set to 0 and qual position adjusted to ' + val + \".\")\n\n                    # The cadet is not in the AFSC's preference list\n                    else:\n                        num_removals += 1\n                        lines.append('Edit ' + str(num_removals) + ': Cadet ' + str(i) + ' eligible for ' + afsc +\n                                     ' based on degree qualification matrix but the cadet/afsc pairing was in neither '\n                                     'matrix (a_pref_matrix or c_pref_matrix). Both a_pref_matrix and c_pref_matrix '\n                                     'position (' + str(i) + \", \" + str(\n                                         j) + ') were already 0 so only qual position was '\n                                              'adjusted to ' + val + \".\")\n\n                    # Force ineligibility in the qual matrix as well\n                    p['qual'][i, j] = val\n                    p['eligible'][i, j] = 0\n                    p['ineligible'][i, j] = 0\n\n    # Print statement\n    if printing:\n        for line in lines:\n            print(line)\n        print(num_removals, \"total adjustments.\")\n    return p  # Return parameters\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.update_preference_matrices","title":"<code>update_preference_matrices(parameters)</code>","text":"<p>This method takes the preference arrays and re-creates the preference matrices based on the cadets/AFSCs on each list</p> Source code in <code>afccp/data/preferences.py</code> <pre><code>def update_preference_matrices(parameters):\n    \"\"\"\n    This method takes the preference arrays and re-creates the preference\n    matrices based on the cadets/AFSCs on each list\n    \"\"\"\n    # Shorthand\n    p = parameters\n\n    # Update the cadet preference matrix (c_pref_matrix)\n    if 'cadet_preferences' in p:\n\n        # Since 'cadet_preferences' is an array of AFSC indices, we can do this\n        p['c_pref_matrix'] = np.zeros([p['N'], p['M']]).astype(int)\n        for i in p['I']:\n\n            # If this cadet does not have any preferences, we skip them (must be an OTS candidate)\n            if len(p['cadet_preferences'][i]) == 0:\n                continue\n            p['c_pref_matrix'][i, p['cadet_preferences'][i]] = np.arange(1, len(p['cadet_preferences'][i]) + 1)\n\n    # Update the AFSC preference matrix (a_pref_matrix)\n    if 'afsc_preferences' in p:\n\n        # Since 'afsc_preferences' is an array of cadet indices, we can do this\n        p['a_pref_matrix'] = np.zeros([p['N'], p['M']]).astype(int)\n        for j in p['J']:\n            p['a_pref_matrix'][p['afsc_preferences'][j], j] = np.arange(1, len(p['afsc_preferences'][j]) + 1)\n\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.update_cadet_utility_matrices","title":"<code>update_cadet_utility_matrices(parameters)</code>","text":"<p>This method takes in the \"Util_1 -&gt; Util_P\" columns from Cadets.csv and updates the utility matrices accordingly</p> Source code in <code>afccp/data/preferences.py</code> <pre><code>def update_cadet_utility_matrices(parameters):\n    \"\"\"\n    This method takes in the \"Util_1 -&gt; Util_P\" columns from Cadets.csv and updates the utility matrices\n    accordingly\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Simple error checking\n    required_parameters = ['cadet_preferences', 'c_utilities']\n    for param in required_parameters:\n        if param not in p:\n            raise ValueError(\"Error. Parameter '\" + param + \"' not in instance parameters. It is required.\")\n\n    # Initialize matrix (reported cadet utility)\n    p['utility'] = np.zeros((p['N'], p['M'] + 1))  # Additional column for unmatched cadets\n\n    # Loop through each cadet\n    for i in p['I']:\n\n        # If this cadet does not have any preferences, we skip them (must be an OTS candidate)\n        if len(p['cadet_preferences'][i]) == 0:\n            continue\n\n        # List of ordered AFSC indices (by cadet preference) up to the number of utilities\n        afsc_indices = p['cadet_preferences'][i][:p['num_util']]\n\n        # Fill in the reported utilities\n        p['utility'][i, afsc_indices] = p['c_utilities'][i, :len(afsc_indices)]\n\n    # Create the \"cadet_utility\" matrix by re-calculating utility based on ordinal rankings\n    if 'last_afsc' in p:\n        p = create_final_cadet_utility_matrix_from_new_formula(p)\n    else:\n        p = create_new_cadet_utility_matrix(p)\n\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.create_new_cadet_utility_matrix","title":"<code>create_new_cadet_utility_matrix(parameters)</code>","text":"<p>This function creates a new \"cadet_utility\" matrix using normalized preferences and the original \"utility\" matrix.</p> Source code in <code>afccp/data/preferences.py</code> <pre><code>def create_new_cadet_utility_matrix(parameters):\n    \"\"\"\n    This function creates a new \"cadet_utility\" matrix using normalized preferences and\n    the original \"utility\" matrix.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Initialize matrix\n    p['cadet_utility'] = np.zeros([p['N'], p['M'] + 1])  # Additional column for unmatched cadets\n\n    # Loop through each cadet\n    for i in p['I']:\n\n        # 1, 2, 3, 4, ..., N  (Pure rankings)\n        rankings = np.arange(p['num_cadet_choices'][i]) + 1\n\n        # 1, 0.8, 0.6, 0.4, ..., 1 / N  (Scale rankings to range from 1 to 0)\n        normalized_rankings = 1 - (rankings / np.max(rankings)) + (1 / np.max(rankings))\n\n        # 1, 0.75, 0, 0, etc. (From utility matrix)\n        original_utilities = p['utility'][i, p['cadet_preferences'][i]]\n\n        # \"New\" Utilities based on a weighted sum of normalized rankings and original utilities\n        new_utilities = np.around(0.5 * normalized_rankings + 0.5 * original_utilities, 4)\n\n        # Put these new utilities back into the utility matrix in the appropriate spots\n        p['cadet_utility'][i, p['cadet_preferences'][i]] = new_utilities\n\n    # Return parameters\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.create_final_cadet_utility_matrix_from_new_formula","title":"<code>create_final_cadet_utility_matrix_from_new_formula(parameters)</code>","text":"<p>This function creates a new \"cadet_utility\" matrix using normalized preferences and the original \"utility\" matrix and some other stuff.</p> Source code in <code>afccp/data/preferences.py</code> <pre><code>def create_final_cadet_utility_matrix_from_new_formula(parameters):\n    \"\"\"\n    This function creates a new \"cadet_utility\" matrix using normalized preferences and\n    the original \"utility\" matrix and some other stuff.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Initialize matrix (0.1 for everyone by default as indifference)\n    p['cadet_utility'] = np.ones([p['N'], p['M'] + 1]) * 0.1  # Additional column for unmatched cadets\n\n    # Loop through each cadet\n    for i in p['I']:\n\n        # AFSCs the cadet is eligible for and selected (ordered appropriately)\n        intersection = np.intersect1d(p['J^Selected'][i], p['cadet_preferences'][i])\n        intersection = np.array([j for j in p['cadet_preferences'][i] if j in intersection])\n        num_selected = len(intersection)\n\n        # Skip this cadet if they don't have any eligible choices\n        if num_selected == 0:\n            continue\n\n        # 1, 2, 3, 4, ..., N  (Pure rankings)\n        rankings = np.arange(num_selected) + 1\n\n        # 1, 0.8, 0.6, 0.4, ..., 1 / N  (Scale rankings to range from 1 to 0)\n        normalized_rankings = 1 - (rankings / np.max(rankings)) + (1 / np.max(rankings))\n\n        # Create dictionary of normalized ordinal rankings\n        norm_ord_rankings_dict = {j: normalized_rankings[index] for index, j in enumerate(intersection)}\n\n        # Loop through all AFSCs that the cadet is eligible for\n        for j in p['cadet_preferences'][i]:\n\n            # A: AFSC is NOT the LAST choice\n            a = (j != p['J^Last Choice'][i]) * 1\n\n            # B: AFSC is NOT in the bottom 3 choices\n            b = ((j not in p['J^Bottom 2 Choices'][i]) and (j != p['J^Last Choice'][i])) * 1\n\n            # C: AFSC was selected as a preference\n            c = (j in p['J^Selected'][i]) * 1\n\n            # D: AFSC was selected as a preference and has a utility assigned\n            d = (p['utility'][i, j] &gt; 0) * 1\n\n            # X: Normalized ordinal ranking of the AFSC\n            x = norm_ord_rankings_dict[j] if j in norm_ord_rankings_dict else 0\n\n            # Y: Utility value the cadet assigned to the AFSC\n            y = p['utility'][i, j]\n\n            # Execute the formula and load it into the cadet utility matrix\n            p['cadet_utility'][i, j] = 0.05*a + 0.05*b + 0.9*(0.3*c*x + 0.7*d*y)\n\n    # Return parameters\n    return p\n</code></pre>"},{"location":"reference/data/preferences/#data.preferences.fill_remaining_preferences","title":"<code>fill_remaining_preferences(parameters)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>parameters</code> required <p>Returns:</p> Type Description Source code in <code>afccp/data/preferences.py</code> <pre><code>def fill_remaining_preferences(parameters):\n    \"\"\"\n\n    :param parameters:\n    :return:\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Loop through all cadets\n    for i in p['I']:\n\n        # We don't fill in remaining preferences for OTS!\n        if 'I^OTS' in p:\n            if i in p['I^OTS']:\n                continue  # They are ineligible for anything they didn't select\n\n        # Loop through all \"indifferent\" AFSCs that they are eligible for\n        pref_num = len(p['cadet_preferences'][i]) + 1\n        for j in p['J']:\n\n            # The AFSC is not in the cadet's preferences and it's not in the bottom choices\n            if j not in p['cadet_preferences'][i] and \\\n                    j not in p['J^Bottom 2 Choices'][i] and j != p['J^Last Choice'][i]:\n                p['c_pref_matrix'][i, j] = pref_num\n                pref_num += 1\n\n        # Loop through bottom 2 choices\n        for j in p['J^Bottom 2 Choices'][i]:\n            p['c_pref_matrix'][i, j] = pref_num\n            pref_num += 1\n\n        # Set last choice preference if applicable\n        if p['J^Last Choice'][i] != p['M']:\n            p['c_pref_matrix'][i, p['J^Last Choice'][i]] = pref_num\n\n    return p\n</code></pre>"},{"location":"reference/data/processing/","title":"Processing","text":""},{"location":"reference/data/processing/#data.processing","title":"<code>data.processing</code>","text":""},{"location":"reference/data/processing/#data.processing.initialize_file_information","title":"<code>initialize_file_information(data_name: str, data_version: str)</code>","text":"<p>Returns the file paths for importing and exporting the data files for a given data instance.</p> <p>Parameters: data_name (str): The name of the data instance. data_version (str): The version of the data instance.</p> <p>Returns: Tuple[Dict[str, str], Dict[str, str]]: A tuple containing two dictionaries. The first dictionary contains the file paths for importing the necessary data files, and the second dictionary contains the file paths for exporting the data files.</p> <p>The function checks for the existence of the data instance folder in the 'instances' directory. If the folder does not exist, it is created. The function also creates any sub-folders that do not already exist.</p> <p>The file paths are determined by checking the sub-folders for the necessary data files. If the data version is 'Default', the function imports and exports the files from the default sub-folders. If the data version is specified, the function checks if the sub-folder with that version exists. If it does not, the function imports the files from the default sub-folders and exports them to the specified version sub-folder. If the sub-folder with the specified version already exists, the function imports and exports the files from that sub-folder.</p> <p>The function returns two dictionaries containing the file paths for importing and exporting the data files. The keys in the dictionaries are the names of the data files, and the values are the corresponding file paths.</p> Source code in <code>afccp/data/processing.py</code> <pre><code>def initialize_file_information(data_name: str, data_version: str):\n    \"\"\"\n    Returns the file paths for importing and exporting the data files for a given data instance.\n\n    Parameters:\n    data_name (str): The name of the data instance.\n    data_version (str): The version of the data instance.\n\n    Returns:\n    Tuple[Dict[str, str], Dict[str, str]]: A tuple containing two dictionaries. The first dictionary contains\n    the file paths for importing the necessary data files, and the second dictionary contains the file paths\n    for exporting the data files.\n\n    The function checks for the existence of the data instance folder in the 'instances' directory. If the\n    folder does not exist, it is created. The function also creates any sub-folders that do not already exist.\n\n    The file paths are determined by checking the sub-folders for the necessary data files. If the data version\n    is 'Default', the function imports and exports the files from the default sub-folders. If the data version is\n    specified, the function checks if the sub-folder with that version exists. If it does not, the function\n    imports the files from the default sub-folders and exports them to the specified version sub-folder. If the\n    sub-folder with the specified version already exists, the function imports and exports the files from that\n    sub-folder.\n\n    The function returns two dictionaries containing the file paths for importing and exporting the data files.\n    The keys in the dictionaries are the names of the data files, and the values are the corresponding file paths.\n    \"\"\"\n\n    # If we don't already have the instance folder, we make it now\n    instance_path = \"instances/\" + data_name + \"/\"\n    if data_name not in afccp.globals.instances_available:\n        os.mkdir(instance_path)\n    instance_folder = np.array(os.listdir(instance_path))\n\n    # Valid files/folders\n    sub_folders = [\"Original &amp; Supplemental\", \"Combined Data\", \"CFMs\", \"Model Input\", \"Analysis &amp; Results\"]\n    sub_folder_files = {\"Model Input\": [\"Cadets\", \"Cadets Preferences\", \"Cadets Utility\", \"Cadets Utility Constraints\",\n                                        \"Cadets Utility (Final)\", \"AFSCs\", \"AFSCs Preferences\", \"AFSCs Utility\",\n                                        \"Value Parameters\", \"Goal Programming\", \"ROTC Rated Interest\",\n                                        \"ROTC Rated OM\", \"USAFA Rated OM\", \"OTS Rated OM\",\n                                        \"Bases\", \"Bases Preferences\",\n                                        \"Bases Utility\", \"Courses\", \"Cadets Selected\", \"AFSCs Buckets\",\n                                        'Castle Input'],\n                        \"Analysis &amp; Results\": [\"Solutions\", \"Base Solutions\", \"Course Solutions\"]}\n\n    # Loop through each sub-folder in the above list and determine the filepaths for the various files\n    import_filepaths = {}\n    export_filepaths = {}\n    for i, sub_folder in enumerate(sub_folders):\n\n        # Sub-Folder with the number: \"4. Model Input\" for example\n        numbered_sub_folder = str(i + 1) + \". \" + sub_folder\n\n        # All the sub-folders that have this numbered sub-folder\n        if len(instance_folder) != 0:\n            indices = np.flatnonzero(np.core.defchararray.find(instance_folder, numbered_sub_folder) != -1)\n            sub_folder_individuals = instance_folder[indices]\n        else:\n            sub_folder_individuals = []\n\n        # If this is the \"default version\", we already know what the sub-folder has to be\n        if data_version == \"Default\":\n            import_sub_folder = numbered_sub_folder\n            export_sub_folder = numbered_sub_folder\n\n            # If we don't currently have this sub-folder, we make it (New instance file)\n            if numbered_sub_folder not in sub_folder_individuals:\n                os.mkdir(instance_path + numbered_sub_folder + \"/\")\n\n        # If the data version was specified, we have to check if it has the specific folder or not\n        else:\n\n            # If the version folder is not there, we import from the default but will export to the data version folder\n            version_indices = np.flatnonzero(np.core.defchararray.find(sub_folder_individuals, data_version) != -1)\n            if len(version_indices) == 0:\n                import_sub_folder = numbered_sub_folder\n                export_sub_folder = numbered_sub_folder + \" (\" + data_version + \")\"\n\n                # We will only ever export specific version data to these sub-folders\n                if sub_folder in [\"Model Input\", \"Analysis &amp; Results\"]:\n                    os.mkdir(instance_path + export_sub_folder + \"/\")\n\n            # We already have the version folder\n            else:\n                import_sub_folder = sub_folder_individuals[version_indices[0]]\n                export_sub_folder = sub_folder_individuals[version_indices[0]]\n\n        # If this is one of the sub-folders we can import/export to/from\n        if sub_folder in sub_folder_files:\n\n            # Get sub folder paths\n            import_sub_folder_path = instance_path + import_sub_folder + \"/\"\n            export_sub_folder_path = instance_path + export_sub_folder + \"/\"\n\n            # Add generic file-paths for this sub-folder\n            export_filepaths[sub_folder] = export_sub_folder_path\n            import_filepaths[sub_folder] = import_sub_folder_path\n\n            # Loop through each file listed above in the \"sub_folder_files\" for this sub-folder\n            sub_folder_files_available = os.listdir(import_sub_folder_path)\n            for file in sub_folder_files[sub_folder]:\n\n                # Create the name of the file\n                if data_version == \"Default\":\n                    filename = data_name + \" \" + file + \".csv\"\n                else:\n                    filename = data_name + \" \" + file + \" (\" + data_version + \").csv\"\n\n                # Get the path that we would export this file to\n                export_filepaths[file] = export_sub_folder_path + filename\n\n                # If we already have this file in the \"import path\", we add it to that filepath dictionary\n                if filename in sub_folder_files_available:\n                    import_filepaths[file] = import_sub_folder_path + filename\n                elif data_version != \"Default\" and data_name + \" \" + file + \".csv\" in sub_folder_files_available:\n                    import_filepaths[file] = import_sub_folder_path + data_name + \" \" + file + \".csv\"\n\n    # If we don't have one of the Analysis &amp; Results \"sub-sub folders\", we make it\n    for sub_sub_folder in [\"Data Charts\", \"Results Charts\", \"Cadet Board\", 'Value Functions']:\n        if sub_sub_folder not in os.listdir(export_filepaths[\"Analysis &amp; Results\"]):\n            os.mkdir(export_filepaths[\"Analysis &amp; Results\"] + sub_sub_folder + \"/\")\n\n    # Return the information\n    return import_filepaths, export_filepaths\n</code></pre>"},{"location":"reference/data/processing/#data.processing.import_afscs_data","title":"<code>import_afscs_data(import_filepaths: dict, parameters: dict) -&gt; dict</code>","text":"<p>Imports the 'AFSCs' csv file and updates the instance parameters dictionary with the values from the file.</p> <p>Args:     import_filepaths (dict): A dictionary of filepaths containing the location of the 'AFSCs' csv file.     parameters (dict): A dictionary of instance parameters to update.</p> <p>Returns:     dict: The updated instance parameters.</p> Source code in <code>afccp/data/processing.py</code> <pre><code>def import_afscs_data(import_filepaths: dict, parameters: dict) -&gt; dict:\n    \"\"\"\n    Imports the 'AFSCs' csv file and updates the instance parameters dictionary with the values from the file.\n\n    Args:\n        import_filepaths (dict): A dictionary of filepaths containing the location of the 'AFSCs' csv file.\n        parameters (dict): A dictionary of instance parameters to update.\n\n    Returns:\n        dict: The updated instance parameters.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Import 'AFSCs' dataframe\n    afscs_df = afccp.globals.import_csv_data(import_filepaths[\"AFSCs\"])\n\n    # Remove \"nans\"\n    afscs_df = afscs_df.replace('nan', '')\n    afscs_df = afscs_df.fillna('')\n\n    # Initialize dictionary translating 'AFSCs' df columns to their parameter counterparts\n    afsc_columns_to_parameters = {\"AFSC\": \"afscs\", \"Accessions Group\": \"acc_grp\", \"STEM\": 'afscs_stem',\n                                  \"USAFA Target\": \"usafa_quota\",\n                                  \"ROTC Target\": \"rotc_quota\",\n                                  \"OTS Target\": \"ots_quota\",\n                                  \"PGL Target\": \"pgl\", \"Estimated\": \"quota_e\",\n                                  \"Desired\": \"quota_d\", \"Min\": \"quota_min\", \"Max\": \"quota_max\",\n                                  \"Assign Base\": 'afsc_assign_base', 'Num Courses': 'T'}\n\n    # Loop through each column in the 'AFSCs' dataframe to put it into the p dictionary\n    for col in afscs_df.columns:\n\n        # If the column is an instance parameter, we load it in as a numpy array\n        if col in afsc_columns_to_parameters:\n            p_name = afsc_columns_to_parameters[col]\n            p[p_name] = np.array(afscs_df.loc[:, col])\n\n    # Number of AFSCs\n    p[\"M\"] = len(p[\"afscs\"])\n\n    # Add an \"*\" to the list of AFSCs to be considered the \"Unmatched AFSC\"\n    p[\"afscs\"] = np.hstack((p[\"afscs\"], \"*\"))\n\n    # Get the degree tier information from the AFSCs\n    if \"Deg Tier 1\" in afscs_df:\n        p[\"Deg Tiers\"] = np.array(afscs_df.loc[:, \"Deg Tier 1\": \"Deg Tier 4\"]).astype(str)\n\n    # Return parameters dictionary\n    return p\n</code></pre>"},{"location":"reference/data/processing/#data.processing.import_cadets_data","title":"<code>import_cadets_data(import_filepaths, parameters)</code>","text":"<p>Imports data from the \"Cadets\" csv file and updates the instance parameters dictionary with relevant information.</p> <p>Args: import_filepaths (dict): A dictionary with the names and paths of the csv files to import. The \"Cadets\" file should be included. parameters (dict): A dictionary of instance parameters to be updated.</p> <p>Returns: dict: The updated instance parameters dictionary.</p> Source code in <code>afccp/data/processing.py</code> <pre><code>def import_cadets_data(import_filepaths, parameters):\n    \"\"\"\n    Imports data from the \"Cadets\" csv file and updates the instance parameters dictionary with relevant information.\n\n    Args:\n    import_filepaths (dict): A dictionary with the names and paths of the csv files to import. The \"Cadets\" file should be included.\n    parameters (dict): A dictionary of instance parameters to be updated.\n\n    Returns:\n    dict: The updated instance parameters dictionary.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Import 'Cadets' dataframe\n    cadets_df = afccp.globals.import_csv_data(import_filepaths[\"Cadets\"])\n\n    # Initialize dictionary translating 'AFSCs' df columns to their parameter counterparts\n    cadet_columns_to_parameters = {\"Cadet\": \"cadets\", 'Male': 'male', 'Minority': 'minority', 'Race': 'race',\n                                   \"Ethnicity\": \"ethnicity\", 'USAFA': 'usafa', 'SOC': 'soc',\n                                   'ASC1': 'asc1', 'ASC2': 'asc2',\n                                   'CIP1': 'cip1', 'CIP2': 'cip2', 'Merit': 'merit', 'Real Merit': 'merit_all',\n                                   \"Assigned\": \"assigned\", \"STEM\": \"stem\", \"Accessions Group\": \"acc_grp_constraint\",\n                                   \"SF OM\": \"sf_om\", 'Start Date': 'training_start', 'Start Pref': 'training_preferences',\n                                   'Base Threshold': 'base_threshold', 'Course Threshold': 'training_threshold',\n                                   'AFSC Weight': 'weight_afsc', 'Base Weight': 'weight_base',\n                                   'Course Weight': 'weight_course', 'Least Desired AFSC': 'last_afsc',\n                                   'Second Least Desired AFSCs': 'second_to_last_afscs'}\n\n    # Loop through each column in the 'Cadets' dataframe to put it into the p dictionary\n    for col in cadets_df.columns:\n\n        # Weird characters showing up\n        if \"\u00ef\u00bb\u00bf\" in col:\n            col_name = col.replace(\"\u00ef\u00bb\u00bf\", \"\")\n        else:\n            col_name = col\n\n        # If the column is an instance parameter, we load it in as a numpy array\n        if col_name in cadet_columns_to_parameters:\n            p_name = cadet_columns_to_parameters[col_name]\n            p[p_name] = np.array(cadets_df.loc[:, col])\n\n    # Number of Cadets\n    p[\"N\"] = len(p[\"cadets\"])\n\n    # Get qual matrix information\n    p = afccp.data.adjustments.gather_degree_tier_qual_matrix(cadets_df, p)\n\n    # Number of cadet preference choices available and number of utilities available\n    p[\"P\"] = len([col for col in cadets_df.columns if 'Pref_' in col])\n    p[\"num_util\"] = min(10, p[\"P\"])\n    if p[\"P\"] != 0:\n\n        # Get the preferences and utilities columns from the cadets dataframe\n        p[\"c_preferences\"] = np.array(cadets_df.loc[:, \"Pref_1\": \"Pref_\" + str(p['P'])])\n        p[\"c_utilities\"] = np.array(cadets_df.loc[:, \"Util_1\": \"Util_\" + str(p[\"num_util\"])])\n\n    # Determine which SOCs are in this instance\n    if 'soc' in p:\n        unique_socs = np.unique(p['soc'])  # Get unique list of SOCs\n\n        # This just gets the SOCs in the right order\n        soc_options = ['USAFA', 'ROTC', 'OTS']\n        p['SOCs'] = np.array([soc.lower() for soc in soc_options if soc in unique_socs])\n\n        for soc in unique_socs:\n            if soc not in soc_options:\n                raise ValueError(f'SOC {soc} not recognized as valid SOC option! At least one cadet has it.')\n\n    # Return parameters dictionary\n    return p\n</code></pre>"},{"location":"reference/data/processing/#data.processing.import_afsc_cadet_matrices_data","title":"<code>import_afsc_cadet_matrices_data(import_filepaths, parameters)</code>","text":"<p>Imports additional  data (if available) for cadets and AFSCs, and adds the relevant information to the input dictionary of parameters.</p> <p>Parameters: import_filepaths (dict): A dictionary containing the filepaths of the csv files to be imported.     - Required keys: 'Cadets Utility', 'Cadets Preferences', 'AFSCs Utility', 'AFSCs Preferences' (if available) parameters (dict): A dictionary containing the initial input parameters for the model.     - Required keys: 'afscs', 'N', 'M', 'num_util', 'P'</p> <p>Returns: dict: The updated dictionary of parameters.</p> <p>Raises: ValueError: If there is no cadet utility data provided, which is required.</p> <p>Note: The function expects that the 'AFSCs' and 'Cadets' csv files have already been imported.</p> Source code in <code>afccp/data/processing.py</code> <pre><code>def import_afsc_cadet_matrices_data(import_filepaths, parameters):\n    \"\"\"\n    Imports additional  data (if available) for cadets and AFSCs, and adds the relevant information to the\n    input dictionary of parameters.\n\n    Parameters:\n    import_filepaths (dict): A dictionary containing the filepaths of the csv files to be imported.\n        - Required keys: 'Cadets Utility', 'Cadets Preferences', 'AFSCs Utility', 'AFSCs Preferences' (if available)\n    parameters (dict): A dictionary containing the initial input parameters for the model.\n        - Required keys: 'afscs', 'N', 'M', 'num_util', 'P'\n\n    Returns:\n    dict: The updated dictionary of parameters.\n\n    Raises:\n    ValueError: If there is no cadet utility data provided, which is required.\n\n    Note:\n    The function expects that the 'AFSCs' and 'Cadets' csv files have already been imported.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Loop through the potential additional dataframes and import them if we have them\n    datasets = {}\n    for dataset in [\"Cadets Utility\", \"Cadets Preferences\", \"AFSCs Utility\", \"AFSCs Preferences\",\n                    \"ROTC Rated Interest\", \"ROTC Rated OM\", \"USAFA Rated OM\", \"OTS Rated OM\", 'Cadets Utility (Final)',\n                    \"Cadets Selected\", \"AFSCs Buckets\"]:\n\n        # If we have the dataset, import it\n        if dataset in import_filepaths:\n            datasets[dataset] = afccp.globals.import_csv_data(import_filepaths[dataset])\n\n    # First and last AFSC (for collecting matrices from dataframes)\n    afsc_1, afsc_M = p[\"afscs\"][0], p[\"afscs\"][p[\"M\"] - 1]\n\n    # Load in extra dataframes\n    for dataset, param in {'Cadets Selected': 'c_selected_matrix', 'AFSCs Buckets': 'a_bucket_matrix'}.items():\n        if dataset in datasets:\n            p[param] = np.array(datasets[dataset].loc[:, afsc_1: afsc_M])\n\n    # Determine how we incorporate the original cadets' utility matrix\n    if \"Cadets Utility\" in datasets:  # Load in the matrix directly\n        p[\"utility\"] = np.array(datasets[\"Cadets Utility\"].loc[:, afsc_1: afsc_M])\n    elif \"c_utilities\" in p:  # Create the matrix using the columns\n\n        # Create utility matrix (numpy array NxM) from the utility/preference column information\n        p[\"utility\"] = np.zeros([p[\"N\"], p[\"M\"]])\n        for i in range(p[\"N\"]):\n            for util in range(p['num_util']):\n                j = np.where(p[\"c_preferences\"][i, util] == p[\"afscs\"])[0]\n                if len(j) != 0:\n                    p['utility'][i, j[0]] = p[\"c_utilities\"][i, util]\n    else:\n        raise ValueError(\"Error. No cadet utility data provided which is required.\")\n\n    # Cadets \"Real\" Utility (after aggregating it with their ordinal rankings)\n    if 'Cadets Utility (Final)' in datasets:  # Load in the cadet utility matrix\n        p['cadet_utility'] = np.array(datasets[\"Cadets Utility (Final)\"].loc[:, afsc_1: afsc_M])\n\n    # Determine how we incorporate the cadets' preferences dataframe\n    if \"Cadets Preferences\" in datasets:  # Load in the preferences dataframe directly\n        p[\"c_pref_matrix\"] = np.array(datasets[\"Cadets Preferences\"].loc[:, afsc_1: afsc_M])\n    elif \"c_preferences\" in p:  # Create the preferences dataframe using the columns\n\n        # Create cadet preferences dataframe (numpy array NxM) from the preference column information\n        p[\"c_pref_matrix\"] = np.zeros([p[\"N\"], p[\"M\"]]).astype(int)\n        for i in range(p[\"N\"]):\n            for util in range(p['P']):\n                j = np.where(p[\"c_preferences\"][i, util] == p[\"afscs\"])[0]\n                if len(j) != 0:\n                    p['c_pref_matrix'][i, j[0]] = util + 1  # 1 is first choice (NOT 0)\n\n    # AFSC preferences and utilities are not required initial data elements (Depending on how we solve, they may be)\n    if \"AFSCs Utility\" in datasets:  # Load in the AFSC utility matrix\n        p[\"afsc_utility\"] = np.array(datasets[\"AFSCs Utility\"].loc[:, afsc_1: afsc_M])\n    if \"AFSCs Preferences\" in datasets:  # Load in the AFSC preferences dataframe\n        p[\"a_pref_matrix\"] = np.array(datasets[\"AFSCs Preferences\"].loc[:, afsc_1: afsc_M])\n\n    # All USAFA Cadets\n    p['usafa_cadets'] = np.where(p['usafa'])[0]\n\n    # Rated dataframes\n    if \"ROTC Rated Interest\" in datasets:\n        r_afscs = list(datasets['ROTC Rated Interest'].columns[1:])\n        p['rr_interest_matrix'] = np.array(datasets['ROTC Rated Interest'].loc[:, r_afscs[0]:r_afscs[len(r_afscs) - 1]])\n    if \"ROTC Rated OM\" in datasets:\n        r_afscs = list(datasets['ROTC Rated OM'].columns[1:])\n        p['rr_om_matrix'] = np.array(datasets['ROTC Rated OM'].loc[:, r_afscs[0]:r_afscs[len(r_afscs) - 1]])\n        p['rr_om_cadets'] = np.array(datasets['ROTC Rated OM']['Cadet'])\n    if \"USAFA Rated OM\" in datasets:\n        r_afscs = list(datasets['USAFA Rated OM'].columns[1:])\n        p['ur_om_matrix'] = np.array(datasets['USAFA Rated OM'].loc[:, r_afscs[0]:r_afscs[len(r_afscs) - 1]])\n        p['ur_om_cadets'] = np.array(datasets['USAFA Rated OM']['Cadet'])\n    if \"OTS Rated OM\" in datasets:\n        r_afscs = list(datasets['OTS Rated OM'].columns[1:])\n        p['or_om_matrix'] = np.array(datasets['OTS Rated OM'].loc[:, r_afscs[0]:r_afscs[len(r_afscs) - 1]])\n        p['or_om_cadets'] = np.array(datasets['OTS Rated OM']['Cadet'])\n\n    # Return dictionary of parameters\n    return p\n</code></pre>"},{"location":"reference/data/processing/#data.processing.import_value_parameters_data","title":"<code>import_value_parameters_data(import_filepaths, parameters, num_breakpoints=24)</code>","text":"<p>Imports the data pertaining to the value parameters of the model.</p> <p>Args:     import_filepaths (dict): A dictionary of file paths to import.         Required keys: \"Model Input\", \"Value Parameters\".         Optional key: \"Cadets Utility Constraints\".     parameters (dict): A dictionary of parameters for the model.     num_breakpoints (int): The number of breakpoints to use for value functions.</p> <p>Returns:     dict: A dictionary containing the value parameters for the model.</p> <p>Raises:     FileNotFoundError: If a file path in import_filepaths is invalid.</p> <p>The \"value parameters\" refer to the weights, values, and constraints applied to the VFT model that by in large the analyst determines. The function loads the following data:     - A dataframe of cadet utility constraints (if present).     - A dataframe of value parameters that describes sets of weights, values, and constraints for the VFT model.     - A dataframe for each set of value parameters, specifying weights, values, and constraints for the VFT model. The function returns a dictionary of value parameters, containing the following keys:     - 'O': The number of AFSC objectives.     - 'afscs_overall_weight': The weight for the AFSCs component.     - 'cadets_overall_weight': The weight for the cadets component.     - 'cadet_weight_function': The type of function used to calculate cadet weights.     - 'afsc_weight_function': The type of function used to calculate AFSC weights.     - 'cadets_overall_value_min': The minimum value for the cadets component.     - 'afscs_overall_value_min': The minimum value for the AFSCs component.     - 'M': The number of AFSCs.     - 'afsc_value_min': An array of minimum AFSC values.     - 'cadet_value_min': An array of minimum cadet values.     - 'objective_value_min': A 2D array of minimum objective values.     - 'value_functions': A 2D array of value functions for each AFSC objective.     - 'constraint_type': A 2D array specifying the type of constraint for each objective and AFSC.     - 'a': A nested list of breakpoints for each AFSC objective.     - 'objective_target': A 2D array of target values for each objective and AFSC.     - 'f^hat': A nested list of breakpoint values for each objective and AFSC.     - 'objective_weight': A 2D array of weights for each objective and AFSC.     - 'afsc_weight': An array of weights for each AFSC.     - 'objectives': An array of AFSC objectives.     - 'K^A': A dictionary of weights for the cadets component.</p> Source code in <code>afccp/data/processing.py</code> <pre><code>def import_value_parameters_data(import_filepaths, parameters, num_breakpoints=24):\n    \"\"\"\n    Imports the data pertaining to the value parameters of the model.\n\n    Args:\n        import_filepaths (dict): A dictionary of file paths to import.\n            Required keys: \"Model Input\", \"Value Parameters\".\n            Optional key: \"Cadets Utility Constraints\".\n        parameters (dict): A dictionary of parameters for the model.\n        num_breakpoints (int): The number of breakpoints to use for value functions.\n\n    Returns:\n        dict: A dictionary containing the value parameters for the model.\n\n    Raises:\n        FileNotFoundError: If a file path in import_filepaths is invalid.\n\n    The \"value parameters\" refer to the weights, values, and constraints applied to the VFT model that by in large\n    the analyst determines. The function loads the following data:\n        - A dataframe of cadet utility constraints (if present).\n        - A dataframe of value parameters that describes sets of weights, values, and constraints for the VFT model.\n        - A dataframe for each set of value parameters, specifying weights, values, and constraints for the VFT model.\n    The function returns a dictionary of value parameters, containing the following keys:\n        - 'O': The number of AFSC objectives.\n        - 'afscs_overall_weight': The weight for the AFSCs component.\n        - 'cadets_overall_weight': The weight for the cadets component.\n        - 'cadet_weight_function': The type of function used to calculate cadet weights.\n        - 'afsc_weight_function': The type of function used to calculate AFSC weights.\n        - 'cadets_overall_value_min': The minimum value for the cadets component.\n        - 'afscs_overall_value_min': The minimum value for the AFSCs component.\n        - 'M': The number of AFSCs.\n        - 'afsc_value_min': An array of minimum AFSC values.\n        - 'cadet_value_min': An array of minimum cadet values.\n        - 'objective_value_min': A 2D array of minimum objective values.\n        - 'value_functions': A 2D array of value functions for each AFSC objective.\n        - 'constraint_type': A 2D array specifying the type of constraint for each objective and AFSC.\n        - 'a': A nested list of breakpoints for each AFSC objective.\n        - 'objective_target': A 2D array of target values for each objective and AFSC.\n        - 'f^hat': A nested list of breakpoint values for each objective and AFSC.\n        - 'objective_weight': A 2D array of weights for each objective and AFSC.\n        - 'afsc_weight': An array of weights for each AFSC.\n        - 'objectives': An array of AFSC objectives.\n        - 'K^A': A dictionary of weights for the cadets component.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n    afccp_vp = afccp.data.values  # Reduce the module name so it fits on one line\n\n    # Import the cadets utility constraints dataframe if we have it.\n    if \"Cadets Utility Constraints\" in import_filepaths:\n        vp_cadet_df = afccp.globals.import_csv_data(import_filepaths[\"Cadets Utility Constraints\"])\n    else:\n        vp_cadet_df = None\n\n    # Import the \"Value Parameters\" dataframe if we have it. If we don't, the \"vp_dict\" will be \"None\"\n    if \"Value Parameters\" in import_filepaths:\n        overall_vp_df = afccp.globals.import_csv_data(import_filepaths[\"Value Parameters\"])\n    else:\n        return None  # Nothing more we can do now (No \"Value Parameters\" determined yet for this instance)\n\n    # Information about the sets of value parameters listed in the \"Value Parameters\" dataframe\n    vp_names = np.array(overall_vp_df['VP Name'])\n    num_vps = len(vp_names)\n    vp_weights = np.ones(num_vps) * 100  # Initially all weighted at 100%\n    if 'VP Weight' in overall_vp_df:\n        vp_weights = np.array(overall_vp_df['VP Weight'])\n\n    # Determine the filenames for the sets of value parameters (VP, VP_2, etc.)\n    vp_files = {}\n    for file in os.listdir(import_filepaths[\"Model Input\"]):\n        if \".csv\" not in file:\n            continue\n        check_vp = file.split(\" \")[1].replace(\".csv\", \"\")\n        if check_vp in vp_names and \"Utility\" not in file:  # Don't want VP Global Utility included here\n            vp_files[check_vp] = file\n\n    # Loop through each set of value parameters and load it into the dictionary\n    vp_dict = {}\n    for v, vp_name in enumerate(vp_names):\n\n        # Only load in the set of value parameters if we have it\n        if vp_name in vp_files:\n            filepath = import_filepaths[\"Model Input\"] + vp_files[vp_name]\n        else:\n            print(\"WARNING. Value Parameter set '\" + vp_name + \"' listed in the 'Value Parameters' dataframe but does\"\n                                                               \" not have its own dataframe (.csv) in 'Model Inputs'.\")\n            continue  # Skip this set of value parameters\n\n        # Load value parameter set dataframe\n        vp_df = afccp.globals.import_csv_data(filepath)\n        M, O = p['M'], int(len(vp_df) / p['M'])  # Number of AFSCs (M) and number of AFSC objectives (O)\n\n        # Initialize value parameters dictionary\n        value_parameters = {'O': O, \"afscs_overall_weight\": np.array(overall_vp_df['AFSCs Weight'])[v],\n                            \"cadets_overall_weight\": np.array(overall_vp_df['Cadets Weight'])[v],\n                            \"cadet_weight_function\": np.array(overall_vp_df['Cadet Weight Function'])[v],\n                            \"afsc_weight_function\": np.array(overall_vp_df['AFSC Weight Function'])[v],\n                            \"cadets_overall_value_min\": np.array(overall_vp_df['Cadets Min Value'])[v],\n                            \"afscs_overall_value_min\": np.array(overall_vp_df['AFSCs Min Value'])[v], \"M\": M,\n                            \"afsc_value_min\": np.zeros(M), 'cadet_value_min': np.zeros(p['N']),\n                            \"objective_value_min\": np.array([[\" \" * 20 for _ in range(O)] for _ in range(M)]),\n                            \"value_functions\": np.array([[\" \" * 200 for _ in range(O)] for _ in range(M)]),\n                            \"constraint_type\": np.zeros([M, O]), 'a': [[[] for _ in range(O)] for _ in range(M)],\n                            \"objective_target\": np.zeros([M, O]), 'f^hat': [[[] for _ in range(O)] for _ in range(M)],\n                            \"objective_weight\": np.zeros([M, O]), \"afsc_weight\": np.zeros(M),\n                            'objectives': np.array(vp_df.loc[:int(len(vp_df) / M - 1), 'Objective']), \"K^A\": {},\n                            'num_breakpoints': num_breakpoints}\n\n        # If we have constraints specified for cadet utility\n        if vp_cadet_df is not None:\n            value_parameters[\"cadet_value_min\"] = np.array(vp_cadet_df[vp_name]).astype(float)\n\n        # Determine weights on cadets\n        if 'merit_all' in parameters:\n            value_parameters['cadet_weight'] = afccp_vp.cadet_weight_function(\n                parameters['merit_all'], func=value_parameters['cadet_weight_function'])\n        else:\n            value_parameters['cadet_weight'] = afccp_vp.cadet_weight_function(\n                parameters['merit'], func=value_parameters['cadet_weight_function'])\n\n        # Load in value parameter data for each AFSC\n        for j in p[\"J\"]:  # These are Os (Ohs) not 0s (zeros)\n            value_parameters[\"objective_target\"][j, :] = np.array(vp_df.loc[j * O:(j * O + O - 1), 'Objective Target'])\n\n            # Force objective weights to sum to 1. K^A is the set of objectives that have non-zero weights for each AFSC\n            objective_weights = np.array(vp_df.loc[j * O:(j * O + O - 1), 'Objective Weight'])\n            value_parameters[\"objective_weight\"][j, :] = objective_weights / sum(objective_weights)\n            value_parameters['K^A'][j] = np.where(value_parameters['objective_weight'][j, :] &gt; 0)[0].astype(int)\n\n            value_parameters[\"objective_value_min\"][j, :] = np.array(vp_df.loc[j * O:(j * O + O - 1),\n                                                                     'Min Objective Value'])\n            value_parameters[\"constraint_type\"][j, :] = np.array(vp_df.loc[j * O:(j * O + O - 1), 'Constraint Type'])\n            value_parameters[\"value_functions\"][j, :] = np.array(vp_df.loc[j * O:(j * O + O - 1), 'Value Functions'])\n            value_parameters[\"afsc_weight\"][j] = vp_df.loc[j * O, \"AFSC Weight\"]\n            value_parameters[\"afsc_value_min\"][j] = vp_df.loc[j * O, \"Min Value\"]\n            cadets = parameters['I^E'][j]  # Indices of cadets that are eligible for this AFSC\n\n            # Loop through each objective for this AFSC\n            for k, objective in enumerate(value_parameters['objectives']):\n\n                # Refactored column names\n                if 'Function Breakpoints' in vp_df:\n                    measure_col_name = 'Function Breakpoints'\n                    value_col_name = 'Function Breakpoint Values'\n                else:\n                    measure_col_name = 'Function Breakpoint Measures (a)'\n                    value_col_name = 'Function Breakpoint Values (f^hat)'\n\n                # We import the functions directly from the breakpoints\n                if num_breakpoints is None:\n                    a_string = vp_df.loc[j * O + k, measure_col_name]\n                    if type(a_string) == str:\n                        value_parameters['a'][j][k] = [float(x) for x in a_string.split(\",\")]\n                    fhat_string = vp_df.loc[j * O + k, value_col_name]\n                    if type(fhat_string) == str:\n                        value_parameters['f^hat'][j][k] = [float(x) for x in fhat_string.split(\",\")]\n\n                # Recreate the functions from the vf strings\n                else:\n                    vf_string = value_parameters[\"value_functions\"][j, k]\n                    if vf_string != 'None':\n                        if objective == 'Merit':\n                            actual = np.mean(parameters['merit'][cadets])\n                        elif objective == 'USAFA Proportion':\n                            actual = np.mean(parameters['usafa'][cadets])\n                        else:\n                            actual = None\n\n                        # Adjust target information for the \"Combined Quota\" objective\n                        if objective == 'Combined Quota':\n                            minimum, maximum = p['quota_min'][j], p['quota_max'][j]\n                            target = p['quota_d'][j]  # Desired number of cadets\n                        else:\n                            minimum, maximum, target = None, None, value_parameters['objective_target'][j, k]\n\n                        # Construct the value function (get the breakpoint coordinates)\n                        segment_dict = afccp_vp.create_segment_dict_from_string(\n                            vf_string, target, actual=actual, maximum=maximum, minimum=minimum)\n                        value_parameters['a'][j][k], value_parameters['f^hat'][j][k] = afccp_vp.value_function_builder(\n                            segment_dict, num_breakpoints=num_breakpoints)\n\n        # Force AFSC weights to sum to 1\n        value_parameters[\"afsc_weight\"] = value_parameters[\"afsc_weight\"] / sum(value_parameters[\"afsc_weight\"])\n\n        # \"Condense\" the value functions by removing unnecessary zeros\n        value_parameters = afccp_vp.condense_value_functions(p, value_parameters)\n\n        # Add indexed sets and subsets of AFSCs and AFSC objectives\n        value_parameters = afccp_vp.value_parameters_sets_additions(p, value_parameters)\n\n        # Save the value parameters to the dictionary\n        vp_dict[vp_name] = copy.deepcopy(value_parameters)\n        vp_dict[vp_name]['vp_weight'] = vp_weights[v]\n        vp_dict[vp_name]['vp_local_weight'] = vp_weights[v] / sum(vp_weights)\n\n    # Return the dictionary of value parameter sets\n    return vp_dict\n</code></pre>"},{"location":"reference/data/processing/#data.processing.import_solutions_data","title":"<code>import_solutions_data(import_filepaths, parameters)</code>","text":"<p>This function takes in the names of the files (and paths) to import, as well as a dictionary of parameters (p) and then imports the \"Solutions\" dataframe. A dictionary of solutions is then returned.</p> <p>Args:     import_filepaths (dict): A dictionary of file names (and paths) to import.     parameters (dict): A dictionary of parameters needed for the function to run.</p> <p>Returns:     dict: A dictionary of solutions for the given parameters.</p> Source code in <code>afccp/data/processing.py</code> <pre><code>def import_solutions_data(import_filepaths, parameters):\n    \"\"\"\n    This function takes in the names of the files (and paths) to import, as well as a dictionary of parameters (p)\n    and then imports the \"Solutions\" dataframe. A dictionary of solutions is then returned.\n\n    Args:\n        import_filepaths (dict): A dictionary of file names (and paths) to import.\n        parameters (dict): A dictionary of parameters needed for the function to run.\n\n    Returns:\n        dict: A dictionary of solutions for the given parameters.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Import the \"Solutions\" dataframe if we have it. If we don't, the \"solutions_dict\" will be \"None\"\n    if \"Solutions\" in import_filepaths:\n        solutions_df = afccp.globals.import_csv_data(import_filepaths[\"Solutions\"])\n    else:\n        return None  # Nothing more we can do now (No solutions determined yet for this instance)\n\n    # Get list of solution names\n    solution_names = list(solutions_df.keys())[1:]\n\n    # Loop through each solution, convert to a numpy array of AFSC indices, and then add it to the dictionary\n    solutions = {}\n    for solution_name in solution_names:\n\n        # Convert solution of AFSC names to indices and then save it to the dictionary\n        afsc_solution = np.array(solutions_df[solution_name])  # [\"15A\", \"14N\", \"17X\", ...]\n        solution = {'j_array': np.array([np.where(p['afscs'] == afsc)[0][0] for afsc in afsc_solution]), # [3, 2, 5, ...]\n                    'name': solution_name, 'afsc_array': afsc_solution}\n        solutions[solution_name] = copy.deepcopy(solution)\n\n    # If we have this extra component\n    if 'Base Solutions' in import_filepaths:\n        solutions_df = afccp.globals.import_csv_data(import_filepaths['Base Solutions'])\n\n        # Get list of solution names\n        solution_names = list(solutions_df.keys())[1:]\n\n        # Loop through each solution in this dataframe and add the base assignments\n        for solution_name in solution_names:\n            base_solution = np.array(solutions_df[solution_name])\n            solutions[solution_name]['base_array'] = base_solution\n            solutions[solution_name]['b_array'] = np.array(\n                [np.where(p['bases'] == base)[0][0] if base in base_solution else p['S'] for base in base_solution])\n\n    # If we have this extra component\n    if 'Course Solutions' in import_filepaths:\n        solutions_df = afccp.globals.import_csv_data(import_filepaths['Course Solutions'])\n\n        # Get list of solution names\n        solution_names = list(solutions_df.keys())[1:]\n\n        # Loop through each solution in this dataframe and add the course assignments\n        for solution_name in solution_names:\n            course_solution = np.array(solutions_df[solution_name])\n            solutions[solution_name]['course_array'] = course_solution\n            c_array = []\n            for i, course in enumerate(course_solution):\n                found = False\n                for j in range(p['M']):\n                    if course in p['courses'][j]:\n                        c = np.where(p['courses'][j] == course)[0][0]\n                        c_array.append((j, c))\n                        found = True\n                        break\n\n                # This shouldn't happen!\n                if not found:\n                    print(\"Course '\" + str(course) + \"' not valid for cadet\", i)\n                    c_array.append((0, 0))\n            solutions[solution_name]['c_array'] = np.array(c_array)\n\n    # Return the dictionary of solutions\n    return solutions\n</code></pre>"},{"location":"reference/data/processing/#data.processing.import_additional_data","title":"<code>import_additional_data(import_filepaths, parameters)</code>","text":"<p>Imports additional csv files and updates the instance parameters dictionary with the values from the file.     Extra datasets: \"Bases.csv\" Args:     import_filepaths (dict): A dictionary of filepaths containing the location of the additional csv files.     parameters (dict): A dictionary of instance parameters to update.</p> <p>Returns:     dict: The updated instance parameters.</p> Source code in <code>afccp/data/processing.py</code> <pre><code>def import_additional_data(import_filepaths, parameters):\n    \"\"\"\n    Imports additional csv files and updates the instance parameters dictionary with the values from the file.\n        Extra datasets: \"Bases.csv\"\n    Args:\n        import_filepaths (dict): A dictionary of filepaths containing the location of the additional csv files.\n        parameters (dict): A dictionary of instance parameters to update.\n\n    Returns:\n        dict: The updated instance parameters.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Loop through the potential additional dataframes and import them if we have them\n    datasets = {}\n    for dataset in [\"Bases\", \"Bases Preferences\", \"Bases Utility\", \"Courses\", \"Castle Input\"]:\n\n        # If we have the dataset, import it\n        if dataset in import_filepaths:\n            datasets[dataset] = afccp.globals.import_csv_data(import_filepaths[dataset])\n\n    # First and last AFSC (for collecting matrices from dataframes)\n    afsc_1, afsc_M = p[\"afscs\"][0], p[\"afscs\"][p[\"M\"] - 1]\n\n    # Extract data from \"Bases.csv\" if applicable\n    if \"Bases\" in datasets:\n        p['bases'] = np.array(datasets[\"Bases\"][\"Base\"])  # Set of bases (names)\n        p['S'] = len(p['bases'])  # Number of bases (S for \"Station\")\n        p['base_min'] = np.array(datasets['Bases'].loc[:, afsc_1 + \" Min\": afsc_M + \" Min\"])  # Minimum base # by AFSC\n        p['base_max'] = np.array(datasets['Bases'].loc[:, afsc_1 + \" Max\": afsc_M + \" Max\"])  # Maximum base # by AFSC\n\n    # Extract data from \"Base Preferences.csv\" and \"Base Utility.csv\" if applicable\n    for parameter, dataset in {'b_pref_matrix': 'Bases Preferences', 'base_utility': 'Bases Utility'}.items():\n        if dataset in datasets:\n            base_1, base_S = p['bases'][0], p['bases'][p['S'] - 1]\n            p[parameter] = np.array(datasets[dataset].loc[:, base_1: base_S])\n\n    # Extract data from \"Courses.csv\" if applicable\n    if \"Courses\" in datasets:\n\n        # Need a dictionary of indices of courses that apply to each AFSC\n        afscs = np.array(datasets[\"Courses\"][\"AFSC\"])\n        afsc_courses = {j: np.where(afscs == p['afscs'][j])[0] for j in range(p['M'])}\n\n        # Dictionary to translate parameter names to column names\n        column_translation = {\"Course\": 'courses', 'Start Date': 'course_start', 'Min': 'course_min',\n                              'Max': 'course_max'}\n\n        # Get each parameter from the columns of this dataset\n        for col, param in column_translation.items():\n            arr = np.array(datasets['Courses'][col])  # Convert dataframe column to numpy array\n            p[param] = {j: arr[afsc_courses[j]] for j in range(p['M'])}\n\n    # Extract data from \"Castle Input.csv\" if applicable\n    if \"Castle Input\" in datasets:\n\n        # Load in AFSC arrays\n        castle_afscs = np.array(datasets['Castle Input']['CASTLE AFSC'])\n        afpc_afscs = np.array(datasets['Castle Input']['AFPC AFSC'])\n        p['castle_afscs_arr'], p['afpc_afscs_arr'] = castle_afscs, afpc_afscs\n\n        # Create dictionary of CASTLE AFSCs -&gt; AFPC AFSCs (account for groupings)\n        p['castle_afscs'], p['J^CASTLE'] = {}, {}\n        for castle_afsc in np.unique(castle_afscs):\n            indices = np.where(castle_afscs == castle_afsc)[0]\n            p['castle_afscs'][castle_afsc] = afpc_afscs[indices]\n            p['J^CASTLE'][castle_afsc] = np.array([np.where(p['afscs'] == afsc)[0][0] for afsc in afpc_afscs[indices]])\n\n        # Initialize OTS counts and optimal policy dictionary\n        p['ots_counts'], p['optimal_policy'] = {}, {}\n\n        # Load in \"q\" dictionary information if it exists\n        df = datasets['Castle Input']  # Shorthand\n        if 'a' in df.columns:\n            q = {'a': {}, 'f^hat': {}, 'r': {}, 'L': {}}\n            for afsc in np.unique(castle_afscs):\n                row = df.loc[df['CASTLE AFSC'] == afsc].head(1).iloc[0]\n\n                # Add OTS count information and optimal policy information for this AFSC\n                p['ots_counts'][afsc] = row['OTS Count']\n                p['optimal_policy'][afsc] = row['Optimal']\n\n                # Load breakpoint coordinates into q dictionary\n                a_str, f_hat_str = str(row['a']), str(row['f^hat'])\n                q['a'][afsc] = np.array([float(x) for x in a_str.split(\",\")])\n                q['f^hat'][afsc] = np.array([float(x) for x in f_hat_str.split(\",\")])\n\n                # Save additional information to q dictionary\n                q['r'][afsc], q['L'][afsc] = len(q['a'][afsc]), np.arange(len(q['a'][afsc]))\n                p['castle_q'] = q  # Save to parameters dictionary\n\n    # Return parameters dictionary\n    return p\n</code></pre>"},{"location":"reference/data/processing/#data.processing.export_afscs_data","title":"<code>export_afscs_data(instance)</code>","text":"<p>This function takes an Instance object as an argument, which contains the AFSC data to be exported. It creates a dictionary of columns to be included in the \"AFSCs\" csv file by translating AFSC parameters to their corresponding column names in the file. The function then creates a dataframe using these columns and exports it as a csv file to the path specified in the export_paths attribute of the Instance object.</p> <p>Args:     instance (Instance): An Instance object containing the AFSC data to export.</p> <p>Returns:     None</p> Source code in <code>afccp/data/processing.py</code> <pre><code>def export_afscs_data(instance):\n    \"\"\"\n    This function takes an Instance object as an argument, which contains the AFSC data to be exported.\n    It creates a dictionary of columns to be included in the \"AFSCs\" csv file by translating AFSC parameters\n    to their corresponding column names in the file. The function then creates a dataframe using these columns\n    and exports it as a csv file to the path specified in the export_paths attribute of the Instance object.\n\n    Args:\n        instance (Instance): An Instance object containing the AFSC data to export.\n\n    Returns:\n        None\n    \"\"\"\n\n    # Shorthand\n    p = instance.parameters\n\n    # Initialize dictionary translating AFSC parameters to their \"AFSCs\" df column counterparts\n    afsc_parameters_to_columns = {\"afscs\": \"AFSC\", \"acc_grp\": \"Accessions Group\", \"afscs_stem\": \"STEM\",\n                                  \"usafa_quota\": \"USAFA Target\", \"rotc_quota\": \"ROTC Target\", 'ots_quota': 'OTS Target',\n                                  \"pgl\": \"PGL Target\", \"quota_e\": \"Estimated\",\n                                  \"quota_d\": \"Desired\", \"quota_min\": \"Min\", \"quota_max\": \"Max\",\n                                  \"afsc_assign_base\": 'Assign Base', 'T': 'Num Courses',\n                                  'usafa_eligible_count': 'USAFA Eligible', 'rotc_eligible_count': 'ROTC Eligible',\n                                  'ots_eligible_count': \"OTS Eligible\"}\n\n    # Loop through each parameter in the translation dictionary to create dictionary of \"AFSCs\" columns\n    afscs_columns = {}\n    for parameter in afsc_parameters_to_columns:\n\n        # If we have the parameter, create the column\n        if parameter in p:\n            col_name = afsc_parameters_to_columns[parameter]\n            afscs_columns[col_name] = p[parameter][:p[\"M\"]]  # Don't want to include the *!\n\n    # Create the degree tier columns\n    if \"Deg Tiers\" in p:\n        for t in range(4):\n            afscs_columns[\"Deg Tier \" + str(t + 1)] = p[\"Deg Tiers\"][:, t]\n\n    # Degree Tier Counts\n    if \"Tier 1\" in p['I^D']:\n        for t in ['1', '2', '3', '4']:\n            afscs_columns['Deg Tier ' + t + ' Count'] = [len(p['I^D']['Tier ' + t][j]) for j in p['J']]\n\n    # Preference Counts\n    if 'Choice Count' in p:\n        for choice in p['Choice Count']:\n            afscs_columns['Choice ' + str(choice + 1)] = p['Choice Count'][choice]\n\n    # Create dataframe\n    afscs_df = pd.DataFrame(afscs_columns)\n\n    # Export 'AFSCs' dataframe\n    afscs_df.to_csv(instance.export_paths[\"AFSCs\"], index=False)\n</code></pre>"},{"location":"reference/data/processing/#data.processing.export_cadets_data","title":"<code>export_cadets_data(instance)</code>","text":"<p>Export the \"Cadets\" csv by taking in the names of the files (and paths) to export, as well as a dictionary of parameters (p). The function first translates 'AFSCs' df columns to their parameter counterparts and creates the corresponding 'Cadets' dataframe column. If cadet preference/utility columns and qualification matrix exist in the input parameters, they will be added to the 'Cadets' dataframe. Finally, the function exports the 'Cadets' dataframe to a csv file.</p> <p>Args: - instance: an instance of the CadetCareerProblem class</p> <p>Returns: None</p> Source code in <code>afccp/data/processing.py</code> <pre><code>def export_cadets_data(instance):\n    \"\"\"\n    Export the \"Cadets\" csv by taking in the names of the files (and paths) to export, as well as a dictionary of\n    parameters (p). The function first translates 'AFSCs' df columns to their parameter counterparts and creates\n    the corresponding 'Cadets' dataframe column. If cadet preference/utility columns and qualification matrix\n    exist in the input parameters, they will be added to the 'Cadets' dataframe. Finally, the function exports the\n    'Cadets' dataframe to a csv file.\n\n    Args:\n    - instance: an instance of the CadetCareerProblem class\n\n    Returns: None\n    \"\"\"\n\n    # Shorthand\n    p = instance.parameters\n\n    # Initialize dictionary translating 'AFSCs' df columns to their parameter counterparts\n    cadet_parameters_to_columns = {\"cadets\": \"Cadet\", \"assigned\": \"Assigned\", \"acc_grp_constraint\": \"Accessions Group\",\n                                   'training_start': 'Start Date', 'training_preferences': 'Start Pref',\n                                   'base_threshold': 'Base Threshold', 'training_threshold': 'Course Threshold',\n                                   'weight_afsc': 'AFSC Weight', 'weight_base': 'Base Weight',\n                                   'weight_course': 'Course Weight',\n                                   \"sf_om\": \"SF OM\", 'usafa': 'USAFA', 'soc': 'SOC',\n                                   'male': 'Male', 'minority': 'Minority',\n                                   'race': 'Race', \"ethnicity\": \"Ethnicity\", 'asc1': 'ASC1', 'asc2': 'ASC2',\n                                   'stem': 'STEM', 'cip1': 'CIP1', 'cip2': 'CIP2', 'merit': 'Merit',\n                                   'merit_all': 'Real Merit', 'last_afsc': 'Least Desired AFSC',\n                                   'second_to_last_afscs': 'Second Least Desired AFSCs'}\n\n    # Loop through each parameter in the translation dictionary to get \"Cadets\" dataframe column counterpart\n    cadets_columns = {}\n    for parameter in cadet_parameters_to_columns:\n\n        # If we have the parameter, we create its column\n        if parameter in p:\n            col_name = cadet_parameters_to_columns[parameter]\n            cadets_columns[col_name] = p[parameter]\n\n    # If we had the cadet preference/utility columns before, we'll add them back in\n    if \"c_preferences\" in p:\n\n        # Add utility columns\n        for c in range(p[\"num_util\"]):\n            cadets_columns[\"Util_\" + str(c + 1)] = p[\"c_utilities\"][:, c]\n\n        # Add preference columns\n        for c in range(p[\"P\"]):\n            cadets_columns[\"Pref_\" + str(c + 1)] = p[\"c_preferences\"][:, c]\n\n    # If we have the qual matrix, we add that here\n    if \"qual\" in p:\n\n        for j, afsc in enumerate(p[\"afscs\"][:p[\"M\"]]):\n            cadets_columns[\"qual_\" + afsc] = p['qual'][:, j]\n\n    # Create dataframe\n    cadets_df = pd.DataFrame(cadets_columns)\n\n    # Export 'Cadets' dataframe\n    cadets_df.to_csv(instance.export_paths[\"Cadets\"], index=False)\n</code></pre>"},{"location":"reference/data/processing/#data.processing.export_afsc_cadet_matrices_data","title":"<code>export_afsc_cadet_matrices_data(instance)</code>","text":"<p>Exports the preferences dataframes if they exist in the instance's parameters dictionary.</p> <p>Parameters: instance (Instance): An Instance object containing the parameters dictionary and export paths.</p> <p>Returns: None</p> <p>For each potential dataset to export, if it exists in the instance's parameters dictionary, a new dataframe is constructed and exported to the corresponding file path. The potential datasets are: - \"Cadets Utility\": A matrix of the utility values that each cadet assigns to each AFSC. - \"Cadets Preferences\": A matrix of the preferences of each cadet for each AFSC, derived from the utility values. - \"AFSCs Utility\": A matrix of the utility values that each AFSC assigns to each cadet. - \"AFSCs Preferences\": A matrix of the preferences of each AFSC for each cadet, derived from the utility values.</p> <p>Each dataframe has the cadets in the first column and the AFSCs in the remaining columns. The values in each cell correspond to the utility or preference value of the cadet or AFSC for that particular AFSC or cadet.</p> Source code in <code>afccp/data/processing.py</code> <pre><code>def export_afsc_cadet_matrices_data(instance):\n    \"\"\"\n    Exports the preferences dataframes if they exist in the instance's parameters dictionary.\n\n    Parameters:\n    instance (Instance): An Instance object containing the parameters dictionary and export paths.\n\n    Returns:\n    None\n\n    For each potential dataset to export, if it exists in the instance's parameters dictionary, a new dataframe is constructed\n    and exported to the corresponding file path. The potential datasets are:\n    - \"Cadets Utility\": A matrix of the utility values that each cadet assigns to each AFSC.\n    - \"Cadets Preferences\": A matrix of the preferences of each cadet for each AFSC, derived from the utility values.\n    - \"AFSCs Utility\": A matrix of the utility values that each AFSC assigns to each cadet.\n    - \"AFSCs Preferences\": A matrix of the preferences of each AFSC for each cadet, derived from the utility values.\n\n    Each dataframe has the cadets in the first column and the AFSCs in the remaining columns. The values in each cell\n    correspond to the utility or preference value of the cadet or AFSC for that particular AFSC or cadet.\n    \"\"\"\n\n    # Shorthand\n    p, vp = instance.parameters, instance.value_parameters\n\n    # Dataset name translations\n    parameter_trans_dict = {\"utility\": \"Cadets Utility\", \"c_pref_matrix\": \"Cadets Preferences\",\n                            \"afsc_utility\": \"AFSCs Utility\", \"a_pref_matrix\": \"AFSCs Preferences\",\n                            \"rr_interest_matrix\": \"ROTC Rated Interest\", \"rr_om_matrix\": \"ROTC Rated OM\",\n                            'ur_om_matrix': 'USAFA Rated OM', 'or_om_matrix': 'OTS Rated OM',\n                           'cadet_utility': 'Cadets Utility (Final)',\n                            'c_selected_matrix': 'Cadets Selected', 'a_bucket_matrix': 'AFSCs Buckets'\n                            }\n\n    # Get all rated AFSCs\n    all_rated_afscs = p['afscs'][p['J^Rated']]\n\n    # Loop through each potential dataset to export\n    for parameter in parameter_trans_dict:\n\n        # If we have this dataset, we export it\n        if parameter in p:\n            dataset = parameter_trans_dict[parameter]\n\n            # Construct the dataframe\n            if 'ROTC' in dataset:\n                cadet_indices = p[\"Rated Cadets\"]['rotc']\n                pref_df = pd.DataFrame({\"Cadet\": p['cadets'][cadet_indices]})\n                afscs = afccp.data.preferences.determine_soc_rated_afscs(\n                    soc='rotc', all_rated_afscs=all_rated_afscs)\n            elif 'USAFA' in dataset:\n                cadet_indices = p[\"Rated Cadets\"]['usafa']\n                pref_df = pd.DataFrame({\"Cadet\": p['cadets'][cadet_indices]})\n                afscs = afccp.data.preferences.determine_soc_rated_afscs(\n                    soc='usafa', all_rated_afscs=all_rated_afscs)\n            elif 'OTS' in dataset:\n                cadet_indices = p[\"Rated Cadets\"]['ots']\n                pref_df = pd.DataFrame({\"Cadet\": p['cadets'][cadet_indices]})\n                afscs = afccp.data.preferences.determine_soc_rated_afscs(\n                    soc='ots', all_rated_afscs=all_rated_afscs)\n            else:\n                pref_df = pd.DataFrame({\"Cadet\": p[\"cadets\"]})\n                afscs = p[\"afscs\"][:p[\"M\"]]\n\n            # Add the AFSC columns\n            for j, afsc in enumerate(afscs):\n                pref_df[afsc] = p[parameter][:, j]\n\n            # Export the dataset\n            pref_df.to_csv(instance.export_paths[dataset], index=False)\n</code></pre>"},{"location":"reference/data/processing/#data.processing.export_value_parameters_data","title":"<code>export_value_parameters_data(instance)</code>","text":"<p>Export value parameter datasets and related information to CSV files for analysis.</p> <p>This function exports various value parameter datasets to separate CSV files. It provides detailed information about value parameters and constraint data for further analysis.</p> <p>Args:     instance (object): An object containing problem instance and value parameter data.</p> <p>Returns:     None</p> <p>Details: - Value parameters (VP) define optimization settings and constraints. This function extracts and exports different   aspects of the VP data.</p> <ul> <li> <p>Value Parameters CSVs:</p> <ul> <li>For each set of value parameters, this function exports a CSV file containing detailed information about   objective weights, objectives, breakpoint measures (a), breakpoint values (f^hat), and value functions.</li> <li>These CSVs provide insights into the parameters used in the optimization process.</li> </ul> </li> <li> <p>Global Utility CSVs (if applicable):</p> <ul> <li>If global utility data is included in the value parameters, this function exports a CSV containing global   utility values for each cadet and AFSC.</li> <li>This additional dataset is useful for assessing the global utility aspect of the optimization solution.</li> </ul> </li> <li> <p>Cadet Utility Constraints CSV:</p> <ul> <li>This CSV file contains information about minimum value settings for cadets.</li> <li>It helps understand the constraints and preferences applied to individual cadets.</li> </ul> </li> <li> <p>Overall Value Parameters CSV:</p> <ul> <li>A summary CSV is generated, providing an overview of overall value parameters for different VP sets.</li> <li>It includes information on weights, minimum values, weight functions, and other key parameters.</li> </ul> </li> </ul> <p>The exported CSV files are saved with informative names and extensions to distinguish between different versions of data. The function assumes that the 'instance' object contains the required data and file paths for export. ```</p> Source code in <code>afccp/data/processing.py</code> <pre><code>def export_value_parameters_data(instance):\n    \"\"\"\n    Export value parameter datasets and related information to CSV files for analysis.\n\n    This function exports various value parameter datasets to separate CSV files. It provides detailed information\n    about value parameters and constraint data for further analysis.\n\n    Args:\n        instance (object): An object containing problem instance and value parameter data.\n\n    Returns:\n        None\n\n    Details:\n    - Value parameters (VP) define optimization settings and constraints. This function extracts and exports different\n      aspects of the VP data.\n\n    - Value Parameters CSVs:\n        - For each set of value parameters, this function exports a CSV file containing detailed information about\n          objective weights, objectives, breakpoint measures (a), breakpoint values (f^hat), and value functions.\n        - These CSVs provide insights into the parameters used in the optimization process.\n\n    - Global Utility CSVs (if applicable):\n        - If global utility data is included in the value parameters, this function exports a CSV containing global\n          utility values for each cadet and AFSC.\n        - This additional dataset is useful for assessing the global utility aspect of the optimization solution.\n\n    - Cadet Utility Constraints CSV:\n        - This CSV file contains information about minimum value settings for cadets.\n        - It helps understand the constraints and preferences applied to individual cadets.\n\n    - Overall Value Parameters CSV:\n        - A summary CSV is generated, providing an overview of overall value parameters for different VP sets.\n        - It includes information on weights, minimum values, weight functions, and other key parameters.\n\n    The exported CSV files are saved with informative names and extensions to distinguish between different versions\n    of data. The function assumes that the 'instance' object contains the required data and file paths for export.\n    ```\n    \"\"\"\n\n    # Shorthand\n    p = instance.parameters\n\n    # Error data\n    if instance.vp_dict is None:\n        return None  # No value parameters to export!\n\n    # Determine how we're going to show merit for context in the Cadet Constraints dataframe\n    merit_col = \"merit\"\n    if \"merit_all\" in p:\n        merit_col = \"merit_all\"\n\n    # Initialize dataframes\n    vp_cadet_df = pd.DataFrame({\"Cadet\": p[\"cadets\"], \"Merit\": p[merit_col]})\n    vp_overall_df = pd.DataFrame({})\n\n    # Loop through each set of value parameters\n    for v, vp_name in enumerate(list(instance.vp_dict.keys())):\n        vp = instance.vp_dict[vp_name]\n\n        # Initialize Value Function breakpoint arrays\n        a_strings = np.array([[\" \" * 400 for _ in vp[\"K\"]] for _ in p[\"J\"]])\n        fhat_strings = np.array([[\" \" * 400 for _ in vp[\"K\"]] for _ in p[\"J\"]])\n        for j, afsc in enumerate(p['afscs'][:p[\"M\"]]):\n            for k, objective in enumerate(vp['objectives']):\n                a_string_list = [str(x) for x in vp['a'][j][k]]\n                a_strings[j, k] = \",\".join(a_string_list)\n                fhat_strings_list = [str(x) for x in vp['f^hat'][j][k]]\n                fhat_strings[j, k] = \",\".join(fhat_strings_list)\n\n        # Flatten the 2-d arrays to convert them into one long list that is sorted by AFSC and then by objective\n        objective_value_min = np.ndarray.flatten(vp['objective_value_min'])\n        constraint_type = np.ndarray.flatten(vp['constraint_type'])\n        objective_target = np.ndarray.flatten(vp['objective_target'])\n        value_functions = np.ndarray.flatten(vp['value_functions'])\n        breakpoint_a = np.ndarray.flatten(a_strings)\n        breakpoint_fhat = np.ndarray.flatten(fhat_strings)\n\n        # AFSC objective swing weights\n        max_weights = np.max(vp['objective_weight'], axis=1)\n        ow = np.array([[vp['objective_weight'][j, k] / max_weights[j] for k in vp[\"K\"]] for j in p[\"J\"]])\n        objective_weight = np.ndarray.flatten(np.around(ow * 100, 3))\n\n        # Repeating objectives\n        objectives = np.tile(vp['objectives'], p['M'])\n\n        # Repeating AFSCs\n        afscs = np.ndarray.flatten(np.array(list(np.repeat(p['afscs'][j], vp['O']) for j in p[\"J\"])))\n        afsc_value_min = np.ndarray.flatten(np.array(list(np.repeat(vp['afsc_value_min'][j], vp['O']) for j in p[\"J\"])))\n\n        # AFSC swing weights\n        afsc_weight = np.around(vp['afsc_weight'] / np.max(vp['afsc_weight']) * 100, 3)\n        afsc_weight = np.repeat(afsc_weight, vp['O'])\n\n        # Create the \"vp_df\"\n        vp_df = pd.DataFrame({'AFSC': afscs, 'Objective': objectives, 'Objective Weight': objective_weight,\n                              'Objective Target': objective_target, 'AFSC Weight': afsc_weight,\n                              'Min Value': afsc_value_min, 'Min Objective Value': objective_value_min,\n                              'Constraint Type': constraint_type, 'Function Breakpoint Measures (a)': breakpoint_a,\n                              'Function Breakpoint Values (f^hat)': breakpoint_fhat,\n                              'Value Functions': value_functions})\n\n        # Add the minimum value column for this set of value parameters to the cadets df\n        vp_cadet_df[vp_name] = vp[\"cadet_value_min\"]\n\n        # Initialize overall vp column dictionary\n        overall_vp_columns = {'VP Name': vp_name,\n                              'Cadets Weight': vp['cadets_overall_weight'],\n                              'AFSCs Weight': vp['afscs_overall_weight'],\n                              'Cadets Min Value': vp['cadets_overall_value_min'],\n                              'AFSCs Min Value': vp['afscs_overall_value_min'],\n                              'Cadet Weight Function': vp['cadet_weight_function'],\n                              'AFSC Weight Function': vp['afsc_weight_function']}\n\n        # Add the row for this set of value parameters to the overall df\n        for col in overall_vp_columns:\n            vp_overall_df.loc[v, col] = overall_vp_columns[col]\n\n        # Determine extension of VP file (in case it's a different version of data)\n        if instance.data_version == \"Default\":\n            extension = \".csv\"\n        else:\n            extension = \" (\" + instance.data_version + \").csv\"\n\n        # Export 'VP' dataframe\n        vp_df.to_csv(instance.export_paths[\"Model Input\"] + instance.data_name + \" \" + vp_name + extension, index=False)\n\n        # Create \"Global Utility\" dataframe if it's in the value parameters\n        if \"global_utility\" in vp:\n            gu_df = pd.DataFrame({'Cadet': p['cadets']})\n            for j, afsc in enumerate(p['afscs'][:p['M']]):\n                gu_df[afsc] = vp['global_utility'][:, j]\n\n            # Export \"Global Utility\" dataframe\n            filename = instance.data_name + \" \" + vp_name + \" Global Utility\" + extension\n            gu_df.to_csv(instance.export_paths[\"Model Input\"] + filename, index=False)\n\n    # Export 'Value Parameters' dataframe\n    vp_overall_df.to_csv(instance.export_paths[\"Value Parameters\"], index=False)\n\n    # Export 'Cadets Utility Constraints' dataframe\n    vp_cadet_df.to_csv(instance.export_paths[\"Cadets Utility Constraints\"], index=False)\n</code></pre>"},{"location":"reference/data/processing/#data.processing.export_solutions_data","title":"<code>export_solutions_data(instance)</code>","text":"<p>Export solutions data to a CSV file for analysis.</p> <p>This function exports the solutions generated by the optimization process to a CSV file. Each solution is represented as a column in the CSV, providing detailed information about the assignment of cadets to AFSCs for different scenarios or optimization runs.</p> <p>Args:     instance (object): An object containing problem instance and solution data.</p> <p>Returns:     None</p> <p>Details: - This function creates a solutions dataframe with each column representing a different solution. It includes   data about the assignment of cadets to AFSCs for each scenario.</p> <ul> <li> <p>The exported CSV file is saved with an informative name, which typically corresponds to the specific scenario   or optimization run being documented.</p> </li> <li> <p>The function assumes that the 'instance' object contains the required data and file paths for export. ```</p> </li> </ul> Source code in <code>afccp/data/processing.py</code> <pre><code>def export_solutions_data(instance):\n    \"\"\"\n    Export solutions data to a CSV file for analysis.\n\n    This function exports the solutions generated by the optimization process to a CSV file. Each solution is\n    represented as a column in the CSV, providing detailed information about the assignment of cadets to AFSCs\n    for different scenarios or optimization runs.\n\n    Args:\n        instance (object): An object containing problem instance and solution data.\n\n    Returns:\n        None\n\n    Details:\n    - This function creates a solutions dataframe with each column representing a different solution. It includes\n      data about the assignment of cadets to AFSCs for each scenario.\n\n    - The exported CSV file is saved with an informative name, which typically corresponds to the specific scenario\n      or optimization run being documented.\n\n    - The function assumes that the 'instance' object contains the required data and file paths for export.\n    ```\n    \"\"\"\n\n    # Shorthand\n    p = instance.parameters\n\n    # Error data\n    if instance.solutions is None:\n        return None  # No solutions to export!\n\n    # Initialize solutions dataframe\n    solutions_df = pd.DataFrame({\"Cadet\": p[\"cadets\"]})\n\n    # Loop through each solution and add it to the dataframe\n    for solution_name in instance.solutions:\n        solutions_df[solution_name] = instance.solutions[solution_name]['afsc_array']\n\n    # Export 'Solutions' dataframe\n    solutions_df.to_csv(instance.export_paths[\"Solutions\"], index=False)\n\n    # Initialize solutions dataframe\n    extra_dict = {\"Base Solutions\": \"base_array\", \"Course Solutions\": \"course_array\"}\n    for df_name, key in extra_dict.items():\n\n        # Get list of solutions that have this extra component\n        solution_names_found = []\n        for solution_name in instance.solutions:\n            if key in instance.solutions[solution_name]:\n                solution_names_found.append(solution_name)\n\n        # If we have at least one solution with this base or course component, we create this dataframe\n        if len(solution_names_found) &gt; 0:\n            solutions_df = pd.DataFrame({\"Cadet\": p[\"cadets\"]})\n\n            # Loop through each solution with this component and add it to the dataframe\n            for solution_name in solution_names_found:\n                solutions_df[solution_name] = instance.solutions[solution_name][key]\n\n            # Export extra 'Solutions' dataframe\n            solutions_df.to_csv(instance.export_paths[df_name], index=False)\n</code></pre>"},{"location":"reference/data/processing/#data.processing.export_additional_data","title":"<code>export_additional_data(instance)</code>","text":"<p>This function takes an Instance object as an argument, which contains the additional data to be exported. It creates a dictionary of columns to be included in the additional csv files by translating the parameters to their corresponding column names in the file. The function then creates a dataframe using these columns and exports it as a csv file to the path specified in the export_paths attribute of the Instance object.</p> <p>Args:     instance (Instance): An Instance object containing the additional data to export.</p> <p>Returns:     None</p> Source code in <code>afccp/data/processing.py</code> <pre><code>def export_additional_data(instance):\n    \"\"\"\n    This function takes an Instance object as an argument, which contains the additional data to be exported.\n    It creates a dictionary of columns to be included in the additional csv files by translating the parameters\n    to their corresponding column names in the file. The function then creates a dataframe using these columns\n    and exports it as a csv file to the path specified in the export_paths attribute of the Instance object.\n\n    Args:\n        instance (Instance): An Instance object containing the additional data to export.\n\n    Returns:\n        None\n    \"\"\"\n\n    # Shorthand\n    p = instance.parameters\n\n    # See if we can export the \"Bases\" csv file\n    if \"bases\" in p:\n\n        # Initialize dataframe\n        df = pd.DataFrame({\"Base\": p['bases']})\n\n        # Add \"minimum\" # to assign to each base by AFSC\n        for j in p['J']:\n            afsc = p['afscs'][j]\n            df[afsc + ' Min'] = p['base_min'][:, j]\n\n        # Add \"maximum\" # to assign to each base by AFSC\n        for j in p['J']:\n            afsc = p['afscs'][j]\n            df[afsc + ' Max'] = p['base_max'][:, j]\n\n        # Export the dataset\n        df.to_csv(instance.export_paths[\"Bases\"], index=False)\n\n    # Export base preferences/utility if applicable\n    for parameter, dataset in {'b_pref_matrix': 'Bases Preferences', 'base_utility': 'Bases Utility'}.items():\n        if parameter in p:\n\n            # Initialize dataframe\n            df = pd.DataFrame({\"Cadet\": p['cadets']})\n\n            # Add base columns\n            for b, base in enumerate(p['bases']):\n                df[base] = p[parameter][:, b]\n\n            # Export the dataset\n            df.to_csv(instance.export_paths[dataset], index=False)\n\n    # Export training course data if applicable\n    if 'courses' in p:\n\n        # Dictionary to translate parameter names to column names\n        column_translation = {\"Course\": 'courses', 'Start Date': 'course_start', 'Min': 'course_min', 'Max': 'course_max'}\n\n        # Initialize dictionary of new columns\n        new_cols = {'AFSC': [p['afscs'][j] for j in p['J'] for _ in range(p['T'][j])]}\n\n        # Create each column for this dataset\n        for col, param in column_translation.items():\n            new_cols[col] = [p[param][j][c] for j in p['J'] for c in range(p['T'][j])]\n\n        # Create dataframe\n        df = pd.DataFrame(new_cols)\n\n        # Export the dataframe\n        df.to_csv(instance.export_paths['Courses'], index=False)\n\n    # Export Castle AFSCs data\n    if 'castle_afscs_arr' in p:\n\n        # Create dataframe\n        df = pd.DataFrame({'AFPC AFSC': p['afpc_afscs_arr'],\n                           'CASTLE AFSC': p['castle_afscs_arr']})\n\n        # Add in value curve data\n        if 'castle_q' in p:\n            df['a'] = [', '.join(np.around(p['castle_q']['a'][afsc], 3).astype(str)) for afsc in p['castle_afscs_arr']]\n            df['f^hat'] = \\\n                [', '.join(np.around(p['castle_q']['f^hat'][afsc], 3).astype(str)) for afsc in p['castle_afscs_arr']]\n            df['Optimal'] = [p['optimal_policy'][afsc] for afsc in p['castle_afscs_arr']]\n            df['OTS Count'] = [p['ots_counts'][afsc] for afsc in p['castle_afscs_arr']]\n\n        # Export the dataframe\n        df.to_csv(instance.export_paths['Castle Input'], index=False)\n</code></pre>"},{"location":"reference/data/processing/#data.processing.export_solution_results_excel","title":"<code>export_solution_results_excel(instance, filepath)</code>","text":"<p>Export a solution and associated metrics to an Excel file for detailed analysis.</p> <p>This function exports a comprehensive set of solution metrics, objective values, and constraints, along with detailed solution information, to an Excel file. The exported file serves as a valuable resource for in-depth analysis of optimization results.</p> <p>Args:     instance (object): An object containing problem instance and solution data.     filepath (str): The path where the Excel file will be saved.</p> <p>Returns:     None</p> <p>Details: - The exported Excel file contains multiple sheets, each providing specific information about the optimization   solution.</p> <ul> <li> <p>\"Main\" Sheet:</p> <ul> <li>Displays overall metrics such as the value of the objective function (z).</li> <li>Lists key metrics related to cadet preferences and choices, including choice counts and proportions.</li> <li>Provides additional metrics relevant to the optimization problem, constraints, and objectives.</li> </ul> </li> <li> <p>\"Objective Measures\" Sheet:</p> <ul> <li>Presents objective measures for each AFSC (Air Force Specialty Code) in the optimization problem.</li> <li>Helps in evaluating how well the solution aligns with each objective.</li> </ul> </li> <li> <p>\"Constraint Fails\" Sheet:</p> <ul> <li>Displays the number of constraint violations for each AFSC based on various optimization objectives.</li> <li>Identifies where constraints are not met.</li> </ul> </li> <li> <p>\"Objective Values\" Sheet:</p> <ul> <li>Lists the values achieved for each AFSC for all objectives.</li> <li>Highlights the performance of AFSCs with conditional formatting.</li> </ul> </li> <li> <p>\"Solution\" Sheet:</p> <ul> <li>Provides detailed information on each cadet's assignment, including matched AFSCs and preferences.</li> <li>Shows merit, cadet choice, AFSC choice, cadet utility, and AFSC utility.</li> <li>Includes information about rated cadet assignments and AFSC rankings.</li> </ul> </li> <li> <p>\"X\" Sheet (Optional):</p> <ul> <li>Displays the assignment matrix (X matrix) for cadets and AFSCs.</li> <li>Shows the assignment status for each combination.</li> </ul> </li> </ul> <p>The function expects an 'instance' object to contain relevant data, including problem parameters, solution data, and value parameters. The Excel file generated by this function serves as a valuable tool for studying and assessing optimization results.</p> <p>Note: This function assumes that the 'instance' object conforms to the specific structure expected for your optimization problem. Ensure that the 'instance' is correctly configured before using this function for export. ```</p> Source code in <code>afccp/data/processing.py</code> <pre><code>def export_solution_results_excel(instance, filepath):\n    \"\"\"\n    Export a solution and associated metrics to an Excel file for detailed analysis.\n\n    This function exports a comprehensive set of solution metrics, objective values, and constraints, along with detailed\n    solution information, to an Excel file. The exported file serves as a valuable resource for in-depth analysis of\n    optimization results.\n\n    Args:\n        instance (object): An object containing problem instance and solution data.\n        filepath (str): The path where the Excel file will be saved.\n\n    Returns:\n        None\n\n    Details:\n    - The exported Excel file contains multiple sheets, each providing specific information about the optimization\n      solution.\n\n    - \"Main\" Sheet:\n        - Displays overall metrics such as the value of the objective function (z).\n        - Lists key metrics related to cadet preferences and choices, including choice counts and proportions.\n        - Provides additional metrics relevant to the optimization problem, constraints, and objectives.\n\n    - \"Objective Measures\" Sheet:\n        - Presents objective measures for each AFSC (Air Force Specialty Code) in the optimization problem.\n        - Helps in evaluating how well the solution aligns with each objective.\n\n    - \"Constraint Fails\" Sheet:\n        - Displays the number of constraint violations for each AFSC based on various optimization objectives.\n        - Identifies where constraints are not met.\n\n    - \"Objective Values\" Sheet:\n        - Lists the values achieved for each AFSC for all objectives.\n        - Highlights the performance of AFSCs with conditional formatting.\n\n    - \"Solution\" Sheet:\n        - Provides detailed information on each cadet's assignment, including matched AFSCs and preferences.\n        - Shows merit, cadet choice, AFSC choice, cadet utility, and AFSC utility.\n        - Includes information about rated cadet assignments and AFSC rankings.\n\n    - \"X\" Sheet (Optional):\n        - Displays the assignment matrix (X matrix) for cadets and AFSCs.\n        - Shows the assignment status for each combination.\n\n    The function expects an 'instance' object to contain relevant data, including problem parameters, solution data,\n    and value parameters. The Excel file generated by this function serves as a valuable tool for studying and assessing\n    optimization results.\n\n    Note:\n    This function assumes that the 'instance' object conforms to the specific structure expected for your optimization\n    problem. Ensure that the 'instance' is correctly configured before using this function for export.\n    ```\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = instance.parameters, instance.value_parameters, instance.solution\n    mdl_p = instance.mdl_p\n\n    # Get list of excel columns in order (\"A\", \"AB\", etc.)\n    alphabet = list(string.ascii_uppercase)\n    excel_columns = copy.deepcopy(alphabet)\n    for letter in alphabet:\n        for letter_2 in alphabet:\n            excel_columns.append(letter + letter_2)\n\n    # Create a Pandas Excel writer using XlsxWriter as the engine.\n    writer = pd.ExcelWriter(filepath, engine='xlsxwriter')\n\n    # Get the xlsxwriter objects from the dataframe writer object.\n    workbook = writer.book\n    worksheet = workbook.add_worksheet(\"Main\")\n\n    # Make the background white initially\n    white_format = workbook.add_format({'bold': False, 'font_color': 'black', 'bg_color': 'white',\n                                       'font_size': 14, 'font_name': 'Calibri'})\n    for r in range(200):\n        for c in range(50):\n            worksheet.write(r, c, '', white_format)\n\n    # Merge cells\n    merge_format = workbook.add_format({'bold': True, 'font_color': 'black', 'bg_color': 'white',\n                                       'font_size': 14, 'font_name': 'Calibri', 'align': 'center',\n                                        'valign': 'vcenter', 'border_color': 'black', 'border': 1})\n    worksheet.merge_range(\"B2:D2\", \"VFT Overall Metrics\", merge_format)\n    worksheet.merge_range(\"F2:G2\", \"Additional Metrics\", merge_format)\n    worksheet.write('I2', 'Preference', merge_format)\n    worksheet.write('J2', 'Count', merge_format)\n    worksheet.write('K2', 'Proportion', merge_format)\n\n    # Objective Value\n    obj_format = workbook.add_format({'bold': True, 'font_color': 'black', 'bg_color': 'yellow',\n                                      'font_size': 14, 'font_name': 'Calibri', 'align': 'center',\n                                      'valign': 'vcenter', 'border_color': 'black', 'border': 1})\n    worksheet.merge_range(\"C6:D6\", round(solution['z'], 4), obj_format)\n\n    # Other cells\n    cell_format = workbook.add_format({'bold': False, 'font_color': 'black', 'bg_color': 'white',\n                                       'font_size': 14, 'font_name': 'Calibri', 'align': 'center',\n                                        'valign': 'vcenter', 'border_color': 'black', 'border': 1})\n    worksheet.write('B3', 'VFT', cell_format)\n    worksheet.write('B4', 'Cadets', cell_format)\n    worksheet.write('B5', 'AFSCs', cell_format)\n    worksheet.write('B6', 'Z', cell_format)\n    worksheet.write('C3', 'Value', cell_format)\n    worksheet.write('D3', 'Weight', cell_format)\n\n    # Basic format\n    cell_format = workbook.add_format({'bold': False, 'font_color': 'black', 'bg_color': 'white',\n                                        'font_size': 14, 'font_name': 'Calibri', 'border_color': 'black', 'border': 1})\n\n    # Choice Counts\n    choice_dict = {1: \"First\", 2: \"Second\", 3: \"Third\", 4: \"Fourth\", 5: \"Fifth\", 6: \"Sixth\", 7: \"Seventh\",\n                   8: \"Eighth\", 9: \"Ninth\", 10: \"Tenth\"}\n    for choice in choice_dict:\n        worksheet.write(\"J\" + str(2 + choice), int(solution['cadet_choice_counts'][choice]), cell_format)\n        worksheet.write(\"I\" + str(2 + choice), choice_dict[choice], cell_format)\n        worksheet.write(\"K\" + str(2 + choice), round(solution['cadet_choice_counts'][choice] / p['N^Match'], 3),\n                        cell_format)\n    worksheet.write(\"I\" + str(3 + choice), \"All Others\", cell_format)\n    worksheet.write(\"J\" + str(3 + choice), int(solution['cadet_choice_counts']['All Others']), cell_format)\n    worksheet.write(\"K\" + str(3 + choice), round(solution['cadet_choice_counts'][\"All Others\"] / p['N^Match'], 3),\n                    cell_format)\n\n    # Additional solution metrics\n    name_metric_dict = {'Blocking Pairs': 'num_blocking_pairs', 'Ineligible Cadets': 'num_ineligible',\n                        'Unmatched Cadets': 'num_unmatched',\n                        'Top 3 Choices (Proportion) for USSF': 'top_3_ussf_count',\n                        'Top 3 Choices (Proportion) for USAF': 'top_3_usaf_count',\n                        'Top 3 Choices (Proportion) for USAFA': 'top_3_usafa_count',\n                        'Top 3 Choices (Proportion) for ROTC': 'top_3_rotc_count',\n                        'Top 3 Choices (Proportion) for OTS': 'top_3_ots_count',\n                        'Average Cadet Choice': 'average_cadet_choice',\n                        'Average Normalized AFSC Score': 'weighted_average_afsc_score',\n                        'Average NRL Normalized AFSC Score': 'weighted_average_nrl_afsc_score',\n                        'Failed Constraints': 'total_failed_constraints', 'USSF OM': 'ussf_om',\n                        'Global Utility': 'z^gu', 'Cadet Utility': 'cadet_utility_overall',\n                        'z^CASTLE': 'z^CASTLE', 'z^CASTLE (Values)': 'z^CASTLE (Values)',\n                        'AFSC Utility': 'afsc_utility_overall', 'USAFA Cadet Utility': 'usafa_cadet_utility',\n                        'ROTC Cadet Utility': 'rotc_cadet_utility', 'OTS Cadet Utility': 'ots_cadet_utility',\n                        'USSF Cadet Utility': 'ussf_cadet_utility',\n                        'USAF Cadet Utility': 'usaf_cadet_utility', 'USSF AFSC Utility': 'ussf_afsc_utility',\n                        'USAF AFSC Utility': 'usaf_afsc_utility',\n                        'Average Normalized AFSC Score (USSF)': 'weighted_average_ussf_afsc_score',\n                        'Average Normalized AFSC Score (USAF)': 'weighted_average_usaf_afsc_score',\n                        'USAFA USSF Cadets / USAFA USSF PGL': 'ussf_usafa_pgl_target',\n                        'ROTC USSF Cadets / ROTC USSF PGL': 'ussf_rotc_pgl_target',\n                        'Cadets Successfully Constrained to Accessions Group / Total Fixed Accession Group Slots':\n                            'constrained_acc_grp_target',\n                        \"Cadets Successfully Constrained to AFSC / Total Fixed AFSC Slots\":\n                            'cadets_fixed_correctly',\n                        \"Cadets Successfully Reserved to AFSC / Total Reserved AFSC Slots\":\n                            'cadets_reserved_correctly',\n                        \"Successful Alternate List Scenarios / Total Possible Alternate List Scenarios\":\n                            'alternate_list_metric'}\n    for acc_grp in p['afscs_acc_grp']:\n        name_metric_dict[acc_grp + \" Racial Simpson Index\"] = 'simpson_index_' + acc_grp\n\n    # Add these metrics into excel\n    for r, name in enumerate(list(name_metric_dict.keys())):\n        if name_metric_dict[name] in solution:\n\n            # Sometimes we can't write in a value for a solution metric that is incomplete\n            try:\n                worksheet.write('F' + str(3 + r), name, cell_format)\n                worksheet.write('G' + str(3 + r), solution[name_metric_dict[name]], cell_format)\n            except:\n                pass\n\n    # VFT Metrics\n    worksheet.write('C4', round(solution['cadets_overall_value'], 4), cell_format)\n    worksheet.write('C5', round(solution['afscs_overall_value'], 4), cell_format)\n    worksheet.write('D4', round(vp['cadets_overall_weight'], 4), cell_format)\n    worksheet.write('D5', round(vp['afscs_overall_weight'], 4), cell_format)\n\n    # Draw bigger borders\n    draw_frame_border_outside(workbook, worksheet, 1, 1, 5, 3, color='black', width=2)\n    draw_frame_border_outside(workbook, worksheet, 1, 5, len(name_metric_dict.keys()) + 1, 2, color='black', width=2)\n    draw_frame_border_outside(workbook, worksheet, 1, 8, 12, 3, color='black', width=2)\n\n    # Adjust Column Widths\n    column_widths = {0: 1.50, 4: 1.50, 5: 31, 7: 1.50, 8: 14, 10: 12}\n    for c in column_widths:\n        worksheet.set_column(c, c, column_widths[c])\n\n    def export_results_dfs():\n        \"\"\"\n        This nested function is here to export all other dataframes\n        \"\"\"\n\n        # Get the xlsxwriter worksheet object.\n        workbook = writer.book\n\n        # AFSC Objective measures dataframe\n        df = pd.DataFrame({'AFSC': p['afscs'][:p['M']]})\n        for k, objective in enumerate(vp['objectives']):\n            df[objective] = np.around(solution['objective_measure'][:, k], 2)\n\n        # Convert the dataframe to an XlsxWriter Excel object.\n        df.to_excel(writer, sheet_name='Objective Measures', index=False)\n\n        # Add Castle Data if it exists\n        if 'castle_q' in p:\n            castle_afscs = [afsc for afsc, _ in p['J^CASTLE'].items()]\n            castle_counts = [solution['castle_counts'][afsc] for afsc in castle_afscs]\n            castle_values = [solution['castle_v'][afsc] for afsc in castle_afscs]\n            df = pd.DataFrame({'AFSC': castle_afscs, 'Count': castle_counts, 'Value': castle_values})\n            df.to_excel(writer, sheet_name='Castle Metrics', index=False)\n\n        # AFSC Constraint Fail dataframe\n        df = pd.DataFrame({'AFSC': p['afscs'][:p['M']]})\n        for k, objective in enumerate(vp['objectives']):\n            df[objective] = solution['objective_constraint_fail'][:, k]\n\n        # Convert the dataframe to an XlsxWriter Excel object.\n        df.to_excel(writer, sheet_name='Constraint Fails', index=False)\n\n        # AFSC Objective values dataframe\n        df = pd.DataFrame({'AFSC': p['afscs'][:p['M']]})\n        for k, objective in enumerate(vp['objectives']):\n            values = np.empty((p['M']))\n            values[:] = np.nan\n            np.put(values, vp['J^A'][k], np.around(solution['objective_value'][vp['J^A'][k], k], 2))\n\n            df[objective] = values\n\n        # Convert the dataframe to an XlsxWriter Excel object.\n        df.to_excel(writer, sheet_name='Objective Values', index=False)\n\n        # Get the xlsxwriter worksheet object.\n        worksheet = writer.sheets[\"Objective Values\"]\n\n        # Add a percent number format\n        percent_format = workbook.add_format({\"num_format\": \"0.0%\"})\n        worksheet.set_column(1, vp['O'] + 1, None, percent_format)\n\n        # Conditional formatting to highlight which objectives were met/not met\n        worksheet.conditional_format(\"B2:\" + excel_columns[vp['O']] + str(p['M'] + 1), {\"type\": \"3_color_scale\"})\n\n        # Solution Dataframe\n        df = pd.DataFrame({'Cadet': p['cadets']})\n        df['USAFA'] = p['usafa']\n        df['Merit'] = p['merit']\n        df[\"Matched AFSC\"] = solution['afsc_array']\n        if \"base_array\" in solution:\n            df[\"Matched Base\"] = solution['base_array']\n            df[\"Matched Course\"] = solution['course_array']\n            col_dict = {'Base Choice': 'base_choice', 'Cadet State': 'cadet_state_achieved',\n                        'State Utility': 'state_utility_used', 'Cadet Value': 'cadet_value_achieved',\n                        'AFSC Weight': 'afsc_weight_used', 'Base Weight': 'base_weight_used',\n                        'Course Weight': 'course_weight_used', 'Base Utility': 'base_utility_achieved',\n                        'Course Utility': 'course_utility_achieved'}\n            for key, val in col_dict.items():\n                if val in solution:\n                    df[key] = solution[val]\n        df['Cadet Choice'] = solution['cadet_choice']\n        df['AFSC Choice'] = solution['afsc_choice']\n        df['Cadet Utility'] = solution['cadet_utility_achieved']\n        df['AFSC Utility'] = solution['afsc_utility_achieved']\n        df['Global Utility'] = solution['global_utility_achieved']\n        df['Matched Deg Tier'] = [  # \"U\" for unmatched cadets\n            p['qual'][i, solution['j_array'][i]] if solution['j_array'][i] in p['J'] else 'U' for i in p['I']]\n\n        # Rated Reserves/Matches/Alternates\n        for s_name in ['Rated Matches', 'Rated Reserves', 'Rated Alternates (Hard)', 'Rated Alternates (Soft)']:\n            if s_name in instance.solutions:\n                df[s_name] = instance.solutions[s_name]['afsc_array']\n            else:\n                df[s_name] = [\"*\" for _ in p['I']]\n\n        # Rated Rankings\n        for j in p['J^Rated']:\n            df[p['afscs'][j] + \" Rank\"] = p['a_pref_matrix'][:, j]\n\n        # Add the cadet's top 10 choices for more information!\n        for choice in range(min(p['P'], 10)):\n            df['Choice ' + str(choice + 1)] = p['c_preferences'][:, choice]\n\n        # Capture preference columns\n        preference_columns = excel_columns[len(df.columns) - min(p['P'], 10): len(df.columns)]\n\n        # Add the cadet's top 10 utilities for more information!\n        for choice in range(min(p['P'], 10)):\n            df['Utility ' + str(choice + 1)] = np.zeros(p['N'])\n            for i in p['I']:\n\n                # Might run out of utilities\n                if len(p['cadet_preferences'][i]) &gt; choice:\n                    j = p['cadet_preferences'][i][choice]\n                    df['Utility ' + str(choice + 1)][i] = p['cadet_utility'][i, j]\n\n        # Convert the dataframe to an XlsxWriter Excel object.\n        df.to_excel(writer, sheet_name='Solution', index=False, startrow=1, header=False)\n\n        # Get the xlsxwriter worksheet object.\n        worksheet = writer.sheets[\"Solution\"]\n\n        # Add additional formatting to top row\n        header_format = workbook.add_format({'bold': True, 'text_wrap': True, 'align': 'center', 'valign': 'vcenter'})\n        for col_num, value in enumerate(df.columns.values):\n            worksheet.write(0, col_num, value, header_format)\n\n        # Get numpy array of df columns\n        df_columns = np.array(df.columns)\n\n        # Conditional Formatting on preferences\n        cadet_choice_col = excel_columns[np.where(df_columns == 'Cadet Choice')[0][0]]\n        for col, c in enumerate(preference_columns):\n            format1 = workbook.add_format({'bg_color': mdl_p['choice_colors'][col + 1]})\n            worksheet.conditional_format(c + \"2:\" + c + str(p['N'] + 1),\n                                         {'type': 'cell', 'value': 'D2',\n                                          'criteria': '=',\n                                          'format': format1\n                                          })\n            # Cadet Choice Column\n            worksheet.conditional_format(cadet_choice_col + \"2:\" + cadet_choice_col + str(p['N'] + 1),\n                                         {'type': 'cell', 'value': col + 1,\n                                          'criteria': '=',\n                                          'format': format1\n                                          })\n\n        # Freeze top row\n        worksheet.freeze_panes(1, 0)\n\n        # Add filter to headers\n        worksheet.autofilter('A1:' + str(excel_columns[len(df.columns) - 1]) + str(p['N'] + 1))\n\n        # Replace unassigned base values\n        if 'Base Choice' in df:\n            cell_format = workbook.add_format({})\n            for i in p['I']:\n                if df.loc[i, 'Base Choice'] == 0:\n                    letters = [excel_columns[np.where(df_columns == col)[0][0]] for col in\n                               ['Base Weight', 'Base Choice', 'Base Utility']]\n                    for letter in letters:\n                        worksheet.write(letter + str(i + 2), '', cell_format)\n\n        # Small values good (1, 2, 3, 4, ...) Conditional Formatting\n        sv_excel_cols = []\n        for col in ['AFSC Choice', 'Base Choice', 'Cadet State']:\n            if col in df:\n                sv_excel_cols.append(excel_columns[np.where(df_columns == col)[0][0]])\n        for c in sv_excel_cols:\n            worksheet.conditional_format(\n                c + \"2:\" + c + str(p['N'] + 1), {'type': '3_color_scale', 'min_color': '#63be7b',\n                                                 'mid_color': '#ffeb84', 'max_color': '#f8696b'})\n\n        # Large values good (1, ...,  0) Conditional Formatting\n        lv_excel_cols = []\n        for col in ['Merit', 'Cadet Utility', 'AFSC Utility', 'Global Utility', 'Base Utility', 'Course Utility',\n                    'State Utility', 'Cadet Value', 'Cadet Value (Pyomo)']:\n            if col in df:\n                lv_excel_cols.append(excel_columns[np.where(df_columns == col)[0][0]])\n        for c in lv_excel_cols:\n            worksheet.conditional_format(c + \"2:\" + c + str(p['N'] + 1), {\"type\": \"3_color_scale\"})\n\n        # \"All Others\" for the choice column\n        format1 = workbook.add_format({'bg_color': mdl_p['all_other_choice_colors']})\n        worksheet.conditional_format(cadet_choice_col + \"2:\" + cadet_choice_col + str(p['N'] + 1),\n                                     {'type': 'cell', 'value': 10, 'criteria': '&gt;', 'format': format1})\n\n        # Add a percent number format to certain columns\n        percent_cols = ['Merit', 'State Utility', 'Cadet Value', 'AFSC Weight', 'Base Weight', 'Course Weight',\n                        'Base Utility', 'Course Utility', 'Cadet Utility', 'AFSC Utility', 'Global Utility']\n        percent_format = workbook.add_format({\"num_format\": \"0.0%\"})\n        for col in percent_cols:\n            if col in df_columns:\n                c_num = np.where(df_columns == col)[0][0]\n                worksheet.set_column(c_num, c_num, None, percent_format)\n\n        # Solution/X Matrix\n        if 'x' in solution:\n            df = pd.DataFrame({'Cadet': p['cadets']})\n            df[instance.solution_name] = instance.solution['afsc_array']\n            for j, afsc in enumerate(p['afscs'][:p['M']]):\n                df[afsc] = instance.solution['x'][:, j]\n\n            # Convert the dataframe to an XlsxWriter Excel object.\n            df.to_excel(writer, sheet_name='X', index=False)\n\n        # Base Matrix\n        if 'v' in solution:\n            df = pd.DataFrame({'Cadet': p['cadets']})\n            df[instance.solution_name] = instance.solution['base_array']\n            for b, base in enumerate(p['bases'][:p['S']]):\n                df[base] = instance.solution['v'][:, b]\n\n            # Convert the dataframe to an XlsxWriter Excel object.\n            df.to_excel(writer, sheet_name='V', index=False)\n\n        # Training Matrix\n        if 'q' in solution:\n\n            df = pd.DataFrame({'Cadet': p['cadets']})\n            df[instance.solution_name] = instance.solution['course_array']\n            for j, afsc in enumerate(p['afscs'][:p['M']]):\n                for c, course in enumerate(p['courses'][j]):\n                    df[afsc + \"-\" + course] = instance.solution['q'][:, j, c]\n\n            # Convert the dataframe to an XlsxWriter Excel object.\n            df.to_excel(writer, sheet_name='Q', index=False)\n\n        # Value Function Matrices\n        if 'lambda' in solution:\n\n            afsc_arr = [afsc for afsc in p['afscs'][:p['M']] for _ in vp['K']]\n            objective_arr = [objective for _ in p['J'] for objective in vp['objectives']]\n\n            df = pd.DataFrame({'AFSC': afsc_arr, 'Objective': objective_arr})\n            for l in range(solution['r^max']):\n                arr = [solution['lambda'][j, k, l] for j in p['J'] for k in vp['K']]\n                df['l_' + str(l + 1)] =  arr\n\n            # Convert the dataframe to an XlsxWriter Excel object.\n            df.to_excel(writer, sheet_name='Lambda', index=False)\n\n            df = pd.DataFrame({'AFSC': afsc_arr, 'Objective': objective_arr})\n            for l in range(solution['r^max']):\n                arr = [solution['y'][j, k, l] for j in p['J'] for k in vp['K']]\n                df['y_' + str(l + 1)] = arr\n\n            # Convert the dataframe to an XlsxWriter Excel object.\n            df.to_excel(writer, sheet_name='Y', index=False)\n\n        # Blocking Pairs\n        if 'blocking_pairs' in solution:\n\n            # Create \"blocking pairs\" dataframe and export it to excel\n            blocking_cadets = [tuple[0] for tuple in solution['blocking_pairs']]\n            blocking_afscs = [p['afscs'][tuple[1]] for tuple in solution['blocking_pairs']]\n            df = pd.DataFrame({'Blocking Cadet': blocking_cadets, 'Blocking AFSC': blocking_afscs})\n            df.to_excel(writer, sheet_name='Blocking Pairs', index=False)\n\n        # Close the workbook\n        writer.close()\n    export_results_dfs()\n</code></pre>"},{"location":"reference/data/support/","title":"Support","text":""},{"location":"reference/data/support/#data.support","title":"<code>data.support</code>","text":""},{"location":"reference/data/support/#data.support.initialize_instance_functional_parameters","title":"<code>initialize_instance_functional_parameters(N)</code>","text":"<p>Initializes the various instance parameters for the CadetCareerProblem object.</p> <p>Parameters:     N (int): The number of cadets in the problem instance.</p> <p>Returns:     dict: A dictionary containing the initialized instance parameters.</p> <p>This function initializes the hyperparameters and toggles for the CadetCareerProblem object. It sets default values for various parameters that control the behavior and visualization of the problem instance.</p> <p>The parameters are organized into different sections, including graph parameters, AFSC chart versions, colors for different bar types, animation colors, value function chart parameters, and more.</p> <p>The function returns a dictionary containing all the initialized instance parameters.</p> <p>Note: The analyst can modify the default parameter values by specifying new values in this initialization function or by passing them as arguments when calling the CadetCareerProblem object methods.</p> Source code in <code>afccp/data/support.py</code> <pre><code>def initialize_instance_functional_parameters(N):\n    \"\"\"\n    Initializes the various instance parameters for the CadetCareerProblem object.\n\n    Parameters:\n        N (int): The number of cadets in the problem instance.\n\n    Returns:\n        dict: A dictionary containing the initialized instance parameters.\n\n    This function initializes the hyperparameters and toggles for the CadetCareerProblem object.\n    It sets default values for various parameters that control the behavior and visualization of the problem instance.\n\n    The parameters are organized into different sections, including graph parameters, AFSC chart versions,\n    colors for different bar types, animation colors, value function chart parameters, and more.\n\n    The function returns a dictionary containing all the initialized instance parameters.\n\n    Note: The analyst can modify the default parameter values by specifying new values in this initialization\n    function or by passing them as arguments when calling the CadetCareerProblem object methods.\n    \"\"\"\n\n    # Parameters for the graphs\n    mdl_p = {\n\n        # Generic Solution Handling (for multiple algorithms/models)\n        \"initial_solutions\": None, \"solution_names\": None, \"add_to_dict\": True, \"set_to_instance\": True,\n        \"initialize_new_heuristics\": False, 'gather_all_metrics': True, 're-calculate x': True, 'solution_method': None,\n\n        # Matching Algorithm Parameters\n        'ma_printing': False, 'capacity_parameter': 'quota_max', 'collect_solution_iterations': True,\n        'create_new_rated_solutions': True,\n\n        # Rated Matching Algorithm Parameters\n        'rated_alternate_afscs': None, 'rated_alternates': True, 'rotc_rated_board_afsc_order': None, 'soc': 'usafa',\n        'incorporate_rated_results': True, 'usafa_soc_pilot_cross_in': False, 'socs_to_use': None,\n\n        # Genetic Matching Algorithm Parameters\n        \"gma_pop_size\": 4, 'gma_max_time': 20, 'gma_num_crossover_points': 2, 'gma_mutations': 1,\n        'gma_mutation_rate': 1, 'gma_printing': False, 'stopping_conditions': 'Time', 'gma_num_generations': 200,\n\n        # Genetic Algorithm Parameters\n        \"pop_size\": 12, \"ga_max_time\": 60, \"num_crossover_points\": 3, \"initialize\": True, \"ga_printing\": True,\n        \"mutation_rate\": 0.05, \"num_time_points\": 100, \"num_mutations\": int(np.ceil(N / 75)), \"time_eval\": False,\n        \"percent_step\": 10, \"ga_constrain_first_only\": False, 'mutation_function': 'cadet_choice',\n        'preference_mutation_rate': 0.5,\n\n        # Pyomo General Parameters\n        \"real_usafa_n\": 960, \"solver_name\": \"cbc\", \"pyomo_max_time\": None, \"provide_executable\": False,\n        \"executable\": None, \"exe_extension\": False, 'alternate_list_iterations_printing': False,\n        'ots_accessions': None,\n\n        # Additional Constraints/Modeling\n        \"assignment_model_obj\": \"Global Utility\", 'ussf_merit_bound': 0.03, 'ussf_soc_pgl_constraint': False,\n        'ussf_soc_pgl_constraint_bound': 0.01, 'USSF OM': False,\n        'USAFA-Constrained AFSCs': None,\n\n        # Base/Training Parameters\n        'BIG M': 100, 'solve_extra_components': False,\n\n        # VFT Model Parameters\n        \"pyomo_constraint_based\": True, \"constraint_tolerance\": 0.95, \"warm_start\": None, \"init_from_X\": False,\n        \"obtain_warm_start_variables\": True, \"add_breakpoints\": True, \"approximate\": True,\n\n        # VFT Population Generation Parameters\n        \"populate\": True, \"iterate_from_quota\": True, \"max_quota_iterations\": 5, \"population_additions\": 10,\n        \"population_generation_model\": \"Assignment\",\n\n        # Model Constraint Placement Algorithm parameters\n        'constraint_model_to_use': 'Assignment', \"skip_quota_constraint\": False,\n\n        # Sensitivity Analysis\n        \"pareto_step\": 10, \"num_pgl_analysis_iterations\": 30, \"import_pgl_analysis_folder\": None,\n\n        # Goal Programming Parameters\n        \"get_reward\": False, \"con_term\": None, \"get_new_rewards_penalties\": False, \"use_gp_df\": True,\n\n        # CASTLE Integration Parameters\n        \"w^G\": 0.8,  # Weight on GUO solution relative to CASTLE\n        \"solve_castle_guo\": False,  # Whether we should solve the castle version of GUO or not\n\n        # Value Parameter Generation\n        \"new_vp_weight\": 100, \"num_breakpoints\": 24,\n\n        # BubbleChart Parameters\n        'b_figsize': (13.33, 7.5), 's': 1, 'fw': 100, 'circle_radius_percent': 0.8,\n        'fh_ratio': 0.5, 'bw^t_ratio': 0.05, 'bw^l_ratio': 0, 'bw^r_ratio': 0, 'b_title': None,\n        'bw^b_ratio': 0, 'bw^u_ratio': 0.02, 'abw^lr_ratio': 0.01, 'abw^ud_ratio': 0.02, 'b_title_size': 30,\n        'lh_ratio': 0.1, 'lw_ratio': 0.1, 'dpi': 200, 'pgl_linestyle': '-', 'pgl_color': 'gray',\n        'pgl_alpha': 0.5, 'surplus_linestyle': '--', 'surplus_color': 'white', 'surplus_alpha': 1,\n        'usafa_pgl_color': 'blue', 'rotc_pgl_color': 'red', 'usafa_bubble': 'blue', 'rotc_bubble': 'red',\n        'ots_pgl_color': 'yellow', 'ots_bubble': 'yellow',\n        'cb_edgecolor': 'black', 'save_board_default': True, 'circle_color': 'black', 'focus': 'Cadet Choice',\n        'save_iteration_frames': True, 'afsc_title_size': 20, 'afsc_names_sized_box': False,\n        'b_solver_name': 'couenne', 'b_pyomo_max_time': None, 'row_constraint': False, 'n^rows': 3,\n        'simplified_model': True, 'use_pyomo_model': True, 'sort_cadets_by': 'AFSC Preferences', 'add_legend': False,\n        'draw_containers': False, 'figure_color': 'black', 'text_color': 'white', 'afsc_text_to_show': 'Norm Score',\n        'use_rainbow_hex': True, 'build_orientation_slides': True, 'b_legend': True, 'b_legend_size': 20,\n        'b_legend_marker_size': 20, 'b_legend_title_size': 20, 'x_ext_left': 0, 'x_ext_right': 0, 'y_ext_left': 0,\n        'y_ext_right': 0, 'show_rank_text': False, 'rank_text_color': 'white', 'fontsize_single_digit_adj': 0.6,\n        'b_legend_loc': 'upper right', 'redistribute_x': True, 'cadets_solved_for': None,\n\n        # These parameters pertain to the AFSCs that will ultimately show up in the visualizations\n        'afscs_solved_for': 'All', 'afscs_to_show': 'All',\n\n        # Generic Chart Handling\n        \"save\": True, \"figsize\": (19, 10), \"facecolor\": \"white\", \"title\": None, \"filename\": None, \"display_title\": True,\n        \"label_size\": 25, \"afsc_tick_size\": 20, \"yaxis_tick_size\": 25, \"bar_text_size\": 15, \"xaxis_tick_size\": 20,\n        \"afsc_rotation\": None, \"bar_color\": \"#3287cd\", \"alpha\": 1, \"legend_size\": 25, \"title_size\": 25,\n        \"text_size\": 15, 'text_bar_threshold': 400, 'dot_size': 35, 'legend_dot_size': 15, 'ncol': 1,\n        \"color_afsc_text_by_grp\": True, \"proportion_legend_size\": 15, 'proportion_text_bar_threshold': 10,\n        \"square_figsize\": (11, 10), 'legend_fontsize': 15,\n\n        # AFSC Chart Elements\n        \"eligibility\": True, \"eligibility_limit\": None, \"skip_afscs\": None, \"all_afscs\": True, \"y_max\": 1.1,\n        \"y_exact_max\": None, \"preference_chart\": False, \"preference_proportion\": False, \"dot_chart\": False,\n        \"sort_by_pgl\": True, \"solution_in_title\": True, \"afsc\": None, \"only_desired_graphs\": True,\n        'add_legend_afsc_chart': True, 'legend_loc': 'upper right', \"add_bound_lines\": False,\n        \"large_afsc_distinction\": False,\n\n        # Cadet Utility Chart Elements\n        \"cadet\": 0, \"util_type\": \"Final Utility\",\n\n        # Accessions Chart Elements\n        \"label_size_acc\": 25, \"acc_text_size\": 25, \"acc_bar_text_size\": 25, \"acc_legend_size\": 15,\n        \"acc_text_bar_threshold\": 10,\n\n        # Macro Chart Controls\n        \"cadets_graph\": True, \"data_graph\": \"AFOCD Data\", \"results_graph\": \"Measure\", \"objective\": \"Merit\",\n        \"version\": \"bar\", \"macro_chart_kind\": \"AFSC Chart\",\n\n        # Similarity Chart Elements\n        \"sim_dot_size\": 220, \"new_similarity_matrix\": True, 'default_sim_color': 'black',\n        'default_sim_marker': 'o',\n\n        # Value Function Chart Elements\n        \"smooth_value_function\": False,\n\n        # Solution Comparison Chart Information\n        \"compare_solutions\": False, \"vp_name\": None,\n        \"color_choices\": [\"red\", \"blue\", \"green\", \"orange\", \"purple\", \"black\", \"magenta\"],\n        \"marker_choices\": ['o', 'D', '^', 'P', 'v', '*', 'h'], \"marker_size\": 20, \"comparison_afscs\": None,\n        \"zorder_choices\": [2, 3, 2, 2, 2, 2, 2], \"num_solutions\": None,\n\n        # Multi-Criteria Chart\n        \"num_afscs_to_compare\": 8, \"comparison_criteria\": [\"Utility\", \"Merit\", \"AFOCD\"],\n\n        # Slide Parameters\n        \"ch_top\": 2.35, \"ch_left\": 0.59, \"ch_height\": 4.64, \"ch_width\": 8.82,\n\n        # Subset of charts I actually really care about\n        \"desired_charts\": [(\"Combined Quota\", \"quantity_bar\"), (\"Norm Score\", \"quantity_bar_proportion\"),\n                           (\"Norm Score\", \"bar\"),\n                           (\"Utility\", \"quantity_bar_proportion\"), (\"Utility\", \"quantity_bar_choice\"),\n                           (\"Merit\", \"bar\"), (\"USAFA Proportion\", \"quantity_bar_proportion\"),\n                           (\"USAFA Proportion\", \"preference_chart\"),\n                           # (\"Male\", \"preference_chart\"),\n                           # ('Extra', 'Race Chart'),\n                           # ('Extra', 'Race Chart_proportion'), ('Extra', 'Ethnicity Chart'),\n                           # ('Extra', 'Ethnicity Chart_proportion'), ('Extra', 'Gender Chart'),\n                           # ('Extra', 'Gender Chart_proportion'),\n                           ('Extra', 'SOC Chart'),\n                           ('Extra', 'SOC Chart_proportion')],\n\n        \"desired_comparison_charts\": [('Utility', 'median_preference'), ('Combined Quota', 'dot'), ('Utility', 'dot'),\n                                      ('Norm Score', 'dot'), ('Merit', 'dot'), ('Tier 1', 'dot'),\n                                      # ('Extra', 'Race Chart'),\n                                      ('USAFA Proportion', 'dot'),\n                                      # ('Male', 'dot'),\n                                      ('Utility', 'mean_preference')],\n\n        'desired_other_charts': [\n                                # (\"Accessions Group\", \"Race Chart\"), (\"Accessions Group\", \"Gender Chart\"),\n                                #  (\"Accessions Group\", \"Ethnicity Chart\"),\n                                 (\"Accessions Group\", \"SOC Chart\"),\n            ]\n\n    }\n\n    # AFSC Measure Chart Versions\n    afsc_chart_versions = {\"Merit\": [\"large_only_bar\", \"bar\", \"quantity_bar_gradient\", \"quantity_bar_proportion\"],\n                           \"USAFA Proportion\": [\"large_only_bar\", \"bar\", \"preference_chart\", \"quantity_bar_proportion\"],\n                           \"Male\": [\"bar\", \"preference_chart\", \"quantity_bar_proportion\"],\n                           \"Combined Quota\": [\"dot\", \"quantity_bar\"],\n                           \"Minority\": [\"bar\", \"preference_chart\", \"quantity_bar_proportion\"],\n                           \"Utility\": [\"bar\", \"quantity_bar_gradient\", \"quantity_bar_proportion\", \"quantity_bar_choice\"],\n                           \"Mandatory\": [\"dot\"], \"Desired\": [\"dot\"], \"Permitted\": [\"dot\"],\n                           \"Tier 1\": [\"dot\"], \"Tier 2\": [\"dot\"], \"Tier 3\": [\"dot\"], \"Tier 4\": [\"dot\"],\n                           \"Norm Score\": [\"dot\", \"quantity_bar_proportion\", \"bar\", 'quantity_bar_choice'],\n                           'Extra': ['Race Chart', 'Race Chart_proportion', 'Gender Chart', 'SOC Chart',\n                                     'Ethnicity Chart', 'Gender Chart_proportion', 'SOC Chart_proportion',\n                                     'Ethnicity Chart_proportion']}\n\n    # Colors for the various bar types:\n    colors = {\n\n        # Cadet Preference Charts\n        \"top_choices\": \"#5490f0\", \"mid_choices\": \"#eef09e\", \"bottom_choices\": \"#f25d50\",\n        \"Volunteer\": \"#5490f0\", \"Non-Volunteer\": \"#f25d50\", \"Top 6 Choices\": \"#5490f0\", \"7+ Choice\": \"#f25d50\",\n\n        # Quartile Charts\n        \"quartile_1\": \"#373aed\", \"quartile_2\": \"#0b7532\", \"quartile_3\": \"#d1bd4d\", \"quartile_4\": \"#cc1414\",\n\n        # AFOCD Charts\n        \"Mandatory\": \"#311cd4\", \"Desired\": \"#085206\", \"Permitted\": \"#bda522\", \"Ineligible\": \"#f25d50\",\n\n        # Cadet Demographics\n        \"male\": \"#6531d6\", \"female\": \"#73d631\", \"usafa\": \"#5ea0bf\", \"rotc\": \"#cc9460\", \"ots\": \"green\",  # TODO: change\n        \"minority\": \"#eb8436\",\n        \"non-minority\": \"#b6eb6c\",\n\n        # Misc. AFSC Criteria  #cdddf7\n        \"large_afscs\": \"#060d47\", \"small_afscs\": \"#3287cd\", \"merit_above\": \"#c7b93a\", \"merit_within\": \"#3d8ee0\",\n        \"merit_below\": \"#bf4343\", \"large_within\": \"#3d8ee0\", \"large_else\": \"#c7b93a\",\n\n        # Utility Chart Colors\n        \"Utility Ascribed\": \"#4793AF\", \"Normalized Rank\": \"#FFC470\", \"Not Bottom 3\": \"#DD5746\",\n        \"Not Last Choice\": \"#8B322C\",\n\n        # PGL Charts\n        \"pgl\": \"#5490f0\", \"surplus\": \"#eef09e\", \"failed_pgl\": \"#f25d50\",\n\n        # Race Colors\n        \"American Indian/Alaska Native\": \"#d46013\", \"American Indian or Alaska Native\": \"#d46013\",\n        \"Asian\": \"#3ad413\",\n        \"Black or African American\": \"#1100ff\", \"Native Hawaiian/Pacific Islander\": \"#d4c013\",\n        \"Native Hawaiian or Other Pacific Islander\": \"#d4c013\",\n        \"Two or more races\": \"#ff0026\", \"Unknown\": \"#27dbe8\", \"White\": \"#a3a3a2\",\n\n        # Gender/SOC written differently (need to fix this later)\n        \"Male\": \"#6531d6\", \"Female\": \"#73d631\", \"USAFA\": \"#5ea0bf\", \"ROTC\": \"#cc9460\", \"OTS\": \"green\",  # TODO: Change\n\n        # Accessions group colors\n        \"All Cadets\": \"#000000\", \"Rated\": \"#ff0011\", \"USSF\": \"#0015ff\", \"NRL\": \"#000000\",\n\n        \"Hispanic or Latino\": \"#66d4ce\", \"Not Hispanic\": \"#e09758\", \"Not Hispanic or Latino\": \"#e09758\",\n        \"Unknown Ethnicity\": \"#9e9e9e\"\n\n    }\n\n    # Animation Colors\n    choice_colors = {1: '#3700ff', 2: '#008dff', 3: '#00e7ff', 4: '#00FF93', 5: '#17FF00',  # #00ff04\n                     6: '#BDFF00', 7: '#FFFF00', 8: '#FFCD00', 9: '#FF8700', 10: '#FF5100'}\n    mdl_p['all_other_choice_colors'] = '#FF0000'\n    mdl_p['choice_colors'] = choice_colors\n    mdl_p['interest_colors'] = {'High': '#3700ff', 'Med': '#dad725', 'Low': '#ff9100', 'None': '#ff000a'}\n    mdl_p['reserved_slot_color'] = \"#ac9853\"\n    mdl_p['matched_slot_color'] = \"#3700ff\"\n    mdl_p['unfocused_color'] = \"#aaaaaa\"\n    mdl_p['unmatched_color'] = \"#aaaaaa\"\n    mdl_p['exception_edge'] = \"#FFD700\"\n    mdl_p['base_edge'] = 'black'\n\n    # Add these elements to the main dictionary\n    mdl_p[\"afsc_chart_versions\"] = afsc_chart_versions\n    mdl_p[\"bar_colors\"] = colors\n\n    # Value Function Chart parameters\n    mdl_p['ValueFunctionChart'] = {'x_pt': None, 'y_pt': None, 'title': None, 'display_title': True, 'figsize': (10, 10),\n                                   'facecolor': 'white', 'save': True, 'breakpoints': None, 'x_ticks': None,\n                                   'crit_point': None, 'label_size': 25, 'yaxis_tick_size': 25, 'xaxis_tick_size': 25,\n                                   'x_label': None, 'filepath': None, 'graph_color': 'black', 'breakpoint_color': 'black'}\n\n    return mdl_p\n</code></pre>"},{"location":"reference/data/support/#data.support.determine_afsc_plot_details","title":"<code>determine_afsc_plot_details(instance, results_chart=False)</code>","text":"<p>Takes in the problem instance object and alters the plot parameters based on the kind of chart being generated as well as the type of data we're looking at</p> Source code in <code>afccp/data/support.py</code> <pre><code>def determine_afsc_plot_details(instance, results_chart=False):\n    \"\"\"\n    Takes in the problem instance object and alters the plot parameters based on the kind of chart\n    being generated as well as the type of data we're looking at\n    \"\"\"\n\n    # Shorthand\n    p, mdl_p = instance.parameters, instance.mdl_p\n\n    # Get list of AFSCs we're showing\n    mdl_p = determine_afscs_in_image(p, mdl_p)\n\n    # Determine if we are \"skipping\" AFSC labels in the x-axis\n    if mdl_p[\"skip_afscs\"] is None:\n        if instance.data_variant == \"Year\" or \"CTGAN\" in instance.data_name:  # Real AFSCs don't get skipped!\n            mdl_p[\"skip_afscs\"] = False\n        else:\n            if mdl_p[\"M\"] &lt; p['M']:\n                mdl_p[\"skip_afscs\"] = False\n            else:  # \"C2, C4, C6\" could be appropriate\n                mdl_p[\"skip_afscs\"] = True\n\n    # Determine if we are rotating the AFSC labels in the x-axis\n    if mdl_p[\"afsc_rotation\"] is None:\n        if mdl_p[\"skip_afscs\"]:  # If we skip the AFSCs, then we don't rotate them\n            mdl_p[\"afsc_rotation\"] = 0\n        else:\n\n            # We're not skipping the AFSCs, but we could rotate them\n            if instance.data_variant == \"Year\" or \"CTGAN\" in instance.data_name:\n                if mdl_p['M'] &gt; 32:\n                    mdl_p[\"afsc_rotation\"] = 80\n                elif mdl_p[\"M\"] &gt; 18:\n                    mdl_p[\"afsc_rotation\"] = 45\n                else:\n                    mdl_p[\"afsc_rotation\"] = 0\n            else:\n                if mdl_p[\"M\"] &lt; 25:\n                    mdl_p[\"afsc_rotation\"] = 0\n                else:\n                    mdl_p[\"afsc_rotation\"] = 45\n\n    # Get AFSC\n    if mdl_p[\"afsc\"] is None:\n        mdl_p[\"afsc\"] = p['afscs'][0]\n\n    # Get AFSC index\n    j = np.where(p[\"afscs\"] == mdl_p[\"afsc\"])[0][0]\n\n    # Get objective\n    if mdl_p[\"objective\"] is None:\n        k = instance.value_parameters[\"K^A\"][j][0]\n        mdl_p[\"objective\"] = instance.value_parameters['objectives'][k]\n\n    # Figure out which solutions to show, what the colors/markers are going to be, and some error data\n    if results_chart:\n\n        # Only applies to AFSC charts\n        if mdl_p[\"results_graph\"] in [\"Measure\", \"Value\"]:\n            if mdl_p[\"objective\"] not in mdl_p[\"afsc_chart_versions\"]:\n                raise ValueError(\"Objective \" + mdl_p[\"objective\"] +\n                                 \" does not have any charts available\")\n\n            if mdl_p[\"version\"] not in mdl_p[\"afsc_chart_versions\"][mdl_p[\"objective\"]]:\n\n                if not mdl_p[\"compare_solutions\"]:\n                    raise ValueError(\"Objective '\" + mdl_p[\"objective\"] +\n                                     \"' does not have chart version '\" + mdl_p[\"version\"] + \"'.\")\n\n            if mdl_p[\"objective\"] == \"Norm Score\" and mdl_p[\"version\"] == \"quantity_bar_proportion\":\n                if \"afsc_utility\" not in p:\n                    raise ValueError(\"The AFSC Utility matrix is needed for the Norm Score \"\n                                     \"'quantity_bar_proportion' chart. \")\n\n        if mdl_p[\"solution_names\"] is None:\n\n            # Default to the current active solutions\n            mdl_p[\"solution_names\"] = list(instance.solutions.keys())\n            num_solutions = len(mdl_p[\"solution_names\"])  # Number of solutions in dictionary\n\n            # Get number of solutions\n            if mdl_p[\"num_solutions\"] is None:\n                mdl_p[\"num_solutions\"] = num_solutions\n\n            # Can't have more than 4 solutions\n            if num_solutions &gt; 4:\n                mdl_p[\"num_solutions\"] = 4\n                mdl_p[\"solution_names\"] = list(instance.solutions.keys())[:4]\n\n        else:\n            mdl_p[\"num_solutions\"] = len(mdl_p[\"solution_names\"])\n            if mdl_p[\"num_solutions\"] &gt; 4 and mdl_p[\"results_graph\"] != \"Multi-Criteria Comparison\":\n                raise ValueError(\"Error. Can't have more than 4 solutions shown in the results plot.\")\n\n        # Don't need to do this for the Multi-Criteria Comparison chart\n        if mdl_p[\"results_graph\"] != \"Multi-Criteria Comparison\":\n\n            # Load in the colors and markers for each of the solutions\n            mdl_p[\"colors\"], mdl_p[\"markers\"], mdl_p[\"zorder\"] = {}, {}, {}\n            for s, solution in enumerate(mdl_p[\"solution_names\"]):\n                mdl_p[\"colors\"][solution] = mdl_p[\"color_choices\"][s]\n                mdl_p[\"markers\"][solution] = mdl_p[\"marker_choices\"][s]\n                mdl_p[\"zorder\"][solution] = mdl_p[\"zorder_choices\"][s]\n\n            # This only applies to the Merit and USAFA proportion objectives\n            if mdl_p[\"version\"] == \"large_only_bar\":\n                mdl_p[\"all_afscs\"] = False\n            else:\n                mdl_p[\"all_afscs\"] = True\n\n        # Value Parameters\n        if mdl_p[\"vp_name\"] is None:\n            mdl_p[\"vp_name\"] = instance.vp_name\n\n    return mdl_p\n</code></pre>"},{"location":"reference/data/support/#data.support.determine_afscs_in_image","title":"<code>determine_afscs_in_image(p, mdl_p)</code>","text":"<p>This function determines which AFSCs were solved for and which AFSCs should be in the visualization</p> Source code in <code>afccp/data/support.py</code> <pre><code>def determine_afscs_in_image(p, mdl_p):\n    \"\"\"\n    This function determines which AFSCs were solved for and which AFSCs should be in the visualization\n    \"\"\"\n\n    # Determine what AFSCs we solved for\n    if mdl_p['afscs_solved_for'] == 'All':\n        mdl_p['afscs_in_solution'] = p['afscs'][:p['M']]  # All AFSCs (without unmatched)\n    else:\n\n        # We solved for some subset of Rated, NRL, or USSF AFSCs\n        mdl_p['afscs_in_solution'] = []\n        for acc_grp in ['Rated', 'NRL', 'USSF']:\n\n            # If this accessions group was specified by the user\n            if acc_grp in mdl_p['afscs_solved_for']:\n\n                # Make sure this is an accessions group for which we have data\n                if acc_grp in p['afscs_acc_grp']:\n\n                    # Add each of these AFSCs to the list\n                    for afsc in p['afscs_acc_grp'][acc_grp]:\n                        mdl_p['afscs_in_solution'].append(afsc)\n\n                # We don't have data on this group\n                else:\n                    raise ValueError(\n                        \"Error. Accessions group '\" + str(acc_grp) + \"' not found in this problem instance.\")\n        mdl_p['afscs_in_solution'] = np.array(mdl_p['afscs_in_solution'])  # Convert to numpy array\n\n    # Now Determine what AFSCs we want to show in this visualization (must be a subset of AFSCs in the solution)\n    if mdl_p['afscs_to_show'] == 'All':\n        mdl_p['afscs'] = mdl_p['afscs_in_solution']  # All AFSCs that we solved for\n\n    # If the user still supplied a string, we know we're looking for the three accessions groups\n    elif type(mdl_p['afscs_to_show']) == str:\n\n        # Loop through each of the three groups\n        mdl_p['afscs'] = []\n        for acc_grp in ['Rated', 'NRL', 'USSF']:\n\n            # If this accessions group was specified by the user\n            if acc_grp in mdl_p['afscs_to_show']:\n\n                # Make sure this is an accessions group for which we have data\n                if acc_grp in p['afscs_acc_grp']:\n\n                    # Add each of these AFSCs to the list if they were also in the list of AFSCs we solved for\n                    for afsc in p['afscs_acc_grp'][acc_grp]:\n                        if afsc in mdl_p['afscs_in_solution']:\n                            mdl_p['afscs'].append(afsc)\n\n                # We don't have data on this group\n                else:\n                    raise ValueError(\n                        \"Error. Accessions group '\" + str(acc_grp) + \"' not found in this problem instance.\")\n        mdl_p['afscs'] = np.array(mdl_p['afscs'])  # Convert to numpy array\n\n    # The user supplied a list of AFSCs\n    else:\n\n        # Loop through each AFSC in the supplied list and add it if it is also in the list of AFSCs we solved for\n        mdl_p['afscs'] = []\n        for afsc in mdl_p['afscs_to_show']:\n            if afsc in mdl_p['afscs_in_solution']:\n                mdl_p['afscs'].append(afsc)\n        mdl_p['afscs'] = np.array(mdl_p['afscs'])  # Convert to numpy array\n\n    # New set of AFSC indices\n    mdl_p['J'] = np.array([np.where(p['afscs'] == afsc)[0][0] for afsc in mdl_p['afscs']])\n    mdl_p['M'] = len(mdl_p['J'])\n\n    # Determine if we only want to view smaller AFSCs (those with fewer eligible cadets than the specified limit)\n    if mdl_p[\"eligibility_limit\"] is not None:\n\n        # Update set of AFSCs\n        mdl_p['J'] = np.array([j for j in mdl_p['J'] if len(p['I^E'][j]) &lt;= mdl_p[\"eligibility_limit\"]])\n        mdl_p['afscs'] = np.array([p['afscs'][j] for j in mdl_p['J']])\n        mdl_p['M'] = len(mdl_p['J'])\n    else:\n        mdl_p[\"eligibility_limit\"] = p['N']\n\n    return mdl_p\n</code></pre>"},{"location":"reference/data/support/#data.support.pick_most_changed_afscs","title":"<code>pick_most_changed_afscs(instance)</code>","text":"<p>Checks the specified solutions for the instance \"Multi-Criteria Comparison\" chart and determines which AFSCs change the most in the solution based on the cadets that are assigned.</p> Source code in <code>afccp/data/support.py</code> <pre><code>def pick_most_changed_afscs(instance):\n    \"\"\"\n    Checks the specified solutions for the instance \"Multi-Criteria Comparison\" chart and determines which\n    AFSCs change the most in the solution based on the cadets that are assigned.\n    \"\"\"\n\n    # Get necessary info\n    p = instance.parameters\n    assigned_cadets = {}\n    max_assigned = np.zeros(p[\"M\"])\n    solution_names = instance.mdl_p[\"solution_names\"]\n\n    # Loop through each solution to get the max number of cadets assigned to each AFSC across each solution\n    for solution_name in solution_names:\n        solution = instance.solutions[solution_name]\n        assigned_cadets[solution_name] = {j: np.where(solution['j_array'] == j)[0] for j in p[\"J\"]}\n        num_assigned = np.array([len(assigned_cadets[solution_name][j]) for j in p[\"J\"]])\n        max_assigned = np.array([max(max_assigned[j], num_assigned[j]) for j in p[\"J\"]])\n\n    # Loop through each AFSC to get the number of cadets shared across each solution for each AFSC\n    shared_cadet_count = np.zeros(p[\"M\"])\n    for j in p[\"J\"]:\n\n        # Pick the first solution as a baseline\n        baseline_cadets = assigned_cadets[solution_names[0]][j]\n\n        # Loop through each cadet assigned to this AFSC in the \"baseline\" solution\n        for i in baseline_cadets:\n\n            # Check if the cadet is assigned to this AFSC in all solutions\n            cadet_in_each_solution = True\n            for solution_name in solution_names:\n                if i not in assigned_cadets[solution_name][j]:\n                    cadet_in_each_solution = False\n                    break\n\n            # If the cadet is assigned in all solutions, we add one to the shared count\n            if cadet_in_each_solution:\n                shared_cadet_count[j] += 1\n\n    # The difference between the maximum number of cadets assigned to a given AFSC across all solutions and the number\n    # of cadets that are common to said AFSC across all solutions is our \"Delta\"\n    delta_afsc = max_assigned - shared_cadet_count\n\n    # Return the AFSCs that change the most\n    indices = np.argsort(delta_afsc)[::-1]\n    afscs = p[\"afsc_vector\"][indices][:instance.mdl_p[\"num_afscs_to_compare\"]]\n    return afscs\n</code></pre>"},{"location":"reference/data/support/#data.support.cip_to_qual_tiers","title":"<code>cip_to_qual_tiers(afscs, cip1, cip2=None, cip3=None, business_hours=None, true_tiers=True)</code>","text":"<p>Generate qualification tiers for cadets based on their CIP codes and AFSCs.</p> <p>AFOCD c/ao Oct '23</p> <p>This function calculates qualification tiers for a list of cadets based on their CIP (Classification of Instructional Programs) codes and the specified AFSCs. The qualification tiers consider both tier and requirement (e.g., M1, D2).</p> <p>Args:     afscs (list of str): A list of Air Force Specialty Codes (AFSCs) to determine cadet qualifications for.     cip1 (numpy array): A numpy array containing CIP codes for the primary degrees of the cadets.     cip2 (numpy array, optional): A numpy array containing CIP codes for the secondary degrees of the cadets.     cip3 (numpy array, optional): A numpy array containing CIP codes for a third \"source of truth\".     business_hours (numpy array, optional): An array indicating the number of business hours each cadet works.     true_tiers (bool, optional): Set to True to use more accurate qualification tiers (as of June 2023).</p> <p>Returns:     numpy array: A qualification matrix representing the qualification tiers for each cadet and AFSC.</p> <p>Details: - The function calculates qualification tiers for both primary and, if specified, secondary degrees of the cadets. - The qualification tiers are generated based on the CIP codes and the specified AFSCs. - The <code>true_tiers</code> parameter allows you to choose between more accurate tiers (as of June 2023) or the   official tiers defined in the AFOCD (Air Force Officer Classification Directory). ```</p> Source code in <code>afccp/data/support.py</code> <pre><code>def cip_to_qual_tiers(afscs, cip1, cip2=None, cip3=None, business_hours=None, true_tiers=True):\n    \"\"\"\n    Generate qualification tiers for cadets based on their CIP codes and AFSCs.\n\n    AFOCD c/ao Oct '23\n\n    This function calculates qualification tiers for a list of cadets based on their CIP (Classification of Instructional\n    Programs) codes and the specified AFSCs. The qualification tiers consider both tier and requirement (e.g., M1, D2).\n\n    Args:\n        afscs (list of str): A list of Air Force Specialty Codes (AFSCs) to determine cadet qualifications for.\n        cip1 (numpy array): A numpy array containing CIP codes for the primary degrees of the cadets.\n        cip2 (numpy array, optional): A numpy array containing CIP codes for the secondary degrees of the cadets.\n        cip3 (numpy array, optional): A numpy array containing CIP codes for a third \"source of truth\".\n        business_hours (numpy array, optional): An array indicating the number of business hours each cadet works.\n        true_tiers (bool, optional): Set to True to use more accurate qualification tiers (as of June 2023).\n\n    Returns:\n        numpy array: A qualification matrix representing the qualification tiers for each cadet and AFSC.\n\n    Details:\n    - The function calculates qualification tiers for both primary and, if specified, secondary degrees of the cadets.\n    - The qualification tiers are generated based on the CIP codes and the specified AFSCs.\n    - The `true_tiers` parameter allows you to choose between more accurate tiers (as of June 2023) or the\n      official tiers defined in the AFOCD (Air Force Officer Classification Directory).\n    ```\n    \"\"\"\n\n    # AFOCD CLASSIFICATION\n    N = len(cip1)  # Number of Cadets\n    M = len(afscs)  # Number of AFSCs we're building the qual matrix for\n\n    # Dictionary of CIP codes\n    cips = {1: cip1, 2: cip2, 3: cip3}\n\n    # List of CIP degrees that are not empty\n    degrees = []\n    for d in cips:\n        if cips[d] is not None:\n            degrees.append(d)\n\n    # Initialize qual dictionary\n    qual = {}\n\n    # Loop through both sets of degrees (if applicable)\n    for d in degrees:\n\n        # Initialize qual matrix (for this set of degrees)\n        qual[d] = np.array([[\"I5\" for _ in range(M)] for _ in range(N)])\n\n        # Loop through each cadet and AFSC pair\n        for i in range(N):\n            cip = str(cips[d][i])\n            cip = \"0\" * (6 - len(cip)) + cip\n            for j, afsc in enumerate(afscs):\n\n                # Rated Career Fields\n                if afsc in [\"11U\", \"11XX\", \"12XX\", \"13B\", \"18X\", \"92T0\", \"92T1\", \"92T2\", \"92T3\",\n                            \"11XX_R\", \"11XX_U\", \"11XX_O\", \"USSF\", \"USSF_U\", \"USSF_R\"]:\n                    qual[d][i, j] = \"P1\"\n\n                # Aerospace Physiologist\n                elif afsc == '13H':  # Proportions/Degrees Updated Oct '23\n                    if cip in ['302701', '260912', '310505', '260908', '260707', '260403']:\n                        qual[d][i, j] = 'M1'\n                    elif cip in ['290402', '261501', '422813'] or cip[:4] in ['2609']:\n                        qual[d][i, j] = 'P2'\n                    else:\n                        qual[d][i, j] = 'I3'\n\n                # Airfield Ops\n                elif afsc == '13M':  # Proportions Updated Oct '23\n                    if cip == '290402' or cip[:4] == '4901':\n                        qual[d][i, j] = 'D1'\n                    elif cip[:4] in ['5201', '5202', '5206', '5207', '5211', '5212', '5213',\n                                     '5214', '5218', '5219', '5220']:\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'P3'\n\n                # Nuclear and Missile Operations\n                elif afsc == '13N':  # Updated Oct '23\n                    qual[d][i, j] = 'P1'\n\n                # Space Operations\n                elif afsc in ['13S', '13S1S']:\n                    m_list4 = ['1402', '1410', '1419', '1427', '4002']\n                    d_list4 = ['1101', '1102', '1104', '1105', '1107', '1108', '1109', '1110', '1404', '1406', '1407',\n                               '1408', '1409', '1411', '1412', '1413', '1414', '1418', '1420', '1423', '1432', '1435',\n                               '1436', '1437', '1438', '1439', '1441', '1442', '1444', '3006', '3008', '3030', '4008']\n                    d_list6 = ['140101', '290203', '290204', '290205', '290207', '290301', '290302', '290304']\n                    if cip[:4] in m_list4 or cip[:2] == '27' or cip == '290305':\n                        qual[d][i, j] = 'M1'\n                    elif cip[:4] in d_list4 or cip in d_list6:\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'P3'\n\n                # Information Operations\n                elif afsc == '14F':\n                    m_list4 = ['3017', '4201', '4227', '4511']\n                    d_list4 = ['5214', '3023', '3026']\n                    p_list4 = ['4509', '4502', '3025', '0901']\n                    if cip[:4] in m_list4:\n                        qual[d][i, j] = 'M1'\n                    elif cip[:4] in d_list4 or cip in [\"090902\", \"090903\", \"090907\"]:\n                        qual[d][i, j] = 'D2'\n                    elif cip[:4] in p_list4:\n                        qual[d][i, j] = 'P3'\n                    else:\n                        qual[d][i, j] = 'I4'\n\n                # Intelligence\n                elif afsc in ['14N', '14N1S']:\n                    m_list2 = ['05', '16', '22', '24', '28', '29', '45', '54']\n                    d_list2 = ['13', '09', '23', '28', '29', '30', '35', '38', '42', '43', '52']\n                    if cip[:2] in ['11', '14', '27', '40'] or cip == '307001':\n                        qual[d][i, j] = 'M1'\n                    elif cip[:2] in m_list2 or cip == '301701':\n                        qual[d][i, j] = 'M2'\n                    elif cip[:2] in d_list2 or cip == '490101':\n                        qual[d][i, j] = 'D3'\n                    else:\n                        qual[d][i, j] = 'P4'\n\n                # Operations Research Analyst\n                elif afsc in ['15A', '61A']:\n                    m_list4 = ['1437', '1435', '3070', '3030', '3008']\n                    if cip[:4] in m_list4 or cip[:2] == '27' or cip == '110102':\n                        qual[d][i, j] = 'M1'\n                    elif cip in ['110804', '450603'] or cip[:4] in ['1427', '1107', '3039', '3049']:\n                        qual[d][i, j] = 'D2'\n                    elif (cip[:2] == '14' and cip != '140102') or cip[:4] in ['4008', '4506', '2611', '3071', '5213']:\n                        qual[d][i, j] = 'P3'\n                    else:\n                        qual[d][i, j] = 'I4'\n\n                # Weather and Environmental Sciences (Current a/o Apr '24 AFOCD)\n                elif afsc == '15W':\n                    if cip[:4] == '4004':\n                        qual[d][i, j] = 'M1'\n                    elif cip in ['270301', '270303', '270304', '303501', '303001', '140802',\n                                 '303801', '141201', '141301', '400601', '400605', '400607', '400801', '400805',\n                                 '400806', '400807', '400809']:\n                        qual[d][i, j] = 'P2'\n                    elif cip[:2] in ['40'] or cip in ['040999', '030104', '110102', '110101', '110803', '110201',\n                                                      '110701', '110802', '110104', '110804']:\n                        qual[d][i, j] = 'P3'\n\n                    else:\n                        qual[d][i, j] = 'I4'\n\n                # Cyberspace Operations\n                elif afsc in ['17D', '17S', '17X', '17S1S']:\n                    m_list6 = ['150303', '151202', '290207', '303001', '307001', '270103', '270303', '270304']\n                    d_list4 = ['1503', '1504', '1508', '1512', '1514', '4008', '4005']\n                    if cip[:4] in ['3008', '3016', '5212'] or cip in m_list6 or \\\n                            (cip[:2] == '11' and cip[:4] not in ['1103', '1106']) or (\n                            cip[:2] == '14' and cip != '140102'):\n                        qual[d][i, j] = 'M1'\n                    elif cip[:4] in d_list4 or cip[:2] == '27':\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'P3'\n\n                # Aircraft Maintenance\n                elif afsc == '21A':  # Proportions Updated Oct '23\n                    d_list4 = ['5202', '5206', '1101', '1102', '1103', '1104', '1107', '1110', '5212']\n                    if cip[:2] == '14':\n                        qual[d][i, j] = 'D1'\n                    elif cip[:4] in d_list4 or cip[:2] == '40' or cip in ['151501', '520409', '490104', '490101']:\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'P3'\n\n                # Munitions and Missile Maintenance\n                elif afsc == '21M':  # Proportions Updated Oct '23\n                    d_list4 = ['1107', '1101', '1110', '5202', '5206', '5213']\n                    d_list2 = ['27', '40']\n\n                    # Added \"Data Processing\" (no CIPs in AFOCD, and others are already captured in other tiers)\n                    d_list6 = ['290407', '290408', '151501', '520409', \"110301\"]\n                    if cip[:2] == \"14\":\n                        qual[d][i, j] = 'D1'\n                    elif cip[:2] in d_list2 or cip[:4] in d_list4 or cip in d_list6:\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'P3'\n\n                # Logistics Readiness: Conversations w/CFMs changed this!\n                elif afsc == '21R':\n                    if true_tiers:  # More accurate than current AFOCD a/o Oct '23\n                        cip_list = ['520203', '520409', '142501', '490199', '520209', '499999', '521001', '520201',\n                                    '140101', '143501', '280799', '450601', '520601', '520304', '520899', '520213',\n                                    '520211', '143701', '110802']\n                        if cip in cip_list:\n                            qual[d][i, j] = 'D1'\n                        else:\n                            qual[d][i, j] = 'P2'\n                    else:\n                        d_list4 = ['1101', '1102', '1103', '1104', '1107', '1110', '4506', '5202', '5203', '5206',\n                                   '5208']\n                        d_list6 = ['151501', '490101', '520409']\n\n                        # Added Ops Research and Data Processing (no CIPs in AFOCD)\n                        d_list6_add = ['143701', '110301']\n                        if cip[:4] in ['1425', '1407']:\n                            qual[d][i, j] = 'D1'\n                        elif cip[:4] in d_list4 or cip in d_list6 or cip in d_list6_add or cip[:3] == \"521\":\n                            qual[d][i, j] = 'D2'\n                        else:\n                            qual[d][i, j] = 'P3'\n\n                # Security Forces\n                elif afsc == '31P':  # Updated Oct '23\n                    qual[d][i, j] = 'P1'\n\n                # Civil Engineering: Architect/Architectural Engineer\n                elif afsc == '32EXA':\n                    if cip[:4] == '0402' or cip in ['140401']:  # Sometimes 402010 is included\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Civil Engineering: Civil Engineer\n                elif afsc == '32EXC':\n                    if cip[:4] == '1408':\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Civil Engineering: Electrical Engineer  *added 1447 per CFM conversation 2 Jun '23\n                elif afsc == '32EXE':\n                    if cip[:4] in ['1410', '1447']:\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Civil Engineering: Mechanical Engineer\n                elif afsc == '32EXF':\n                    if cip == '141901':\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Civil Engineering: General Engineer  *Updated AFOCD a/o 30 Apr '23 w/further adjustments a/o 2 Jun '23\n                elif afsc == '32EXG':\n                    if cip[:4] in ['1408', '1410'] or cip in ['140401', '141401', '141901', '143301', '143501',\n                                                              '144701']:\n                        qual[d][i, j] = 'M1'\n                    elif cip in [\"140701\"] or cip[:4] in [\"1405\", \"1425\", \"1402\", \"5220\", '1510']:  # added 1510\n                        qual[d][i, j] = 'D2'  # FY23 added a desired tier to 32EXG!\n                    else:\n                        qual[d][i, j] = 'I3'\n\n                # Civil Engineering: Environmental Engineer\n                elif afsc == '32EXJ':\n                    if cip == '141401':\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Public Affairs\n                elif afsc == '35P':\n                    if cip[:2] == '09':\n                        qual[d][i, j] = 'M1'\n                    elif cip[:4] in ['2313', '4509', '4510', '5214'] or cip[:2] == '42':\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'P3'\n\n                # Force Support\n                elif afsc in ['38F', '38P']:  # Updated Oct '24\n                    d_list4 = ['4404', '5202', '5210', '5214']\n                    if cip[:4] == ['4506', '3017'] or cip in ['143701', '520213']:\n                        qual[d][i, j] = 'M1'\n                    elif cip[:2] == ['13', '27', '42'] or cip[:4] in d_list4 or cip in ['301701', '450901',\n                                                                                        '520304', '520901']:\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'P3'\n\n                # Old 14F (Information Operations)\n                elif afsc == '61B':\n                    m_list4 = ['3017', '4502', '4511', '4513', '4514', '4501']\n                    if cip[:2] == '42' or cip[:4] in m_list4 or cip in ['450501', '451201']:\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Chemist/Nuclear Chemist\n                elif afsc == '61C':\n                    d_list6 = ['140601', '141801', '143201', '144301', '144401', '260299']\n                    if cip[:4] in ['1407', '4005'] or cip in ['260202', '260205']:\n                        qual[d][i, j] = 'M1'\n                    elif cip in d_list6 or cip[:5] == '26021' or cip[:4] == '4010':\n                        qual[d][i, j] = 'D2'\n                    elif cip in ['140501', '142001', '142501', '144501']:\n                        qual[d][i, j] = 'P3'\n                    else:\n                        qual[d][i, j] = 'I4'\n\n                # Physicist/Nuclear Engineer\n                elif afsc == '61D':\n                    if cip[:4] in ['1412', '1423', '4002', '4008']:\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Developmental Engineering: Aeronautical Engineer\n                elif afsc in ['62EXA', '62E1A1S']:\n                    if cip[:4] == '1402':\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Developmental Engineering: Astronautical Engineer\n                elif afsc in ['62EXB', '62E1B1S']:\n                    if cip[:4] == '1402':\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Developmental Engineering: Computer Systems Engineer\n                elif afsc in ['62EXC', '62E1C1S']:  # Updated Oct '24\n                    if cip[:4] == '1409':\n                        qual[d][i, j] = 'M1'\n                    elif cip[:4] == '1101' or cip == '110701':\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'I3'\n\n                # Developmental Engineering: Electrical/Electronic Engineer\n                elif afsc in ['62EXE', '62E1E1S']:\n                    if cip[:4] in ['1410', '1447']:\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Developmental Engineering: Flight Test Engineer\n                elif afsc == '62EXF':\n                    if cip[:2] in ['27', '40'] or (cip[:2] == '14' and cip != '140102'):\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Developmental Engineering: Project/General Engineer\n                elif afsc in ['62EXG', '62E1G1S']:  # Updated Oct '24\n                    if cip[:2] == '14' and cip not in ['140102', '141001', '144701'] and cip[:4] not in [\"1437\",\n                                                                                                         \"1408\"]:\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Developmental Engineering: Mechanical Engineer\n                elif afsc in ['62EXH', '62E1H1S']:  # Updated Oct '24\n                    if cip[:4] == '1419':  # and cip != '141901': (Is this a mistake? 141901 seems to be popular among\n                        qual[d][i, j] = 'M1'  # cadets that want this AFSC)\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Developmental Engineering: Systems/Human Factors Engineer\n                elif afsc in ['62EXI', '62EXS', '62E1I1S']:\n                    if cip[:4] in ['1427', '1435']:\n                        qual[d][i, j] = 'M1'\n                    else:\n                        qual[d][i, j] = 'I2'\n\n                # Acquisition Manager\n                elif afsc in ['63A', '63A1S']:\n                    if cip[:2] in ['14', '40']:\n                        qual[d][i, j] = 'M1'\n                    elif cip[:2] in ['11', '27'] or cip[:4] == '4506' or (cip[:2] == '52' and cip[:4] != '5204'):\n                        qual[d][i, j] = 'D2'\n                    else:\n                        if business_hours is not None:\n                            if business_hours[i] &gt;= 24:\n                                qual[d][i, j] = 'P3'\n                            else:\n                                qual[d][i, j] = 'I4'\n                        else:\n                            qual[d][i, j] = 'P3'\n\n                # Contracting\n                elif afsc == '64P':\n                    d_list2 = ['28', '44', '54', '16', '23', '05', '42']\n                    if cip[:2] == \"52\":\n                        qual[d][i, j] = 'D1'\n                    elif cip[:2] in ['14', '15', '26', '27', '29', '40', '41']:\n                        qual[d][i, j] = 'D2'\n                    elif cip[:2] in d_list2 or (cip[:2] == '45' and cip[:4] != '4506') or \\\n                            cip[:4] in ['2200', '2202'] or cip == '220101':\n                        qual[d][i, j] = 'D3'\n                    else:\n                        qual[d][i, j] = 'P4'\n\n                # Financial Management\n                elif afsc == '65F':\n                    if cip[:4] in ['4506', '5203', '5206', '5213', '5208']:\n                        qual[d][i, j] = 'D1'\n                    elif cip[:2] in ['27', '52', '14']:\n                        qual[d][i, j] = 'D2'\n                    else:\n                        qual[d][i, j] = 'P3'\n\n                # This shouldn't happen... but here's some error checking!\n                else:\n                    raise ValueError(\"Error. AFSC '\" + str(afsc) + \"' not a valid AFSC that this code recognizes.\")\n\n    # If no other CIP list is specified, we just take the qual matrix from the first degrees\n    if len(degrees) == 1:\n        qual_matrix = copy.deepcopy(qual[1])\n\n    # If CIP2 is specified, we take the highest tier that the cadet qualifies for\n    else:\n        qual_matrix = np.array([[\"I5\" for _ in range(M)] for _ in range(N)])\n\n        # Loop though each cadet and AFSC pair\n        for i in range(N):\n            for j in range(M):\n\n                # Get degree tier qualifications from both degrees\n                qual_1 = qual[1][i, j]\n                qual_2 = qual[2][i, j]\n\n                if cip3 is not None:\n                    qual_3 = qual[3][i, j]\n                else:\n                    qual_3 = \"I9\"  # Dummy value\n\n                # Determine which qualification is best\n                if int(qual_1[1]) &lt; int(qual_2[1]):  # D1 beats D2\n                    if int(qual_1[1]) &lt; int(qual_3[1]): # D1 beats D3\n                        qual_matrix[i, j] = qual_1  # Qual 1 wins!\n                    else:  # D3 beats D1\n                        qual_matrix[i, j] = qual_3  # Qual 3 wins!\n                else:  # D2 beats D1\n                    if int(qual_2[1]) &lt; int(qual_3[1]):  # D2 beats D3\n                        qual_matrix[i, j] = qual_2  # Qual 2 wins!\n                    else:  # D3 beats D2\n                        qual_matrix[i, j] = qual_3  # Qual 3 wins!\n\n    return qual_matrix\n</code></pre>"},{"location":"reference/data/values/","title":"Values","text":""},{"location":"reference/data/values/#data.values","title":"<code>data.values</code>","text":""},{"location":"reference/data/values/#data.values.value_parameters_sets_additions","title":"<code>value_parameters_sets_additions(parameters, value_parameters, printing=False)</code>","text":"<p>Creates subsets for AFSCs and objectives to distinguish which AFSCs care about which objectives so that we don't have to calculate every value only to multiply them by zero.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <p>model fixed parameters</p> required <code>value_parameters</code> <p>model weight/value parameters</p> required <code>printing</code> <p>whether the procedure should print something</p> <code>False</code> <p>Returns:</p> Type Description <p>updated value parameters with sets</p> Source code in <code>afccp/data/values.py</code> <pre><code>def value_parameters_sets_additions(parameters, value_parameters, printing=False):\n    \"\"\"\n    Creates subsets for AFSCs and objectives to distinguish which AFSCs care about which objectives so that we don't\n    have to calculate every value only to multiply them by zero.\n    :param parameters: model fixed parameters\n    :param value_parameters: model weight/value parameters\n    :param printing: whether the procedure should print something\n    :return: updated value parameters with sets\n    \"\"\"\n    if printing:\n        print('Adding AFSC and objective subsets to value parameters...')\n\n    # Shorthand\n    p, vp = parameters, value_parameters\n\n    # Temporary manual adjustment of constraint_type matrix\n    indices_3 = np.where(vp['constraint_type'] == 3)\n    indices_4 = np.where(vp['constraint_type'] == 4)\n    vp['constraint_type'][indices_3] = 1\n    vp['constraint_type'][indices_4] = 2\n\n    # Set of Objectives\n    vp['K'] = np.arange(vp[\"O\"])\n\n    # Set of objectives for each AFSC\n    vp['K^A'] = {}  # objectives\n    vp['K^C'] = {}  # constrained objectives\n    for j in p[\"J\"]:\n        vp['K^A'][j] = np.where(vp['objective_weight'][j, :] &gt; 0)[0].astype(int)\n        vp['K^C'][j] = np.where(vp['constraint_type'][j, :] &gt; 0)[0].astype(int)\n\n    # 5% of total USAFA graduating class set\n    vp[\"J^USAFA\"] = None\n\n    # Add the AFSC indices to the set\n    if \"USAFA-Constrained AFSCs\" in vp:\n        if \",\" in vp[\"USAFA-Constrained AFSCs\"]:\n            vp[\"J^USAFA\"] = np.array([])\n            usafa_afscs = vp[\"USAFA-Constrained AFSCs\"].split(\",\")\n            for afsc in usafa_afscs:\n                afsc = afsc.strip()\n                j = np.where(p[\"afscs\"] == afsc)[0]\n                if len(j) == 0:\n                    print(\"WARNING: Something is wrong with the USAFA-Constrained AFSCs! \"\n                          \"'\" + afsc + \"' is not in the list of AFSCs.\")\n                else:\n                    vp[\"J^USAFA\"] = np.hstack((vp[\"J^USAFA\"], j))\n            vp[\"J^USAFA\"] = vp[\"J^USAFA\"].astype(int)\n\n    # Set of objectives that seek to balance some cadet demographic\n    vp['K^D'] = ['USAFA Proportion', 'Mandatory', 'Desired', 'Permitted', 'Male', 'Minority',\n                 'Tier 1', 'Tier 2', 'Tier 3', 'Tier 4']\n\n    # Set of AFSCs for each objective:\n    vp['J^A'] = {}\n    for k in range(vp[\"O\"]):\n        vp['J^A'][k] = np.where(vp['objective_weight'][:, k] &gt; 0)[0].astype(int)\n\n    # Cadet Value Constraint Set\n    vp['I^C'] = np.where(vp['cadet_value_min'] &gt; 0)[0]\n\n    # Create a set of preferred AFSCs that are constrained for cadets with utility constraints\n    vp['J^Top_Choice'] = {}\n    for i in vp['I^C']:\n        vp['J^Top_Choice'][i] = np.intersect1d(np.where(p['cadet_utility'][i, :] &gt;= vp['cadet_value_min'][i])[0],\n                                               p['J^E'][i])\n\n    # AFSC Value Constraint Set\n    vp['J^C'] = np.where(vp['afsc_value_min'] &gt; 0)[0]\n\n    # number of breakpoints\n    vp['r'] = np.array([[len(vp['a'][j][k]) for k in vp[\"K\"]] for j in p[\"J\"]])\n\n    # set of breakpoints\n    vp['L'] = np.array([[np.arange(vp['r'][j, k]) for k in range(vp[\"O\"])] for j in range(p[\"M\"])], dtype=object)\n\n    # Round weights\n    vp['objective_weight'] = np.around(vp['objective_weight'], 8)\n    vp['afsc_weight'] = np.around(vp['afsc_weight'], 8)\n    vp['cadet_weight'] = np.around(vp['cadet_weight'], 8)\n\n    # Extract AFSC objective min/max measures\n    vp[\"objective_min\"], vp[\"objective_max\"] = np.zeros([p['M'], vp['O']]), np.zeros([p[\"M\"], vp[\"O\"]])\n    for j in p['J']:\n        for k in vp['K^C'][j]:\n            value_list = vp['objective_value_min'][j, k].split(\",\")\n            vp[\"objective_min\"][j, k] = float(value_list[0].strip())\n            vp[\"objective_max\"][j, k] = float(value_list[1].strip())\n\n    # \"Global Utility\" matrix\n    if \"afsc_utility\" in p and \"cadet_utility\" in p:\n        vp['global_utility'] = np.zeros([p['N'], p['M'] + 1])\n        for j in p['J']:\n            vp['global_utility'][:, j] = vp['cadets_overall_weight'] * p['cadet_utility'][:, j] + \\\n                                         vp['afscs_overall_weight'] * p['afsc_utility'][:, j]\n\n    return vp\n</code></pre>"},{"location":"reference/data/values/#data.values.model_value_parameters_to_defaults","title":"<code>model_value_parameters_to_defaults(instance, filepath, printing=False)</code>","text":"<p>This function takes the current instance value parameters and exports them as defaults back to excel</p> Source code in <code>afccp/data/values.py</code> <pre><code>def model_value_parameters_to_defaults(instance, filepath, printing=False):\n    \"\"\"\n    This function takes the current instance value parameters and exports them as defaults back to excel\n    \"\"\"\n    if printing:\n        print('Exporting value parameters as defaults to excel...')\n\n    # Shorthand\n    p, vp = instance.parameters, instance.value_parameters\n\n    # Create \"Overall Weights\" dataframe\n    overall_weights_df = pd.DataFrame({'Cadets Weight': [vp['cadets_overall_weight']],\n                                       'AFSCs Weight': [vp['afscs_overall_weight']],\n                                       'Cadets Min Value': [vp['cadets_overall_value_min']],\n                                       'AFSCs Min Value': [vp['afscs_overall_value_min']],\n                                       'Cadet Weight Function': [vp['cadet_weight_function']],\n                                       'AFSC Weight Function': [vp['afsc_weight_function']]})\n\n    # Construct other dataframes\n    afsc_weights_df = pd.DataFrame({'AFSC': p['afscs'][:p[\"M\"]],\n                                    'AFSC Swing Weight': np.around((vp['afsc_weight'] / max(vp['afsc_weight'])) * 100, 2),\n                                    'AFSC Min Value': vp['afsc_value_min']})\n\n    # AFSC Objective Components Translations Dictionary\n    ao_trans_dict = {'AFSC Objective Weights': 'objective_weight', 'AFSC Objective Targets': 'objective_target',\n                     'AFSC Objective Min Value': 'objective_value_min', 'Constraint Type': 'constraint_type',\n                     'Value Functions': 'value_functions'}\n\n    # Create the AFSC Objective Components DataFrames\n    ao_dfs = {component: pd.DataFrame({'AFSC': p['afscs'][:p[\"M\"]]}) for component in ao_trans_dict}\n    for component in ao_dfs:\n\n        # Scale AFSC Objective Weights so that the largest is set to 100 rather than forcing them all to sum to 1\n        if component == \"AFSC Objective Weights\":\n            comp_arr = np.array([(vp[\"objective_weight\"][j] / max(vp[\"objective_weight\"][j])) * 100 for j in p[\"J\"]])\n        else:\n            comp_arr = vp[ao_trans_dict[component]]  # \"Component Array\", vp[\"objective_target\"] for example\n\n        # Load columns of the dataframe\n        for k, objective in enumerate(vp['objectives']):\n            ao_dfs[component][objective] = comp_arr[:, k]\n\n    # Export to excel\n    with pd.ExcelWriter(filepath) as writer:\n        overall_weights_df.to_excel(writer, sheet_name=\"Overall Weights\", index=False)\n        afsc_weights_df.to_excel(writer, sheet_name=\"AFSC Weights\", index=False)\n        for component in ao_dfs:\n            ao_dfs[component].to_excel(writer, sheet_name=component, index=False)\n</code></pre>"},{"location":"reference/data/values/#data.values.default_value_parameters_from_excel","title":"<code>default_value_parameters_from_excel(filepath, num_breakpoints=24, printing=False)</code>","text":"<p>Imports the \"factory defaults\" for value parameters</p> <p>Parameters:</p> Name Type Description Default <code>num_breakpoints</code> <p>number of breakpoints to use for value functions</p> <code>24</code> <code>filepath</code> <p>Filepath to import from</p> required <code>printing</code> <p>Whether the function should print something</p> <code>False</code> <p>Returns:</p> Type Description <p>default user parameters</p> Source code in <code>afccp/data/values.py</code> <pre><code>def default_value_parameters_from_excel(filepath, num_breakpoints=24, printing=False):\n    \"\"\"\n    Imports the \"factory defaults\" for value parameters\n    :param num_breakpoints: number of breakpoints to use for value functions\n    :param filepath: Filepath to import from\n    :param printing: Whether the function should print something\n    :return: default user parameters\n    \"\"\"\n    if printing:\n        print('Importing default value parameters...')\n\n    # Get dataframes\n    overall_weights_df = afccp.globals.import_data(filepath, sheet_name=\"Overall Weights\")\n    afsc_weights_df = afccp.globals.import_data(filepath, sheet_name=\"AFSC Weights\")\n    afsc_objective_weights_df = afccp.globals.import_data(filepath, sheet_name=\"AFSC Objective Weights\")\n    afsc_objective_targets_df = afccp.globals.import_data(filepath, sheet_name=\"AFSC Objective Targets\")\n    afsc_objective_value_min_df = afccp.globals.import_data(filepath, sheet_name=\"AFSC Objective Min Value\")\n    afsc_objective_convex_constraints_df = afccp.globals.import_data(filepath, sheet_name=\"Constraint Type\")\n    afsc_value_functions_df = afccp.globals.import_data(filepath, sheet_name=\"Value Functions\")\n    objectives = np.array(afsc_objective_weights_df.keys()[1:])\n    default_value_parameters = {'cadet_weight_function': overall_weights_df['Cadet Weight Function'][0],\n                                'afsc_weight_function': overall_weights_df['AFSC Weight Function'][0],\n                                'cadets_overall_weight': overall_weights_df['Cadets Weight'][0],\n                                'afscs_overall_weight': overall_weights_df['AFSCs Weight'][0],\n                                'afsc_weight': np.array(afsc_weights_df['AFSC Swing Weight']),\n                                'objective_weight': np.array(afsc_objective_weights_df.iloc[:,\n                                                             1:(len(objectives) + 1)]),\n                                'objective_target': np.array(\n                                    afsc_objective_targets_df.iloc[:, 1:(len(objectives) + 1)]),\n                                'objective_value_min': np.array(\n                                    afsc_objective_value_min_df.iloc[:, 1:(len(objectives) + 1)]),\n                                'constraint_type': np.array(\n                                    afsc_objective_convex_constraints_df.iloc[:, 1:(len(objectives) + 1)]),\n                                'value_functions': np.array(afsc_value_functions_df.iloc[:, 1:(len(objectives) + 1)]),\n                                'cadets_overall_value_min': overall_weights_df['Cadets Min Value'][0],\n                                'afscs_overall_value_min': overall_weights_df['AFSCs Min Value'][0],\n                                'afsc_value_min': np.array(afsc_weights_df['AFSC Min Value']),\n                                'objectives': objectives,\n                                'complete_afscs': np.array(afsc_weights_df['AFSC']),\n                                'num_breakpoints': num_breakpoints, \"M\": len(afsc_weights_df)}\n\n    return default_value_parameters\n</code></pre>"},{"location":"reference/data/values/#data.values.generate_afocd_value_parameters","title":"<code>generate_afocd_value_parameters(parameters, default_value_parameters)</code>","text":"<p>Function to add in AFOCD value parameters</p> Source code in <code>afccp/data/values.py</code> <pre><code>def generate_afocd_value_parameters(parameters, default_value_parameters):\n    \"\"\"\n    Function to add in AFOCD value parameters\n    \"\"\"\n    p, vp = parameters, default_value_parameters\n\n    # AFOCD Objective Indices\n    tier_objectives = np.array([np.where(vp[\"objectives\"] == \"Tier \" + t)[0][0] for t in [\"1\", \"2\", \"3\", \"4\"]])\n\n    # Tier multipliers\n    tm = {1: 1, 2: 0.8, 3: 0.6, 4: 0.4}\n\n    # Loop through each AFSC\n    for j in p[\"J\"]:\n\n        # Loop through each AFOCD tier\n        for t, k in enumerate(tier_objectives):\n            tier = t + 1\n\n            # We only do this for valid AFOCD tiers\n            if tier &lt;= p[\"t_count\"][j]:\n\n                # Objective Weight\n                if p[\"t_mandatory\"][j, t] == 1:\n                    vp[\"objective_weight\"][j, k] = round(90 * tm[tier], 2)\n                elif p[\"t_desired\"][j, t] == 1:\n                    vp[\"objective_weight\"][j, k] = round(70 * tm[tier], 2)\n                elif p[\"t_permitted\"][j, t] == 1:\n                    vp[\"objective_weight\"][j, k] = round(50 * tm[tier], 2)\n                else:\n                    vp[\"objective_weight\"][j, k] = 0  # Tier doesn't exist or is an ineligible tier\n\n                # Objective Target\n                vp[\"objective_target\"][j, k] = p[\"t_proportion\"][j, t]\n\n                # Objective Min Value\n                if p[\"t_leq\"][j, t] == 1:\n                    vp[\"objective_value_min\"][j, k] = \"0, \" + str(p[\"t_proportion\"][j, t])\n                else:  # &lt;= OR ==\n                    vp[\"objective_value_min\"][j, k] = str(p[\"t_proportion\"][j, t]) + \", 5\"\n\n                # Constraint Type (Default to turning all constraints on. It's easier to make them zeros later...)\n                if p[\"t_mandatory\"][j, t] == 1:\n                    vp[\"constraint_type\"][j, k] = 1  # Easier to meet \"at least\" constraint (M &gt;/= x) based on PGL\n                elif p[\"t_desired\"][j, t] == 1:\n                    if p[\"t_leq\"][j, t] == 1:\n                        vp[\"constraint_type\"][j, k] = 2  # Easier to meet \"at most\" constraint (D &lt; x) based on proportion\n                    elif p[\"t_geq\"][j, t] == 1:\n                        vp[\"constraint_type\"][j, k] = 1  # Easier to meet \"at least\" constraint (D &gt; x) based on PGL\n                elif p[\"t_permitted\"][j, t] == 1:\n                    vp[\"constraint_type\"][j, k] = 2  # Easier to meet \"at most\" constraint (P &lt; x) based on proportion\n\n                # Value Functions\n                if p['t_leq'][j, t] == 1:\n                    vp['value_functions'][j, k] = \"Min Decreasing|0.3\"\n                else:  # &lt;= OR ==\n                    vp['value_functions'][j, k] = \"Min Increasing|0.3\"\n\n    return vp\n</code></pre>"},{"location":"reference/data/values/#data.values.generate_value_parameters_from_defaults","title":"<code>generate_value_parameters_from_defaults(parameters, default_value_parameters, generate_afsc_weights=True, num_breakpoints=None, printing=False)</code>","text":"<p>Generates value parameters from the defaults for a specified problem</p> Source code in <code>afccp/data/values.py</code> <pre><code>def generate_value_parameters_from_defaults(parameters, default_value_parameters, generate_afsc_weights=True,\n                                            num_breakpoints=None, printing=False):\n    \"\"\"\n    Generates value parameters from the defaults for a specified problem\n    \"\"\"\n    if printing:\n        print('Generating value parameters from defaults...')\n\n    # Shorthand\n    p, dvp = parameters, default_value_parameters\n\n    # Variable to control if we load in AFOCD value parameters from the default excel workbook or create them here\n    init_afocd = False\n\n    # Manipulate AFOCD objectives based on what \"system\" we're using (Tiers or \"Old\")\n    if p[\"Qual Type\"] == \"Tiers\":\n\n        # Weight \"Old\" AFOCD Objectives at zero (but keep them in because we can select them if needed)\n        for objective in [\"Mandatory\", \"Desired\", \"Permitted\"]:\n            if objective in dvp[\"objectives\"]:\n                k = np.where(dvp[\"objectives\"] == objective)[0][0]\n                dvp[\"objective_weight\"][:, k] = np.zeros(len(dvp[\"objective_weight\"]))\n\n        # Add in \"Tier\" AFOCD Objectives\n        for t in [\"1\", \"2\", \"3\", \"4\"]:\n            objective = \"Tier \" + t\n            if objective not in dvp[\"objectives\"]:\n                init_afocd = True  # We're going to initialize the value parameters for AFOCD objectives\n                dvp[\"objectives\"] = np.hstack([dvp[\"objectives\"], objective])\n\n                # Add these columns in the other arrays as well\n                for vp_key in [\"objective_weight\", \"objective_value_min\", \"constraint_type\", \"objective_target\",\n                               \"value_functions\"]:\n                    if vp_key in [\"objective_weight\", \"constraint_type\", \"objective_target\"]:\n                        new_column = np.array([[0] for _ in p[\"J\"]])\n                    else:\n                        new_column = np.array([[\"0\"] for _ in p[\"J\"]])\n                    dvp[vp_key] = np.hstack((dvp[vp_key], new_column))\n\n    elif p[\"Qual Type\"] == \"Relaxed\":\n\n        # Remove \"Tier\" AFOCD Objectives\n        for t in [\"1\", \"2\", \"3\", \"4\"]:\n            objective = \"Tier \" + t\n            if objective in dvp[\"objectives\"]:\n                k = np.where(dvp[\"objectives\"] == objective)[0][0]\n                dvp[\"objectives\"] = np.delete(dvp[\"objectives\"], k)\n\n    # Generate AFOCD value parameters if necessary\n    if init_afocd:\n        dvp = generate_afocd_value_parameters(p, dvp)\n\n    # Objective to parameters lookup dictionary (if the parameter is in \"p\", we include the objective)\n    objective_lookups = {'Norm Score': 'a_pref_matrix', 'Merit': 'merit', 'USAFA Proportion': 'usafa',\n                         'Combined Quota': 'quota_d', 'USAFA Quota': 'usafa_quota', 'ROTC Quota': 'rotc_quota',\n                         'OTS Quota': 'ots_quota',\n                         'Mandatory': 'mandatory', 'Desired': 'desired', 'Permitted': 'permitted',\n                         'Utility': 'utility', 'Male': 'male', 'Minority': 'minority'}\n    for t in [\"1\", \"2\", \"3\", \"4\"]:  # Add in AFOCD Degree tiers\n        objective_lookups[\"Tier \" + t] = \"tier \" + t\n\n    # Add the AFSC objectives that are included in this instance (check corresponding parameters using dict above)\n    objectives = []\n    objective_indices = []\n    for k, objective in enumerate(dvp[\"objectives\"]):\n        if objective_lookups[objective] in p:\n            objectives.append(objective)\n            objective_indices.append(k)\n\n    # Convert to numpy arrays\n    objectives = np.array(objectives)\n    objective_indices = np.array(objective_indices)\n\n    # Additional information\n    afsc_indices = np.array([np.where(dvp['complete_afscs'] == p['afscs'][j])[0][0] for j in p[\"J\"]])\n    O = len(objectives)\n    if num_breakpoints is None:\n        num_breakpoints = dvp['num_breakpoints']\n\n    # Initialize set of value p\n    vp = {'cadets_overall_weight': dvp['cadets_overall_weight'],\n          'afscs_overall_weight': dvp['afscs_overall_weight'],\n          'cadet_weight_function': dvp['cadet_weight_function'],\n          'afsc_weight_function': dvp['afsc_weight_function'],\n          'cadets_overall_value_min': dvp['cadets_overall_value_min'],\n          'afscs_overall_value_min': dvp['afscs_overall_value_min'],\n          'afsc_value_min': np.zeros(p[\"M\"]), 'cadet_value_min': np.zeros(p[\"N\"]),\n          'objective_weight': np.zeros([p[\"M\"], O]), 'afsc_weight': np.zeros(p[\"M\"]), \"M\": p[\"M\"],\n          'objective_target': np.zeros([p[\"M\"], O]), 'objectives': objectives, 'O': O,\n          'objective_value_min': np.array([[\" \" * 20 for _ in range(O)] for _ in p[\"J\"]]),\n          'constraint_type': np.zeros([p[\"M\"], O]).astype(int),\n          'num_breakpoints': num_breakpoints}\n\n    # Determine weights on cadets\n    if 'merit_all' in p:\n        vp['cadet_weight'] = cadet_weight_function(p['merit_all'], func=vp['cadet_weight_function'])\n    else:\n        vp['cadet_weight'] = cadet_weight_function(p['merit'], func=vp['cadet_weight_function'])\n\n    # Determine weights on AFSCs\n    if generate_afsc_weights:\n        func = vp['afsc_weight_function']\n        if func == 'Custom':  # We take the AFSC weights directly from the defaults\n            generate_afsc_weights = False\n        else:\n            vp['afsc_weight'] = afsc_weight_function(p[\"pgl\"], func)\n\n    # Initialize breakpoints\n    vp['a'] = [[[] for _ in range(O)] for _ in p[\"J\"]]\n    vp['f^hat'] = [[[] for _ in range(O)] for _ in p[\"J\"]]\n\n    # Load value function strings\n    value_functions = dvp['value_functions'][:, objective_indices]\n    value_functions = value_functions[afsc_indices, :]\n    vp['value_functions'] = value_functions\n\n    # Initialize objective set\n    vp['K^A'] = {}\n\n    # Loop through each AFSC to load in their value parameters\n    for j, afsc in enumerate(p['afscs']):\n\n        if afsc != \"*\":\n\n            # Get location of afsc in the default value parameters (matters if this set of afscs does not match)\n            loc = np.where(dvp['complete_afscs'] == afsc)[0][0]\n\n            # Initially assign all default weights, targets, etc.\n            vp['objective_weight'][j, :] = dvp['objective_weight'][loc, objective_indices]\n            vp['objective_target'][j] = dvp['objective_target'][loc, objective_indices]\n            vp['objective_value_min'][j] = dvp['objective_value_min'][loc, objective_indices]\n            vp['afsc_value_min'][j] = dvp['afsc_value_min'][loc]\n            vp['constraint_type'][j] = dvp['constraint_type'][loc, objective_indices]\n            vp['K^A'][j] = np.where(vp['objective_weight'][j, :] &gt; 0)[0].astype(int)\n\n            # If we're not generating afsc weights using the specified weight function...\n            if not generate_afsc_weights:  # Also, if the weight function is \"Custom\"\n                vp['afsc_weight'][j] = dvp['afsc_weight'][loc]\n\n            # Loop through each objective to load their targets\n            for k, objective in enumerate(vp['objectives']):\n\n                maximum, minimum, actual = None, None, None\n                if objective == 'Merit':\n                    vp['objective_target'][j, k] = p['sum_merit'] / p['N']\n                    actual = np.mean(p['merit'][p['I^E'][j]])\n\n                elif objective == 'USAFA Proportion':\n                    vp['objective_target'][j, k] = p['usafa_proportion']\n                    if len(p['I^E'][j]) == 0:  # In case there are no eligible USAFA cadets\n                        actual = 0\n                    else:\n                        actual = len(p['I^D'][objective][j]) / len(p['I^E'][j])\n\n                elif objective == 'Combined Quota':\n                    vp['objective_target'][j, k] = p['quota_d'][j]\n\n                    # Get bounds\n                    minimum, maximum = p['quota_min'][j], p['quota_max'][j]\n                    vp['objective_value_min'][j, k] = str(int(minimum)) + \", \" + str(int(maximum))\n\n                elif objective == 'USAFA Quota':\n                    vp['objective_target'][j, k] = p['usafa_quota'][j]\n                    vp['objective_value_min'][j, k] = str(int(p['usafa_quota'][j])) + \", \" + \\\n                                                                    str(int(p['quota_max'][j]))\n\n                elif objective == 'ROTC Quota':\n                    vp['objective_target'][j, k] = p['rotc_quota'][j]\n                    vp['objective_value_min'][j, k] = str(int(p['rotc_quota'][j])) + \", \" + \\\n                                                                    str(int(p['quota_max'][j]))\n                elif objective == 'OTS Quota':\n                    vp['objective_target'][j, k] = p['ots_quota'][j]\n                    vp['objective_value_min'][j, k] = str(int(p['ots_quota'][j])) + \", \" + \\\n                                                                    str(int(p['quota_max'][j]))\n\n                elif objective == 'Male':\n                    vp['objective_target'][j, k] = p['male_proportion']\n                    if len(p['I^E'][j]) == 0:  # In case there are no eligible male cadets\n                        actual = 0\n                    else:\n                        actual = len(p['I^D'][objective][j]) / len(p['I^E'][j])\n\n                elif objective == 'Minority':\n                    vp['objective_target'][j, k] = p['minority_proportion']\n                    if len(p['I^E'][j]) == 0:  # In case there are no eligible minority cadets\n                        actual = 0\n                    else:\n                        actual = len(p['I^D'][objective][j]) / len(p['I^E'][j])\n\n                # If we care about this objective, we load in its value function breakpoints\n                if vp['objective_weight'][j, k] != 0:\n\n                    # Create the non-linear piecewise exponential segment dictionary\n                    segment_dict = create_segment_dict_from_string(value_functions[j, k],\n                                                                   vp['objective_target'][j, k],\n                                                                   minimum=minimum, maximum=maximum, actual=actual)\n\n                    # Linearize the non-linear function using the specified number of breakpoints\n                    vp['a'][j][k], vp['f^hat'][j][k] = value_function_builder(\n                        segment_dict, num_breakpoints=num_breakpoints)\n\n            # Scale the objective weights for this AFSC, so they sum to 1\n            vp['objective_weight'][j] = vp['objective_weight'][j] / sum(vp['objective_weight'][j])\n\n    # Scale the weights across all AFSCs, so they sum to 1\n    vp['afsc_weight'] = vp['afsc_weight'] / sum(vp['afsc_weight'])\n\n    return vp\n</code></pre>"},{"location":"reference/data/values/#data.values.update_value_and_weight_functions","title":"<code>update_value_and_weight_functions(instance, num_breakpoints=None)</code>","text":"<p>This function takes in a problem instance and updates the set of value parameters in case the user makes a change to some aspect of them. Note: Only works for the current set of objectives in the value parameters. This does not add/subtract from the objectives. If you want to add a new one in that will have to be re-generated. This works for when the user wants to update an objective weight, weight/value function, etc.</p> Source code in <code>afccp/data/values.py</code> <pre><code>def update_value_and_weight_functions(instance, num_breakpoints=None):\n    \"\"\"\n    This function takes in a problem instance and updates the set of value parameters in case the user\n    makes a change to some aspect of them. Note: Only works for the current set of objectives in the value\n    parameters. This does not add/subtract from the objectives. If you want to add a new one in that will\n    have to be re-generated. This works for when the user wants to update an objective weight, weight/value function,\n    etc.\n    \"\"\"\n\n    # Shorthand\n    p, vp = instance.parameters, instance.value_parameters\n\n    # Determine weights on cadets\n    if 'merit_all' in p:\n        vp['cadet_weight'] = cadet_weight_function(p['merit_all'], func=vp['cadet_weight_function'])\n    else:\n        vp['cadet_weight'] = cadet_weight_function(p['merit'], func=vp['cadet_weight_function'])\n\n    # Determine weights on AFSCs\n    if vp['afsc_weight_function'] != 'Custom':  # If the AFSC weight function is not \"custom\", we regenerate the weights\n        vp['afsc_weight'] = afsc_weight_function(p[\"pgl\"], vp['afsc_weight_function'])\n\n    # Initialize breakpoints\n    vp['a'] = [[[] for _ in range(vp['O'])] for _ in p[\"J\"]]\n    vp['f^hat'] = [[[] for _ in range(vp['O'])] for _ in p[\"J\"]]\n\n    # Loop through each AFSC\n    for j, afsc in enumerate(p['afscs'][:p['M']]):  # Skip the \"unmatched AFSC\": '*'\n\n        # Loop through each objective\n        for k, objective in enumerate(vp['objectives']):\n\n            # Value Function specific parameters\n            actual, minimum, maximum = None, None, None\n            if objective == 'Merit':\n                actual = np.mean(p['merit'][p['I^E'][j]])\n            if objective in ['USAFA Proportion', 'Male', 'Minority']:\n                actual = len(p['I^D'][objective][j]) / len(p['I^E'][j])\n            if objective in ['Combined Quota', 'ROTC Quota', 'USAFA Quota', 'OTS Quota']:\n\n                # Dictionaries for getting the right value for the specific quota objective\n                min_dict = {\"Combined Quota\": 'quota_min', 'ROTC Quota': 'rotc_quota',\n                            'USAFA Quota': 'usafa_quota', 'OTS Quota': 'ots_quota'}\n                target_dict = {\"Combined Quota\": 'quota_d', 'ROTC Quota': 'rotc_quota',\n                               'USAFA Quota': 'usafa_quota', 'OTS Quota': 'ots_quota'}\n                minimum, maximum = int(p[min_dict[objective]][j]), int(p['quota_max'][j])\n\n                # Update minimum values for combined quota objective\n                vp['objective_value_min'][j, k] = str(minimum) + ', ' + str(maximum)\n                vp['objective_min'][j, k], vp['objective_max'][j, k] = minimum, maximum\n                vp['objective_target'][j, k] = p[target_dict[objective]][j]\n\n            # If we care about this objective, we load in its value function breakpoints\n            if vp['objective_weight'][j, k] != 0:\n\n                # Create the non-linear piecewise exponential segment dictionary\n                segment_dict = create_segment_dict_from_string(vp['value_functions'][j, k],\n                                                               vp['objective_target'][j, k],\n                                                               minimum=minimum, maximum=maximum, actual=actual)\n\n                # Linearize the non-linear function using the specified number of breakpoints\n                vp['a'][j][k], vp['f^hat'][j][k] = value_function_builder(\n                    segment_dict, num_breakpoints=num_breakpoints)\n\n        # Scale the objective weights for this AFSC, so they sum to 1\n        vp['objective_weight'][j] = vp['objective_weight'][j] / sum(vp['objective_weight'][j])\n\n    # Scale the weights across all AFSCs, so they sum to 1\n    vp['afsc_weight'] = vp['afsc_weight'] / sum(vp['afsc_weight'])\n\n    return vp  # Return set of value parameters\n</code></pre>"},{"location":"reference/data/values/#data.values.compare_value_parameters","title":"<code>compare_value_parameters(parameters, vp1, vp2, vp1name, vp2name, printing=False)</code>","text":"<p>Compares two sets of value parameters to see if they are identical</p> <p>Returns:</p> Type Description <p>True if they're identical, False otherwise</p> Source code in <code>afccp/data/values.py</code> <pre><code>def compare_value_parameters(parameters, vp1, vp2, vp1name, vp2name, printing=False):\n    \"\"\"\n    Compares two sets of value parameters to see if they are identical\n    :return: True if they're identical, False otherwise\n    \"\"\"\n    # Shorthand\n    p = parameters\n\n    # Assume identical until proven otherwise\n    identical = True\n\n    # Loop through each value parameter key\n    for key in vp1:\n\n        if np.shape(vp1[key]) != np.shape(vp2[key]):\n            if printing:\n                print(vp1name + ' and ' + vp2name + ' not the same. ' + key + ' is a different size.')\n            identical = False\n            break\n\n        if key in ['afscs_overall_weight', 'cadets_overall_weight', 'cadet_weight_function', 'afsc_weight_function',\n                   'cadets_overall_value_min', 'afscs_overall_value_min']:\n            if vp1[key] != vp2[key]:\n                if printing:\n                    print(vp1name + ' and ' + vp2name + ' not the same. ' + key + ' is different.')\n                identical = False\n                break\n\n        elif key in ['afsc_value_min', 'cadet_value_min', 'objective_value_min', 'value_functions', 'objective_target',\n                     'objective_weight', 'afsc_weight', 'cadet_weight', 'I^C', 'J^C', 'value_functions',\n                     'constraint_type']:\n            if key not in ['objective_value_min', 'value_functions']:\n                vp_1_arr, vp_2_arr = np.ravel(np.around(vp1[key], 4)), np.ravel(np.around(vp2[key], 4))\n            else:\n                vp_1_arr, vp_2_arr = np.ravel(vp1[key]), np.ravel(vp2[key])\n\n            diff_arr = np.array([vp_1_arr[i] != vp_2_arr[i] for i in range(len(vp_1_arr))])\n            if sum(diff_arr) != 0 and (vp1[key] != [] or vp2[key] != []):\n                if printing:\n                    print(vp1name + ' and ' + vp2name + ' not the same. ' + key + ' is different.')\n                identical = False\n                break\n\n        elif key == 'a':  # Check the breakpoints\n\n            for j in p['J']:\n                afsc = p[\"afscs\"][j]\n                for k in vp1['K^A'][j]:\n                    objective = vp1[\"objectives\"][k]\n                    for l in vp1['L'][j][k]:\n                        try:\n                            if vp1[key][j][k][l] != vp2[key][j][k][l]:\n                                identical = False\n                                if printing:\n                                    print(vp1name + ' and ' + vp2name + ' not the same. '\n                                                                        'Breakpoints are different for AFSC ' + afsc +\n                                          ' Objective ' + objective + '.')\n                                    print(vp1name + \":\", vp1[key][j][k])\n                                    print(vp2name + \":\", vp2[key][j][k])\n                                break\n                        except:  # If there was a range error, then the breakpoints are not the same\n                            identical = False\n                            if printing:\n                                print(vp1name + ' and ' + vp2name + ' not the same. '\n                                                                    'Breakpoints are different for AFSC ' + afsc +\n                                      ' Objective ' + objective + '.')\n                                print(vp1name + \":\", vp1[key][j][k])\n                                print(vp2name + \":\", vp2[key][j][k])\n                            break\n                    if not identical:\n                        break\n                if not identical:\n                    break\n            if not identical:\n                break\n\n    if identical and printing:\n        print(vp1name + ' and ' + vp2name + ' are the same.')\n\n    return identical\n</code></pre>"},{"location":"reference/data/values/#data.values.cadet_weight_function","title":"<code>cadet_weight_function(merit, func='Curve_1')</code>","text":"<p>Take in a merit array and generate cadet weights depending on function specified</p> Source code in <code>afccp/data/values.py</code> <pre><code>def cadet_weight_function(merit, func=\"Curve_1\"):\n    \"\"\"\n    Take in a merit array and generate cadet weights depending on function specified\n    \"\"\"\n\n    # Number of Cadets\n    N = len(merit)\n\n    # Generate Swing Weights based on function\n    if func == 'Linear':\n        swing_weights = np.array([1 + (2 * x) for x in merit])\n    elif func == \"Direct\":\n        swing_weights = merit\n    elif func == 'Curve_1':\n        swing_weights = np.array([1 + 2 / (1 + exp(-10 * (x - 0.5))) for x in merit])\n    elif func == 'Curve_2':\n        swing_weights = np.array([1 + 2 / (1 + exp(-12 * (x - 0.7))) for x in merit])\n    elif func == 'Equal':\n        swing_weights = np.ones(N)\n    else:  # Exponential Function\n        rho = -0.3\n        swing_weights = np.array([(1 - exp(-x / rho)) / (1 - exp(-1 / rho)) for x in merit])\n\n    # Normalize weights and return them\n    weights = swing_weights / sum(swing_weights)\n    return weights\n</code></pre>"},{"location":"reference/data/values/#data.values.afsc_weight_function","title":"<code>afsc_weight_function(quota, func='Curve')</code>","text":"<p>Take in an AFSC quota array and generate AFSC weights depending on function specified</p> Source code in <code>afccp/data/values.py</code> <pre><code>def afsc_weight_function(quota, func=\"Curve\"):\n    \"\"\"\n    Take in an AFSC quota array and generate AFSC weights depending on function specified\n    \"\"\"\n\n    # Number of AFSCs\n    M = len(quota)\n\n    # Scale quota to be 0-1 (referencing biggest AFSC)\n    quota_scale = quota / np.max(quota)\n\n    # Generate Swing Weights based on function\n    if func == 'Linear':\n        swing_weights = np.array([1 + (10 * x) for x in quota_scale])\n    elif func in [\"Direct\", \"Size\"]:  # Direct relationship between size and importance\n        swing_weights = quota\n    elif func == \"Piece\":\n        swing_weights = np.zeros(M)\n        for j, x in enumerate(quota):\n            if x &gt;= 200:\n                swing_weights[j] = 1\n            elif 150 &lt;= x &lt; 200:\n                swing_weights[j] = 0.9\n            elif 100 &lt;= x &lt; 150:\n                swing_weights[j] = 0.8\n            elif 50 &lt;= x &lt; 100:\n                swing_weights[j] = 0.7\n            elif 25 &lt;= x &lt; 50:\n                swing_weights[j] = 0.6\n            else:\n                swing_weights[j] = 0.5\n    elif func == 'Curve_1':  # Sigmoid Function\n        swing_weights = np.array([1 + 10 / (1 + exp(-5 * (x - 0.5))) for x in quota_scale])\n    elif func == 'Curve_2':  # Sigmoid Function\n        swing_weights = np.array([1 + 12 / (1 + exp(-20 * (x - 0.5))) for x in quota_scale])\n    elif func == 'Equal':  # They're all the same\n        swing_weights = np.ones(M)\n    else:  # Exponential Function\n        rho = -0.3\n        swing_weights = np.array([(1 - exp(-x / rho)) / (1 - exp(-1 / rho)) for x in quota_scale])\n\n    # Scale weights and return them\n    weights = swing_weights / sum(swing_weights)\n    return weights\n</code></pre>"},{"location":"reference/data/values/#data.values.create_segment_dict_from_string","title":"<code>create_segment_dict_from_string(vf_string, target=None, maximum=None, actual=None, multiplier=False, minimum=None)</code>","text":"<p>Converts a value function string into a segment dictionary.</p> <p>Args:     vf_string (str): Value function string.     target (float, optional): Target objective measure.     maximum (float, optional): Maximum objective measure.     actual (float, optional): Proportion of eligible cadets.     multiplier (bool, optional): Specifies whether the target values are multiplied by a scalar for quota objectives.     minimum (float, optional): Minimum objective measure.</p> <p>Returns:     segment_dict (dict): A dictionary representing the segments of the value function.</p> <p>Notes:     - The function assumes that the value function string follows a specific format.     - The segment dictionary contains keys representing the segment number and values representing the segment details.     - Each segment is represented by a dictionary with the following keys:         - 'x1': The starting point on the x-axis.         - 'y1': The starting point on the y-axis.         - 'x2': The ending point on the x-axis.         - 'y2': The ending point on the y-axis.         - 'rho': The value of the rho parameter for the segment.</p> Source code in <code>afccp/data/values.py</code> <pre><code>def create_segment_dict_from_string(vf_string, target=None, maximum=None, actual=None, multiplier=False, minimum=None):\n    \"\"\"\n    Converts a value function string into a segment dictionary.\n\n    Args:\n        vf_string (str): Value function string.\n        target (float, optional): Target objective measure.\n        maximum (float, optional): Maximum objective measure.\n        actual (float, optional): Proportion of eligible cadets.\n        multiplier (bool, optional): Specifies whether the target values are multiplied by a scalar for quota objectives.\n        minimum (float, optional): Minimum objective measure.\n\n    Returns:\n        segment_dict (dict): A dictionary representing the segments of the value function.\n\n    Notes:\n        - The function assumes that the value function string follows a specific format.\n        - The segment dictionary contains keys representing the segment number and values representing the segment details.\n        - Each segment is represented by a dictionary with the following keys:\n            - 'x1': The starting point on the x-axis.\n            - 'y1': The starting point on the y-axis.\n            - 'x2': The ending point on the x-axis.\n            - 'y2': The ending point on the y-axis.\n            - 'rho': The value of the rho parameter for the segment.\n    \"\"\"\n\n    # Collect the kind of function we're creating\n    split_list = vf_string.split('|')\n    f_type = split_list[0]\n\n    if f_type == 'Balance':\n\n        # Receive values from string\n        f_param_list = split_list[1]\n        split_list = f_param_list.split(',')\n        left_bm = float(split_list[0].strip())\n        right_bm = float(split_list[1].strip())\n        rho1 = float(split_list[2].strip())\n        rho2 = float(split_list[3].strip())\n        rho3 = float(split_list[4].strip())\n        rho4 = float(split_list[5].strip())\n        buffer_y = float(split_list[6].strip())\n\n        if actual &lt; target:\n            left_margin = (target - actual) / 4 + left_bm\n            right_margin = right_bm\n        elif actual &gt; target:\n            left_margin = left_bm\n            right_margin = (actual - target) / 4 + right_bm\n        else:\n            left_margin = left_bm\n            right_margin = right_bm\n\n        # Build segments\n        segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': round(target - left_margin, 3), 'y2': buffer_y, 'rho': -rho1},\n                        2: {'x1': round(target - left_margin, 3), 'y1': buffer_y, 'x2': target, 'y2': 1, 'rho': rho2},\n                        3: {'x1': target, 'y1': 1, 'x2': round(target + right_margin, 3), 'y2': buffer_y, 'rho': rho3},\n                        4: {'x1': round(target + right_margin, 3), 'y1': buffer_y, 'x2': 1, 'y2': 0, 'rho': -rho4}}\n\n    elif f_type == 'Quota_Normal':  # \"Method 1\" as described in thesis\n\n        # Receive values from string\n        f_param_list = split_list[1]\n        split_list = f_param_list.split(',')\n        domain_max = float(split_list[0].strip())\n        rho1 = float(split_list[1].strip()) * target\n        rho2 = float(split_list[2].strip()) * target\n        if multiplier:\n            maximum = int(target * maximum)\n        real_max = max(int(target + (maximum - target) + target * domain_max), maximum + 1)\n\n        # Build segments\n        segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': target, 'y2': 1, 'rho': -rho1},\n                        2: {'x1': maximum, 'y1': 1, 'x2': real_max, 'y2': 0, 'rho': -rho2}}\n\n    elif f_type == 'Quota_Over':  # \"Method 2\" as described in thesis\n\n        # Receive values from string\n        f_param_list = split_list[1]\n        split_list = f_param_list.split(',')\n        domain_max = float(split_list[0].strip())\n        rho1 = float(split_list[1].strip()) * target\n        rho2 = float(split_list[2].strip()) * target\n        rho3 = float(split_list[3].strip()) * target\n        buffer_y = float(split_list[4].strip())\n        if multiplier:\n            maximum = int(target * maximum)\n            actual = int(target * actual)\n        real_max = max(int(target + (actual - target) + target * domain_max), actual + 1)\n\n        # Build segments\n        segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': target, 'y2': 1, 'rho': -rho1},\n                        2: {'x1': maximum, 'y1': 1, 'x2': actual, 'y2': buffer_y, 'rho': rho2},\n                        3: {'x1': actual, 'y1': buffer_y, 'x2': real_max, 'y2': 0, 'rho': -rho3}}\n\n    elif f_type == 'Quota_Direct':  # The benefit of value functions is here! Captures ambiguity of PGL/constraints\n\n        # Receive values from string\n        f_param_list = split_list[1]\n        split_list = f_param_list.split(',')\n        domain_max = 1.05  # Arbitrary max (this doesn't really matter since we constrain quota anyway)\n        rho1 = float(split_list[0].strip())\n        rho2 = float(split_list[1].strip())\n        rho3 = float(split_list[2].strip())\n        rho4 = float(split_list[3].strip())\n        y1 = float(split_list[4].strip())\n        y2 = float(split_list[5].strip())\n\n        assert rho1 &gt; 0, f\"rho1 must be greater than 0 for a Quota_Direct value function, got: {rho1}\"\n        assert rho2 &gt; 0, f\"rho2 must be greater than 0 for a Quota_Direct value function, got: {rho2}\"\n        assert rho3 &gt; 0, f\"rho3 must be greater than 0 for a Quota_Direct value function, got: {rho3}\"\n        assert rho4 &gt; 0, f\"rho4 must be greater than 0 for a Quota_Direct value function, got: {rho4}\"\n        assert 0 &lt; y1 &lt; 1, f\"y1 must be between 0 and 1 for a Quota_Direct value function, got: {y1}\"\n        assert 0 &lt; y2 &lt; 1, f\"y2 must be between 0 and 1 for a Quota_Direct value function, got: {y2}\"\n\n        # Build segments\n        if target == minimum:\n            if target == maximum:\n                segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': target, 'y2': 1, 'rho': -(rho1 * target)},\n                                2: {'x1': maximum, 'y1': 1, 'x2': domain_max * maximum, 'y2': 0,\n                                    'rho': -(rho4 * (maximum - target))}}\n            else:\n                segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': target, 'y2': 1, 'rho': -(rho1 * target)},\n                                2: {'x1': target, 'y1': 1, 'x2': maximum, 'y2': y2,\n                                    'rho': (rho3 * (maximum - target))},\n                                3: {'x1': maximum, 'y1': y2, 'x2': domain_max * maximum, 'y2': 0,\n                                    'rho': -(rho4 * (domain_max * maximum - maximum))}}\n\n        else:\n            if target == maximum:\n                segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': minimum, 'y2': y1, 'rho': -(rho1 * (minimum - 0))},\n                                2: {'x1': minimum, 'y1': y1, 'x2': target, 'y2': 1,\n                                    'rho': (rho2 * (target - minimum))},\n                                3: {'x1': target, 'y1': 1, 'x2': domain_max * maximum, 'y2': 0,\n                                    'rho': -(rho4 * (domain_max * maximum - maximum))}}\n            else:\n                segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': minimum, 'y2': y1, 'rho': -(rho1 * (minimum - 0))},\n                                2: {'x1': minimum, 'y1': y1, 'x2': target, 'y2': 1,\n                                    'rho': (rho2 * (target - minimum))},\n                                3: {'x1': target, 'y1': 1, 'x2': maximum, 'y2': y2,\n                                    'rho': (rho3 * (maximum - target))},\n                                4: {'x1': maximum, 'y1': y2, 'x2': domain_max * maximum, 'y2': 0,\n                                    'rho': -(rho4 * (domain_max * maximum - maximum))}}\n\n    else:  # Must be a \"Min Increasing/Decreasing\" function\n\n        # Receive values from string\n        f_param_list = split_list[1]\n        split_list = f_param_list.split(',')\n        rho = float(split_list[0].strip()) * target  # Multiplying by the target normalizes the domain space\n\n        # Build segments\n        if f_type == 'Min Increasing':\n            segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': target, 'y2': 1, 'rho': -rho}}\n        else:\n            segment_dict = {1: {'x1': target, 'y1': 1, 'x2': 1, 'y2': 0, 'rho': -rho}}\n\n    return segment_dict\n</code></pre>"},{"location":"reference/data/values/#data.values.value_function_builder","title":"<code>value_function_builder(segment_dict=None, num_breakpoints=None, derivative_locations=False)</code>","text":"<p>This procedure takes in a dictionary of exponential segments and returns the breakpoints (measures and values) for that value function.</p> <p>Parameters:</p> Name Type Description Default <code>segment_dict</code> <p>A dictionary representing exponential segments of the value function. The dictionary should have the following format: { segment_id: { 'x1': measure of the starting point of the segment, 'y1': value of the starting point of the segment, 'x2': measure of the ending point of the segment, 'y2': value of the ending point of the segment, 'rho': rate of change for the segment, 'r': number of breakpoints per segment (optional) }, ... } If segment_dict is not provided, a default dictionary will be used.</p> <code>None</code> <code>num_breakpoints</code> <p>The total number of breakpoints to be generated for the value function. If not specified within the segment_dict for each segment, a general number of breakpoints will be used. If both segment_dict and num_breakpoints are provided, num_breakpoints takes precedence.</p> <code>None</code> <code>derivative_locations</code> <p>A boolean flag indicating whether breakpoints should be placed at locations where the derivative increases by some interval. If True, breakpoints will be placed based on derivative intervals; if False, breakpoints will be placed at fixed intervals based on x.</p> <code>False</code> <p>Returns:</p> Type Description <p>Two numpy arrays representing the breakpoints of the value function: - a: Array of breakpoint measures. - fhat: Array of breakpoint values.  Note: - The breakpoints are determined based on the exponential segments provided. - The resulting breakpoints are returned as numpy arrays, with measures and values rounded to 5 decimal places.</p> Source code in <code>afccp/data/values.py</code> <pre><code>def value_function_builder(segment_dict=None, num_breakpoints=None, derivative_locations=False):\n    \"\"\"\n    This procedure takes in a dictionary of exponential segments and returns the breakpoints (measures and values) for\n    that value function.\n\n    :param segment_dict: A dictionary representing exponential segments of the value function.\n        The dictionary should have the following format:\n        {\n            segment_id: {\n                'x1': measure of the starting point of the segment,\n                'y1': value of the starting point of the segment,\n                'x2': measure of the ending point of the segment,\n                'y2': value of the ending point of the segment,\n                'rho': rate of change for the segment,\n                'r': number of breakpoints per segment (optional)\n            },\n            ...\n        }\n        If segment_dict is not provided, a default dictionary will be used.\n\n    :param num_breakpoints: The total number of breakpoints to be generated for the value function.\n        If not specified within the segment_dict for each segment, a general number of breakpoints will be used.\n        If both segment_dict and num_breakpoints are provided, num_breakpoints takes precedence.\n\n    :param derivative_locations: A boolean flag indicating whether breakpoints should be placed at locations where\n        the derivative increases by some interval. If True, breakpoints will be placed based on derivative intervals;\n        if False, breakpoints will be placed at fixed intervals based on x.\n\n    :return: Two numpy arrays representing the breakpoints of the value function:\n        - a: Array of breakpoint measures.\n        - fhat: Array of breakpoint values.\n\n    Note:\n    - The breakpoints are determined based on the exponential segments provided.\n    - The resulting breakpoints are returned as numpy arrays, with measures and values rounded to 5 decimal places.\n    \"\"\"\n\n    if segment_dict is None:\n        segment_dict = {1: {'x1': 0, 'y1': 0, 'x2': 0.2, 'y2': 0.8, 'rho': -0.2, 'r': 10},\n                        2: {'x1': 0.2, 'y1': 0.8, 'x2': 0.3, 'y2': 1, 'rho': 0.2, 'r': 10},\n                        3: {'x1': 0.5, 'y1': 1, 'x2': 0.7, 'y2': 0.8, 'rho': 0.2, 'r': 10},\n                        4: {'x1': 0.7, 'y1': 0.8, 'x2': 1, 'y2': 0, 'rho': -0.2, 'r': 10}}\n\n    # Collect segments\n    segments = list(segment_dict.keys())\n    num_segments = len(segments)\n\n    # We need number of breakpoints for each exponential segment\n    if num_breakpoints is None:\n        num_breakpoints = 0\n        for segment in segments:\n            if 'r' in segment_dict[segment].keys():\n                segment_dict[segment]['r'] = segment_dict[segment]['r']\n            else:\n                segment_dict[segment]['r'] = 10\n\n            num_breakpoints += segment_dict[segment]['r']\n\n    else:\n        new_num_breakpoints = 0\n        for segment in segments:\n            if 'r' in segment_dict[segment].keys():\n                segment_dict[segment]['r'] = max(int(num_breakpoints / num_segments), segment_dict[segment]['r'])\n            else:\n                segment_dict[segment]['r'] = int(num_breakpoints / num_segments)\n            new_num_breakpoints += segment_dict[segment]['r']\n        num_breakpoints = new_num_breakpoints\n\n    # Number of breakpoints are determined based on which kinds of exponential segments we're using\n    add_bp = False\n    extra = False\n    insert = False\n    if (num_segments == 4 and segment_dict[2]['x2'] != segment_dict[3]['x1']) or num_segments == 2:\n        a = np.zeros(num_breakpoints + 2)\n        fhat = np.zeros(num_breakpoints + 2)\n        extra = True\n    elif num_segments == 1 and segment_dict[1]['x2'] &lt; 1:\n        a = np.zeros(num_breakpoints + 2)\n        fhat = np.zeros(num_breakpoints + 2)\n        add_bp = True\n    elif num_segments == 1 and segment_dict[1]['x1'] != 0:\n        a = np.zeros(num_breakpoints + 2)\n        fhat = np.zeros(num_breakpoints + 2)\n        fhat[0] = 1\n        insert = True\n    else:\n        a = np.zeros(num_breakpoints + 1)\n        fhat = np.zeros(num_breakpoints + 1)\n\n    # Loop through each exponential segment\n    i = 1\n    for segment in segments:\n\n        # Load variables\n        x1 = segment_dict[segment]['x1']\n        y1 = segment_dict[segment]['y1']\n        x2 = segment_dict[segment]['x2']\n        y2 = segment_dict[segment]['y2']\n        rho = segment_dict[segment]['rho']\n        r = segment_dict[segment]['r']\n\n        # Necessary operations\n        x_diff = x2 - x1\n        y_diff = y2 - y1\n        x_over_y = abs(x_diff / y_diff)\n        if y_diff &lt; 0:\n            positive = False\n        else:\n            positive = True\n\n        if derivative_locations:  # We place x breakpoints at fixed intervals based on derivative\n            y_prime_i = round(derivative_function(0, x_over_y, rho, positive), 2)\n            y_prime_f = round(derivative_function(x_over_y, x_over_y, rho, positive), 2)\n            y_prime_step = (y_prime_f - y_prime_i) / r\n            y_prime_arr = np.array([y_prime_i + y_prime_step * i for i in range(1, r + 1)])\n            x_arr = np.array([\n                inverse_derivative_function(y_prime, x_over_y, rho, positive) for y_prime in y_prime_arr])\n\n        else:  # We place them at fixed intervals based on x\n            x_arr = (np.arange(1, r + 1) / r) * x_over_y\n\n        vals = np.array([exponential_function(x, 0, x_over_y, rho, positive) for x in x_arr])\n\n        # If we need to add extra breakpoints\n        if y1 == 1 and extra:\n            a[i] = x1\n            fhat[i] = 1\n            i += 1\n\n        if insert:\n            a[1] = x1\n            fhat[1] = 1\n            a[2:2 + r] = x1 + x_arr * abs(y_diff)\n            fhat[2:2 + r] = y2 + vals * abs(y_diff)\n        else:\n            a[i:i + r] = x1 + x_arr * abs(y_diff)\n            if positive:\n                fhat[i:i + r] = y1 + vals * y_diff\n            else:\n                fhat[i:i + r] = y2 + vals * abs(y_diff)\n            i += r\n\n            if add_bp:\n                a[r + 1] = 1\n                fhat[r + 1] = 1\n\n    # Return breakpoint measures and values used in value function\n    a = np.around(a, 5)\n    fhat = np.around(fhat, 5)\n    return a, fhat\n</code></pre>"},{"location":"reference/data/values/#data.values.exponential_function","title":"<code>exponential_function(x, x_i, x_f, rho, positive)</code>","text":"<p>This function returns the value obtained from the specified exponential value function</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>current x</p> required <code>x_i</code> <p>initial x from segment</p> required <code>x_f</code> <p>final x from segment</p> required <code>rho</code> <p>rho parameter</p> required <code>positive</code> <p>if we have an increasing function or not</p> required <p>Returns:</p> Type Description <p>current y</p> Source code in <code>afccp/data/values.py</code> <pre><code>def exponential_function(x, x_i, x_f, rho, positive):\n    \"\"\"\n    This function returns the value obtained from the specified exponential value function\n    :param x: current x\n    :param x_i: initial x from segment\n    :param x_f: final x from segment\n    :param rho: rho parameter\n    :param positive: if we have an increasing function or not\n    :return: current y\n    \"\"\"\n    if positive:\n        y = (1 - exp(-(x - x_i) / rho)) / \\\n            (1 - exp(-(x_f - x_i) / rho))\n    else:\n\n        y = (1 - exp(-(x_f - x) / rho)) / \\\n            (1 - exp(-(x_f - x_i) / rho))\n\n    return y\n</code></pre>"},{"location":"reference/data/values/#data.values.derivative_function","title":"<code>derivative_function(x, x_f, rho, positive)</code>","text":"<p>This function calculates the derivative of x for some point along a line segment</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>some x</p> required <code>x_f</code> <p>final x from segment</p> required <code>rho</code> <p>rho parameter</p> required <code>positive</code> <p>if we have an increasing function or not</p> required <p>Returns:</p> Type Description <p>y_prime</p> Source code in <code>afccp/data/values.py</code> <pre><code>def derivative_function(x, x_f, rho, positive):\n    \"\"\"\n    This function calculates the derivative of x for some point\n    along a line segment\n    :param x: some x\n    :param x_f: final x from segment\n    :param rho: rho parameter\n    :param positive: if we have an increasing function or not\n    :return: y_prime\n    \"\"\"\n    if positive:\n        y_prime = exp(-x / rho) / (rho * (1 - exp(-x_f / rho)))\n    else:\n        y_prime = -exp(-(x_f - x) / rho) / (rho * (1 - exp(-x_f / rho)))\n    return y_prime\n</code></pre>"},{"location":"reference/data/values/#data.values.inverse_derivative_function","title":"<code>inverse_derivative_function(y_prime, x_f, rho, positive)</code>","text":"<p>This function calculates the position of x based on its derivative</p> <p>Parameters:</p> Name Type Description Default <code>y_prime</code> <p>first derivative of x</p> required <code>x_f</code> <p>final x from segment</p> required <code>rho</code> <p>rho parameter</p> required <code>positive</code> <p>if we have an increasing function or not</p> required <p>Returns:</p> Type Description <p>x</p> Source code in <code>afccp/data/values.py</code> <pre><code>def inverse_derivative_function(y_prime, x_f, rho, positive):\n    \"\"\"\n    This function calculates the position of x based on its derivative\n    :param y_prime: first derivative of x\n    :param x_f: final x from segment\n    :param rho: rho parameter\n    :param positive: if we have an increasing function or not\n    :return: x\n    \"\"\"\n    if positive:\n        x = -rho * log(rho * (1 - exp(-x_f / rho)) * y_prime)\n    else:\n        x = x_f + rho * log(-rho * (1 - exp(-x_f / rho)) * y_prime)\n\n    return x\n</code></pre>"},{"location":"reference/data/values/#data.values.condense_value_functions","title":"<code>condense_value_functions(parameters, value_parameters)</code>","text":"<p>This procedure takes an instances' value functions and removes all unnecessary zeros in the values</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <p>fixed cadet parameters</p> required <code>value_parameters</code> <p>weight and value parameters</p> required <p>Returns:</p> Type Description <p>value parameters with cleaned value functions</p> Source code in <code>afccp/data/values.py</code> <pre><code>def condense_value_functions(parameters, value_parameters):\n    \"\"\"\n    This procedure takes an instances' value functions and removes all unnecessary zeros in the values\n    :param parameters: fixed cadet parameters\n    :param value_parameters: weight and value parameters\n    :return: value parameters with cleaned value functions\n    \"\"\"\n\n    # Shorthand\n    p, vp = parameters, value_parameters\n    for j in p['J']:\n        for k in vp['K^A'][j]:\n            a = np.array(vp['a'][j][k])\n            fhat = np.array(vp['f^hat'][j][k])\n\n            # Find unnecessary zeros\n            zero_indices = np.where(fhat == 0)[0]\n            last_i = len(a) - 1\n            removals = []\n            for i in zero_indices:\n                if i + 1 in zero_indices and i + 1 != last_i and i != 0:\n                    removals.append(i)\n\n            # Remove unnecessary zeros\n            vp['a'][j][k] = np.delete(a, removals)\n            vp['f^hat'][j][k] = np.delete(fhat, removals)\n\n    return vp\n</code></pre>"},{"location":"reference/data/values/#data.values.translate_vft_to_gp_parameters","title":"<code>translate_vft_to_gp_parameters(instance)</code>","text":"<p>Translates the VFT (Value Focused Thinking) parameters to Rebecca's model parameters.</p> <p>Args:     instance: An instance of CadetCareerProblem</p> <p>Returns:     gp (dict): A dictionary containing the translated parameters for Rebecca's model.</p> <p>Notes:     The function assumes that the instance object contains the following attributes:         - parameters: A dictionary containing the VFT model parameters.         - value_parameters: A dictionary containing the value parameters of the VFT model.</p> Source code in <code>afccp/data/values.py</code> <pre><code>def translate_vft_to_gp_parameters(instance):\n    \"\"\"\n    Translates the VFT (Value Focused Thinking) parameters to Rebecca's model parameters.\n\n    Args:\n        instance: An instance of CadetCareerProblem\n\n    Returns:\n        gp (dict): A dictionary containing the translated parameters for Rebecca's model.\n\n    Notes:\n        The function assumes that the instance object contains the following attributes:\n            - parameters: A dictionary containing the VFT model parameters.\n            - value_parameters: A dictionary containing the value parameters of the VFT model.\n    \"\"\"\n\n    # Shorthand\n    p = instance.parameters\n    vp = instance.value_parameters\n    objectives = vp['objectives']\n\n    # Other parameters\n    large_afscs = np.where(p['pgl'] &gt;= 40)[0]  # set of large AFSCs\n    mand_k = np.where(objectives == 'Mandatory')[0][0]  # mandatory objective index\n    des_k = np.where(objectives == 'Desired')[0][0]  # desired objective index\n    perm_k = np.where(objectives == 'Permitted')[0][0]  # permitted objective index\n    usafa_k = np.where(objectives == 'USAFA Proportion')[0][0]  # USAFA proportion objective index\n\n    # Initialize \"gp\" dictionary (Goal Programming Model Parameters)\n    gp = {}\n\n    # Main sets\n    A = np.arange(p['M'])\n    C = np.arange(p['N'])\n    gp['A'], gp['M'] = A, len(A)  # AFSCs, number of AFSCs\n    gp['C'], gp['N'] = C, len(C)  # Cadets, number of Cadets\n\n    # List of constraints\n    gp['con'] = ['T',  # Target constraint\n                 'F',  # Over-classification constraint\n                 'M',  # Mandatory education constraint\n                 'D_under',  # Desired education constraint (lower bound)\n                 'D_over',  # Desired education constraint (upper bound)\n                 'P',  # Permitted education constraint\n                 'U_under',  # USAFA proportion constraint (lower bound)\n                 'U_over',  # USAFA proportion constraint (upper bound)\n                 'R_under',  # Percentile constraint (lower bound)\n                 'R_over',  # Percentile constraint (upper bound)\n                 'W']  # Cadet preference constraint\n\n    # Subsets of AFSCs that pertain to each constraint (1 dimensional arrays)\n    gp['A^'] = {'T': A,  # Subset of AFSCs with a minimum target quota: assumed all AFSCs\n                'F': A,  # Subset of AFSCs with over-classification limits: assumed all AFSCs\n                'M': np.array([a for a in A if 'Mandatory' in objectives[vp['K^A'][a]]]),  # Mandatory AFSCs\n                'D_under': np.array([a for a in A if 'Increasing' in vp['value_functions'][a, des_k]]),  # Desired AFSCs\n                'D_over': np.array([a for a in A if 'Decreasing' in vp['value_functions'][a, des_k]]),  # Desired AFSCs\n                'P': np.array([a for a in A if 'Permitted' in objectives[vp['K^A'][a]]]),  # Permitted AFSCs\n                'U_under': large_afscs,  # USAFA Proportion constrained AFSCs\n                'U_over': large_afscs,  # USAFA Proportion constrained AFSCs\n                'R_under': large_afscs,  # Percentile constrained AFSCs\n                'R_over': large_afscs,  # Percentile constrained AFSCs\n                'W': A}  # Subset of AFSCs with a cadet preference constraint: assumed all AFSCs\n\n    # Subset of AFSCs for which each cadet is eligible (Replaced A | A^I)\n    gp['A^']['E'] = p['J^E']\n\n    # Subset of AFSCs that each cadet has placed a preference for\n    A_Utility = [np.where(p['utility'][c, :] &gt; 0)[0] for c in C]\n\n    # Subset of AFSCs that each cadet has placed a preference for and is also eligible for\n    gp['A^']['W^E'] = [np.intersect1d(A_Utility[c], gp['A^']['E'][c]) for c in C]\n\n    # Subset of AFSCs which have an upper bound on the number of USAFA cadets\n    gp['A^']['U_lim'] = np.array([a for a in A if ',' in vp['objective_value_min'][a, usafa_k]])\n\n    # Set of cadets that have placed preferences on each of the AFSCs\n    C_Utility = [np.where(p['utility'][:, a] &gt; 0)[0] for a in A]\n\n    # Subsets of Cadets that pertain to each constraint  (2 dimensional arrays)\n    gp['C^'] = {'T': p['I^E'],  # Eligible Cadets for each AFSC\n                'F': p['I^E'],  # Eligible Cadets for each AFSC\n                'M': p['I^D']['Mandatory'],  # Cadets that have mandatory degrees for each AFSC\n                'D_under': p['I^D']['Desired'],  # Cadets that have desired degrees for each AFSC\n                'D_over': p['I^D']['Desired'],  # Cadets that have desired degrees for each AFSC\n                'P': p['I^D']['Permitted'],  # Cadets that have permitted degrees for each AFSC\n                'U_under': p['I^D']['USAFA Proportion'],  # Eligible USAFA Cadets for each AFSC\n                'U_over': p['I^D']['USAFA Proportion'],  # Eligible USAFA Cadets for each AFSC\n                'R_under': p['I^E'],  # Eligible Cadets for each AFSC\n                'R_over': p['I^E'],  # Eligible Cadets for each AFSC\n\n                # Eligible Cadets that have placed preferences for each AFSC\n                'W': [np.intersect1d(C_Utility[a], p['I^E'][a]) for a in A]}\n\n    # Subset of eligible cadets for each AFSC\n    gp['C^']['E'] = p['I^E']\n\n    # Subset of eligible usafa cadets for each AFSC\n    gp['C^']['U'] = p['I^D']['USAFA Proportion']\n\n    # Parameters for each of the constraints (1 dimensional arrays)\n    gp['param'] = {'T': p['quota_min'],  # Target quotas\n                   'F': p['quota_max'],  # Over-classification amounts\n                   'M': vp['objective_target'][:, mand_k],  # Mandatory targets\n                   'D_under': vp['objective_target'][:, des_k],  # Desired targets\n                   'D_over': vp['objective_target'][:, des_k],  # Desired targets\n                   'P': vp['objective_target'][:, perm_k],  # Permitted targets\n                   'U_under': np.repeat(0.2, p['M']),  # USAFA Proportion lower bound\n                   'U_over': np.repeat(0.4, p['M']),  # USAFA Proportion upper bound\n                   'R_under': np.repeat(0.35, p['M']),  # Percentile lower bound\n                   'R_over': np.repeat(0.65, p['M']),  # Percentile upper bound\n                   'W': np.repeat(0.5, p['M'])}  # Cadet preference lower bound\n\n    # Other parameters\n    gp['utility'] = p['utility']  # utility matrix (replaced \"w\" since \"w\" was already a parameter in her model)\n    gp['Big_M'] = 2000  # sufficiently large number\n    gp['u_limit'] = 0.05  # limit on number of USAFA cadets for certain AFSCs\n    gp['merit'] = p['merit']  # cadet percentiles\n\n    # Penalty and Reward parameters\n    columns = ['Normalized Penalty', 'Normalized Reward', 'Run Penalty', 'Run Reward']\n    column_dict = {column: np.array(instance.gp_df[column]) for column in columns}\n\n    # actual reward parameters\n    reward = column_dict['Normalized Reward'] * column_dict['Run Reward']\n\n    # actual penalty parameters\n    penalty = column_dict['Normalized Penalty'] * column_dict['Run Penalty']\n\n    # mu parameters (Penalties)\n    gp['mu^'] = {con: penalty[index] for index, con in enumerate(gp['con'])}\n\n    # lambda parameters (Rewards)\n    gp['lam^'] = {con: reward[index] for index, con in enumerate(gp['con'])}\n    gp['lam^']['S'] = reward[len(gp['con'])]  # extra reward for preference in order of merit\n\n    return gp\n</code></pre>"},{"location":"reference/data/values/#data.values.generate_concave_curve","title":"<code>generate_concave_curve(num_points, max_x)</code>","text":"<p>Generates x and y coordinates for a concave function.</p> <p>Args:     num_points (int): Number of points to generate.     max_x (float): Maximum value along the x-axis.</p> <p>Returns:     tuple: (x_values, y_values) as numpy arrays.</p> Source code in <code>afccp/data/values.py</code> <pre><code>def generate_concave_curve(num_points, max_x):\n    \"\"\"\n    Generates x and y coordinates for a concave function.\n\n    Args:\n        num_points (int): Number of points to generate.\n        max_x (float): Maximum value along the x-axis.\n\n    Returns:\n        tuple: (x_values, y_values) as numpy arrays.\n    \"\"\"\n    x_values = np.linspace(0, max_x, num_points)\n    y_values = 1 - np.exp(-x_values / (max_x / 6))  # Adjust curvature\n    return x_values, y_values\n</code></pre>"},{"location":"reference/research/__init__/","title":"init","text":""},{"location":"reference/research/__init__/#research","title":"<code>research</code>","text":""},{"location":"reference/research/ots_cadet_additions/","title":"Ots cadet additions","text":""},{"location":"reference/research/ots_cadet_additions/#research.ots_cadet_additions","title":"<code>research.ots_cadet_additions</code>","text":""},{"location":"reference/research/rotc_rated/","title":"Rotc rated","text":""},{"location":"reference/research/rotc_rated/#research.rotc_rated","title":"<code>research.rotc_rated</code>","text":""},{"location":"reference/research/rotc_rated/#research.rotc_rated.process_data_in_parameters","title":"<code>process_data_in_parameters(df, parameters, autofix=False)</code>","text":"<p>This function takes in a dataframe (must be of the \"ROTC Rated Data\" format), processes it, and loads it into the appropriate \"parameters\" data dictionary. The \"parameters\" dictionary is then returned</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>dataframe in \"ROTC Rated Data\" format</p> required <code>parameters</code> <p>initialized parameters dictionary</p> required <p>Returns:</p> Type Description <p>parameters dictionary</p> Source code in <code>afccp/research/rotc_rated.py</code> <pre><code>def process_data_in_parameters(df, parameters, autofix=False):\n    \"\"\"\n    This function takes in a dataframe (must be of the \"ROTC Rated Data\" format), processes it,\n    and loads it into the appropriate \"parameters\" data dictionary. The \"parameters\" dictionary is then returned\n    :param df: dataframe in \"ROTC Rated Data\" format\n    :param parameters: initialized parameters dictionary\n    :return: parameters dictionary\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Collect AFSC preferences\n    p['rr_om_matrix'] = np.array(df.loc[:, p['rated_afscs'][0]: p['rated_afscs'][len(p['rated_afscs']) - 1]])\n    p['afscs_preferences'] = {}\n    for idx, j in enumerate(p['J^Rated']):\n        sorted_cadets = np.argsort(p['rr_om_matrix'][:, idx])[::-1]\n        zero_cadets = np.where(p['rr_om_matrix'][:, idx] == 0)[0]\n        num_zero = len(zero_cadets)\n        p['afscs_preferences'][j] = sorted_cadets[:p['N'] - num_zero]\n\n    # Cadets to remove\n    removals = []\n\n    # Collect Cadet preferences\n    p['c_preferences'] = np.array(df.loc[:, 'Pref_1':])\n    p['cadets_preferences'] = {}\n    p['rated_only_preferences'] = {}\n    p['cadet_first_choice'] = {}\n    p['num_eligible'] = {}\n    for i in p['I']:\n\n        # \"Real\" first choice AFSC\n        p['cadet_first_choice'][i] = p['c_preferences'][i, 0]\n\n        # Ordered list of AFSC indices\n        p['rated_only_preferences'][i] = np.array(\n            [np.where(p['afscs'] == afsc)[0][0] for afsc in p['c_preferences'][i] if afsc in p['rated_afscs']])\n        p['cadets_preferences'][i] = np.array(\n            [np.where(p['afscs'] == afsc)[0][0] for afsc in p['c_preferences'][i] if afsc in p['afscs']])\n\n        # Make sure cadet is on each of their desired AFSCs' lists\n        cadet_not_on_afsc_lists = []\n        for j in p['rated_only_preferences'][i]:\n            if i not in p['afscs_preferences'][j]:\n                cadet_not_on_afsc_lists.append(p['afscs'][j])\n\n                # We remove this AFSC from this cadet's preferences\n                idx = np.where(p['rated_only_preferences'][i] == j)[0][0]\n                p['rated_only_preferences'][i] = np.delete(p['rated_only_preferences'][i], idx)\n\n                # We remove this AFSC from this cadet's preferences\n                idx = np.where(p['cadets_preferences'][i] == j)[0][0]\n                p['cadets_preferences'][i] = np.delete(p['cadets_preferences'][i], idx)\n\n        # Print update\n        if len(cadet_not_on_afsc_lists) &gt; 0:\n            print_afscs = \", \".join(cadet_not_on_afsc_lists)\n            print(\"[\" + str(i) + \"] Cadet '\" + str(p['cadets'][i]) + \"' not eligible for \" + print_afscs +\n                  \". AFSC(s) have been removed from the cadet's preferences.\")\n\n        # See if this cadet is on the AFSC's list but the AFSC is not in their preferences\n        afsc_not_on_cadet_list = []\n        for j in [j for j in p['J^Rated'] if j not in p['rated_only_preferences'][i]]:\n            if i in p['afscs_preferences'][j]:\n                afsc_not_on_cadet_list.append(p['afscs'][j])\n\n                # We remove this cadet from this AFSC's preferences\n                idx = np.where(p['afscs_preferences'][j] == i)[0][0]\n                p['afscs_preferences'][j] = np.delete(p['afscs_preferences'][j], idx)\n\n        # Print update\n        if len(afsc_not_on_cadet_list) &gt; 0:\n            print_afscs = \", \".join(afsc_not_on_cadet_list)\n            print(\"[\" + str(i) + \"] Cadet '\" + str(p['cadets'][i]) + \"' on preferences lists for \" + print_afscs +\n                  \". AFSC(s) not in cadet's list. Cadet has been removed from the AFSCs' preferences.\")\n\n        # Number of eligible AFSCs for this cadet\n        p['num_eligible'][i] = len(p['rated_only_preferences'][i])\n\n        # Make sure this cadet is eligible for at least one rated AFSC\n        if p['num_eligible'][i] == 0:\n\n            if autofix:\n                print(\"Error at index '\" + str(i) + \"'. Cadet '\" + str(p['cadets'][i]) +\n                             \"' not eligible for any rated AFSCs but is in the dataset. Cadet will be removed\")\n                removals.append(p['cadets'][i])\n            else:\n                raise ValueError(\"Error at index '\" + str(i) + \"'. Cadet '\" + str(p['cadets'][i]) +\n                                 \"' not eligible for any rated AFSCs but is in the dataset. Please adjust.\")\n\n    # Return parameters and removals\n    return p, removals\n</code></pre>"},{"location":"reference/research/rotc_rated/#research.rotc_rated.rotc_rated_hr_algorithm","title":"<code>rotc_rated_hr_algorithm(parameters, printing=True)</code>","text":"<p>This function performs the classic hospital/residents algorithm to match ROTC rated cadets. The ideas of reserved/fixed AFSCs is also imposed here.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <p>dictionary of model parameters pertaining to the ROTC rated matching process</p> required <code>printing</code> <p>whether to print status updates</p> <code>True</code> <p>Returns:</p> Type Description <p>solution augmented parameters</p> Source code in <code>afccp/research/rotc_rated.py</code> <pre><code>def rotc_rated_hr_algorithm(parameters, printing=True):\n    \"\"\"\n    This function performs the classic hospital/residents algorithm to match ROTC rated cadets. The ideas of\n    reserved/fixed AFSCs is also imposed here.\n    :param parameters: dictionary of model parameters pertaining to the ROTC rated matching process\n    :param printing: whether to print status updates\n    :return: solution augmented parameters\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Dictionary to keep track of what AFSC choice in their list the cadets are proposing to\n    cadet_proposal_choice = {i: 0 for i in p['I']} # Initially all propose to their top Rated preference!\n\n    # Begin the simple Hospital/Residents Algorithm\n    total_rejections = {j: 0 for j in p['J^Rated']}  # Number of rejections for each rated AFSC\n    total_matched = {j: 0 for j in p['J^Rated']}  # Number of accepted cadets for each rated AFSC\n    exhausted_cadets = []  # Will contain the cadets that have exhausted (been rejected by) all of their preferences\n    iteration = 1 # First iteration of the algorithm\n    while sum([total_matched[j] for j in p['J^Rated']]) + len(exhausted_cadets) &lt; p['N']:  # Stopping conditions\n\n        # Cadets propose to their top choice that hasn't been rejected\n        proposals = {i: p['rated_only_preferences'][i][\n            cadet_proposal_choice[i]] if i not in exhausted_cadets else p['M'] for i in p['I']}\n        proposal_array = np.array([proposals[i] if i in p['I'] else p['M'] for i in p['I']])\n        counts = {p['afscs'][j]: len(np.where(proposal_array == j)[0]) for j in p['J^Rated']}\n\n        # Initialize matches information for this iteration\n        total_matched = {j: 0 for j in p['J^Rated']}\n\n        # AFSCs accept their best cadets and reject the others\n        for j in p['J^Rated']:\n\n            # Loop through their preferred cadets from top to bottom\n            iteration_rejections = 0\n            for i in p['afscs_preferences'][j]:\n\n                # If the cadet is proposing to this AFSC, we have two options\n                if proposals[i] == j:\n\n                    # We haven't hit capacity, so we accept this cadet\n                    if total_matched[j] &lt; p['total_slots'][j]:\n                        total_matched[j] += 1\n\n                    # We're at capacity, so we reject this cadet\n                    else:\n\n                        # Essentially \"delete\" the preference from the cadet's list\n                        cadet_proposal_choice[i] += 1\n                        proposals[i] = p['M']  # index of the unmatched AFSC (*)\n\n                        # Collect additional information\n                        if printing:\n                            iteration_rejections += 1\n                            total_rejections[j] += 1\n\n        # Check exhausted cadets\n        exhausted_cadets = []\n        for i in p['I']:\n            if cadet_proposal_choice[i] &gt;= p['num_eligible'][i]:\n                exhausted_cadets.append(i)\n\n        # Print statement\n        if printing:\n            print(\"\\nIteration\", iteration)\n            print('Proposals:', counts)\n            print('Matched', {p['afscs'][j]: total_matched[j] for j in p['J^Rated']})\n            print('Rejected', {p['afscs'][j]: total_rejections[j] for j in p['J^Rated']})\n            total_matched_sum = sum([total_matched[j] for j in p['J^Rated']])\n            exhausted_sum = len(exhausted_cadets)\n            print(\"Total Exhausted (\" + str(exhausted_sum) + \") + Total Matched (\" + str(total_matched_sum)\n                  + \") = Total Accounted (\" + str(exhausted_sum + total_matched_sum) + \") || N: \" + str(p['N']) + \".\")\n\n        iteration += 1  # Next iteration!\n\n    # Create \"Matched\" and \"Reserved\" solution arrays\n    p['matches'], p['reserves'] = np.array([p['M'] for _ in p['I']]), np.array([p['M'] for _ in p['I']])\n    p['J^Fixed'], p['J^Reserved'] = {}, {}\n    for i in p['I']:\n        j = proposal_array[i]\n        if j in p['J^Rated']:\n            if p['cadet_first_choice'][i] == p['afscs'][j]:\n                p['matches'][i] = j\n                p['J^Fixed'][i] = j\n            else:\n                p['reserves'][i] = j\n                choice = np.where(p['cadets_preferences'][i] == j)[0][0]\n                p['J^Reserved'][i] = p['cadets_preferences'][i][:choice + 1]\n\n\n\n\n    return p\n</code></pre>"},{"location":"reference/research/rotc_rated/#research.rotc_rated.rotc_rated_alternates_algorithm","title":"<code>rotc_rated_alternates_algorithm(parameters, printing=True)</code>","text":"<p>This function takes in the results from the ROTC Rated HR algorithm and then augments it with the alternate list logic</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <p>dictionary of model parameters pertaining to the ROTC rated matching process</p> required <code>printing</code> <p>whether to print status updates</p> <code>True</code> <p>Returns:</p> Type Description <p>augmented parameters containing the solution w/alternates</p> Source code in <code>afccp/research/rotc_rated.py</code> <pre><code>def rotc_rated_alternates_algorithm(parameters, printing=True):\n    \"\"\"\n    This function takes in the results from the ROTC Rated HR algorithm and then augments it with the\n    alternate list logic\n    :param parameters: dictionary of model parameters pertaining to the ROTC rated matching process\n    :param printing: whether to print status updates\n    :return: augmented parameters containing the solution w/alternates\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Start with a full list of cadets eligible for each AFSC\n    possible_cadets = {j: list(p['afscs_preferences'][j]) for j in p['J^Rated']}\n\n    # Used for stopping conditions\n    last_reserves, last_matches, last_alternates_h = np.array([1000 for _ in p['J^Rated']]), \\\n                                                     np.array([1000 for _ in p['J^Rated']]), \\\n                                                     np.array([1000 for _ in p['J^Rated']])\n\n    # Main algorithm\n    iteration, iterating = 0, True\n    while iterating:\n\n        # Set of cadets reserved or matched to each rated AFSC\n        p['I^Reserved'] = {j: np.array([i for i in p['J^Reserved'] if p['reserves'][i] == j]) for j in p['J^Rated']}\n        p['I^Matched'] = {j: np.array([i for i in p['J^Fixed'] if p['matches'][i] == j]) for j in p['J^Rated']}\n\n        # Number of alternates (number of reserved slots)\n        num_reserved = {j: len(p['I^Reserved'][j]) for j in p['J^Rated']}\n\n        # Need to determine who falls into each category of alternates\n        hard_alternates = {j: [] for j in p['J^Rated']}\n        soft_alternates = {j: [] for j in p['J^Rated']}\n        alternates = {j: [] for j in p['J^Rated']}  # all the cadets ordered here\n\n        # Loop through each rated AFSC to determine alternates\n        for j in p['J^Rated']:\n\n            # Loop through each cadet in order of the AFSC's preference\n            for i in p['afscs_preferences'][j]:\n\n                # Assume this cadet is \"next in line\" until proven otherwise\n                next_in_line = True\n\n                # Is the cadet already fixed to something else?\n                if i in p['J^Fixed']:\n                    next_in_line = False\n                    if i in possible_cadets[j]:\n                        possible_cadets[j].remove(i)\n\n                # Is this cadet reserved for something?\n                if i in p['J^Reserved']:\n\n                    # Where did the cadet rank their reserved AFSC?\n                    reserved_choice = np.where(p['rated_only_preferences'][i] == p['reserves'][i])[0][0]\n\n                    # Where did the cadet rank this rated AFSC?\n                    this_choice = np.where(p['rated_only_preferences'][i] == j)[0][0]\n\n                    # If they're already reserved for this rated AFSC or something better, they're not considered\n                    if reserved_choice &lt;= this_choice:\n                        next_in_line = False\n                        if i in possible_cadets[j]:\n                            possible_cadets[j].remove(i)\n\n                # If this cadet is next in line (and we still have alternates to assign)\n                if next_in_line and len(hard_alternates[j]) &lt; num_reserved[j]:\n                    alternates[j].append(i)\n\n                    # Loop through the cadet's preferences:\n                    for j_c in p['cadets_preferences'][i]:\n\n                        # Determine what kind of alternate this cadet is\n                        if j_c == j:  # Hard Rated Alternate\n                            hard_alternates[j].append(i)\n                            break\n                        elif j_c in p['J^Rated']:\n                            if i in possible_cadets[j_c]:  # Soft Rated Alternate\n                                soft_alternates[j].append(i)\n                                break\n                            else:  # Can't be matched, go to next preference\n                                continue\n                        else:  # Soft Non-Rated Alternate\n                            soft_alternates[j].append(i)\n                            break\n\n                # We've run out of hard alternates to assign (thus, we're done assigning alternates)\n                elif len(hard_alternates[j]) &gt;= num_reserved[j]:\n                    if i in possible_cadets[j]:\n                        possible_cadets[j].remove(i)\n\n        # Loop through each AFSC to potentially turn \"reserved\" slots into \"matched\" slots\n        for j in p['J^Rated']:\n\n            # Loop through each cadet in order of the AFSC's preference\n            for i in p['afscs_preferences'][j]:\n\n                # Does this cadet have a reserved slot for something?\n                if i in p['J^Reserved']:\n\n                    # Is this cadet reserved for this AFSC?\n                    if p['reserves'][i] == j:\n\n                        # Determine if there's any possible way this cadet might not be matched to this AFSC\n                        inevitable_match = True\n                        for j_c in p['J^Reserved'][i][:-1]:  # Loop through all more preferred AFSCs than this one\n                            if j_c not in p['J^Rated']:  # Non-Rated\n                                inevitable_match = False\n                            else:  # Rated\n                                if i in alternates[j_c]:  # They're an alternate for something more preferred\n                                    inevitable_match = False\n                                else:  # They're not an alternate for that more preferred AFSC...\n                                    if i in possible_cadets[j_c]:  # ...they cannot be matched to that AFSC\n                                        possible_cadets[j_c].remove(i)  # Remove this cadet as a possibility!\n\n                        # If still inevitable, change from reserved to fixed\n                        if inevitable_match:\n                            p['J^Fixed'][i], p['matches'][i], p['reserves'][i] = j, j, p['M']\n                            p['J^Reserved'].pop(i)\n\n                # This cadet cannot receive this AFSC\n                if i not in alternates[j] and i in possible_cadets[j]:\n                    possible_cadets[j].remove(i)\n\n        # Print Statement\n        if printing:\n            print(\"\\nIteration\", iteration)\n            print(\"Possible\", {p['afscs'][j]: len(possible_cadets[j]) for j in p['J^Rated']})\n            print(\"Matched\", {p['afscs'][j]: len(p['I^Matched'][j]) for j in p['J^Rated']})\n            print(\"Reserved\", {p['afscs'][j]: len(p['I^Reserved'][j]) for j in p['J^Rated']})\n            print(\"Alternates (Hard)\", {p['afscs'][j]: len(hard_alternates[j]) for j in p['J^Rated']})\n            print(\"Alternates (Soft)\", {p['afscs'][j]: len(soft_alternates[j]) for j in p['J^Rated']})\n\n        # Once we stop changing from the algorithm, we're done!\n        current_matched = np.array([len(p['I^Matched'][j]) for j in p['J^Rated']])\n        current_reserved = np.array([len(p['I^Reserved'][j]) for j in p['J^Rated']])\n        current_alternates_h = np.array([len(hard_alternates[j]) for j in p['J^Rated']])\n        if np.sum(current_matched - last_matches + current_reserved -\n                  last_reserves + current_alternates_h - last_alternates_h) == 0:\n            iterating = False\n        else:\n            last_matches, last_reserves, last_alternates_h = current_matched, current_reserved, current_alternates_h\n\n        # Next iteration\n        iteration += 1\n\n    # Incorporate alternate lists (broken down by Hard/Soft)\n    p['alternates_hard'] = np.array([p['M'] for _ in p['I']])\n    p['alternates_soft'] = np.array([p['M'] for _ in p['I']])\n    for i in p['I']:  # Loop through all rated cadets\n        for j in p['rated_only_preferences'][i]:  # Loop through rated preferences in order\n            if i in hard_alternates[j]:\n                p['alternates_hard'][i] = j\n            elif i in soft_alternates[j]:\n                p['alternates_soft'][i] = j\n                break  # Next cadet\n\n    # Return updated parameters (and alternate lists)\n    return p\n</code></pre>"},{"location":"reference/research/rotc_rated/#research.rotc_rated.rotc_rated_match","title":"<code>rotc_rated_match(filename, afsc_quotas, afscs, auto_fix_eligibility=False, printing=True)</code>","text":"<p>This is the main function to match ROTC rated cadets to their AFSCs prior to the main \"One Market\" model match. It calls all necessary functions to process the information and export it back to excel</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <p>name/path to file</p> required <code>afsc_quotas</code> <p>dictionary of ROTC capacities for the rated AFSCs</p> required <code>printing</code> <p>if we should print status updates</p> <code>True</code> <p>Returns:</p> Type Description <p>None. Export results to excel</p> Source code in <code>afccp/research/rotc_rated.py</code> <pre><code>def rotc_rated_match(filename, afsc_quotas, afscs, auto_fix_eligibility=False, printing=True):\n    \"\"\"\n    This is the main function to match ROTC rated cadets to their AFSCs prior to the main \"One Market\" model\n    match. It calls all necessary functions to process the information and export it back to excel\n    :param filename: name/path to file\n    :param afsc_quotas: dictionary of ROTC capacities for the rated AFSCs\n    :param printing: if we should print status updates\n    :return: None. Export results to excel\n    \"\"\"\n\n    # Load in data\n    df = afccp.globals.import_csv_data(filename)\n\n    # Process data twice, first to remove Rated ineligible cadets and then once more to finish\n    for iteration in [1, 2]:\n\n        # Initialize parameter dictionary\n        parameters = {'rated_afscs': np.array([afsc for afsc in afsc_quotas]), 'cadets': np.array(df['Cadet']),\n                      'afscs': afscs}\n\n        # Additional information\n        parameters['N'], parameters['M'] = len(parameters['cadets']), len(parameters['afscs'])\n        parameters['I'], parameters['J'] = np.arange(parameters['N']), np.arange(parameters['M'])\n        parameters['J^Rated'] = np.array([np.where(afsc == parameters['afscs'])[0][0] for afsc in parameters['rated_afscs']])\n        parameters['total_slots'] = {j: afsc_quotas[parameters['afscs'][j]] for j in parameters['J^Rated']}\n\n        if printing:\n            print(\"\\nProcessing Data...Iteration \" + str(iteration) + \"\\n\")\n\n        # Process data\n        parameters, removals = process_data_in_parameters(df, parameters, autofix=auto_fix_eligibility)\n\n        # Drop the cadets we don't want\n        df = df.set_index('Cadet')\n        df = df.drop(removals)\n        df = df.reset_index()\n\n    if printing:\n        print(\"\\nROTC Rated Board Algorithm...\")\n\n    # Run the rated board algorithm\n    parameters = rotc_rated_hr_algorithm(parameters, printing)\n\n    if printing:\n        print(\"\\nROTC Rated Alternates Algorithm...\\n\")\n\n    # Run the rated alternates algorithm\n    parameters = rotc_rated_alternates_algorithm(parameters, printing)\n\n    # Adjust solution arrays and add them into dataframe\n    df['Matches'] = [parameters['afscs'][j] if j in parameters['J'] else '' for j in parameters['matches']]\n    df['Reserves'] = [parameters['afscs'][j] if j in parameters['J'] else '' for j in parameters['reserves']]\n    df['Alternates (H)'] = [parameters['afscs'][j] if j in parameters['J'] else '' for j in\n                            parameters['alternates_hard']]\n    df['Alternates (S)'] = [parameters['afscs'][j] if j in parameters['J'] else '' for j in\n                            parameters['alternates_soft']]\n\n    # Export back to csv\n    df.to_csv(filename, index=False)\n</code></pre>"},{"location":"reference/research/testing/","title":"Testing","text":""},{"location":"reference/research/testing/#research.testing","title":"<code>research.testing</code>","text":""},{"location":"reference/research/testing/#research.testing.test_solve_times","title":"<code>test_solve_times()</code>","text":"<p>Tests solve times</p> Source code in <code>afccp/research/testing.py</code> <pre><code>def test_solve_times():\n    \"\"\"\n    Tests solve times\n    \"\"\"\n\n    # size_list = [(100, 6, 0), (200, 6, 0), (1200, 6, 0), (2500, 16, 0)]\n    size_list = [(500, 10, 6), (1500, 14, 6), (3000, 14, 10)]\n    # model_solver_list = [('GUO', 'cbc'), ('A-VFT', 'cbc'), ('E-VFT', 'ipopt')]\n    model_solver_list = [('GUO', 'cbc')]\n    instances_per_size = 5\n    max_solve_time = 60\n\n    df_columns = {'Iteration': [], 'Size (NxMxS)': [], 'Instance': [], 'Model': [], 'Solver': [], 'Result': [],\n                  'Solve Time (s)': [], 'Pyomo Z': [], 'Real X Exact VFT Z': [], 'Real X Approx VFT Z': [],\n                  'Rounded X Exact VFT Z': [], 'Real X GUO Z': [], 'Rounded X GUO Z': [], 'Integer X': [],\n                  'Integer Y': [], 'Integer V': [], 'Integer Q': [], 'Fixed, Reserved, Alternates': []}\n\n    # Loop through each problem size in the list\n    iteration = 0\n    for size in size_list:\n\n        N, M, S = size[0], size[1], size[2]\n        size_name = str(N) + 'x' + str(M) + 'x' + str(S)\n\n        print('\\nSize', size_name)\n\n        # Loop through each iteration of this problem size\n        for i in range(instances_per_size):\n\n            print('\\nInstance', i + 1)\n\n            # Create the problem instance\n            if S == 0:\n                instance = CadetCareerProblem('Random', N=N, M=M, P=M, printing=False)\n            else:\n                instance = CadetCareerProblem('Random', N=N, M=M, P=M, S=S, generate_extra_components=True,\n                                              printing=False)\n            instance.fix_generated_data(printing=False)\n            instance.set_value_parameters()\n            instance.soc_rated_matching_algorithm({'soc': 'usafa'})\n            instance.soc_rated_matching_algorithm({'soc': 'rotc'})\n            instance.incorporate_rated_algorithm_results()\n\n            # Loop through each model &amp; solver name in the list\n            for model_name, solver_name in model_solver_list:\n                iteration += 1\n\n                # Initialize \"p_dict\" for model controls\n                p_dict = {'solver_name': solver_name, 'pyomo_max_time': max_solve_time, 're-calculate x': False}\n\n                # Change dictionary based on certain features\n                if solver_name == 'couenne':\n                    p_dict['provide_executable'] = True\n                if S != 0:\n                    p_dict['solve_extra_components'] = True\n\n                # Add standard values\n                df_columns['Iteration'].append(iteration), df_columns['Instance'].append(i + 1)\n                df_columns['Size (NxMxS)'].append(size_name), df_columns['Model'].append(model_name),\n                df_columns['Solver'].append(solver_name)\n\n                print(model_name, solver_name, 'solving at', datetime.datetime.now().strftime(\"%H:%M:%S\"))\n\n                # Solve the model\n                try:\n                    if model_name == 'GUO':\n                        instance.solve_guo_pyomo_model(p_dict)\n                    elif model_name == 'A-VFT':\n                        p_dict['approximate'] = True\n                        instance.solve_vft_pyomo_model(p_dict)\n                    elif model_name == 'E-VFT':\n                        p_dict['approximate'] = False\n                        instance.solve_vft_pyomo_model(p_dict)\n\n                    # Solve Time\n                    if instance.solution['solve_time'] &gt;= max_solve_time:\n                        df_columns['Result'].append('Time Limit Reached')\n                    else:\n                        df_columns['Result'].append('Solved')\n\n                    # Add values\n                    df_columns['Solve Time (s)'].append(instance.solution['solve_time'])\n                    df_columns['Pyomo Z'].append(instance.solution['pyomo_obj_value'])\n                    df_columns['Fixed, Reserved, Alternates'].append(\n                        instance.solution['cadets_fixed_correctly'] + ', ' +\n                        instance.solution['cadets_reserved_correctly'] + ', ' + instance.solution['alternate_list_metric'])\n\n                    # Check if we have integer values\n                    df_columns['Integer X'].append(str(instance.solution['x_integer']))\n                    if model_name != 'GUO':\n                        df_columns['Integer Y'].append(str(instance.solution['y_integer']))\n                    else:\n                        df_columns['Integer Y'].append('N/A')\n                    if S != 0:\n                        df_columns['Integer V'].append(str(instance.solution['v_integer']))\n                        df_columns['Integer Q'].append(str(instance.solution['q_integer']))\n                    else:\n                        df_columns['Integer V'].append('N/A')\n                        df_columns['Integer Q'].append('N/A')\n\n                    # Get objective values\n                    df_columns['Real X GUO Z'].append(round(instance.solution['z^gu'], 4))\n                    df_columns['Real X Exact VFT Z'].append(round(instance.solution['z'], 4))\n\n                    # Get approximate VFT Z\n                    instance.measure_solution(approximate=True)\n                    df_columns['Real X Approx VFT Z'].append(round(instance.solution['z'], 4))\n\n                    # Get rounded X matrix objective values\n                    instance.mdl_p['re-calculate x'] = True\n                    instance.measure_solution()\n                    df_columns['Rounded X Exact VFT Z'].append(round(instance.solution['z'], 4))\n                    df_columns['Rounded X GUO Z'].append(round(instance.solution['z^gu'], 4))\n                    print(model_name, solver_name, 'solved in', instance.solution['solve_time'], 'seconds.')\n\n                    print_str = df_columns['Result'][iteration - 1]\n                    for element in ['Real X GUO Z', 'Real X Exact VFT Z', 'Real X Approx VFT Z', 'Rounded X Exact VFT Z',\n                                    'Rounded X GUO Z']:\n                        print_str += ', ' + element + ': ' + str(df_columns[element][iteration - 1])\n                    print(model_name, solver_name, print_str)\n\n                # Solver failed!\n                except:\n\n                    # Add values\n                    df_columns['Result'].append('Failed'), df_columns['Real X Approx VFT Z'].append(0)\n                    df_columns['Solve Time (s)'].append(0), df_columns['Rounded X GUO Z'].append(0)\n                    df_columns['Pyomo Z'].append(0), df_columns['Rounded X Exact VFT Z'].append(0)\n                    df_columns['Real X Exact VFT Z'].append(0), df_columns['Real X GUO Z'].append(0)\n                    df_columns['Integer X'].append('N/A'), df_columns['Integer Y'].append('N/A'), \\\n                    df_columns['Integer V'].append('N/A'), df_columns['Integer Q'].append('N/A')\n                    df_columns['Fixed, Reserved, Alternates'].append('N/A')\n                    print(model_name, solver_name, 'Failed')\n\n    # Put dataframe together\n    df = pd.DataFrame(df_columns)\n\n    # Export to csv\n    df.to_csv('Solve Time Test.csv', index=False)\n</code></pre>"},{"location":"reference/solutions/__init__/","title":"init","text":""},{"location":"reference/solutions/__init__/#solutions","title":"<code>solutions</code>","text":""},{"location":"reference/solutions/algorithms/","title":"Algorithms","text":""},{"location":"reference/solutions/algorithms/#solutions.algorithms","title":"<code>solutions.algorithms</code>","text":""},{"location":"reference/solutions/algorithms/#solutions.algorithms.classic_hr","title":"<code>classic_hr(instance, capacities=None, printing=True)</code>","text":"<p>Matches cadets and AFSCs across all rated, space, and NRL positions using the Hospitals/Residents algorithm.</p> <p>Parameters:     instance (CadetCareerProblem): The instance of the CadetCareerProblem class.     capacities (numpy.ndarray or None): The capacities of AFSCs. If None, the capacities are taken from the         instance parameters. Default is None.     printing (bool): Whether to print status updates or not. Default is True.</p> <p>Returns:     dict: The solution dictionary containing the assigned AFSCs for each cadet.</p> <p>This function implements the Hospitals/Residents algorithm to match cadets and AFSCs across all rated, space, and NRL positions. It takes an instance of the CadetCareerProblem class as input and an optional parameter <code>capacities</code> to specify the capacities of AFSCs. If <code>capacities</code> is None, the capacities are taken from the instance parameters. By default, the function prints status updates during the matching process.</p> <p>The algorithm initializes the necessary variables and dictionaries. It then proceeds with the Hospitals/Residents algorithm by having cadets propose to their top choices and AFSCs accept or reject cadets based on their preferences and capacities. The matching process continues until all cadets are matched or have exhausted their preferences. The function updates the matches and rejections for each AFSC and tracks the progress through iterations.</p> <p>The function returns a solution dictionary containing the assigned AFSCs for each cadet.</p> <p>Example usage:     solution = classic_hr(instance, capacities=capacities, printing=True)</p> Source code in <code>afccp/solutions/algorithms.py</code> <pre><code>def classic_hr(instance, capacities=None, printing=True):\n    \"\"\"\n    Matches cadets and AFSCs across all rated, space, and NRL positions using the Hospitals/Residents algorithm.\n\n    Parameters:\n        instance (CadetCareerProblem): The instance of the CadetCareerProblem class.\n        capacities (numpy.ndarray or None): The capacities of AFSCs. If None, the capacities are taken from the\n            instance parameters. Default is None.\n        printing (bool): Whether to print status updates or not. Default is True.\n\n    Returns:\n        dict: The solution dictionary containing the assigned AFSCs for each cadet.\n\n    This function implements the Hospitals/Residents algorithm to match cadets and AFSCs across all rated, space,\n    and NRL positions. It takes an instance of the CadetCareerProblem class as input and an optional parameter\n    `capacities` to specify the capacities of AFSCs. If `capacities` is None, the capacities are taken from the\n    instance parameters. By default, the function prints status updates during the matching process.\n\n    The algorithm initializes the necessary variables and dictionaries. It then proceeds with the Hospitals/Residents\n    algorithm by having cadets propose to their top choices and AFSCs accept or reject cadets based on their preferences\n    and capacities. The matching process continues until all cadets are matched or have exhausted their preferences.\n    The function updates the matches and rejections for each AFSC and tracks the progress through iterations.\n\n    The function returns a solution dictionary containing the assigned AFSCs for each cadet.\n\n    Example usage:\n        solution = classic_hr(instance, capacities=capacities, printing=True)\n    \"\"\"\n\n    if printing:\n        print(\"Modeling this as an H/R problem and solving with DAA...\")\n\n    # Shorthand\n    p, vp, mdl_p = instance.parameters, instance.value_parameters, instance.mdl_p\n\n    # Algorithm initialization\n    if capacities is None:\n        total_slots = p[mdl_p['capacity_parameter']]\n    else:  # In case this is used in a genetic algorithm\n        total_slots = capacities\n\n    # Array to keep track of what AFSC choice in their list the cadets are proposing to (python index at 0)\n    cadet_proposal_choice = np.zeros(p['N']).astype(int)  # Everyone proposes to their first choice initially\n\n    # Initialize solution dictionary\n    solution = {'method': 'HR'}\n\n    # Dictionary of parameters used for the \"BubbleChart\" object (animation)\n    if mdl_p['collect_solution_iterations']:\n        solution['iterations'] = {'type': 'HR'}\n        for key in ['proposals', 'matches', 'names']:\n            solution['iterations'][key] = {}\n\n    # Begin the simple Hospital/Residents Algorithm\n    total_rejections = np.zeros(p['M'])  # Number of rejections for each AFSC\n    total_matched = np.zeros(p['M'])  # Number of accepted cadets for each AFSC\n    exhausted_cadets = []  # Will contain the cadets that have exhausted (been rejected by) all of their preferences\n    iteration = 0  # First iteration of the algorithm\n    while np.sum(total_matched) + len(exhausted_cadets) &lt; p['N']:  # Stopping conditions\n\n        # Cadets propose to their top choice that hasn't been rejected\n        exhausted_cadets = np.where(cadet_proposal_choice &gt;= p['num_cadet_choices'])[0]\n        proposals = np.array([p['cadet_preferences'][i][cadet_proposal_choice[i]] if i not in exhausted_cadets\n                              else p['M'] for i in p['I']])\n\n        # Solution Iteration components (Proposals) and print statement\n        if mdl_p['collect_solution_iterations']:\n            solution['iterations']['proposals'][iteration] = copy.deepcopy(proposals)\n        if mdl_p['ma_printing']:\n            print(\"\\nIteration\", iteration + 1)\n            counts = {p['afscs'][j]: len(np.where(proposals == j)[0]) for j in p['J']}\n\n        # Initialize matches information for this iteration\n        total_matched = np.zeros(p['M'])\n\n        # AFSCs accept their best cadets and reject the others\n        for j in p['J']:\n\n            # Loop through their preferred cadets from top to bottom\n            iteration_rejections = 0\n            for i in p['afsc_preferences'][j]:\n\n                # If the cadet is proposing to this AFSC, we have two options\n                if proposals[i] == j:\n\n                    # We haven't hit capacity, so we accept this cadet\n                    if total_matched[j] &lt; total_slots[j]:\n                        total_matched[j] += 1\n\n                    # We're at capacity, so we reject this cadet\n                    else:\n\n                        # Essentially \"delete\" the preference from the cadet's list\n                        cadet_proposal_choice[i] += 1\n                        proposals[i] = p['M']  # index of the unmatched AFSC (*)\n\n                        # Collect additional information\n                        if mdl_p['ma_printing']:\n                            iteration_rejections += 1\n                            total_rejections[j] += 1\n\n        # Solution Iteration components\n        if mdl_p['collect_solution_iterations']:\n            solution['iterations']['matches'][iteration] = copy.deepcopy(proposals)\n            solution['iterations']['names'][iteration] = 'Round ' + str(iteration + 1)\n\n        # Specific matching algorithm print statement\n        if mdl_p['ma_printing']:\n            print('Proposals:', counts)\n            print('Matched', {p['afscs'][j]: total_matched[j] for j in p['J']})\n            print('Rejected', {p['afscs'][j]: total_rejections[j] for j in p['J']})\n\n        iteration += 1 # Next iteration!\n\n    # Last solution iteration\n    if mdl_p['collect_solution_iterations']:\n        solution['iterations']['last_s'] = iteration - 1\n\n    # Return solution\n    solution['j_array'] = proposals\n    solution['afsc_array'] = np.array([p['afscs'][j] for j in solution['j_array']])\n    return solution\n</code></pre>"},{"location":"reference/solutions/algorithms/#solutions.algorithms.rotc_rated_board_original","title":"<code>rotc_rated_board_original(instance, printing=False)</code>","text":"<p>Assigns Rated AFSCs to ROTC cadets based on their preferences and the existing quotas for each AFSC using the current rated board algorithm.</p> <p>Parameters:     instance (CadetCareerProblem): The instance of the CadetCareerProblem class.     printing (bool): Whether to print status updates or not. Default is False.</p> <p>Returns:     dict: The solution dictionary containing the assigned AFSCs for each cadet.</p> <p>This function assigns Rated AFSCs to ROTC cadets based on their preferences and the existing quotas for each AFSC. It follows the current rated board algorithm. The function takes an instance of the CadetCareerProblem class as input and an optional parameter <code>printing</code> to specify whether to print status updates. By default, <code>printing</code> is set to False. The function initializes the necessary variables and dictionaries for the algorithm. It then goes through each phase of the rated board algorithm, considering cadets' order of merit and interest levels for each AFSC. Cadets are assigned AFSCs based on availability and eligibility. The function updates the assigned AFSCs for each cadet and tracks the number of matched cadets for each AFSC. Finally, it converts the assigned AFSCs into a solution dictionary and returns it.</p> <p>Example usage:     solution = rotc_rated_board_original(instance, printing=True)</p> Source code in <code>afccp/solutions/algorithms.py</code> <pre><code>def rotc_rated_board_original(instance, printing=False):\n    \"\"\"\n    Assigns Rated AFSCs to ROTC cadets based on their preferences and the existing quotas for each AFSC using the\n    current rated board algorithm.\n\n    Parameters:\n        instance (CadetCareerProblem): The instance of the CadetCareerProblem class.\n        printing (bool): Whether to print status updates or not. Default is False.\n\n    Returns:\n        dict: The solution dictionary containing the assigned AFSCs for each cadet.\n\n    This function assigns Rated AFSCs to ROTC cadets based on their preferences and the existing quotas for each AFSC.\n    It follows the current rated board algorithm. The function takes an instance of the CadetCareerProblem class as\n    input and an optional parameter `printing` to specify whether to print status updates. By default, `printing` is\n    set to False. The function initializes the necessary variables and dictionaries for the algorithm. It then goes\n    through each phase of the rated board algorithm, considering cadets' order of merit and interest levels for each\n    AFSC. Cadets are assigned AFSCs based on availability and eligibility. The function updates the assigned AFSCs\n    for each cadet and tracks the number of matched cadets for each AFSC. Finally, it converts the assigned AFSCs into\n    a solution dictionary and returns it.\n\n    Example usage:\n        solution = rotc_rated_board_original(instance, printing=True)\n    \"\"\"\n\n\n    if printing:\n        print(\"Running status quo ROTC rated algorithm...\")\n\n    # Shorthand\n    p, mdl_p = instance.parameters, instance.mdl_p\n\n    # Cadets/AFSCs and their preferences\n    cadet_indices = p['Rated Cadets']['rotc']  # indices of the cadets in the full set of cadets\n    cadets, N = np.arange(len(cadet_indices)), len(cadet_indices)\n    rated_J = np.array([j for j in p['J^Rated'] if '_U' not in p['afscs'][j]])\n    afscs, M = p['afscs'][rated_J], len(rated_J)\n    afsc_indices = np.array([np.where(p['afscs'] == afsc)[0][0] for afsc in afscs])\n    afsc_om = {afscs[j]: p['rr_om_matrix'][:, j] for j in range(M)}  # list of OM percentiles for each AFSC\n    afsc_interest = {afscs[j]: p['rr_interest_matrix'][:, j] for j in range(M)}  # list of Rated interest from cadets\n    eligible = {afscs[j]: p['rr_om_matrix'][:, j] &gt; 0 for j in range(M)}  # binary eligibility column for each AFSC\n\n    # Dictionary of dictionaries of cadets within each order of merit \"level\" for each AFSC\n    om_cl = {\"High\": (0.4, 1), \"Med\": (0.2, 0.4), \"Low\": (0.1, 0.2)}\n    om = {afsc: {level: np.where((afsc_om[afsc] &gt;= om_cl[level][0]) &amp;\n                                 (afsc_om[afsc] &lt; om_cl[level][1]))[0] for level in om_cl} for afsc in afscs}\n\n    # Dictionary of dictionaries of cadets with each interest \"level\" for each AFSC\n    interest_levels = [\"High\", \"Med\", \"Low\", \"None\"]\n    interest = {afsc: {level: np.where(afsc_interest[afsc] == level)[0] for level in interest_levels} for afsc in afscs}\n\n    # Algorithm initialization\n    total_slots = {afscs[idx]: p['rotc_quota'][j] for idx, j in enumerate(afsc_indices)}\n    total_matched = {afsc: 0 for afsc in afscs}  # Number of matched cadets for each AFSC\n    matching = {afsc: True for afsc in afscs}  # Used in stopping conditions\n    assigned_afscs = {cadet: \"\" for cadet in cadets}\n\n    # Initialize solution dictionary\n    solution = {'cadets_solved_for': 'ROTC Rated', 'afscs_solved_for': 'Rated', 'method': 'ROTCRatedBoard'}\n\n    # Dictionary of parameters used for the \"BubbleChart\" object (animation)\n    if mdl_p['collect_solution_iterations']:\n        solution['iterations'] = {'type': 'ROTC Rated Board'}\n        for key in ['matches', 'names']:\n            solution['iterations'][key] = {}\n\n    # Re-order AFSCs if necessary\n    if instance.mdl_p['rotc_rated_board_afsc_order'] is not None:\n        afscs = instance.mdl_p['rotc_rated_board_afsc_order']  # Need to be ordered list of ROTC Rated AFSCs\n\n    # Phases of the Rated board where each tuple represents the level for (OM, Interest)\n    phases = [(\"High\", \"High\"), (\"High\", \"Med\"), (\"Med\", \"High\"), (\"Med\", \"Med\"), (\"Low\", \"High\"), (\"High\", \"Low\"),\n              (\"Low\", \"Med\"), (\"Med\", \"Low\"), (\"Low\", \"Low\"), (\"High\", \"None\"), (\"Med\", \"None\"), (\"Low\", \"None\")]\n    phase_num = 0\n    s = 0  # for solution iterations\n    while any(matching.values()) and phase_num &lt; len(phases):\n        phase = phases[phase_num]\n        om_level, interest_level = phase[0], phase[1]\n        phase_num += 1\n        if printing:\n            print(\"\\nPhase\", phase_num, om_level, \"OM\", \"&amp;\", interest_level, \"Interest\")\n\n        # Loop through each Rated AFSC\n        for afsc in afscs:\n\n            # Get the ordered list of cadets we're considering in this phase\n            phase_cadets = np.intersect1d(om[afsc][om_level], interest[afsc][interest_level])\n            om_phase_cadets = afsc_om[afsc][phase_cadets]\n            indices = np.argsort(om_phase_cadets)[::-1]\n            ordered_cadets = phase_cadets[indices]\n\n            # Loop through each eligible cadet to assign them this AFSC if applicable\n            eligible_cadets = np.where(eligible[afsc])[0]\n            counter = 0\n            for cadet in ordered_cadets:\n\n                # The cadet has to be eligible for the AFSC to be considered\n                if cadet not in eligible_cadets:\n                    continue\n\n                # If we didn't already assign them an AFSC, and we've still got open slots left, the cadet gets matched\n                if assigned_afscs[cadet] == \"\" and total_matched[afsc] &lt; total_slots[afsc]:\n                    assigned_afscs[cadet] = afsc\n                    total_matched[afsc] += 1\n                    counter += 1\n\n                # We've reached capacity for this AFSC\n                if total_matched[afsc] == total_slots[afsc]:\n                    matching[afsc] = False\n                    break\n\n            if counter != 0 and printing:\n                print(afsc, \"Phase Matched:\", counter, \"  ---&gt;   Total Matched:\", total_matched[afsc], \"/\",\n                      total_slots[afsc])\n\n            # Solution Iteration components\n            s += 1\n            if mdl_p['collect_solution_iterations']:\n                afsc_solution = np.array([\" \" * 10 for _ in p['I']])\n                for cadet, i in enumerate(cadet_indices):\n                    if assigned_afscs[cadet] in afscs:\n                        afsc_solution[i] = assigned_afscs[cadet]\n                indices = np.where(afsc_solution == \" \" * 10)[0]\n                afsc_solution[indices] = \"*\"\n                solution['iterations']['matches'][s] = \\\n                    np.array([np.where(p['afscs'] == afsc)[0][0] for afsc in afsc_solution])\n                solution['iterations']['names'][s] = \\\n                    \"Phase \" + str(phase_num) + \" (\" + om_level + \", \" + interest_level + \") [\" + afsc + \"]\"\n\n    # Solution Iteration components\n    if mdl_p['collect_solution_iterations']:\n        solution['iterations']['last_s'] = s - 1\n\n    # Convert it back to a full solution with all cadets (anyone not matched to a Rated AFSC is unmatched)\n    afsc_solution = np.array([\" \" * 10 for _ in p['I']])\n    for cadet, i in enumerate(cadet_indices):\n        if assigned_afscs[cadet] in afscs:\n            afsc_solution[i] = assigned_afscs[cadet]\n    indices = np.where(afsc_solution == \" \" * 10)[0]\n    afsc_solution[indices] = \"*\"\n    solution['j_array'] = np.array([np.where(p['afscs'] == afsc)[0][0] for afsc in afsc_solution])\n    return solution\n</code></pre>"},{"location":"reference/solutions/algorithms/#solutions.algorithms.soc_rated_matching_algorithm","title":"<code>soc_rated_matching_algorithm(instance, soc='usafa', printing=True)</code>","text":"<p>Matches or reserves cadets to their Rated AFSCs based on the Source of Commissioning (SOC) using the Hospitals/Residents algorithm.</p> <p>Parameters:     instance (CadetCareerProblem): The instance of the CadetCareerProblem class.     soc (str): The SOC for which to perform the matching algorithm. Options are 'usafa' (United States Air Force Academy)                or 'rotc' (Reserve Officer Training Corps). Default is 'usafa'.     printing (bool): Whether to print status updates or not. Default is True.</p> <p>Returns:     tuple: A tuple containing three solution dictionaries: the overall solution, the reserves solution,         and the matches solution.</p> <p>This function implements the Hospitals/Residents algorithm to match or reserve cadets to their Rated AFSCs based on the Source of Commissioning (SOC). It takes an instance of the CadetCareerProblem class as input and an optional parameter <code>soc</code> to specify the SOC for which the matching algorithm should be performed. The available options for <code>soc</code> are 'usafa' (United States Air Force Academy) and 'rotc' (Reserve Officer Training Corps). By default, the SOC is set to 'usafa'. The function also takes an optional parameter <code>printing</code> to control whether status updates are printed during the matching process.</p> <p>The algorithm initializes the necessary variables and dictionaries. It then proceeds with the Hospitals/Residents algorithm by having cadets propose to their top choices and AFSCs accept or reject cadets based on their preferences and capacities. The matching process continues until all cadets are matched or have exhausted their preferences. The function tracks the progress through iterations and collects information on both reserved and matched AFSCs.</p> <p>The function returns a tuple containing three solution dictionaries: the overall solution, the reserves solution, and the matches solution. Each solution dictionary contains the assigned AFSCs for each cadet. The reserves solution only includes cadets with reserved slots, the matches solution only includes cadets with matched slots, and the overall solution includes both cadets with reserved and matched slots.</p> <p>Example usage:     solution, reserves, matches = soc_rated_matching_algorithm(instance, soc='usafa', printing=True)</p> Source code in <code>afccp/solutions/algorithms.py</code> <pre><code>def soc_rated_matching_algorithm(instance, soc='usafa', printing=True):\n    \"\"\"\n    Matches or reserves cadets to their Rated AFSCs based on the Source of Commissioning (SOC) using the Hospitals/Residents algorithm.\n\n    Parameters:\n        instance (CadetCareerProblem): The instance of the CadetCareerProblem class.\n        soc (str): The SOC for which to perform the matching algorithm. Options are 'usafa' (United States Air Force Academy)\n                   or 'rotc' (Reserve Officer Training Corps). Default is 'usafa'.\n        printing (bool): Whether to print status updates or not. Default is True.\n\n    Returns:\n        tuple: A tuple containing three solution dictionaries: the overall solution, the reserves solution,\n            and the matches solution.\n\n    This function implements the Hospitals/Residents algorithm to match or reserve cadets to their Rated AFSCs\n    based on the Source of Commissioning (SOC). It takes an instance of the CadetCareerProblem class as input and\n    an optional parameter `soc` to specify the SOC for which the matching algorithm should be performed. The available\n    options for `soc` are 'usafa' (United States Air Force Academy) and 'rotc' (Reserve Officer Training Corps). By\n    default, the SOC is set to 'usafa'. The function also takes an optional parameter `printing` to control whether\n    status updates are printed during the matching process.\n\n    The algorithm initializes the necessary variables and dictionaries. It then proceeds with the Hospitals/Residents\n    algorithm by having cadets propose to their top choices and AFSCs accept or reject cadets based on their preferences\n    and capacities. The matching process continues until all cadets are matched or have exhausted their preferences.\n    The function tracks the progress through iterations and collects information on both reserved and matched AFSCs.\n\n    The function returns a tuple containing three solution dictionaries: the overall solution, the reserves solution,\n    and the matches solution. Each solution dictionary contains the assigned AFSCs for each cadet. The reserves\n    solution only includes cadets with reserved slots, the matches solution only includes cadets with matched slots,\n    and the overall solution includes both cadets with reserved and matched slots.\n\n    Example usage:\n        solution, reserves, matches = soc_rated_matching_algorithm(instance, soc='usafa', printing=True)\n    \"\"\"\n\n    if printing:\n        print(\"Solving the rated matching algorithm for \" + soc.upper() + \" cadets...\")\n\n    # Shorthand\n    p, mdl_p = instance.parameters, instance.mdl_p\n\n    # Slight change to Rated AFSCs (Remove SOC specific slots)\n    rated_afscs = determine_soc_rated_afscs(soc, all_rated_afscs=p['afscs_acc_grp'][\"Rated\"])\n    rated_J = np.array([np.where(p['afscs'] == afsc)[0][0] for afsc in rated_afscs])\n\n    # Algorithm initialization\n    total_slots = {j: p[soc + \"_quota\"][j] for j in rated_J}\n    cadets = p['Rated Cadets'][soc]\n    N = len(cadets)\n\n    # \"REAL\" first choice of the cadet\n    first_choice = {i: p['cadet_preferences'][i][0] for i in cadets}\n\n    # Dictionary to keep track of what AFSC choice in their list the cadets are proposing to\n    cadet_proposal_choice = {i: 0 for i in cadets}  # Initially all propose to their top Rated preference!\n\n    # Initialize solution dictionary for all 3 solutions (reserves, matches, combined)\n    solution_reserves = {'cadets_solved_for': soc.upper() + ' Rated', 'afscs_solved_for': 'Rated',\n                         'method': 'Rated ' + soc.upper() + ' HR (Reserves)'}\n    solution_matches = {'cadets_solved_for': soc.upper() + ' Rated', 'afscs_solved_for': 'Rated',\n                        'method': 'Rated ' + soc.upper() + ' HR (Matches)'}\n    solution = {'cadets_solved_for': soc.upper() + ' Rated', 'afscs_solved_for': 'Rated',  # Combined Solution\n                'method': 'Rated ' + soc.upper() + ' HR'}\n\n    # Dictionary of parameters used for the \"BubbleChart\" object (animation)\n    if mdl_p['collect_solution_iterations']:\n        solution['iterations'] = {'type': 'Rated SOC HR'}\n        for key in ['proposals', 'matches', 'reserves', 'matched', 'names']:\n            solution['iterations'][key] = {}\n\n    # Begin the simple Hospital/Residents Algorithm\n    total_rejections = {j: 0 for j in rated_J}  # Number of rejections for each AFSC\n    total_matched = {j: 0 for j in rated_J}  # Number of accepted cadets for each AFSC\n    exhausted_cadets = []  # Will contain the cadets that have exhausted (been rejected by) all of their preferences\n    iteration = 0  # First iteration of the algorithm\n    while sum([total_matched[j] for j in rated_J]) + len(exhausted_cadets) &lt; N:  # Stopping conditions\n\n        # Cadets propose to their top choice that hasn't been rejected\n        proposals = {i: p['Rated Choices'][\n            soc][i][cadet_proposal_choice[i]] if i not in exhausted_cadets else p['M'] for i in cadets}\n        proposal_array = np.array([proposals[i] if i in cadets else p['M'] for i in p['I']])\n        counts = {p['afscs'][j]: len(np.where(proposal_array == j)[0]) for j in rated_J}\n\n        # Solution Iteration components (Proposals) and print statement\n        if mdl_p['collect_solution_iterations']:\n            solution['iterations']['proposals'][iteration] = proposal_array\n        if mdl_p['ma_printing']:\n            print(\"\\nIteration\", iteration + 1)\n\n        # Initialize matches information for this iteration\n        total_matched = {j: 0 for j in rated_J}\n\n        # AFSCs accept their best cadets and reject the others\n        for j in rated_J:\n\n            # Loop through their preferred cadets from top to bottom\n            iteration_rejections = 0\n            for i in p['afsc_preferences'][j]:\n                if i not in cadets:\n                    continue  # Other SOC (we don't care about them right now)\n\n                # If the cadet is proposing to this AFSC, we have two options\n                if proposals[i] == j:\n\n                    # We haven't hit capacity, so we accept this cadet\n                    if total_matched[j] &lt; total_slots[j]:\n                        total_matched[j] += 1\n\n                    # We're at capacity, so we reject this cadet\n                    else:\n\n                        # Essentially \"delete\" the preference from the cadet's list\n                        cadet_proposal_choice[i] += 1\n                        proposals[i] = p['M']  # index of the unmatched AFSC (*)\n\n                        # Collect additional information\n                        if mdl_p['ma_printing']:\n                            iteration_rejections += 1\n                            total_rejections[j] += 1\n\n        # Solution Iteration components\n        if mdl_p['collect_solution_iterations']:\n\n            # Rated matches from this iteration\n            solution['iterations']['matches'][iteration] = \\\n                np.array([proposals[i] if i in cadets else p['M'] for i in p['I']])\n            solution['iterations']['names'][iteration] = 'Iteration ' + str(iteration + 1)\n\n            # Collect information on this iteration's reserved slots and actual matched slots\n            reserves = np.zeros(p['N']).astype(int)\n            matches = np.zeros(p['N']).astype(int)\n            for i in p['I']:\n\n                # Default to unmatched\n                reserves[i], matches[i] = p['M'], p['M']\n                if i in cadets:\n                    if proposals[i] in rated_J:\n                        if first_choice[i] == proposals[i]:\n                            matches[i] = proposals[i]\n                        else:\n                            reserves[i] = proposals[i]\n\n            # Set of cadets with reserved or matched slots\n            solution['iterations']['matched'][iteration] = np.where(matches != p['M'])[0]\n            solution['iterations']['reserves'][iteration] = np.where(reserves != p['M'])[0]\n\n        # Specific matching algorithm print statement\n        if mdl_p['ma_printing']:\n            print('Proposals:', counts)\n            print('Matched', {p['afscs'][j]: total_matched[j] for j in rated_J})\n            print('Rejected', {p['afscs'][j]: total_rejections[j] for j in rated_J})\n\n        # Check exhausted cadets\n        exhausted_cadets = []\n        for i in cadets:\n            if cadet_proposal_choice[i] &gt;= p['Num Rated Choices'][soc][i]:\n                exhausted_cadets.append(i)\n\n        iteration += 1 # Next iteration!\n\n    # Last solution iteration\n    if mdl_p['collect_solution_iterations']:\n        solution['iterations']['last_s'] = iteration - 1\n\n    # Collect information on all 3 solutions: reserves, matches, and combined\n    solution_reserves['j_array'] = np.zeros(p['N']).astype(int)\n    solution_matches['j_array'] = np.zeros(p['N']).astype(int)\n    solution['j_array'] = np.zeros(p['N']).astype(int)\n    for i in p['I']:\n\n        # Default to unmatched\n        solution_matches['j_array'][i], solution_reserves['j_array'][i] = p['M'], p['M']\n        solution['j_array'][i] = p['M']\n        if i in cadets:\n            if proposals[i] in rated_J:\n                solution['j_array'][i] = proposals[i]\n                if first_choice[i] == proposals[i]:\n                    solution_matches['j_array'][i] = proposals[i]\n                else:\n                    solution_reserves['j_array'][i] = proposals[i]\n\n    # Add information to the solution matches and reserves components\n    solution['matches'] = np.where(solution_matches['j_array'] != p['M'])[0]\n    solution['reserves'] = np.where(solution_reserves['j_array'] != p['M'])[0]\n\n    # Return solution, reserved array, and solution iterations\n    return solution, solution_reserves, solution_matches\n</code></pre>"},{"location":"reference/solutions/algorithms/#solutions.algorithms.vft_genetic_algorithm","title":"<code>vft_genetic_algorithm(instance, initial_solutions=None, con_fail_dict=None, printing=False)</code>","text":"<p>Solves the optimization problem using a genetic algorithm.</p> <p>Parameters:     instance (CadetCareerProblem): An instance of the CadetCareerProblem class representing the optimization problem.     initial_solutions (ndarray or None): An optional array of initial solutions in the population. If provided, it         should be a numpy ndarray of shape (pop_size, N) where pop_size is the size of the population and N is the         number of cadets. Default is None.     con_fail_dict (dict or None): An optional dictionary containing information about constraints that failed for         the initial solutions. It should be a dictionary where the keys are the indices of the initial solutions         (0-based) and the values are lists of constraint indices that failed for that solution. Default is None.     printing (bool): A flag indicating whether to print status updates during the genetic algorithm execution.         Default is False.</p> <p>Returns:     tuple: A tuple containing the best solution and the time evaluation dataframe (if time evaluation is enabled).</p> <p>This function implements a genetic algorithm to solve the optimization problem defined by the CadetCareerProblem instance. The genetic algorithm works by iteratively evolving a population of candidate solutions through selection, crossover, and mutation operations. The fitness of each solution is evaluated using the Value-Focused Thinking (VFT) objective function.</p> <p>The genetic algorithm operates as follows: 1. Initialize the population: If initial_solutions are provided, they are used as the initial population. Otherwise,    a random population is generated. 2. Evaluate the fitness of each solution in the population using the VFT objective function. 3. Sort the population based on the fitness scores in descending order. 4. Create the next generation of solutions:    - The top two solutions (best fitness) from the current population are automatically included in the next generation.    - For the remaining solutions, select two parents based on their fitness scores using rank selection.    - Apply multi-point crossover to generate two offspring solutions from the selected parents.    - Perform mutation on the offspring solutions to introduce small random changes.    - Add the offspring solutions to the next generation. 5. Repeat steps 2-4 until the termination condition is met (e.g., maximum time limit).</p> <p>The best solution found during the genetic algorithm execution is returned as the output. If time evaluation is enabled, a time evaluation dataframe is also returned, containing the objective values at different time points during the algorithm execution.</p> <p>Example usage:     solution, time_eval_df = vft_genetic_algorithm(instance, initial_solutions, con_fail_dict, printing=True)</p> Source code in <code>afccp/solutions/algorithms.py</code> <pre><code>def vft_genetic_algorithm(instance, initial_solutions=None, con_fail_dict=None, printing=False):\n    \"\"\"\n    Solves the optimization problem using a genetic algorithm.\n\n    Parameters:\n        instance (CadetCareerProblem): An instance of the CadetCareerProblem class representing the optimization problem.\n        initial_solutions (ndarray or None): An optional array of initial solutions in the population. If provided, it\n            should be a numpy ndarray of shape (pop_size, N) where pop_size is the size of the population and N is the\n            number of cadets. Default is None.\n        con_fail_dict (dict or None): An optional dictionary containing information about constraints that failed for\n            the initial solutions. It should be a dictionary where the keys are the indices of the initial solutions\n            (0-based) and the values are lists of constraint indices that failed for that solution. Default is None.\n        printing (bool): A flag indicating whether to print status updates during the genetic algorithm execution.\n            Default is False.\n\n    Returns:\n        tuple: A tuple containing the best solution and the time evaluation dataframe (if time evaluation is enabled).\n\n    This function implements a genetic algorithm to solve the optimization problem defined by the CadetCareerProblem\n    instance. The genetic algorithm works by iteratively evolving a population of candidate solutions through selection,\n    crossover, and mutation operations. The fitness of each solution is evaluated using the Value-Focused Thinking (VFT)\n    objective function.\n\n    The genetic algorithm operates as follows:\n    1. Initialize the population: If initial_solutions are provided, they are used as the initial population. Otherwise,\n       a random population is generated.\n    2. Evaluate the fitness of each solution in the population using the VFT objective function.\n    3. Sort the population based on the fitness scores in descending order.\n    4. Create the next generation of solutions:\n       - The top two solutions (best fitness) from the current population are automatically included in the next generation.\n       - For the remaining solutions, select two parents based on their fitness scores using rank selection.\n       - Apply multi-point crossover to generate two offspring solutions from the selected parents.\n       - Perform mutation on the offspring solutions to introduce small random changes.\n       - Add the offspring solutions to the next generation.\n    5. Repeat steps 2-4 until the termination condition is met (e.g., maximum time limit).\n\n    The best solution found during the genetic algorithm execution is returned as the output. If time evaluation is\n    enabled, a time evaluation dataframe is also returned, containing the objective values at different time points\n    during the algorithm execution.\n\n    Example usage:\n        solution, time_eval_df = vft_genetic_algorithm(instance, initial_solutions, con_fail_dict, printing=True)\n    \"\"\"\n\n\n    def multi_point_crossover(genome1, genome2):\n        \"\"\"\n        Take two parent genomes, crossover the genes at multiple points and return two offspring solutions\n        :param genome1: first parent genome\n        :param genome2: second parent genome\n        :return: offspring\n        \"\"\"\n        points = np.sort(np.random.choice(crossover_positions, size=mp[\"num_crossover_points\"], replace=False))\n        start_points = np.append(0, points)\n        stop_points = np.append(points, p['N'] - 1)\n        child1 = np.zeros(p['N']).astype(int)\n        child2 = np.zeros(p['N']).astype(int)\n        flip = 1\n        for i in range(len(start_points)):\n            if flip == 1:\n                child1[start_points[i]:stop_points[i] + 1] = genome2[start_points[i]:stop_points[i] + 1]\n                child2[start_points[i]:stop_points[i] + 1] = genome1[start_points[i]:stop_points[i] + 1]\n            else:\n                child1[start_points[i]:stop_points[i] + 1] = genome1[start_points[i]:stop_points[i] + 1]\n                child2[start_points[i]:stop_points[i] + 1] = genome2[start_points[i]:stop_points[i] + 1]\n\n            flip = flip * -1\n\n        return child1, child2\n\n    def mutation(genome):\n        \"\"\"\n        Takes a genome, and picks a random cadet index to mutate with some probability.\n        This means we can swap an AFSC for one cadet individually\n        :param genome: solution vector\n        :return: mutated genome\n        \"\"\"\n        for _ in range(mp[\"num_mutations\"]):\n            i = np.random.choice(p['I^Variable'])  # Pick a random cadet that doesn't have a \"fixed\" AFSC\n\n            if mp['mutation_function'] == 'cadet_choice':\n\n                # Determine what set of AFSCs we can choose from (Coin flip on if we're going to select more preferred ones)\n                if np.random.uniform() &gt; mp['preference_mutation_rate']:\n\n                    # Current preference that the cadet received\n                    current_choice = p['c_pref_matrix'][i, genome[i]]\n\n                    # All AFSCs that are at least as preferred as current assigned\n                    possible_afscs = p['cadet_preferences'][i][:current_choice]\n\n                else:\n\n                    # All AFSCs that the cadet is eligible for\n                    possible_afscs = p['J^E'][i]\n            else:\n\n                # All AFSCs that the cadet is eligible for\n                possible_afscs = p['J^E'][i]\n\n            # Fix the possible AFSCs to select from if this cadet has a reserved Rated slot\n            if i in p['J^Reserved']:\n                possible_afscs = p['J^Reserved'][i]\n\n            # Pick a random AFSC\n            j = np.random.choice(possible_afscs)\n\n            # Mutate if applicable\n            genome[i] = j if (np.random.uniform() &lt; mp[\"mutation_rate\"]) else genome[i]\n\n        return genome\n\n    # Shorthand\n    p = instance.parameters\n    vp = instance.value_parameters\n    mp = instance.mdl_p\n\n    # Cadets that aren't \"fixed\" in the solution\n    p['I^Variable'] = np.array([i for i in p['I'] if i not in p['J^Fixed']])\n\n    # Rank Selection Parameters\n    rank_weights = (np.arange(1, mp[\"pop_size\"] + 1)[::-1]) ** 1.2\n    rank_weights = rank_weights / sum(rank_weights)\n    rank_choices = np.arange(mp[\"pop_size\"])\n\n    # Multi-Point Crossover Parameters\n    crossover_positions = np.arange(1, p['N'] - 1)\n\n    # Initialize Population\n    population = np.array([[np.random.choice(p['J^E'][i]) for i in p['I']] for _ in range(mp[\"pop_size\"])]).astype(int)\n    if initial_solutions is not None:\n\n        # Get fitness of initial_solutions in case there are feasibility issues or there are too many initial solutions\n        num_initial = len(initial_solutions)\n        fitness = np.zeros(num_initial)\n        for s, chromosome in enumerate(initial_solutions):\n            fitness[s] = afccp.solutions.handling.fitness_function(chromosome, p, vp, mp, con_fail_dict)\n\n        # Sort Initial solutions by Fitness\n        sorted_indices = fitness.argsort()[::-1]\n        initial_solutions = initial_solutions[sorted_indices]\n\n        # Insert these solutions into the population\n        for s, chromosome in enumerate(initial_solutions):\n\n            # Make sure there aren't too many initial solutions\n            if s &lt; mp[\"pop_size\"]:\n                population[s] = chromosome\n\n    # Initialize Fitness Scores\n    fitness = np.zeros(mp[\"pop_size\"])\n    for s, chromosome in enumerate(population):\n        fitness[s] = afccp.solutions.handling.fitness_function(chromosome, p, vp, mp, con_fail_dict)\n\n    # Sort Population by Fitness\n    sorted_indices = fitness.argsort()[::-1]\n    fitness = fitness[sorted_indices]\n    population = population[sorted_indices]\n\n    # Print updates\n    if mp[\"ga_printing\"]:\n        step = mp[\"ga_max_time\"] / (100 / mp[\"percent_step\"])\n        checkpoint = step\n        completed = 0\n        print('Initial Fitness Scores', fitness)\n\n    # Time Evaluation Initialization\n    if mp[\"time_eval\"]:\n        time_step = mp[\"ga_max_time\"] / mp[\"num_time_points\"]\n        step_num = 1\n        times = [0]\n        scores = [fitness[0]]\n\n    # Main Loop\n    start_time = time.perf_counter()\n    eval_times = []\n    gen_times = []\n    generating = True\n    generation = 1\n    while generating:\n\n        # Start time\n        gen_start_time = time.perf_counter()\n\n        # Evaluate Population\n        for index in range(2, mp[\"pop_size\"]):\n            fitness[index] = afccp.solutions.handling.fitness_function(population[index], p, vp, mp, con_fail_dict)\n        eval_times.append(time.perf_counter() - gen_start_time)\n\n        # Sort Population by Fitness\n        sorted_indices = fitness.argsort()[::-1]\n        fitness = fitness[sorted_indices]\n        population = population[sorted_indices]\n        best_score = fitness[0]\n\n        # Printing updates\n        if mp[\"ga_printing\"]:\n            if (time.perf_counter() - start_time) &gt; checkpoint:\n                completed += mp[\"percent_step\"]\n                checkpoint += step\n                print(str(completed) + \"% complete. Best solution value: \" + str(round(best_score, 4)))\n                avg_eval_time = np.mean(np.array(eval_times[0:generation]))\n                print('Average evaluation time for ' + str(mp[\"pop_size\"]) + ' solutions: ' +\n                      str(round(avg_eval_time, 4)) + ' seconds.')\n                avg_gen_time = np.mean(np.array(gen_times[0:generation]))\n                print('Average generation time: ' + str(round(avg_gen_time, 4)) + ' seconds.')\n\n        # Create next generation\n        next_generation = population[0:2]  # the best two solutions are kept for the next generation\n        for twins in range(int((mp[\"pop_size\"] / 2) - 1)):  # create the offspring\n\n            # Select parents for mating\n            index_1, index_2 = np.random.choice(rank_choices, size=2, replace=False, p=rank_weights)\n            parent_1, parent_2 = population[index_1], population[index_2]\n\n            # Apply crossover function\n            offspring_1, offspring_2 = multi_point_crossover(parent_1, parent_2)\n\n            # Mutate genomes of offspring\n            offspring_1 = mutation(offspring_1)\n            offspring_2 = mutation(offspring_2)\n\n            # Add this pair to the next generation\n            offsprings = np.vstack((offspring_1, offspring_2))\n            next_generation = np.vstack((next_generation, offsprings))\n\n        # Time Eval\n        if mp[\"time_eval\"]:\n            if (time.perf_counter() - start_time) &gt; (time_step * step_num):\n                times.append(time.perf_counter() - start_time)\n                scores.append(best_score)\n                step_num += 1\n\n        # Check stopping criteria\n        if (time.perf_counter() - start_time) &gt; mp[\"ga_max_time\"]:\n            if mp[\"ga_printing\"]:\n                end_time = round(time.perf_counter() - start_time, 2)\n                print('End time reached in ' + str(end_time) + ' seconds.')\n            generating = False\n\n        # Next Generation\n        population = next_generation\n        gen_times.append(time.perf_counter() - gen_start_time)\n        generation += 1\n\n    # Acquire solution dictionary for the top chromosome in the population\n    solution = {'method': 'VFT_Genetic', 'j_array': population[0]}\n\n    # Time Eval\n    if mp[\"time_eval\"]:\n\n        # Create time_eval_df\n        time_eval_df = pd.DataFrame({'Time': times, 'Objective Value': scores})\n\n        if printing:\n            print(time_eval_df)\n        return solution, time_eval_df\n\n    else:\n\n        # Return best solution\n        return solution, None\n</code></pre>"},{"location":"reference/solutions/algorithms/#solutions.algorithms.genetic_matching_algorithm","title":"<code>genetic_matching_algorithm(instance, printing=False)</code>","text":"<p>Genetic algorithm that determines optimal capacities to the classic deferred acceptance algorithm to minimize blocking pairs</p> <p>Parameters:     instance (CadetCareerProblem): An instance of the CadetCareerProblem class representing the optimization problem.     printing (bool): A flag indicating whether to print additional information during the algorithm execution.         Default is False.</p> <p>Returns:     ndarray: An array representing the optimal capacities determined by the genetic algorithm.</p> <p>This function implements a genetic algorithm to determine the optimal capacities for the classic deferred acceptance algorithm. The goal is to minimize the number of blocking pairs in the matching process.</p> <p>The genetic algorithm works as follows: 1. Initialize the population of capacities randomly. Each capacity is selected within the valid range for the    corresponding AFSC. 2. Evaluate the fitness of each capacity configuration using the classic deferred acceptance algorithm with the    given capacities. The fitness is determined by the number of blocking pairs in the resulting matching. 3. Sort the population based on fitness scores in descending order. 4. Create the next generation of capacities:    - The two best capacities (lowest fitness) from the current population are automatically included in the next      generation.    - For the remaining capacities, select two parents based on their fitness scores using rank selection.    - Apply multi-point crossover to generate two offspring capacities from the selected parents.    - Perform mutation on the offspring capacities to introduce small random changes.    - Add the offspring capacities to the next generation. 5. Repeat steps 2-4 until a termination condition is met (e.g., maximum time or number of generations).</p> <p>The best capacity configuration found during the genetic algorithm execution is returned as the output.</p> <p>Example usage:     optimal_capacities = genetic_matching_algorithm(instance, printing=True)</p> Source code in <code>afccp/solutions/algorithms.py</code> <pre><code>def genetic_matching_algorithm(instance, printing=False):\n    \"\"\"\n    Genetic algorithm that determines optimal capacities to the classic deferred acceptance algorithm to minimize\n    blocking pairs\n\n    Parameters:\n        instance (CadetCareerProblem): An instance of the CadetCareerProblem class representing the optimization problem.\n        printing (bool): A flag indicating whether to print additional information during the algorithm execution.\n            Default is False.\n\n    Returns:\n        ndarray: An array representing the optimal capacities determined by the genetic algorithm.\n\n    This function implements a genetic algorithm to determine the optimal capacities for the classic deferred acceptance\n    algorithm. The goal is to minimize the number of blocking pairs in the matching process.\n\n    The genetic algorithm works as follows:\n    1. Initialize the population of capacities randomly. Each capacity is selected within the valid range for the\n       corresponding AFSC.\n    2. Evaluate the fitness of each capacity configuration using the classic deferred acceptance algorithm with the\n       given capacities. The fitness is determined by the number of blocking pairs in the resulting matching.\n    3. Sort the population based on fitness scores in descending order.\n    4. Create the next generation of capacities:\n       - The two best capacities (lowest fitness) from the current population are automatically included in the next\n         generation.\n       - For the remaining capacities, select two parents based on their fitness scores using rank selection.\n       - Apply multi-point crossover to generate two offspring capacities from the selected parents.\n       - Perform mutation on the offspring capacities to introduce small random changes.\n       - Add the offspring capacities to the next generation.\n    5. Repeat steps 2-4 until a termination condition is met (e.g., maximum time or number of generations).\n\n    The best capacity configuration found during the genetic algorithm execution is returned as the output.\n\n    Example usage:\n        optimal_capacities = genetic_matching_algorithm(instance, printing=True)\n    \"\"\"\n\n\n    # Shorthand\n    p, vp, mdl_p = instance.parameters, instance.value_parameters, instance.mdl_p\n\n    # Define functions\n    def initialize_population():\n        \"\"\"\n        Function to initialize all the \"chromosomes\" for this GA\n        \"\"\"\n        population = np.array([np.zeros(p['M']) for _ in range(mdl_p['gma_pop_size'])])\n        for c in range(mdl_p['gma_pop_size']):\n            for j in p['J']:\n                capacity = int(random.choice(capacity_options[j]))\n                population[c, j] = capacity\n\n        return population\n\n    def fitness_function(chromosome):\n        \"\"\"\n        Evaluates the chromosome (capacities for HR)\n        \"\"\"\n\n        # Run the algorithm using these capacities\n        solution = classic_hr(instance, capacities=chromosome, printing=False)\n\n        # Evaluate blocking pairs\n        return afccp.solutions.handling.calculate_blocking_pairs(p, solution, only_return_count=True)\n\n    def multi_point_crossover(genome1, genome2):\n        \"\"\"\n        Take two parent genomes, crossover the genes at multiple points and return two offspring solutions\n        :param genome1: first parent genome\n        :param genome2: second parent genome\n        :return: offspring\n        \"\"\"\n        points = np.sort(np.random.choice(crossover_positions, size=mdl_p[\"gma_num_crossover_points\"], replace=False))\n        start_points = np.append(0, points)\n        stop_points = np.append(points, p['M'] - 1)\n        child1 = np.zeros(p['M']).astype(int)\n        child2 = np.zeros(p['M']).astype(int)\n        flip = 1\n        for i in range(len(start_points)):\n            if flip == 1:\n                child1[start_points[i]:stop_points[i] + 1] = genome2[start_points[i]:stop_points[i] + 1]\n                child2[start_points[i]:stop_points[i] + 1] = genome1[start_points[i]:stop_points[i] + 1]\n            else:\n                child1[start_points[i]:stop_points[i] + 1] = genome1[start_points[i]:stop_points[i] + 1]\n                child2[start_points[i]:stop_points[i] + 1] = genome2[start_points[i]:stop_points[i] + 1]\n\n            flip = flip * -1\n\n        return child1, child2\n\n    def mutation(genome):\n        \"\"\"\n        Takes a genome, and picks a random cadet index to mutate with some probability.\n        This means we can swap an AFSC for one cadet individually\n        :param genome: solution vector\n        :return: mutated genome\n        \"\"\"\n        for _ in range(mdl_p[\"gma_mutations\"]):\n            j = np.random.choice(p['J'])  # Random AFSC\n\n            # Pick random new capacity for AFSC j\n            min, max = p['quota_min'][j], p['quota_max'][j]\n            capacity_options = np.arange(min, max + 1).astype(int)\n            capacity = int(random.choice(capacity_options))\n            genome[j] = capacity if (np.random.uniform() &lt; mdl_p[\"gma_mutation_rate\"]) else genome[j]\n\n        return genome\n\n    # Determine range of capacities for all AFSCs\n    capacity_options = {}\n    for j in p['J']:\n        min, max = p['quota_min'][j], p['quota_max'][j]\n        capacity_options[j] = np.arange(min, max + 1).astype(int)\n\n    # Rank Selection Parameters\n    rank_weights = (np.arange(1, mdl_p[\"gma_pop_size\"] + 1)[::-1]) ** 1.2\n    rank_weights = rank_weights / sum(rank_weights)\n    rank_choices = np.arange(mdl_p[\"gma_pop_size\"])\n\n    # Multi-Point Crossover Parameters\n    crossover_positions = np.arange(1, p['M'] - 1)\n\n    # Initialize population\n    population = initialize_population()\n\n    # Initialize fitness scores\n    fitness = np.zeros(mdl_p['gma_pop_size'])\n    for c in range(mdl_p['gma_pop_size']):\n        fitness[c] = fitness_function(population[c])\n\n    # Sort Population by Fitness\n    sorted_indices = fitness.argsort()\n    fitness = fitness[sorted_indices]\n    population = population[sorted_indices]\n\n    # Main Loop\n    start_time = time.perf_counter()\n    generation = 0\n    generating = True\n    while generating:\n\n        # Evaluate population\n        for c in range(2, mdl_p['gma_pop_size']):\n            fitness[c] = fitness_function(population[c])\n\n        # Sort Population by Fitness\n        sorted_indices = fitness.argsort()\n        fitness = fitness[sorted_indices]\n        population = population[sorted_indices]\n\n        # Print statements\n        if mdl_p['gma_printing']:\n            print('Generation', generation, 'Fitness', fitness)\n\n        # Create next generation\n        next_generation = population[:2]  # the best two solutions are kept for the next generation\n        for twins in range(int((mdl_p[\"gma_pop_size\"] / 2) - 1)):  # create the offspring\n\n            # Select parents for mating\n            c1, c2 = np.random.choice(rank_choices, size=2, replace=False, p=rank_weights)\n            parent_1, parent_2 = population[c1], population[c2]\n\n            # Apply crossover function\n            offspring_1, offspring_2 = multi_point_crossover(parent_1, parent_2)\n\n            # Mutate genomes of offspring\n            offspring_1 = mutation(offspring_1)\n            offspring_2 = mutation(offspring_2)\n\n            # Add this pair to the next generation\n            offsprings = np.vstack((offspring_1, offspring_2))\n            next_generation = np.vstack((next_generation, offsprings))\n\n        # Next Generation\n        population = next_generation\n        generation += 1\n\n        # Stopping conditions\n        if mdl_p['stopping_conditions'] == 'Time':\n            if (time.perf_counter() - start_time) &gt; mdl_p['gma_max_time']:\n                generating = False\n        elif mdl_p['stopping_conditions'] == 'Generations':\n            if generation &gt;= mdl_p['gma_num_generations']:\n                generating = False\n\n        # We have no blocking pairs!\n        if fitness[0] == 0:\n            generating = False\n\n    if printing:\n        print(\"Final capacities:\", population[0])\n\n    # Return the capacities\n    return population[0]\n</code></pre>"},{"location":"reference/solutions/handling/","title":"Handling","text":""},{"location":"reference/solutions/handling/#solutions.handling","title":"<code>solutions.handling</code>","text":""},{"location":"reference/solutions/handling/#solutions.handling.evaluate_solution","title":"<code>evaluate_solution(solution, parameters, value_parameters, approximate=False, re_calculate_x=True, printing=False)</code>","text":"<p>Evaluate a solution (either a vector or a matrix) by calculating various metrics.</p> <p>Parameters:     solution (numpy.ndarray): The solution to evaluate, represented as a vector or a matrix.     parameters (dict): The fixed cadet/AFSC model parameters.     value_parameters (dict): The weight/value parameters.     approximate (bool, optional): Whether the solution is approximate or exact. Defaults to False.     re_calculate_x (bool, optional): If we want to force re-calculation of x as integer matrix. Defaults to True.     printing (bool, optional): Whether to print the evaluated metrics. Defaults to False.</p> <p>Returns:     solution (dict): A dictionary containing the solution core elements and evaluated metrics.</p> <p>Note:     This function evaluates a solution by calculating various metrics, including objective measures, objective values,     AFSC values, cadet values, constraint failures, overall values, and additional useful metrics.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def evaluate_solution(solution, parameters, value_parameters, approximate=False, re_calculate_x=True, printing=False):\n    \"\"\"\n    Evaluate a solution (either a vector or a matrix) by calculating various metrics.\n\n    Parameters:\n        solution (numpy.ndarray): The solution to evaluate, represented as a vector or a matrix.\n        parameters (dict): The fixed cadet/AFSC model parameters.\n        value_parameters (dict): The weight/value parameters.\n        approximate (bool, optional): Whether the solution is approximate or exact. Defaults to False.\n        re_calculate_x (bool, optional): If we want to force re-calculation of x as integer matrix. Defaults to True.\n        printing (bool, optional): Whether to print the evaluated metrics. Defaults to False.\n\n    Returns:\n        solution (dict): A dictionary containing the solution core elements and evaluated metrics.\n\n    Note:\n        This function evaluates a solution by calculating various metrics, including objective measures, objective values,\n        AFSC values, cadet values, constraint failures, overall values, and additional useful metrics.\n    \"\"\"\n\n    # Shorthand\n    p, vp = parameters, value_parameters\n\n    # Get X matrix\n    if 'x' not in solution or re_calculate_x:\n        solution['x'] = np.array([[1 if solution['j_array'][i] == j else 0 for j in p['J']] for i in p['I']])\n    x = solution['x']\n\n    # Initialize solution metrics to be added to solution dictionary\n    metrics = {'objective_measure': np.zeros([p['M'], vp['O']]),  # AFSC objective \"raw\" measure\n               'objective_value': np.ones([p['M'], vp['O']]),  # AFSC objective value determined through value function\n               'afsc_value': np.zeros(p['M']), 'cadet_value': np.zeros(p['N']),  # AFSC/Cadet Individual values\n               'cadet_constraint_fail': np.zeros(p['N']),  # 1-N binary array indicating cadet constraint failures\n               'afsc_constraint_fail': np.zeros(p['M']),  # 1-M binary array indicating AFSC constraint failures\n               'objective_score': np.zeros(vp['O']),  # \"Flipped\" score for the AFSC objective\n\n               # Constraint data metrics\n               'total_failed_constraints': 0, \"failed_constraints\": [],\n               'objective_constraint_fail': np.array([[\" \" * 30 for _ in range(vp['O'])] for _ in range(p['M'])]),\n               'con_fail_dict': {}  # Dictionary containing the new minimum/maximum value we need to adhere to\n               }\n    for key in metrics:\n        solution[key] = metrics[key]\n\n    # Loop through all AFSCs to assign their \"individual\" values\n    for j in p['J']:\n        afsc = p[\"afscs\"][j]\n\n        # Loop through all AFSC objectives\n        for k, objective in enumerate(vp[\"objectives\"]):\n\n            # Calculate AFSC objective measure\n            solution['objective_measure'][j, k], _ = calculate_objective_measure_matrix(\n                solution['x'], j, objective, p, vp, approximate=approximate)\n\n            # Calculate AFSC objective value\n            if k in vp[\"K^A\"][j]:\n                solution['objective_value'][j, k] = value_function(\n                    vp['a'][j][k], vp['f^hat'][j][k], vp['r'][j][k], solution['objective_measure'][j, k])\n\n            # Update metrics dictionary with failed AFSC objective constraint information\n            if k in vp['K^C'][j]:\n                solution = calculate_failed_constraint_metrics(j, k, solution, p, vp)\n\n        # AFSC individual value\n        solution['afsc_value'][j] = np.dot(vp['objective_weight'][j, :], solution['objective_value'][j, :])\n        if solution['afsc_value'][j] &lt; vp['afsc_value_min'][j]:\n            solution['afsc_constraint_fail'][j] = 1\n            solution['total_failed_constraints'] += 1\n            solution[\"failed_constraints\"].append(afsc + \" Value\")\n\n    # Set of cadets that have been matched to AFSCs\n    solution['I^Match'] = np.where(solution['j_array'] != p['M'])[0]\n    solution['Num Matched'] = len(solution['I^Match'])\n\n    # Loop through all cadets to assign their values\n    for i in p['I']:\n        solution['cadet_value'][i] = np.sum(x[i, j] * p['cadet_utility'][i, j] for j in p['J^E'][i])\n        if solution['cadet_value'][i] &lt; vp['cadet_value_min'][i]:\n            solution['cadet_constraint_fail'][i] = 1\n            solution['total_failed_constraints'] += 1\n            solution[\"failed_constraints\"].append(\"Cadet \" + str(p['cadets'][i]) + \" Value\")\n\n    # Variables used to help verify that cadets are receiving the AFSCs they need to if specified\n    num_fixed_correctly = 0\n    num_reserved_correctly = 0\n\n    # Get the AFSC solution (Modified to support \"unmatched\" cadets)\n    solution[\"num_unmatched\"] = 0\n    solution['afsc_array'] = np.array([\" \" * 10 for _ in p['I']])\n    for i in p['I']:\n        j = np.where(x[i, :])[0]\n        if len(j) != 0:\n            j = int(j[0])\n        else:\n            solution[\"num_unmatched\"] += 1\n            j = p['M']  # Last index (*)\n        solution['afsc_array'][i] = p['afscs'][j]\n\n        # Check if this AFSC was \"fixed\" for this cadet\n        if i in p['J^Fixed']:\n            if j == p['J^Fixed'][i]:\n                num_fixed_correctly += 1\n\n        # Check if this AFSC was reserved for this cadet\n        if i in p['J^Reserved']:\n            if j in p['J^Reserved'][i]:\n                num_reserved_correctly += 1\n\n    # Alternate list situation\n    if 'J^Preferred [usafa]' in p:\n        solution['num_alternates_allowed'] = 0  # Number of cadets on alternate lists\n        solution['num_successful_alternates'] = 0  # Number of cadets on alternate lists that don't form blocking pairs\n\n        # Loop through each SOC and rated AFSC\n        for soc in p['SOCs']:\n\n            # Did we not run the algorithm for this specific SOC?\n            if f'J^Preferred [{soc}]' not in p:\n                continue\n\n            # Loop through each rated AFSC\n            for j in p['J^Rated']:\n\n                # Loop through each cadet on this SOC's rated AFSC's list\n                for i in p['I^Alternate [' + soc + ']'][j]:\n                    solution['num_alternates_allowed'] += 1\n\n                    # Check the blocking pair constraint for this rated AFSC and cadet pair\n                    not_blocking_pair = p[soc + '_quota'][j] * (1 - np.sum(\n                        x[i, j_p] for j_p in p['J^Preferred [' + soc + ']'][j][i])) &lt;= np.sum(\n                        x[i_p, j] for i_p in p['I^Preferred [' + soc + ']'][j][i])\n                    if not_blocking_pair:\n                        solution['num_successful_alternates'] += 1\n\n        solution['alternate_list_metric'] = str(solution['num_successful_alternates']) + \" / \" + \\\n                                            str(solution['num_alternates_allowed'])\n\n    else:\n        solution['alternate_list_metric'] = \"0 / 0\"  # Not applicable here\n\n    # Verification that AFSCs are being assigned properly to work with J^Fixed and J^Reserved\n    num_fixed_needed = len(p['J^Fixed'].keys())\n    num_reserved_needed = len(p['J^Reserved'].keys())\n    solution['cadets_fixed_correctly'] = str(num_fixed_needed) + ' / ' + str(num_fixed_needed)\n    solution['cadets_reserved_correctly'] = str(num_reserved_correctly) + ' / ' + str(num_reserved_needed)\n\n    # Define overall metrics\n    solution['cadets_overall_value'] = np.dot(vp['cadet_weight'][solution['I^Match']],\n                                              solution['cadet_value'][solution['I^Match']])\n    solution['afscs_overall_value'] = np.dot(vp['afsc_weight'], solution['afsc_value'])\n    solution['z'] = vp['cadets_overall_weight'] * solution['cadets_overall_value'] + \\\n                   vp['afscs_overall_weight'] * solution['afscs_overall_value']\n    solution['num_ineligible'] = np.sum(x[i, j] * p['ineligible'][i, j] for j in p['J'] for i in solution['I^Match'])\n\n    # Add additional metrics components (Non-VFT stuff)\n    solution = calculate_additional_useful_metrics(solution, p, vp)\n\n    # Add base/training components if applicable\n    if 'base_array' in solution:\n        solution = calculate_base_training_metrics(solution, p, vp)\n\n    # Add Castle solution metrics\n    if 'castle_q' in p:\n        solution = calculate_castle_solution_metrics(solution, p)\n\n    # Calculate blocking pairs\n    if 'a_pref_matrix' in p:\n        solution['blocking_pairs'] = calculate_blocking_pairs(p, solution)\n        solution['num_blocking_pairs'] = len(solution['blocking_pairs'])\n\n    # Print statement\n    if printing:\n        if approximate:\n            model_type = 'approximate'\n        else:\n            model_type = 'exact'\n        if 'name' in solution:\n            print_str = \"Solution Evaluated: \" + solution['name'] + \".\"\n        else:\n            print_str = \"New Solution Evaluated.\"\n        print_str += \"\\nMeasured \" + model_type + \" VFT objective value: \" + str(round(solution['z'], 4))\n        if 'z^gu' in solution:\n            print_str += \".\\nGlobal Utility Score: \" + str(round(solution['z^gu'], 4))\n        print_str += \". \" + solution['cadets_fixed_correctly'] + ' AFSCs fixed. ' + \\\n                     solution['cadets_reserved_correctly'] + ' AFSCs reserved'\n        print_str += \". \" + solution['alternate_list_metric'] + ' alternate list scenarios respected'\n        if 'z^CASTLE' in solution:\n            print_str += f\".\\nCASTLE GUO Score: {solution['z^CASTLE']}. \" \\\n                         f\"Value Curve Score: {solution['z^CASTLE (Values)']}\"\n        if 'num_blocking_pairs' in solution:\n            print_str += \".\\nBlocking pairs: \" + str(solution['num_blocking_pairs'])\n        print_str += \". Unmatched cadets: \" + str(solution[\"num_unmatched\"])\n        print_str += f\".\\nMatched cadets: {solution['Num Matched']}/{p['N']}. N^Match: {p['N^Match']}\"\n        print_str += \". Ineligible cadets: \" + str(solution['num_ineligible']) + \".\"\n        print(print_str)\n\n    # Return the solution/metrics\n    return solution\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.fitness_function","title":"<code>fitness_function(chromosome, p, vp, mp, con_fail_dict=None)</code>","text":"<p>Evaluates a chromosome (solution vector) and returns its fitness score.</p> <p>Parameters:     chromosome (array-like): The chromosome representing the solution vector.     p (dict): Parameters used in the calculations.     vp (dict): Value parameters used in the calculations.     mp (dict): Model parameters.     con_fail_dict (dict, optional): Dictionary to store failed constraints for efficient evaluation.                                     Defaults to None.</p> <p>Returns:     fitness_score (float): The fitness score of the chromosome.</p> <p>Note:     This function is relatively time-consuming and should be as efficient as possible.     The fitness score is calculated based on the provided chromosome and parameters.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def fitness_function(chromosome, p, vp, mp, con_fail_dict=None):\n    \"\"\"\n    Evaluates a chromosome (solution vector) and returns its fitness score.\n\n    Parameters:\n        chromosome (array-like): The chromosome representing the solution vector.\n        p (dict): Parameters used in the calculations.\n        vp (dict): Value parameters used in the calculations.\n        mp (dict): Model parameters.\n        con_fail_dict (dict, optional): Dictionary to store failed constraints for efficient evaluation.\n                                        Defaults to None.\n\n    Returns:\n        fitness_score (float): The fitness score of the chromosome.\n\n    Note:\n        This function is relatively time-consuming and should be as efficient as possible.\n        The fitness score is calculated based on the provided chromosome and parameters.\n    \"\"\"\n\n    # 5% cap on total percentage of USAFA cadets allowed into certain AFSCs\n    if vp[\"J^USAFA\"] is not None:\n\n        # This is a pretty arbitrary constraint and will only be used for real class years (but has since been removed)\n        cap = 0.05 * mp[\"real_usafa_n\"]\n        u_count = 0\n        for j in vp[\"J^USAFA\"]:\n            cadets = np.where(chromosome == j)[0]\n            usafa_cadets = np.intersect1d(p['I^D']['USAFA Proportion'][j], cadets)\n            u_count += len(usafa_cadets)\n\n        # If we fail this constraint, we return an objective value of 0\n        if u_count &gt; int(cap + 1):\n            return 0\n\n    # Calculate AFSC individual values\n    afsc_value = np.zeros(p['M'])\n    for j in p['J']:\n\n        # Initialize objective measures and values\n        measure = np.zeros(vp['O'])\n        value = np.zeros(vp['O'])\n\n        # Indices of cadets assigned to this AFSC\n        cadets = np.where(chromosome == j)[0]\n\n        # Only calculate measures for AFSCs with at least one cadet\n        count = len(cadets)\n        if count &gt; 0:\n\n            # Loop through all AFSC objectives\n            for k in vp[\"K\"]:\n\n                # If this AFSC is constraining this objective or only has it in the objective function\n                if k in vp[\"K^A\"][j]:\n\n                    # Calculate AFSC objective measure\n                    measure[k] = calculate_objective_measure_chromosome(cadets, j, vp['objectives'][k], p, vp, count)\n\n                    # Assign AFSC objective value\n                    value[k] = value_function(vp['a'][j][k], vp['f^hat'][j][k], vp['r'][j][k], measure[k])\n\n                    # Check failed AFSC objective\n                    if k in vp['K^C'][j]:\n                        if check_failed_constraint_chromosome(j, k, measure[k], count, p, vp, con_fail_dict):\n                            return 0\n\n            # Calculate AFSC value\n            afsc_value[j] = np.dot(vp['objective_weight'][j, :], value)\n            if j in vp['J^C']:\n\n                # If we fail this constraint, we return an objective value of 0\n                if afsc_value[j] &lt; vp['afsc_value_min'][j]:\n                    return 0\n\n        # No cadets assigned to the AFSC means it failed\n        else:\n            return 0\n\n    # Calculate Cadet Value\n    cadet_value = np.array([p['cadet_utility'][i, int(chromosome[i])] for i in p['I']])\n    for i in vp['I^C']:\n\n        # If we fail this constraint, we return an objective value of 0\n        if cadet_value[i] &lt; vp['cadet_value_min'][i]:\n            return 0\n\n    # Return fitness value\n    return vp['cadets_overall_weight'] * np.dot(vp['cadet_weight'], cadet_value) + \\\n           vp['afscs_overall_weight'] * np.dot(vp['afsc_weight'], afsc_value)\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_blocking_pairs","title":"<code>calculate_blocking_pairs(parameters, solution, only_return_count=False)</code>","text":"<p>Calculate blocking pairs in a given solution.</p> <p>Parameters: - parameters (dict): The parameters of the matching problem. - solution (dict): The current matching solution. - only_return_count (bool): If True, return the count of blocking pairs; if False,   return the list of blocking pairs.</p> <p>Returns: - blocking_pairs (list or int): A list of blocking pairs (or count of blocking pairs).</p> <p>Description: This function calculates the blocking pairs in a given matching solution based on the stable matching community's definition. A blocking pair consists of an unmatched cadet and a more preferred AFSC that is also unmatched or assigned to a cadet with lower preference.</p> <p>Parameters Dictionary Structure: - 'cadet_preferences': An array representing cadet preferences. - 'a_pref_matrix': A matrix of AFSC preferences. - 'J': The set of all AFSCs. - 'M': A special symbol representing an unmatched cadet.</p> <p>Solution Dictionary Structure: - 'j_array': An array representing the assignment of AFSCs to cadets.</p> <p>Dependencies: - NumPy</p> <p>Reference: - Gale, D., &amp; Shapley, L. S. (1962). College Admissions and the Stability of   Marriage. American Mathematical Monthly, 69(1), 9-15.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_blocking_pairs(parameters, solution, only_return_count=False):\n    \"\"\"\n    Calculate blocking pairs in a given solution.\n\n    Parameters:\n    - parameters (dict): The parameters of the matching problem.\n    - solution (dict): The current matching solution.\n    - only_return_count (bool): If True, return the count of blocking pairs; if False,\n      return the list of blocking pairs.\n\n    Returns:\n    - blocking_pairs (list or int): A list of blocking pairs (or count of blocking pairs).\n\n    Description:\n    This function calculates the blocking pairs in a given matching solution based on\n    the stable matching community's definition. A blocking pair consists of an unmatched\n    cadet and a more preferred AFSC that is also unmatched or assigned to a cadet with\n    lower preference.\n\n    Parameters Dictionary Structure:\n    - 'cadet_preferences': An array representing cadet preferences.\n    - 'a_pref_matrix': A matrix of AFSC preferences.\n    - 'J': The set of all AFSCs.\n    - 'M': A special symbol representing an unmatched cadet.\n\n    Solution Dictionary Structure:\n    - 'j_array': An array representing the assignment of AFSCs to cadets.\n\n    Dependencies:\n    - NumPy\n\n    Reference:\n    - Gale, D., &amp; Shapley, L. S. (1962). College Admissions and the Stability of\n      Marriage. American Mathematical Monthly, 69(1), 9-15.\n    \"\"\"\n\n    # Shorthand\n    p = parameters\n\n    # Dictionary of cadets matched to each AFSC in this solution\n    cadets_matched = {j: np.where(solution['j_array'] == j)[0] for j in p['J']}\n\n    # Loop through all cadets and their assigned AFSCs\n    blocking_pairs = []\n    blocking_pair_count = 0\n\n    # Loop through each cadet, AFSC pair\n    for i, j in enumerate(solution['j_array']):\n\n        # Unmatched cadets are blocking pairs by definition\n        if j == p['M']:\n            if only_return_count:\n                blocking_pair_count += 1\n            else:\n                blocking_pairs.append((i, j))\n                blocking_pair_count += 1\n\n        # Matched cadets need to be calculated\n        else:\n            cadet_choice = np.where(p['cadet_preferences'][i] == j)[0][0]\n\n            # Loop through more desirable AFSCs than current matched\n            for j_compare in p['cadet_preferences'][i][:cadet_choice]:\n\n                # Where is this cadet ranked in the AFSC list?\n                afsc_choice_of_this_cadet = p['a_pref_matrix'][i, j_compare]\n                matched_cadet_ranks = p['a_pref_matrix'][cadets_matched[j_compare], j_compare]\n\n                # No one has been assigned to this more desirable AFSC (another blocking pair situation)\n                if len(matched_cadet_ranks) == 0:\n                    if only_return_count:\n                        blocking_pair_count += 1\n                    else:\n                        blocking_pairs.append((i, j_compare))\n                        blocking_pair_count += 1\n                    break\n\n                # The lowest rank of the assigned cadet\n                afsc_choice_of_worst_cadet = np.max(matched_cadet_ranks)\n\n                # Check for blocking pairs\n                if afsc_choice_of_this_cadet &lt; afsc_choice_of_worst_cadet:\n                    if only_return_count:\n                        blocking_pair_count += 1\n                    else:\n                        blocking_pairs.append((i, j_compare))\n                        blocking_pair_count += 1\n                    break\n\n    if only_return_count:\n        return blocking_pair_count\n    else:\n        return blocking_pairs\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.value_function","title":"<code>value_function(a, f_a, r, x)</code>","text":"<p>Calculates the AFSC objective value based on the provided parameters.</p> <p>Parameters:     a (array-like): Measure at each breakpoint.     f_a (array-like): Value at each breakpoint.     r (int): Number of breakpoints.     x (float): Actual AFSC objective measure.</p> <p>Returns:     value (float): AFSC objective value.</p> <p>Note:     This function finds the appropriate breakpoint based on the measure and calculates the objective value     using linear interpolation.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def value_function(a, f_a, r, x):\n    \"\"\"\n    Calculates the AFSC objective value based on the provided parameters.\n\n    Parameters:\n        a (array-like): Measure at each breakpoint.\n        f_a (array-like): Value at each breakpoint.\n        r (int): Number of breakpoints.\n        x (float): Actual AFSC objective measure.\n\n    Returns:\n        value (float): AFSC objective value.\n\n    Note:\n        This function finds the appropriate breakpoint based on the measure and calculates the objective value\n        using linear interpolation.\n    \"\"\"\n    # Find which breakpoint is immediately before this measure\n    indices = np.array([a[l] &lt;= x &lt;= a[l + 1] for l in range(r - 1)]) * 1\n    l = np.where(indices)[0]\n\n    # Obtain value\n    if len(l) == 0:\n        l = r - 1\n        val = f_a[l]\n    else:\n        l = l[0]\n        val = f_a[l + 1] - ((f_a[l + 1] - f_a[l]) / (a[l + 1] - a[l])) * (a[l + 1] - x)\n\n    # Return value\n    return val\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.value_function_points","title":"<code>value_function_points(a, fhat)</code>","text":"<p>Takes the linear function parameters and returns the approximately non-linear coordinates</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <p>function breakpoints</p> required <code>fhat</code> <p>function breakpoint values</p> required <p>Returns:</p> Type Description <p>x, y</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def value_function_points(a, fhat):\n    \"\"\"\n    Takes the linear function parameters and returns the approximately non-linear coordinates\n    :param a: function breakpoints\n    :param fhat: function breakpoint values\n    :return: x, y\n    \"\"\"\n    x = (np.arange(1001) / 1000) * a[len(a) - 1]\n    y = np.array([value_function(a, fhat, len(a), i) for i in x])\n    return x, y\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_afsc_norm_score","title":"<code>calculate_afsc_norm_score(cadets, j, p, count=None)</code>","text":"<p>Calculate the Normalized Score for an AFSC assignment.</p> <p>Parameters: - cadets (list or numpy.ndarray): A list of cadets assigned to the AFSC. - j (int): The index of the AFSC for which the score is calculated. - p (dict): The problem parameters including preferences and AFSC data. - count (int, optional): The number of cadets assigned to the AFSC. If not provided,   it is calculated from the length of the 'cadets' list.</p> <p>Returns: - norm_score (float): The normalized score for the AFSC assignment, ranging from 0 to 1.</p> <p>Description: This function calculates the normalized score for an assignment of cadets to an AFSC. The score reflects how well the cadets are matched to their preferences for the given AFSC. A higher score indicates a better match, while a lower score suggests a less favorable assignment.</p> <p>The calculation involves comparing the achieved score (sum of cadet preferences) to the best and worst possible scores for the AFSC assignment. The result is then normalized to a range between 0 and 1, with 1 being the best possible score and 0 being the worst.</p> <p>Parameters Dictionary Structure: - 'a_pref_matrix': A matrix of AFSC preferences. - 'num_eligible': A dictionary with the number of eligible cadets for each AFSC.</p> <p>Dependencies: - NumPy</p> <p>Returns: - norm_score (float): The normalized score for the AFSC assignment, ranging from 0 to 1.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_afsc_norm_score(cadets, j, p, count=None):\n    \"\"\"\n    Calculate the Normalized Score for an AFSC assignment.\n\n    Parameters:\n    - cadets (list or numpy.ndarray): A list of cadets assigned to the AFSC.\n    - j (int): The index of the AFSC for which the score is calculated.\n    - p (dict): The problem parameters including preferences and AFSC data.\n    - count (int, optional): The number of cadets assigned to the AFSC. If not provided,\n      it is calculated from the length of the 'cadets' list.\n\n    Returns:\n    - norm_score (float): The normalized score for the AFSC assignment, ranging from 0 to 1.\n\n    Description:\n    This function calculates the normalized score for an assignment of cadets to an AFSC.\n    The score reflects how well the cadets are matched to their preferences for the given AFSC.\n    A higher score indicates a better match, while a lower score suggests a less favorable assignment.\n\n    The calculation involves comparing the achieved score (sum of cadet preferences) to the\n    best and worst possible scores for the AFSC assignment. The result is then normalized to\n    a range between 0 and 1, with 1 being the best possible score and 0 being the worst.\n\n    Parameters Dictionary Structure:\n    - 'a_pref_matrix': A matrix of AFSC preferences.\n    - 'num_eligible': A dictionary with the number of eligible cadets for each AFSC.\n\n    Dependencies:\n    - NumPy\n\n    Returns:\n    - norm_score (float): The normalized score for the AFSC assignment, ranging from 0 to 1.\n    \"\"\"\n\n    # Re-calculate count if necessary\n    if count is None:\n        count = len(cadets)\n\n    # Best score sum we could achieve\n    best_sum = np.sum(c for c in range(count))\n\n    # Worst score sum we could receive\n    worst_range = range(p[\"num_eligible\"][j] - count, p[\"num_eligible\"][j])\n    worst_sum = np.sum(c for c in worst_range)\n\n    # Score sum we did receive\n    achieved_sum = np.sum(p[\"a_pref_matrix\"][cadets, j])\n\n    # Normalize this score and return it\n    return 1 - (achieved_sum - best_sum) / (worst_sum - best_sum)\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_afsc_norm_score_general","title":"<code>calculate_afsc_norm_score_general(ranks, achieved_ranks)</code>","text":"<p>Calculate the Normalized Score for an AFSC assignment using custom ranks.</p> <p>Parameters: - ranks (numpy.ndarray): An array containing the preference ranks for eligible cadets   for the specific AFSC. - achieved_ranks (numpy.ndarray): An array of achieved ranks, indicating the ranks   at which cadets were assigned to the AFSC.</p> <p>Returns: - norm_score (float): The normalized score for the AFSC assignment, ranging from 0 to 1.</p> <p>Description: This function calculates the normalized score for an assignment of cadets to an AFSC. The score reflects how well the cadets are matched to their preferences for the given AFSC. A higher score indicates a better match, while a lower score suggests a less favorable assignment.</p> <p>The calculation involves comparing the achieved ranks of cadets to the best and worst possible ranks for the AFSC assignment. The result is then normalized to a range between 0 and 1, with 1 being the best possible score and 0 being the worst.</p> <p>Dependencies: - NumPy</p> <p>Returns: - norm_score (float): The normalized score for the AFSC assignment, ranging from 0 to 1.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_afsc_norm_score_general(ranks, achieved_ranks):\n    \"\"\"\n    Calculate the Normalized Score for an AFSC assignment using custom ranks.\n\n    Parameters:\n    - ranks (numpy.ndarray): An array containing the preference ranks for eligible cadets\n      for the specific AFSC.\n    - achieved_ranks (numpy.ndarray): An array of achieved ranks, indicating the ranks\n      at which cadets were assigned to the AFSC.\n\n    Returns:\n    - norm_score (float): The normalized score for the AFSC assignment, ranging from 0 to 1.\n\n    Description:\n    This function calculates the normalized score for an assignment of cadets to an AFSC.\n    The score reflects how well the cadets are matched to their preferences for the given AFSC.\n    A higher score indicates a better match, while a lower score suggests a less favorable assignment.\n\n    The calculation involves comparing the achieved ranks of cadets to the best and worst possible ranks\n    for the AFSC assignment. The result is then normalized to a range between 0 and 1, with 1 being the\n    best possible score and 0 being the worst.\n\n    Dependencies:\n    - NumPy\n\n    Returns:\n    - norm_score (float): The normalized score for the AFSC assignment, ranging from 0 to 1.\n    \"\"\"\n    # Number of cadets assigned here\n    count = len(achieved_ranks)\n\n    # Only consider eligible cadets\n    eligible_indices = np.where(ranks != 0)[0]\n    eligible_ranks = ranks[eligible_indices]\n\n    # Determine the best and worst set of rankings in this list\n    worst_indices = np.argsort(eligible_ranks)[-count:][::-1]\n    worst_ranks = eligible_ranks[worst_indices]\n    best_indices = np.argsort(eligible_ranks)[:count]\n    best_ranks = eligible_ranks[best_indices]\n\n    # Calculate the sums\n    best_sum, achieved_sum, worst_sum = np.sum(best_ranks), np.sum(achieved_ranks), np.sum(worst_ranks)\n\n    # Normalize this score and return it\n    return 1 - (achieved_sum - best_sum) / (worst_sum - best_sum)\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_additional_useful_metrics","title":"<code>calculate_additional_useful_metrics(solution, p, vp)</code>","text":"<p>Add additional components to the \"metrics\" dictionary based on the parameters and value parameters.</p> <p>Parameters:     solution (dict): The dictionary containing the existing metrics.     p (dict): The parameters dictionary.     vp (dict): The value parameters dictionary.</p> <p>Returns:     solution (dict): The updated metrics dictionary.</p> <p>Note:     This function adds additional components to the \"solution\" dictionary based on the provided parameters     and value parameters. The purpose is to enhance the information and analysis of the solution/metrics.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_additional_useful_metrics(solution, p, vp):\n    \"\"\"\n    Add additional components to the \"metrics\" dictionary based on the parameters and value parameters.\n\n    Parameters:\n        solution (dict): The dictionary containing the existing metrics.\n        p (dict): The parameters dictionary.\n        vp (dict): The value parameters dictionary.\n\n    Returns:\n        solution (dict): The updated metrics dictionary.\n\n    Note:\n        This function adds additional components to the \"solution\" dictionary based on the provided parameters\n        and value parameters. The purpose is to enhance the information and analysis of the solution/metrics.\n    \"\"\"\n\n    # Only calculate these metrics if we have the right parameters\n    if 'c_pref_matrix' in p and 'a_pref_matrix' in p:\n\n        # Calculate various metrics achieved\n        solution['cadet_choice'] = np.zeros(p[\"N\"]).astype(int)\n        solution['afsc_choice'] = np.zeros(p['N']).astype(int)\n        solution['cadet_utility_achieved'] = np.zeros(p['N'])\n        solution['afsc_utility_achieved'] = np.zeros(p['N'])\n        solution['global_utility_achieved'] = np.zeros(p['N'])\n        for i, j in enumerate(solution['j_array']):\n            if j in p['J']:\n                solution['cadet_choice'][i] = p['c_pref_matrix'][i, j]  # Assigned cadet choice\n\n                # Cadet is not in the AFSC's preferences\n                if i not in p['afsc_preferences'][j]:\n                    print('Cadet', i, 'not in ' + p['afscs'][j] + \"'s preferences. This will cause an error.\")\n                    continue\n                solution['afsc_choice'][i] = np.where(p['afsc_preferences'][j] == i)[0][0] + 1  # Where is the cadet ranked\n                solution['cadet_utility_achieved'][i] = p['cadet_utility'][i, j]\n                solution['afsc_utility_achieved'][i] = p['afsc_utility'][i, j]\n                solution['global_utility_achieved'][i] = vp['global_utility'][i, j]\n            else:\n                solution['cadet_choice'][i] = np.max(p['c_pref_matrix'][i, :]) + 1  # Unassigned cadet choice\n        solution['average_cadet_choice'] = round(np.mean(solution['cadet_choice'][solution['I^Match']]), 2)\n\n        # Calculate average cadet choice for each AFSC individually\n        solution['afsc_average_cadet_choice'] = np.zeros(p['M'])\n        for j in p['J']:\n            cadets = np.where(solution['j_array'] == j)[0]\n            solution['afsc_average_cadet_choice'][j] = np.mean(p['c_pref_matrix'][cadets, j])\n\n        # Calculate overall utility scores\n        solution['z^gu'] = round(np.mean(solution['global_utility_achieved'][solution['I^Match']]), 4)\n        solution['cadet_utility_overall'] = round(np.mean(solution['cadet_utility_achieved'][solution['I^Match']]), 4)\n        solution['afsc_utility_overall'] = round(np.mean(solution['afsc_utility_achieved'][solution['I^Match']]), 4)\n\n        # Calculate cadet utility based on SOC\n        for soc in p['SOCs']:\n            solution[f'{soc}_cadet_utility'] = round(np.mean(solution['cadet_utility_achieved'][p[f'{soc}_cadets']]), 4)\n\n    # Cadet Choice Counts (For exporting solution file to excel)\n    solution['cadet_choice_counts'] = {}\n    for choice in np.arange(1, 11):  # Just looking at top 10\n        choice_cadets = np.where(solution['cadet_choice'] == choice)[0]\n        solution['cadet_choice_counts'][choice] = len(np.intersect1d(choice_cadets, solution['I^Match']))\n    solution['cadet_choice_counts']['All Others'] = int(p['N^Match'] - sum(\n        [solution['cadet_choice_counts'][choice] for choice in np.arange(1, 11)]))\n\n    # Save the counts for each AFSC separately from the objective_measure matrix\n    quota_k = np.where(vp['objectives'] == 'Combined Quota')[0][0]\n    solution['count'] = solution['objective_measure'][:, quota_k]\n\n    # Assigned cadets\n    solution['cadets_assigned'] = {j: np.where(solution['j_array'] == j)[0] for j in p['J']}\n\n    # Cadets assigned to each accession group\n    con_acc_grp_numerator = 0\n    con_acc_grp_denominator = 0\n    for acc_grp in p['afscs_acc_grp']:\n        solution['I^' + acc_grp] = np.array([i for i in p['I'] if solution['j_array'][i] in p['J^' + acc_grp]])\n\n        # Determine if we constrained Accessions groups properly\n        if \"I^\" + acc_grp in p:\n            acc_grp_constrained = len(p['I^' + acc_grp])\n\n            # Calculate metrics if we actually constrained some people from this group\n            if acc_grp_constrained &gt; 0:\n                acc_grp_correct = len(np.intersect1d(p['I^' + acc_grp], solution['I^' + acc_grp]))\n                con_acc_grp_numerator += acc_grp_correct\n                con_acc_grp_denominator += acc_grp_constrained\n    solution['constrained_acc_grp_target'] = str(con_acc_grp_numerator) + \" / \" + str(con_acc_grp_denominator)\n\n    # Air Force Cadets\n    if 'USSF' in p['afscs_acc_grp']:\n        solution['I^USAF'] = np.array([i for i in p['I'] if i not in solution['I^USSF']])\n\n    # Calculate USSF Merit Distribution\n    solution['ussf_om'] = 0  # Just to have something to show\n    if 'USSF' in p['afscs_acc_grp']:\n\n        # Necessary variables to calculate\n        ussf_merit_sum = np.sum(np.sum(p['merit'][i] * solution['x'][i, j] for i in p['I^E'][j]) for j in p['J^USSF'])\n        ussf_sum = np.sum(np.sum(solution['x'][i, j] for i in p['I^E'][j]) for j in p['J^USSF'])\n\n        # Calculate metric\n        solution['ussf_om'] = round(ussf_merit_sum / ussf_sum, 3)\n\n        # USSF/USAF cadet distinctions\n        solution['ussf_cadets'] = np.array([i for i in p['I'] if solution['j_array'][i] in p['J^USSF']])\n        solution['usaf_cadets'] = np.array([i for i in p['I'] if solution['j_array'][i] not in p['J^USSF']])\n\n        # Calculate cadet/AFSC utility relative to USSF/USAF cadets\n        for service in ['ussf', 'usaf']:\n            for entity in ['cadet', 'afsc']:\n\n                if len(solution[service + '_cadets']) &gt; 0:\n                    solution[service + '_' + entity + '_utility'] = round(\n                        np.mean(solution[entity + '_utility_achieved'][solution[service + '_cadets']]), 4)\n                else:\n                    solution[service + '_' + entity + '_utility'] = 0\n\n        # USSF SOC Breakout\n        solution['ussf_usafa_cadets'] = np.intersect1d(solution['ussf_cadets'], p['usafa_cadets'])\n        solution['ussf_rotc_cadets'] = np.intersect1d(solution['ussf_cadets'], p['rotc_cadets'])\n        solution['ussf_usafa_cadets_count'] = len(solution['ussf_usafa_cadets'])\n        solution['ussf_rotc_cadets_count'] = len(solution['ussf_rotc_cadets'])\n\n        # Metrics that will be printed to excel\n        solution['ussf_usafa_pgl_target'] = str(solution['ussf_usafa_cadets_count']) + \" / \" + str(p['ussf_usafa_pgl'])\n        solution['ussf_rotc_pgl_target'] = str(solution['ussf_rotc_cadets_count']) + \" / \" + str(p['ussf_rotc_pgl'])\n\n    # Calculate weighted average AFSC choice (based on Norm Score)\n    if 'Norm Score' in vp['objectives']:\n        k = np.where(vp['objectives'] == 'Norm Score')[0][0]\n\n        # Individual norm scores for each AFSC\n        solution['afsc_norm_score'] = solution['objective_measure'][:, k]\n\n        # Weighted average AFSC choice\n        weights = solution['count'] / np.sum(solution['count'])\n        solution['weighted_average_afsc_score'] = np.dot(weights, solution['afsc_norm_score'])\n        solution['weighted_average_nrl_afsc_score'] = np.dot(weights[p['J^NRL']] / np.sum(weights[p['J^NRL']]),\n                                                             solution['afsc_norm_score'][p['J^NRL']])\n\n        # Space Force and Air Force differences\n        if 'USSF' in p['afscs_acc_grp']:\n\n            # Weighted average AFSC choice for USSF AFSCs (SFSCs)\n            weights = solution['count'][p['J^USSF']] / np.sum(solution['count'][p['J^USSF']])\n            solution['weighted_average_ussf_afsc_score'] = np.dot(weights, solution['afsc_norm_score'][p['J^USSF']])\n\n            # Weighted average AFSC choice for USAF AFSCs (AFSCs)\n            weights = solution['count'][p['J^USAF']] / np.sum(solution['count'][p['J^USAF']])\n            solution['weighted_average_usaf_afsc_score'] = np.dot(weights, solution['afsc_norm_score'][p['J^USAF']])\n\n    # Generate objective scores for each objective\n    for k in vp['K']:\n        new_weights = vp['afsc_weight'] * vp['objective_weight'][:, k]\n        new_weights = new_weights / sum(new_weights)\n        solution['objective_score'][k] = np.dot(new_weights, solution['objective_value'][:, k])\n\n    # SOC/Gender proportions across AFSCs\n    solution['usafa_proportion_afscs'] = np.array(\n        [round(np.mean(p['usafa'][solution['cadets_assigned'][j]]), 2) for j in p['J']])\n    if 'male' in p:\n        solution['male_proportion_afscs'] = np.array(\n            [round(np.mean(p['male'][solution['cadets_assigned'][j]]), 2) for j in p['J']])\n\n    # SOC/Gender proportions across each Accession group\n    for acc_grp in p['afscs_acc_grp']:\n        if len(solution['I^' + acc_grp]) &gt; 0:\n            solution['usafa_proportion_' + acc_grp] = np.around(np.mean(p['usafa'][solution['I^' + acc_grp]]), 2)\n            if 'male' in p:\n                solution['male_proportion_' + acc_grp] = np.around(np.mean(p['male'][solution['I^' + acc_grp]]), 2)\n\n    # Simpson index\n    if 'race' in p:\n        races = p['race_categories']  # Shorthand (easier to type)\n\n        # Calculate Simpson diversity index for each AFSC\n        solution['simpson_index'] = np.zeros(p['M'])  # Initialize index array for all the AFSCs\n        for j in p['J']:\n            n = solution['count'][j]  # Just grabbing \"n\" as the number of cadets assigned to this AFSC\n\n            # \"AFSC Cadets Race\" dictionary of the number of cadets that were assigned to this AFSC from each race\n            acr = {race: len(np.intersect1d(p['I^' + race], solution['cadets_assigned'][j])) for race in races}\n\n            # Calculate simpson diversity index for this AFSC\n            solution['simpson_index'][j] = round(1 - np.sum([(acr[r] * (acr[r] - 1)) / (n * (n - 1)) for r in races]), 2)\n\n        # Calculate Simpson diversity index for each Accessions Group\n        for acc_grp in p['afscs_acc_grp']:\n            n = len(solution['I^' + acc_grp])  # Just grabbing \"n\" as the number of cadets assigned to this acc group\n\n            # \"Accessions Cadets Race\" dictionary of the number of cadets that were assigned to this grp from each race\n            acr = {race: len(np.intersect1d(p['I^' + race], solution['I^' + acc_grp])) for race in races}\n\n            # Calculate simpson diversity index for this accessions group\n            try:\n                solution['simpson_index_' + acc_grp] = round(1 - np.sum(\n                    [(acr[r] * (acr[r] - 1)) / (n * (n - 1)) for r in races]), 2)\n            except:\n                solution['simpson_index_' + acc_grp] = 0\n\n    # Simpson index (Ethnicity)\n    if 'ethnicity' in p:\n        eths = p['ethnicity_categories']  # Shorthand (easier to type)\n\n        # Calculate Simpson diversity index for each AFSC\n        solution['simpson_index_eth'] = np.zeros(p['M'])  # Initialize index array for all the AFSCs\n        for j in p['J']:\n            n = solution['count'][j]  # Just grabbing \"n\" as the number of cadets assigned to this AFSC\n\n            # \"AFSC Cadets Ethnicity\" dictionary of the number of cadets that were assigned to this AFSC from each eth\n            ace = {eth: len(np.intersect1d(p['I^' + eth], solution['cadets_assigned'][j])) for eth in eths}\n\n            # Calculate simpson diversity index for this AFSC\n            solution['simpson_index_eth'][j] = round(\n                1 - np.sum([(ace[eth] * (ace[eth] - 1)) / (n * (n - 1)) for eth in eths]), 2)\n\n        # Calculate Simpson diversity index for each Accessions Group\n        for acc_grp in p['afscs_acc_grp']:\n            n = len(\n                solution['I^' + acc_grp])  # Just grabbing \"n\" as the number of cadets assigned to this acc group\n\n            # \"Accessions Cadets Ethnicity\" dictionary of the number of cadets that were assigned to this grp/from eth\n            ace = {eth: len(np.intersect1d(p['I^' + eth], solution['I^' + acc_grp])) for eth in eths}\n\n            # Calculate simpson diversity index for this accessions group\n            try:\n                solution['simpson_index_eth_' + acc_grp] = round(1 - np.sum(\n                    [(ace[eth] * (ace[eth] - 1)) / (n * (n - 1)) for eth in eths]), 2)\n            except:\n                solution['simpson_index_eth_' + acc_grp] = 0\n\n    # Calculate STEM proportions in each AFSC\n    if 'stem' in p:\n        pass\n\n    # Initialize dictionaries for cadet choice based on demographics\n    dd = {\"usafa\": [soc.upper() for soc in p['SOCs']], \"male\": [\"Male\", \"Female\"]}  # Demographic Dictionary\n    demographic_dict = {cat: [dd[cat][0], dd[cat][1]] for cat in dd if cat in p}  # Demographic Dictionary (For this instance)\n    solution[\"choice_counts\"] = {\"TOTAL\": {}}  # Everyone\n    for cat in demographic_dict:\n        for dem in demographic_dict[cat]:\n            solution[\"choice_counts\"][dem] = {}\n\n    # Top 3 Choices from USSF and USAF (and ROTC/USAFA)\n    if 'USSF' in p['afscs_acc_grp']:\n        for cat in ['USSF', 'USAF']:\n\n            # Might not have anyone assigned from this group\n            if len(solution['I^' + cat]) == 0:\n                solution['top_3_' + cat.lower() + '_count'] = 0\n                continue\n\n            # Calculate actual top 3 count\n            arr = np.array([i for i in solution['I^' + cat] if solution['j_array'][i] in p['cadet_preferences'][i][:3]])\n            solution['top_3_' + cat.lower() + '_count'] = round(len(arr) / len(solution['I^' + cat]), 4)\n    for cat in dd['usafa']:\n        arr = np.array([i for i in p['I^' + cat] if solution['j_array'][i] in p['cadet_preferences'][i][:3]])\n        solution['top_3_' + cat.lower() + '_count'] = round(len(arr) / len(p['I^' + cat]), 4)\n\n    # Initialize arrays within the choice dictionaries for the AFSCs\n    choice_categories = [\"Top 3\", \"Next 3\", \"All Others\", \"Total\"]\n    for dem in solution[\"choice_counts\"]:\n        for c_cat in choice_categories:\n            solution[\"choice_counts\"][dem][c_cat] = np.zeros(p[\"M\"]).astype(int)\n        for afsc in p[\"afscs\"]:\n            solution[\"choice_counts\"][dem][afsc] = np.zeros(p[\"P\"]).astype(int)\n\n    # AFSC choice\n    solution['afsc_choice_counts'] = {}\n\n    cat_bound_dict = {'90-100%': 0.9, '80-89%': 0.8, '70-79%': 0.7, '60-69%': 0.6, '50-59%': 0.5,\n                      '40-49%': 0.4, '30-39%': 0.3, '20-29%': 0.2, '10-19%': 0.1, '0-10%': 0}\n\n    # Loop through each AFSC\n    for j, afsc in enumerate(p[\"afscs\"][:p['M']]):  # Skip unmatched AFSC\n\n        # The cadets that were assigned to this AFSC\n        dem_cadets = {\"TOTAL\": np.where(solution[\"afsc_array\"] == afsc)[0]}\n\n        # The cadets with the demographic that were assigned to this AFSC\n        for cat in demographic_dict:\n            dem_1, dem_2 = demographic_dict[cat][0], demographic_dict[cat][1]\n            dem_cadets[dem_1] = np.intersect1d(np.where(p[cat] == 1)[0], dem_cadets[\"TOTAL\"])\n            dem_cadets[dem_2] = np.intersect1d(np.where(p[cat] == 0)[0], dem_cadets[\"TOTAL\"])\n\n        afsc_utilities = p['afsc_utility'][dem_cadets['TOTAL'], j]\n        solution['afsc_choice_counts'][afsc] = {}\n        for cat, bound in cat_bound_dict.items():\n\n            if cat == 0.9:\n                condition = (afsc_utilities &gt;= bound) &amp; (afsc_utilities &lt;= bound + 0.1)\n            else:\n                condition = (afsc_utilities &gt;= bound) &amp; (afsc_utilities &lt; bound + 0.1)\n            cadets = np.where(condition)[0]\n            solution['afsc_choice_counts'][afsc][cat] = len(cadets)\n\n        # Loop through each choice and calculate the metric\n        for choice in range(p[\"P\"]):\n\n            # The cadets that were assigned to this AFSC and placed it in their Pth choice\n            assigned_choice_cadets = np.intersect1d(p[\"I^Choice\"][choice][j], dem_cadets[\"TOTAL\"])\n\n            # The cadets that were assigned to this AFSC, placed it in their Pth choice, and had the demographic\n            for dem in solution[\"choice_counts\"]:\n                solution[\"choice_counts\"][dem][afsc][choice] = len(\n                    np.intersect1d(assigned_choice_cadets, dem_cadets[dem]))\n\n        # Loop through each demographic\n        for dem in solution[\"choice_counts\"]:\n            solution[\"choice_counts\"][dem][\"Total\"][j] = int(len(dem_cadets[dem]))\n            solution[\"choice_counts\"][dem][\"Top 3\"][j] = int(np.sum(solution[\"choice_counts\"][dem][afsc][:3]))\n            solution[\"choice_counts\"][dem][\"Next 3\"][j] = int(np.sum(solution[\"choice_counts\"][dem][afsc][3:6]))\n            solution[\"choice_counts\"][dem][\"All Others\"][j] = int(len(\n                dem_cadets[dem]) - solution[\"choice_counts\"][dem][\"Top 3\"][j] - solution[\"choice_counts\"][dem][\"Next 3\"][j])\n\n    # Top 3 Choice Percentage\n    solution['top_3_choice_percent'] = np.around(\n        np.sum([1 &lt;= solution['cadet_choice'][i] &lt;= 3 for i in solution['I^Match']]) / p['N^Match'], 3)\n    return solution\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_base_training_metrics","title":"<code>calculate_base_training_metrics(solution, p, vp)</code>","text":"<p>Add additional base/training components to the \"solution\" dictionary based on the parameters and value parameters.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_base_training_metrics(solution, p, vp):\n    \"\"\"\n    Add additional base/training components to the \"solution\" dictionary based on the parameters and value parameters.\n    \"\"\"\n\n    # Initialize arrays\n    solution['base_choice'] = np.zeros(p['N']).astype(int)\n    solution['base_utility_achieved'] = np.zeros(p['N'])\n    solution['course_utility_achieved'] = np.zeros(p['N'])\n    solution['cadet_state_achieved'] = np.zeros(p['N']).astype(int)\n    solution['cadet_value_achieved'] = np.zeros(p['N'])\n\n    # Weights Implemented\n    solution['afsc_weight_used'] = np.zeros(p['N'])\n    solution['base_weight_used'] = np.zeros(p['N'])\n    solution['course_weight_used'] = np.zeros(p['N'])\n    solution['state_utility_used'] = np.zeros(p['N'])\n\n    # Loop through each cadet to load in their values to each of the above\n    for i, j in enumerate(solution['j_array']):\n        b, c = solution['b_array'][i], solution['c_array'][i][1]\n\n        # Determine what state this cadet achieved\n        d = [d for d in p['D'][i] if j in p['J^State'][i][d]][0]\n        solution['cadet_state_achieved'][i] = d\n\n        # Base-components depend on base outcome\n        if b != p['S']:\n            solution['base_choice'][i] = p['b_pref_matrix'][i, b]\n            solution['base_utility_achieved'][i] = p['base_utility'][i, b]\n            solution['base_weight_used'][i] = p['w^B'][i][d]\n        else:\n            solution['base_choice'][i] = 0\n            solution['base_utility_achieved'][i] = 0\n            solution['base_weight_used'][i] = 0\n\n        # Load other components\n        solution['course_utility_achieved'][i] = p['course_utility'][i][j][c]\n        solution['afsc_weight_used'][i] = p['w^A'][i][d]\n        solution['course_weight_used'][i] = p['w^C'][i][d]\n        solution['state_utility_used'][i] = p['u^S'][i][d]\n\n        # Calculate Cadet Value\n        solution['cadet_value_achieved'][i] = p['u^S'][i][d] * (\n                p['w^A'][i][d] * (p['cadet_utility'][i, j] / p['u^S'][i][d]) +\n                solution['base_weight_used'][i] * solution['base_utility_achieved'][i] +\n                p['w^C'][i][d] * solution['course_utility_achieved'][i])\n\n    # Calculate adjusted Z value (VFT) and associated metrics\n    solution['cadet_value'] = solution['cadet_value_achieved']\n    solution['cadets_overall_value'] = np.dot(vp['cadet_weight'], solution['cadet_value'])\n    solution['z'] = vp['cadets_overall_weight'] * solution['cadets_overall_value'] + \\\n                    vp['afscs_overall_weight'] * solution['afscs_overall_value']\n\n    # Calculate adjusted Z value (GUO)\n    solution['z^gu'] = (1 / p['N']) * vp['afscs_overall_weight'] * np.sum(solution['afsc_utility_achieved']) + \\\n                       vp['cadets_overall_weight'] * solution['cadets_overall_value']\n\n    return solution\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_castle_solution_metrics","title":"<code>calculate_castle_solution_metrics(solution, p)</code>","text":"<p>Add CASTLE-specific solution metrics</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_castle_solution_metrics(solution, p):\n    \"\"\"\n    Add CASTLE-specific solution metrics\n    \"\"\"\n\n    # Shorthand\n    x, q = solution['x'], p['castle_q']\n\n    # Loop through each CASTLE AFSC to calculate the numbers of people assigned\n    solution['castle_counts'], solution['castle_v'] = {}, {}\n    afscs = [afsc for afsc, _ in p['J^CASTLE'].items()]\n    for afsc, j_indices in p['J^CASTLE'].items():\n\n        # Get the number of people assigned to each AFSC under this \"CASTLE\" AFSC umbrella\n        measure = np.sum(np.sum(x[i, j] for i in p['I^E'][j]) for j in j_indices)\n\n        # (+ ADD OTS if they're not being matched!!)\n        if 'ots' not in p['SOCs']:\n            measure += p['ots_counts'][afsc]\n\n        # Save the measure\n        solution['castle_counts'][afsc] = measure\n\n        # Get the value from this AFSC's curve\n        v = value_function(q['a'][afsc], q['f^hat'][afsc], q['r'][afsc], measure)\n        solution['castle_v'][afsc] = v\n\n    # Calculate \"z^CASTLE\"\n    solution['z^CASTLE (Values)'] = round(np.sum(solution['castle_v'][afsc] for afsc in afscs), 4)\n    solution['z^CASTLE'] = round(p['w^G'] * solution['z^gu'] + (1 - p['w^G']) * solution['z^CASTLE (Values)'], 4)\n    return solution\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_objective_measure_chromosome","title":"<code>calculate_objective_measure_chromosome(cadets, j, objective, p, vp, count)</code>","text":"<p>Calculates the AFSC objective measure based on the provided parameters.</p> <p>Parameters:     cadets (list): List of cadets.     j (int): AFSC index.     objective (str): Objective for which to calculate the measure.     p (dict): Parameters used in the calculations.     vp (dict): Value parameters used in the calculations.     count (int): Number of cadets.</p> <p>Returns:     measure (float): The calculated AFSC objective measure.</p> <p>Note:     The function assumes an \"exact\" model since it's used in the fitness function.     The measure is calculated based on the objective and the provided inputs.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_objective_measure_chromosome(cadets, j, objective, p, vp, count):\n    \"\"\"\n    Calculates the AFSC objective measure based on the provided parameters.\n\n    Parameters:\n        cadets (list): List of cadets.\n        j (int): AFSC index.\n        objective (str): Objective for which to calculate the measure.\n        p (dict): Parameters used in the calculations.\n        vp (dict): Value parameters used in the calculations.\n        count (int): Number of cadets.\n\n    Returns:\n        measure (float): The calculated AFSC objective measure.\n\n    Note:\n        The function assumes an \"exact\" model since it's used in the fitness function.\n        The measure is calculated based on the objective and the provided inputs.\n\n    \"\"\"\n\n    # Objective to balance some demographic of the cadets (binary indicator)\n    if objective in vp['K^D']:\n        return len(np.intersect1d(p['I^D'][objective][j], cadets)) / count\n\n    # Balancing Merit\n    elif objective == 'Merit':\n        return np.mean(p['merit'][cadets])\n\n    # \"Number of Cadets\" Objectives\n    elif objective == 'Combined Quota':\n        return count\n    elif objective == 'USAFA Quota':\n        return len(np.intersect1d(p['usafa_cadets'], cadets))\n    elif objective == 'ROTC Quota':\n        return len(np.intersect1d(p['rotc_cadets'], cadets))\n    elif objective == 'OTS Quota':\n        return len(np.intersect1d(p['ots_cadets'], cadets))\n\n    # Maximize cadet utility\n    elif objective == 'Utility':\n        return np.mean(p['cadet_utility'][cadets, j])\n\n    # New objective to evaluate CFM preference lists\n    elif objective == \"Norm Score\":\n        return calculate_afsc_norm_score(cadets, j, p, count=count)\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_objective_measure_matrix","title":"<code>calculate_objective_measure_matrix(x, j, objective, p, vp, approximate=True)</code>","text":"<p>Calculates the AFSC objective measure based on the provided parameters.</p> <p>Parameters:     x (ndarray): Matrix representing the assignment of cadets to AFSCs.     j (int): AFSC index.     objective (str): Objective for which to calculate the measure.     p (dict): Parameters used in the calculations.     vp (dict): Value parameters used in the calculations.     approximate (bool, optional): Flag indicating whether to use an approximate measure (divide by estimated number         of cadets, not the REAL number af cadets assigned to the AFSC. Defaults to True.</p> <p>Returns:     measure (float): The calculated AFSC objective measure.     numerator (float or None): The numerator used in the calculation of the measure.         It is None for certain objectives.</p> <p>Raises:     ValueError: If the provided objective does not have a means of calculation in the VFT model.</p> <p>Note:     The measure and numerator are calculated based on the objective and the provided inputs.     The numerator is the value used in the calculation of the measure (sum of cadets with some feature over the     \"num_cadets\" variable which is either the actual number of cadets assigned (count) or estimated (quota_e).</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_objective_measure_matrix(x, j, objective, p, vp, approximate=True):\n    \"\"\"\n    Calculates the AFSC objective measure based on the provided parameters.\n\n    Parameters:\n        x (ndarray): Matrix representing the assignment of cadets to AFSCs.\n        j (int): AFSC index.\n        objective (str): Objective for which to calculate the measure.\n        p (dict): Parameters used in the calculations.\n        vp (dict): Value parameters used in the calculations.\n        approximate (bool, optional): Flag indicating whether to use an approximate measure (divide by estimated number\n            of cadets, not the REAL number af cadets assigned to the AFSC. Defaults to True.\n\n    Returns:\n        measure (float): The calculated AFSC objective measure.\n        numerator (float or None): The numerator used in the calculation of the measure.\n            It is None for certain objectives.\n\n    Raises:\n        ValueError: If the provided objective does not have a means of calculation in the VFT model.\n\n    Note:\n        The measure and numerator are calculated based on the objective and the provided inputs.\n        The numerator is the value used in the calculation of the measure (sum of cadets with some feature over the\n        \"num_cadets\" variable which is either the actual number of cadets assigned (count) or estimated (quota_e).\n\n    \"\"\"\n\n    # Get count variables for this AFSC\n    count = np.sum(x[i, j] for i in p['I^E'][j])\n    if approximate:\n        num_cadets = int(p['quota_e'][j])  # estimated number of cadets\n    else:\n        num_cadets = count  # actual number of cadets\n\n    # Objective to balance some demographic of the cadets (binary indicator)\n    if objective in vp['K^D']:\n        numerator = np.sum(x[i, j] for i in p['I^D'][objective][j])\n        return numerator / num_cadets, numerator # Measure, Numerator\n\n    # Balancing Merit\n    elif objective == \"Merit\":\n        numerator = np.sum(p['merit'][i] * x[i, j] for i in p['I^E'][j])\n        return numerator / num_cadets, numerator # Measure, Numerator\n\n    # \"Number of Cadets\" Objectives\n    elif objective == \"Combined Quota\":\n        return count, None # Measure, Numerator\n    elif objective == \"USAFA Quota\":\n        return np.sum(x[i, j] for i in np.intersect1d(p['usafa_cadets'], p['I^E'][j])), None # Measure, Numerator\n    elif objective == \"ROTC Quota\":\n        return np.sum(x[i, j] for i in np.intersect1d(p['rotc_cadets'], p['I^E'][j])), None  # Measure, Numerator\n    elif objective == \"OTS Quota\":\n        return np.sum(x[i, j] for i in np.intersect1d(p['ots_cadets'], p['I^E'][j])), None  # Measure, Numerator\n\n    # Maximize cadet utility\n    elif objective == \"Utility\":\n        numerator = np.sum(p['cadet_utility'][i, j] * x[i, j] for i in p['I^E'][j])\n        return numerator / num_cadets, numerator  # Measure, Numerator\n\n    # New objective to evaluate CFM preference lists\n    elif objective == \"Norm Score\":\n\n        # Proxy for constraint purposes\n        numerator = np.sum(p['afsc_utility'][i, j] * x[i, j] for i in p['I^E'][j])\n\n        # Temporary placeholder- need better methodology for calculating Norm Score in \"Exact Model\"!\n        if type(num_cadets) not in [int, np.int64]:\n            num_cadets = int(p['quota_e'][j])\n\n        # Actual objective measure\n        best_range = range(num_cadets)\n        best_sum = np.sum(c for c in best_range)\n        worst_range = range(p[\"num_eligible\"][j] - num_cadets, p[\"num_eligible\"][j])\n        worst_sum = np.sum(c for c in worst_range)\n        achieved_sum = np.sum(p[\"a_pref_matrix\"][i, j] * x[i, j] for i in p[\"I^E\"][j])\n        return 1 - (achieved_sum - best_sum) / (worst_sum - best_sum), numerator  # Measure, Numerator\n\n    # Unrecognized objective\n    else:\n        raise ValueError(\"Error. Objective '\" + objective + \"' does not have a means of calculation in the\"\n                                                            \" VFT model. Please adjust.\")\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.calculate_failed_constraint_metrics","title":"<code>calculate_failed_constraint_metrics(j, k, solution, p, vp)</code>","text":"<p>Calculate failed constraint metrics for an AFSC objective and return the updated metrics dictionary.</p> <p>Parameters:     j (int): Index of the AFSC objective.     k (int): Index of the objective measure.     solution (dict): The solution/metrics dictionary.     p (dict): The fixed cadet/AFSC model parameters.     vp (dict): The weight/value parameters.</p> <p>Returns:     solution (dict): The updated solution/metrics dictionary.</p> <p>Note:     This function calculates the failed constraint metrics for an AFSC objective and updates the metrics dictionary     with the newly calculated values.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def calculate_failed_constraint_metrics(j, k, solution, p, vp):\n    \"\"\"\n    Calculate failed constraint metrics for an AFSC objective and return the updated metrics dictionary.\n\n    Parameters:\n        j (int): Index of the AFSC objective.\n        k (int): Index of the objective measure.\n        solution (dict): The solution/metrics dictionary.\n        p (dict): The fixed cadet/AFSC model parameters.\n        vp (dict): The weight/value parameters.\n\n    Returns:\n        solution (dict): The updated solution/metrics dictionary.\n\n    Note:\n        This function calculates the failed constraint metrics for an AFSC objective and updates the metrics dictionary\n        with the newly calculated values.\n    \"\"\"\n\n    # Constrained Approximate Measure (Only meant for degree tier constraints)\n    if vp[\"constraint_type\"][j, k] == 1:  # Should be an \"at least constraint\"\n\n        # Get count variable\n        count = np.sum(solution['x'][i, j] for i in p['I^E'][j])\n        constrained_measure = (solution['objective_measure'][j, k] * count) / min(p['quota_min'][j], p['pgl'][j])\n\n    # Constrained Exact Measure\n    elif vp[\"constraint_type\"][j, k] == 2:  # Should be either an \"at most constraint\" or simple valid range (0.2, 0.4)\n        constrained_measure = solution['objective_measure'][j, k]\n\n    else:\n        pass\n\n    # Measure is below the range\n    if constrained_measure &lt; vp['objective_min'][j, k]:\n        solution['objective_constraint_fail'][j, k] = \\\n            str(round(constrained_measure, 2)) + ' &lt; ' + str(vp['objective_min'][j, k]) + '. ' + \\\n            str(round(100 * constrained_measure / vp['objective_min'][j, k], 2)) + '% Met.'\n        solution['total_failed_constraints'] += 1\n        solution[\"failed_constraints\"].append(p['afscs'][j] + \" \" + vp['objectives'][k])\n        solution[\"con_fail_dict\"][(j, k)] = '&gt; ' + str(round(constrained_measure, 4))\n\n    # Measure is above the range\n    elif constrained_measure &gt; vp['objective_max'][j, k]:\n        solution['objective_constraint_fail'][j, k] = \\\n            str(round(constrained_measure, 2)) + ' &gt; ' + str(vp['objective_max'][j, k]) + '. ' + \\\n            str(round(100 * vp['objective_max'][j, k] / constrained_measure, 2)) + '% Met.'\n        solution['total_failed_constraints'] += 1\n        solution[\"failed_constraints\"].append(p['afscs'][j] + \" \" + vp['objectives'][k])\n        solution[\"con_fail_dict\"][(j, k)] = '&lt; ' + str(round(constrained_measure, 4))\n\n    return solution  # Return *updated* solution/metrics\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.check_failed_constraint_chromosome","title":"<code>check_failed_constraint_chromosome(j, k, measure, count, p, vp, con_fail_dict)</code>","text":"<p>This function takes in the AFSC index, objective index, AFSC objective measure, number of cadets assigned (count), parameters, value parameters, and the constraint fail dictionary and determines if we've failed the constraint or not.</p> <p>Parameters:</p> Name Type Description Default <code>j</code> <p>Index of the AFSC (Air Force Specialty Code).</p> required <code>k</code> <p>Index of the objective.</p> required <code>measure</code> <p>Measure of the AFSC objective.</p> required <code>count</code> <p>Number of cadets assigned.</p> required <code>p</code> <p>Dictionary of parameters. - 'quota_min': Array of minimum quotas for each AFSC. - 'pgl': Array of Program Guidance Letter (PGL) targets for each AFSC.</p> required <code>vp</code> <p>Dictionary of value parameters. - 'constraint_type': Array representing the constraint type for each AFSC and objective. - 1 represents Constrained Approximate Measure. - 2 represents Constrained Exact Measure. - 'objective_min': Array representing the minimum objective value for each AFSC and objective. - 'objective_max': Array representing the maximum objective value for each AFSC and objective.</p> required <code>con_fail_dict</code> <p>Dictionary containing information about failed constraints (optional). - Keys are tuples (j, k) representing AFSC and objective indices. - Values are strings representing adjusted min/max values for the failed constraint. - If the string starts with '&gt;', it means the minimum value needed should be lowered. - Otherwise, it means the maximum value allowed should be raised.</p> required <p>Returns:</p> Type Description <p>A boolean indicating whether the constraint is failed or not. - True if the measure is outside the constrained range (constraint failed). - False if the measure is within the constrained range (constraint passed).</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def check_failed_constraint_chromosome(j, k, measure, count, p, vp, con_fail_dict):\n    \"\"\"\n    This function takes in the AFSC index, objective index, AFSC objective measure, number of cadets assigned (count),\n    parameters, value parameters, and the constraint fail dictionary and determines if we've failed the constraint or not.\n\n    :param j: Index of the AFSC (Air Force Specialty Code).\n    :param k: Index of the objective.\n    :param measure: Measure of the AFSC objective.\n    :param count: Number of cadets assigned.\n    :param p: Dictionary of parameters.\n        - 'quota_min': Array of minimum quotas for each AFSC.\n        - 'pgl': Array of Program Guidance Letter (PGL) targets for each AFSC.\n    :param vp: Dictionary of value parameters.\n        - 'constraint_type': Array representing the constraint type for each AFSC and objective.\n            - 1 represents Constrained Approximate Measure.\n            - 2 represents Constrained Exact Measure.\n        - 'objective_min': Array representing the minimum objective value for each AFSC and objective.\n        - 'objective_max': Array representing the maximum objective value for each AFSC and objective.\n    :param con_fail_dict: Dictionary containing information about failed constraints (optional).\n        - Keys are tuples (j, k) representing AFSC and objective indices.\n        - Values are strings representing adjusted min/max values for the failed constraint.\n            - If the string starts with '&gt;', it means the minimum value needed should be lowered.\n            - Otherwise, it means the maximum value allowed should be raised.\n\n    :return: A boolean indicating whether the constraint is failed or not.\n        - True if the measure is outside the constrained range (constraint failed).\n        - False if the measure is within the constrained range (constraint passed).\n    \"\"\"\n\n    # Constrained Approximate Measure (Only meant for degree tier constraints)\n    if vp[\"constraint_type\"][j, k] == 1:  # Should be an \"at least constraint\"\n        constrained_measure = (measure * count) / min(p['quota_min'][j], p['pgl'][j])\n\n    # Constrained Exact Measure\n    elif vp[\"constraint_type\"][j, k] == 2:  # Should be either an \"at most constraint\" or simple valid range (0.2, 0.4)\n        constrained_measure = measure\n\n    # The constrained min and max values as specified by the value parameters\n    constrained_min, constrained_max = vp[\"objective_min\"][j, k], vp[\"objective_max\"][j, k]\n\n    # We adjust the constrained min and max based on the pyomo solution since it could be a little off due to rounding\n    if con_fail_dict is not None:\n        if (j, k) in con_fail_dict:\n\n            # Split up the value in the dictionary to get the new min and max\n            split_list = con_fail_dict[(j, k)].split(' ')\n            if split_list[0] == '&gt;':  # We lower the minimum value needed\n                constrained_min = float(split_list[1])\n            else:  # We raise the maximum value allowed\n                constrained_max = float(split_list[1])\n\n    # Round everything to stay consistent\n    constrained_min, constrained_measure, constrained_max = round(constrained_min, 4), round(constrained_measure, 4), \\\n                                                            round(constrained_max, 4)\n\n    # Check if we failed the constraint, and return a boolean\n    if constrained_min &lt;= constrained_measure &lt;= constrained_max:\n        return False  # Measure is in the range, we DID NOT fail the constraint (failed = False)\n    else:\n        return True  # Measure is outside the range, we DID fail the constraint (failed = True)\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.compare_solutions","title":"<code>compare_solutions(baseline, compared, printing=False)</code>","text":"<p>Compare two solutions (in vector form) to the same problem and determine the similarity between them based on the AFSCs assigned to cadets.</p> <p>Parameters:     baseline (numpy.ndarray): The first solution (baseline) to compare.     compared (numpy.ndarray): The second solution to compare against the baseline.     printing (bool, optional): Whether to print the similarity percentage. Defaults to False.</p> <p>Returns:     percent_similar (float): The percentage of the compared solution that is the same as the baseline solution.</p> <p>Note:     This function compares two solutions represented as vectors and calculates the percentage of similarity     between them in terms of the AFSCs assigned to cadets. The solutions must be for the same set of cadets     and AFSCs.</p> <p>Example:     baseline = np.array([0, 1, 2, 1, 0])     compared = np.array([1, 0, 2, 1, 0])     similarity = compare_solutions(baseline, compared, printing=True)     # Output: The two solutions are 60.0% the same (3/5).</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def compare_solutions(baseline, compared, printing=False):\n    \"\"\"\n    Compare two solutions (in vector form) to the same problem and determine the similarity between them based on the\n    AFSCs assigned to cadets.\n\n    Parameters:\n        baseline (numpy.ndarray): The first solution (baseline) to compare.\n        compared (numpy.ndarray): The second solution to compare against the baseline.\n        printing (bool, optional): Whether to print the similarity percentage. Defaults to False.\n\n    Returns:\n        percent_similar (float): The percentage of the compared solution that is the same as the baseline solution.\n\n    Note:\n        This function compares two solutions represented as vectors and calculates the percentage of similarity\n        between them in terms of the AFSCs assigned to cadets. The solutions must be for the same set of cadets\n        and AFSCs.\n\n    Example:\n        baseline = np.array([0, 1, 2, 1, 0])\n        compared = np.array([1, 0, 2, 1, 0])\n        similarity = compare_solutions(baseline, compared, printing=True)\n        # Output: The two solutions are 60.0% the same (3/5).\n    \"\"\"\n\n    percent_similar = (sum(baseline == compared * 1) / len(baseline))\n    if printing:\n        print(\"The two solutions are \" + str(percent_similar) + \"% the same.\")\n    return percent_similar\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.similarity_coordinates","title":"<code>similarity_coordinates(similarity_matrix)</code>","text":"<p>Perform Multidimensional Scaling (MDS) on a similarity matrix to obtain coordinates representing the solutions' similarity relationships.</p> <p>Parameters: - similarity_matrix (numpy.ndarray): A square similarity matrix where each element   (i, j) measures the similarity between solutions i and j.</p> <p>Returns: - coordinates (numpy.ndarray): An array of 2D coordinates representing the solutions   in a space where the distance between solutions reflects their similarity.</p> <p>Description: This function takes in a similarity matrix and performs Multidimensional Scaling (MDS) to obtain coordinates representing the solutions in a lower-dimensional space. The purpose of MDS is to transform similarity data into distances. In the resulting 2D space, solutions that are similar to each other will be closer together, while dissimilar solutions will be farther apart.</p> <p>MDS is particularly useful for visualizing the similarity relationships among solutions. These coordinates can be used for plotting or further analysis to gain insights into how solutions relate to each other based on their similarities.</p> <p>Note: Ensure that you have the required libraries, such as NumPy and Scikit-learn, installed.</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def similarity_coordinates(similarity_matrix):\n    \"\"\"\n    Perform Multidimensional Scaling (MDS) on a similarity matrix to obtain coordinates\n    representing the solutions' similarity relationships.\n\n    Parameters:\n    - similarity_matrix (numpy.ndarray): A square similarity matrix where each element\n      (i, j) measures the similarity between solutions i and j.\n\n    Returns:\n    - coordinates (numpy.ndarray): An array of 2D coordinates representing the solutions\n      in a space where the distance between solutions reflects their similarity.\n\n    Description:\n    This function takes in a similarity matrix and performs Multidimensional Scaling (MDS)\n    to obtain coordinates representing the solutions in a lower-dimensional space. The\n    purpose of MDS is to transform similarity data into distances. In the resulting 2D\n    space, solutions that are similar to each other will be closer together, while\n    dissimilar solutions will be farther apart.\n\n    MDS is particularly useful for visualizing the similarity relationships among solutions.\n    These coordinates can be used for plotting or further analysis to gain insights into\n    how solutions relate to each other based on their similarities.\n\n    Note: Ensure that you have the required libraries, such as NumPy and Scikit-learn, installed.\n    \"\"\"\n\n    # Change similarity matrix into distance matrix\n    distances = 1 - similarity_matrix\n\n    # Get coordinates\n    if afccp.globals.use_manifold:\n        mds = manifold.MDS(n_components=2, dissimilarity='precomputed', random_state=10)\n        results = mds.fit(distances)\n        coordinates = results.embedding_\n    else:\n        coordinates = np.zeros([len(distances), 2])\n        print('Sklearn manifold not available')\n\n    return coordinates\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.incorporate_rated_results_in_parameters","title":"<code>incorporate_rated_results_in_parameters(instance, printing=True)</code>","text":"<p>This function extracts the results from the two Rated solutions (for both USAFA &amp; ROTC) and incorporates them into the problem's parameters. It fixes cadets who were \"matched\" by the algorithm to specific AFSCs and constrains individuals who had \"reserved\" slots.</p> <p>Parameters: - instance: An instance of the problem, containing parameters and algorithm results. - printing (bool, optional): A flag to control whether to print information during execution.   Set to True to enable printing, and False to suppress it. Default is True.</p> <p>Returns: - parameters (dict): The updated parameters dictionary reflecting the rated algorithm results.</p> <p>Description: This function is used to integrate the outcomes of the Rated SOC (Source of Commissioning) algorithm into the problem's parameters. It processes the results for both USAFA (United States Air Force Academy) and ROTC (Reserve Officers' Training Corps) categories.</p> <ul> <li> <p>The \"Matched\" cadets are assigned to specific AFSCs based on the algorithm results. These assignments   are recorded in the 'J^Fixed' array within the parameters.</p> </li> <li> <p>The \"Reserved\" cadets have their AFSC selections constrained based on their reserved slots. The   'J^Reserved' dictionary is updated to enforce these constraints.</p> </li> <li> <p>Special treatment is provided for AFSCs with an \"alternate list\" concept. Cadets who did not receive   one of their top preferences but are next in line for a particular AFSC are assigned to the \"alternate list.\"   Cadets on this list may be given preferences or reserved slots, depending on availability.</p> </li> </ul> <p>This function aims to ensure that the problem's parameters align with the Rated SOC algorithm's results, facilitating further decision-making and analysis.</p> <p>Note: Detailed information on the Rated SOC algorithm results is assumed to be available within the 'instance.'</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def incorporate_rated_results_in_parameters(instance, printing=True):\n    \"\"\"\n    This function extracts the results from the two Rated solutions (for both USAFA &amp; ROTC)\n    and incorporates them into the problem's parameters. It fixes cadets who were \"matched\" by the algorithm\n    to specific AFSCs and constrains individuals who had \"reserved\" slots.\n\n    Parameters:\n    - instance: An instance of the problem, containing parameters and algorithm results.\n    - printing (bool, optional): A flag to control whether to print information during execution.\n      Set to True to enable printing, and False to suppress it. Default is True.\n\n    Returns:\n    - parameters (dict): The updated parameters dictionary reflecting the rated algorithm results.\n\n    Description:\n    This function is used to integrate the outcomes of the Rated SOC (Source of Commissioning) algorithm into\n    the problem's parameters. It processes the results for both USAFA (United States Air Force Academy)\n    and ROTC (Reserve Officers' Training Corps) categories.\n\n    - The \"Matched\" cadets are assigned to specific AFSCs based on the algorithm results. These assignments\n      are recorded in the 'J^Fixed' array within the parameters.\n\n    - The \"Reserved\" cadets have their AFSC selections constrained based on their reserved slots. The\n      'J^Reserved' dictionary is updated to enforce these constraints.\n\n    - Special treatment is provided for AFSCs with an \"alternate list\" concept. Cadets who did not receive\n      one of their top preferences but are next in line for a particular AFSC are assigned to the \"alternate list.\"\n      Cadets on this list may be given preferences or reserved slots, depending on availability.\n\n    This function aims to ensure that the problem's parameters align with the Rated SOC algorithm's results,\n    facilitating further decision-making and analysis.\n\n    Note: Detailed information on the Rated SOC algorithm results is assumed to be available within the 'instance.'\n    \"\"\"\n\n    if printing:\n        print(\"Incorporating rated algorithm results...\")\n\n    # Shorthand\n    p, vp, solutions = instance.parameters, instance.value_parameters, instance.solutions\n    mdl_p = instance.mdl_p\n    if mdl_p['socs_to_use'] is None:\n        socs_to_use = p['SOCs']\n    else:\n        socs_to_use = mdl_p['socs_to_use']\n    upper_socs = [soc.upper() for soc in socs_to_use]\n\n    # Make sure we have the solutions from both SOCs with matches and reserves\n    for soc in upper_socs:\n        for kind in ['Reserves', 'Matches']:\n            solution_name = \"Rated \" + soc.upper() + \" HR (\" + kind + \")\"\n            if solution_name not in solutions:\n                return p  # We don't have the required solutions!\n\n    # Matched cadets get fixed in the solution!\n    for soc in upper_socs:\n        solution = solutions[\"Rated \" + soc.upper() + \" HR (Matches)\"]\n        matched_cadets = np.where(solution['j_array'] != p['M'])[0]\n        for i in matched_cadets:\n            p['J^Fixed'][i] = solution['j_array'][i]\n\n    # Reserved cadets AFSC selection is constrained to be AT LEAST their reserved Rated slot\n    p['J^Reserved'] = {}\n    for soc in upper_socs:\n        solution = solutions[\"Rated \" + soc.upper() + \" HR (Reserves)\"]\n        reserved_cadets = np.where(solution['j_array'] != p['M'])[0]\n        for i in reserved_cadets:\n            j = solution['j_array'][i]\n            choice = np.where(p['cadet_preferences'][i] == j)[0][0]\n            p['J^Reserved'][i] = p['cadet_preferences'][i][:choice + 1]\n\n    # Calculate additional rated algorithm result information for both SOCs\n    for soc in socs_to_use:\n\n        # Do we want to potentially allow ROTC to fill USAFA pilot slots?\n        if mdl_p['usafa_soc_pilot_cross_in'] and soc == 'rotc':\n\n            # If we want to allow cross-flow, we need to add USAFA reserved pilot slots to be potentially filled\n            j_pilot_u = np.where(p['afscs'] == '11XX_U')[0][0]  # by ROTC (increase their alternate list)\n\n            # First we calculate the number of reserved USAFA pilot slots there are\n            u_reserved_pilot = \\\n                [i for i in p['J^Reserved'] if\n                 p['cadet_preferences'][i][len(p['J^Reserved'][i]) - 1] == j_pilot_u and p['usafa'][i]]\n            num_reserved_u_pilot = len(u_reserved_pilot)\n\n            # We also need the number of hard alternates for USAFA pilot\n            u_hard_alternates_pilot = [i for i, j in p['J^Alternates (Hard)'].items() if j == j_pilot_u]\n            num_hard_alternates_u_pilot = len(u_hard_alternates_pilot)\n\n            # The number of potential additions for ROTC pilot is going to be the total number of resered USAFA slots\n            num_additions_rotc_pilot = num_reserved_u_pilot - num_hard_alternates_u_pilot  # minus hard alternates\n\n        else:\n            num_additions_rotc_pilot = 0\n        p = augment_rated_algorithm_results(p, soc=soc, printing=instance.mdl_p['alternate_list_iterations_printing'],\n                                            num_additions_rotc_pilot=num_additions_rotc_pilot)\n\n    # Print statement\n    if printing:\n\n        # Matched/Reserved Lists\n        print_str = \"Rated SOC Algorithm Results:\\n\"\n        for soc in upper_socs:\n            for kind in [\"Fixed\", \"Reserved\"]:\n                count = str(len([i for i in p[soc.lower() + \"_cadets\"] if i in p['J^' + kind]]))\n                print_str += soc + ' ' + kind + ' Cadets: ' + count + ', '\n        print(print_str[:-2])\n\n        # Alternate Lists\n        count_u = str(int(sum([len(p['I^Alternate [usafa]'][j]) for j in p['J^Rated']])))\n        count_r = str(int(sum([len(p['I^Alternate [rotc]'][j]) for j in p['J^Rated']])))\n        print_str = \"USAFA Rated Alternates: \" + count_u + \", ROTC Rated Alternates: \" + count_r\n        if 'ots' in socs_to_use:\n            count_o = str(int(sum([len(p['I^Alternate [ots]'][j]) for j in p['J^Rated']])))\n            print_str += \", OTS Rated Alternates: \" + count_o\n        print(print_str)\n\n    return p  # Return the parameters!\n</code></pre>"},{"location":"reference/solutions/handling/#solutions.handling.augment_rated_algorithm_results","title":"<code>augment_rated_algorithm_results(p, soc='rotc', printing=False, num_additions_rotc_pilot: int = 0)</code>","text":"<p>Analyzes the results of the Rated SOC algorithm for a specific SOC (Source of Commissioning), such as ROTC or USAFA, and augments the system's parameters. This analysis includes identifying alternates and definitively matching additional individuals to AFSCs.</p> <p>Parameters: - p (dict): The problem's parameters containing relevant data. - soc (str, optional): The SOC to analyze and augment results for. Default is 'rotc'. - printing (bool, optional): A flag to control whether to print information during execution.   Set to True to enable printing, and False to suppress it. Default is False.</p> <p>Returns: - parameters (dict): The updated parameters dictionary reflecting the rated algorithm results,   including alternates and definitively matched individuals.</p> <p>Description: This function processes the results of the Rated SOC algorithm for a specific SOC category, identifying alternates and definitively matching additional individuals to AFSCs. The primary goal is to ensure the system's parameters accurately reflect the outcomes of the algorithm, which aids in further analysis and decision-making.</p> <ul> <li>'Reserved' cadets have their AFSC selections constrained to match their reserved slots.</li> <li>'Matched' cadets are assigned specific AFSCs based on the algorithm results.</li> <li>'Alternates' are cadets who did not receive one of their top AFSC preferences but are next in line   for specific AFSCs based on the algorithm's execution. Alternates may be given preferences or   reserved slots, depending on availability.</li> </ul> <p>Note: Detailed information on the Rated SOC algorithm results is assumed to be available within the 'parameters.'</p> Source code in <code>afccp/solutions/handling.py</code> <pre><code>def augment_rated_algorithm_results(p, soc='rotc', printing=False, num_additions_rotc_pilot: int = 0):\n    \"\"\"\n    Analyzes the results of the Rated SOC algorithm for a specific SOC (Source of Commissioning),\n    such as ROTC or USAFA, and augments the system's parameters. This analysis includes identifying\n    alternates and definitively matching additional individuals to AFSCs.\n\n    Parameters:\n    - p (dict): The problem's parameters containing relevant data.\n    - soc (str, optional): The SOC to analyze and augment results for. Default is 'rotc'.\n    - printing (bool, optional): A flag to control whether to print information during execution.\n      Set to True to enable printing, and False to suppress it. Default is False.\n\n    Returns:\n    - parameters (dict): The updated parameters dictionary reflecting the rated algorithm results,\n      including alternates and definitively matched individuals.\n\n    Description:\n    This function processes the results of the Rated SOC algorithm for a specific SOC category,\n    identifying alternates and definitively matching additional individuals to AFSCs. The primary goal\n    is to ensure the system's parameters accurately reflect the outcomes of the algorithm, which\n    aids in further analysis and decision-making.\n\n    - 'Reserved' cadets have their AFSC selections constrained to match their reserved slots.\n    - 'Matched' cadets are assigned specific AFSCs based on the algorithm results.\n    - 'Alternates' are cadets who did not receive one of their top AFSC preferences but are next in line\n      for specific AFSCs based on the algorithm's execution. Alternates may be given preferences or\n      reserved slots, depending on availability.\n\n    Note: Detailed information on the Rated SOC algorithm results is assumed to be available within the 'parameters.'\n    \"\"\"\n\n    # Start with a full list of cadets eligible for each AFSC from this SOC\n    possible_cadets = {j: list(np.intersect1d(p['I^E'][j], p[soc + '_cadets'])) for j in p['J^Rated']}\n\n    # Used for stopping conditions\n    last_reserves, last_matches, last_alternates_h = np.array([1000 for _ in p['J^Rated']]), \\\n                                                     np.array([1000 for _ in p['J^Rated']]), \\\n                                                     np.array([1000 for _ in p['J^Rated']])\n\n    if printing:\n        print(\"\\nSOC:\", soc.upper())\n        print()\n\n    # Main algorithm\n    iteration, iterating = 0, True\n    while iterating:\n\n        # Set of cadets reserved or matched to each AFSC\n        p['I^Reserved'] = {j: np.array([i for i in p['J^Reserved'] if p['cadet_preferences'][i][\n            len(p['J^Reserved'][i]) - 1] == j and p[soc][i]]) for j in p['J^Rated']}\n        p['I^Matched'] = {j: np.array([\n            i for i in p['J^Fixed'] if j == p['J^Fixed'][i] and p[soc][i]]) for j in p['J^Rated']}\n\n        # Number of alternates (number of reserved slots)\n        num_reserved = {j: len(p['I^Reserved'][j]) for j in p['J^Rated']}\n\n        # Need to determine who falls into each category of alternates\n        hard_alternates = {j: [] for j in p['J^Rated']}\n        soft_r_alternates = {j: [] for j in p['J^Rated']}\n        soft_n_alternates = {j: [] for j in p['J^Rated']}\n        alternates = {j: [] for j in p['J^Rated']}  # all the cadets ordered here\n\n        # Loop through each rated AFSC to determine alternates\n        for j in p['J^Rated']:\n\n            # We may want to increase the length of ROTC pilot alternate list to account for USAFA\n            if j == '11XX_R':\n                num_additions = copy.deepcopy(num_additions_rotc_pilot)\n            else:\n                num_additions = 0\n\n            # Loop through each cadet in order of the AFSC's preference from this SOC\n            for i in p['afsc_preferences'][j]:\n                if not p[soc][i]:\n                    continue\n\n                # Assume this cadet is \"next in line\" until proven otherwise\n                next_in_line = True\n\n                # Is the cadet already fixed to something else?\n                if i in p['J^Fixed']:\n                    next_in_line = False\n                    if i in possible_cadets[j]:\n                        possible_cadets[j].remove(i)\n\n                # Is this cadet reserved for something?\n                if i in p['J^Reserved']:\n\n                    # If they're already reserved for this AFSC or something better, they're not considered\n                    if len(p['J^Reserved'][i]) &lt;= p['c_pref_matrix'][i, j]:\n                        next_in_line = False\n                        if i in possible_cadets[j]:\n                            possible_cadets[j].remove(i)\n\n                # If this cadet is next in line (and we still have alternates to assign)\n                if next_in_line and len(hard_alternates[j]) &lt; (num_reserved[j] + num_additions):\n                    alternates[j].append(i)\n\n                    # Loop through the cadet's preferences:\n                    for j_c in p['cadet_preferences'][i]:\n\n                        # Determine what kind of alternate this cadet is\n                        if j_c == j:  # Hard Rated Alternate\n                            hard_alternates[j].append(i)\n                            break\n                        elif j_c in p['J^Rated']:\n                            if i in possible_cadets[j_c]:  # Soft Rated Alternate\n                                soft_r_alternates[j].append(i)\n                                break\n                            else:  # Can't be matched, go to next preference\n                                continue\n                        else:  # Soft Non-Rated Alternate\n                            soft_n_alternates[j].append(i)\n                            break\n\n                # We've run out of hard alternates to assign (thus, we're done assigning alternates)\n                elif len(hard_alternates[j]) &gt;= (num_reserved[j] + num_additions):\n                    if i in possible_cadets[j]:\n                        possible_cadets[j].remove(i)\n\n        # Loop through each rated AFSC to potentially turn \"reserved\" slots into \"matched\" slots\n        for j in p['J^Rated']:\n\n            # Loop through each cadet in order of the AFSC's preference from this SOC\n            for i in p['afsc_preferences'][j]:\n                if not p[soc][i]:\n                    continue\n\n                # Does this cadet have a reserved slot for something?\n                if i in p['J^Reserved']:\n\n                    # Is this cadet reserved for this AFSC?\n                    if len(p['J^Reserved'][i]) == p['c_pref_matrix'][i, j]:\n\n                        # Determine if there's any possible way this cadet might not be matched to this AFSC\n                        inevitable_match = True\n                        for j_c in p['J^Reserved'][i][:-1]:\n                            if j_c not in p['J^Rated']:\n                                inevitable_match = False\n                            else:  # Rated\n                                if i in alternates[j_c]:\n                                    inevitable_match = False\n                                else:\n                                    if i in possible_cadets[j_c]:\n                                        possible_cadets[j_c].remove(i)  # Remove this cadet as a possibility!\n\n                        # If still inevitable, change from reserved to fixed\n                        if inevitable_match:\n                            p['J^Fixed'][i] = j\n                            p['J^Reserved'].pop(i)\n\n                # This cadet cannot receive this AFSC\n                if i not in alternates[j] and i in possible_cadets[j]:\n                    possible_cadets[j].remove(i)\n\n        # Print Statement\n        if printing:\n            print(\"Iteration\", iteration)\n            print(\"Possible\", {p['afscs'][j]: len(possible_cadets[j]) for j in p['J^Rated']})\n            print(\"Matched\", {p['afscs'][j]: len(p['I^Matched'][j]) for j in p['J^Rated']})\n            print(\"Reserved\", {p['afscs'][j]: len(p['I^Reserved'][j]) for j in p['J^Rated']})\n            print(\"Alternates (Hard)\", {p['afscs'][j]: len(hard_alternates[j]) for j in p['J^Rated']})\n            print(\"Alternates (Soft)\", {p['afscs'][j]: len(soft_n_alternates[j]) +\n                                                       len(soft_r_alternates[j]) for j in p['J^Rated']})\n\n        # Once we stop changing from the algorithm, we're done!\n        current_matched = np.array([len(p['I^Matched'][j]) for j in p['J^Rated']])\n        current_reserved = np.array([len(p['I^Reserved'][j]) for j in p['J^Rated']])\n        current_alternates_h = np.array([len(hard_alternates[j]) for j in p['J^Rated']])\n        if np.sum(current_matched - last_matches + current_reserved -\n                  last_reserves + current_alternates_h - last_alternates_h) == 0:\n            iterating = False\n        else:\n            last_matches, last_reserves, last_alternates_h = current_matched, current_reserved, current_alternates_h\n\n        # Next iteration\n        iteration += 1\n\n    # Incorporate alternate lists (broken down by Hard/Soft)\n    if 'J^Alternates (Hard)' not in p:\n        p['J^Alternates (Hard)'] = {}\n    if 'J^Alternates (Soft)' not in p:\n        p['J^Alternates (Soft)'] = {}\n    for i in p['Rated Cadets'][soc]:  # Loop through all rated cadets\n        for j in p['Rated Choices'][soc][i]:  # Loop through rated preferences in order\n            if i in hard_alternates[j]:\n                p['J^Alternates (Hard)'][i] = j\n            elif i in soft_r_alternates[j] or i in soft_n_alternates[j]:\n                p['J^Alternates (Soft)'][i] = j\n                break # Next cadet\n\n    # Alternate List Optimization Formulation Sets Needed\n    p['J^Preferred [' + soc + ']'], p['I^Preferred [' + soc + ']'], p['I^Alternate [' + soc + ']'] = {}, {}, {}\n    for j in p['J^Rated']:\n\n        # Empty sets for each AFSC\n        p['I^Alternate [' + soc + ']'][j] = []\n        p['I^Preferred [' + soc + ']'][j] = {}\n        p['J^Preferred [' + soc + ']'][j] = {}\n\n        # Loop through each cadet in order of the AFSC's preference\n        for i in p['afsc_preferences'][j]:\n\n            # Where this cadet ranked this AFSC\n            cadet_rank_afsc = np.where(p['cadet_preferences'][i] == j)[0][0]\n\n            # Set of more preferred AFSCs (including this AFSC too) for this cadet\n            p['J^Preferred [' + soc + ']'][j][i] = p['cadet_preferences'][i][:cadet_rank_afsc + 1]\n\n            # Where this AFSC ranked this cadet\n            afsc_rank_cadet = np.where(p['afsc_preferences'][j] == i)[0][0]\n\n            # Set of more preferred cadets (including this cadet too) for this AFSC\n            p['I^Preferred [' + soc + ']'][j][i] = np.intersect1d(\n                p['afsc_preferences'][j][:afsc_rank_cadet + 1], p[soc + '_cadets'])\n\n            # Is this cadet an alternate from this SOC?\n            if i in p[soc + '_cadets'] and (i in p['J^Alternates (Hard)'] or i in p['J^Alternates (Soft)']):\n\n                # This cadet needs to be an alternate specifically for this AFSC\n                alternate = False\n                if i in p['J^Alternates (Hard)']:\n                    if p['J^Alternates (Hard)'][i] == j:\n                        alternate = True\n                elif i in p['J^Alternates (Soft)']:\n                    if p['J^Alternates (Soft)'][i] == j:\n                        alternate = True\n                if not alternate:\n                    continue\n\n                # Add the cadet to the alternate list for this AFSC\n                p['I^Alternate [' + soc + ']'][j].append(i)\n\n        # Convert to numpy array\n        p['I^Alternate [' + soc + ']'][j] = np.array(p['I^Alternate [' + soc + ']'][j])\n\n    # Return updated parameters (and alternate lists)\n    return p\n</code></pre>"},{"location":"reference/solutions/optimization/","title":"Optimization","text":""},{"location":"reference/solutions/optimization/#solutions.optimization","title":"<code>solutions.optimization</code>","text":""},{"location":"reference/solutions/optimization/#solutions.optimization.assignment_model_build","title":"<code>assignment_model_build(instance, printing=False)</code>","text":"<p>Converts the parameters and value parameters to the pyomo data structure</p> <p>Parameters:     instance (object): Problem instance object     printing (bool, optional): Whether the procedure should print something. Default is False.</p> <p>Returns:     pyomo data: Pyomo data representing the converted model</p> <p>Description:     This function builds a Pyomo model based on the provided problem instance. It converts the parameters and value     parameters into the Pyomo data structure and constructs the objective function and constraints of the model.</p> <pre><code>The function takes a problem instance object as input, which contains the necessary parameters and value parameters\nfor building the model. The `printing` parameter controls whether the procedure should print progress information\nduring model construction.\n\nThe utility/cost matrix is computed based on the parameters and value parameters. The AFSC preferences, merit,\nand eligibility information are used to calculate the cost values for each cadet-AFSC pair in the matrix.\n\nThe model is built using the Pyomo `ConcreteModel` class. The variables, objective function, and constraints\nare defined within the model.\n\nThe objective function is defined as the sum of the cost values multiplied by the corresponding decision variable\nfor each cadet-AFSC pair.\n\nThe constraints include ensuring that each cadet is assigned to exactly one AFSC, limiting the percentage of\nUSAFA cadets in certain AFSCs, and applying AFSC objective measure constraints if specified.\n\nIf `printing` is set to True, the function prints progress information during the model construction.\n\nFinally, the constructed model is returned.\n</code></pre> <p>Example:     instance = ProblemInstance()     model = assignment_model_build(instance, printing=True)     ...</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def assignment_model_build(instance, printing=False):\n    \"\"\"\n    Converts the parameters and value parameters to the pyomo data structure\n\n    Parameters:\n        instance (object): Problem instance object\n        printing (bool, optional): Whether the procedure should print something. Default is False.\n\n    Returns:\n        pyomo data: Pyomo data representing the converted model\n\n    Description:\n        This function builds a Pyomo model based on the provided problem instance. It converts the parameters and value\n        parameters into the Pyomo data structure and constructs the objective function and constraints of the model.\n\n        The function takes a problem instance object as input, which contains the necessary parameters and value parameters\n        for building the model. The `printing` parameter controls whether the procedure should print progress information\n        during model construction.\n\n        The utility/cost matrix is computed based on the parameters and value parameters. The AFSC preferences, merit,\n        and eligibility information are used to calculate the cost values for each cadet-AFSC pair in the matrix.\n\n        The model is built using the Pyomo `ConcreteModel` class. The variables, objective function, and constraints\n        are defined within the model.\n\n        The objective function is defined as the sum of the cost values multiplied by the corresponding decision variable\n        for each cadet-AFSC pair.\n\n        The constraints include ensuring that each cadet is assigned to exactly one AFSC, limiting the percentage of\n        USAFA cadets in certain AFSCs, and applying AFSC objective measure constraints if specified.\n\n        If `printing` is set to True, the function prints progress information during the model construction.\n\n        Finally, the constructed model is returned.\n\n    Example:\n        instance = ProblemInstance()\n        model = assignment_model_build(instance, printing=True)\n        ...\n    \"\"\"\n\n    # Shorthand\n    p, vp, mdl_p = instance.parameters, instance.value_parameters, instance.mdl_p\n\n    # *New* Utility/\"Cost\" Matrix based on CFM preferences and cadet preferences (GUO model)\n    if mdl_p['assignment_model_obj'] == 'Global Utility':\n        c = vp['global_utility']\n\n        if printing:\n            print(\"Building assignment problem (GUO) model...\")\n\n    # Original Model Utility/\"Cost\" Matrix  (Original model)\n    else:  # This is the \"legacy\" AFPC model!\n\n        if printing:\n            print(\"Building original assignment problem model...\")\n\n        c = np.zeros([p['N'], p['M']])\n        for i in p['I']:\n            for j in p['J^E'][i]:  # Only looping through AFSCs that the cadet is eligible for\n\n                # If AFSC j is a preference for cadet i\n                if p['cadet_utility'][i, j] &gt; 0:\n\n                    if p['mandatory'][i, j] == 1:\n                        c[i, j] = 10 * p['merit'][i] * p['cadet_utility'][i, j] + 250\n                    elif p['desired'][i, j] == 1:\n                        c[i, j] = 10 * p['merit'][i] * p['cadet_utility'][i, j] + 150\n                    else:  # Permitted, though it could also be an \"exception\"\n                        c[i, j] = 10 * p['merit'][i] * p['cadet_utility'][i, j]\n\n                # If it is not a preference for cadet i\n                else:\n\n                    if p['mandatory'][i, j] == 1:\n                        c[i, j] = 100 * p['merit'][i]\n                    elif p['desired'][i, j] == 1:\n                        c[i, j] = 50 * p['merit'][i]\n                    else:  # Permitted, though it could also be an \"exception\"\n                        c[i, j] = 0\n\n    # Build Model\n    m = ConcreteModel()\n\n    # ___________________________________VARIABLE DEFINITION_________________________________\n    m = common_optimization_handling(m, p, vp, mdl_p)  # Define x along with additional functional constraints\n\n    # Base/Training model extra components\n    if mdl_p['solve_extra_components']:\n        m = base_training_model_handling(m, p, mdl_p)\n\n    # Initialize CASTLE value curve variables\n    if mdl_p['solve_castle_guo']:\n        m = initialize_castle_value_curve_function_variables(m, p, q=p['castle_q'])\n\n    # ___________________________________OBJECTIVE FUNCTION__________________________________\n    m.objective = assignment_model_objective_function_definition(m=m, p=p, vp=vp, mdl_p=mdl_p, c=c)\n\n    # ________________________________________CONSTRAINTS_____________________________________\n    m.measure_constraints = ConstraintList()  # AFSC Objective Measure Constraints (Optional decision-maker constraints)\n\n    # Incorporate CASTLE value curve functional constraints\n    if mdl_p['solve_castle_guo']:\n        m = initialize_value_function_constraint_lists(m)\n\n        # Loop through each CASTLE AFSC to add the constraints\n        for castle_afsc, j_indices in p['J^CASTLE'].items():\n\n            # Get the number of people assigned to each AFSC under this \"CASTLE\" AFSC umbrella (+ ADD OTS!!)\n            if 'ots' in p['SOCs']:  # If OTS is in the model, we don't have to account for them\n                measure = np.sum(np.sum(m.x[i, j] for i in p['I^E'][j]) for j in j_indices)\n            else:  # If we are not matching OTS, we have to account for them\n                measure = np.sum(np.sum(m.x[i, j] for i in p['I^E'][j]) for j in j_indices) + p['ots_counts'][\n                    castle_afsc]\n\n            # Add the value curve constraints for this \"CASTLE\" AFSC\n            m = add_castle_value_curve_function_constraints(m, measure, afsc=castle_afsc, q=p['castle_q'])\n\n    # Loop through all AFSCs to add AFSC objective measure constraints\n    for j in p['J']:\n\n        # Loop through all constrained AFSC objectives\n        for k in vp['K^C'][j]:\n            # Calculate AFSC objective measure components\n            measure, numerator = afccp.solutions.handling.calculate_objective_measure_matrix(\n                m.x, j, vp['objectives'][k], p, vp, approximate=True)\n\n            # Add AFSC objective measure constraint\n            m = add_objective_measure_constraint(m, j, k, measure, numerator, p, vp)\n\n    if printing:\n        print(\"Done. Solving model...\")\n\n    if mdl_p['usafa_soc_pilot_cross_in']:\n        j = np.where(p['afscs'] == '11XX_U')[0][0]\n        k = np.where(vp['objectives'] == 'Combined Quota')[0][0]\n        if (vp[\"objective_min\"][j, k] == vp[\"objective_max\"][j, k]) and vp['constraint_type'][j, k] != 0:\n            print(\"*****************WARNING**********************\",\n                  \"\\nModel designated to allow USAFA Pilot cross-flows but constraints are still activated that\"\n                  \" would prevent this.\\nEnsure you turn off the USAFA/ROTC pilot quota\",\n                  f\"constraints in '{instance.data_name} VP.csv'\")\n\n    return m  # Return model\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.vft_model_build","title":"<code>vft_model_build(instance, printing=False)</code>","text":"<p>Builds the VFT optimization model using pyomo.</p> <p>Parameters:     instance (object): Problem instance object.     printing (bool): Whether the procedure should print something. Default is False.</p> <p>Returns:     object: Pyomo model object.</p> <p>This function builds the VFT (Value Focused Thinking) optimization model using the Pyomo library. It takes a problem instance as input and returns the constructed model.</p> <p>The function performs the following steps: 1. Initializes the Pyomo model. 2. Adjusts certain parameters used in the model. 3. Defines and initializes the decision variables of the model. 4. Defines the objective function of the model. 5. Defines the constraints of the model.</p> <p>Parameter Adjustments: The function adjusts certain parameters related to the value function breakpoints and sets. These adjustments are necessary to account for the approximate model's capability of exceeding the normal domain. The adjusted parameters are stored in a new dictionary called 'q' for use in the model.</p> <p>Variable Definitions: The function defines the decision variables used in the model, including 'x' (main decision variable), 'f_value' (AFSC objective value), 'lam' (lambda and y variables for value functions), and 'y' (binary variable for line segments between breakpoints).</p> <p>Variable Adjustments: This function initializes the variables defined above if applicable (warm start has been determined) and fixes certain 'x' variables if necessary/applicable.</p> <p>Objective Function: The objective function of the model is to maximize the overall weighted sum of all VFT objectives. It combines the AFSC objective values and the cadet utility values based on their respective weights.</p> <p>Constraints: The function defines various constraints for the model, including the constraint that each cadet receives one and only one AFSC, the 5% cap on the total percentage of USAFA cadets allowed into certain AFSCs, the value function constraints linking the main methodology with the value function methodology, and optional decision-maker constraints.</p> <p>AFSC Objective Measure Constraints: The function adds AFSC objective measure constraints for each AFSC and objective. It calculates the objective measure components and adds linear value function constraints based on the measure and value functions.</p> <p>AFSC Value Constraints: Optional decision-maker constraints can be added to enforce minimum AFSC objective values. The function adds constraints to ensure that the weighted sum of AFSC objective values meets the specified minimum value for each AFSC.</p> <p>Cadet Value Constraints: Optional decision-maker constraints can be added to enforce minimum cadet utility values. The function adds constraints to ensure that the weighted sum of cadet utility values meets the specified minimum value for each cadet.</p> <p>AFSCs Overall Min Value Constraint: If a minimum overall value for AFSCs is specified, the function adds a constraint to ensure that the weighted sum of AFSC objective values meets the specified minimum value for all AFSCs.</p> <p>Note: The function assumes the availability of additional helper functions, such as 'add_objective_measure_constraint', which are used to add specific types of constraints to the model.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def vft_model_build(instance, printing=False):\n    \"\"\"\n    Builds the VFT optimization model using pyomo.\n\n    Parameters:\n        instance (object): Problem instance object.\n        printing (bool): Whether the procedure should print something. Default is False.\n\n    Returns:\n        object: Pyomo model object.\n\n    This function builds the VFT (Value Focused Thinking) optimization model using the Pyomo library. It takes a\n    problem instance as input and returns the constructed model.\n\n    The function performs the following steps:\n    1. Initializes the Pyomo model.\n    2. Adjusts certain parameters used in the model.\n    3. Defines and initializes the decision variables of the model.\n    4. Defines the objective function of the model.\n    5. Defines the constraints of the model.\n\n    Parameter Adjustments:\n    The function adjusts certain parameters related to the value function breakpoints and sets. These adjustments are\n    necessary to account for the approximate model's capability of exceeding the normal domain. The adjusted parameters\n    are stored in a new dictionary called 'q' for use in the model.\n\n    Variable Definitions:\n    The function defines the decision variables used in the model, including 'x' (main decision variable), 'f_value'\n    (AFSC objective value), 'lam' (lambda and y variables for value functions), and 'y' (binary variable for line\n    segments between breakpoints).\n\n    Variable Adjustments:\n    This function initializes the variables defined above if applicable (warm start has been determined) and fixes\n    certain 'x' variables if necessary/applicable.\n\n    Objective Function:\n    The objective function of the model is to maximize the overall weighted sum of all VFT objectives. It combines the\n    AFSC objective values and the cadet utility values based on their respective weights.\n\n    Constraints:\n    The function defines various constraints for the model, including the constraint that each cadet receives one and\n    only one AFSC, the 5% cap on the total percentage of USAFA cadets allowed into certain AFSCs, the value function\n    constraints linking the main methodology with the value function methodology, and optional decision-maker\n    constraints.\n\n    AFSC Objective Measure Constraints:\n    The function adds AFSC objective measure constraints for each AFSC and objective. It calculates the objective measure\n    components and adds linear value function constraints based on the measure and value functions.\n\n    AFSC Value Constraints:\n    Optional decision-maker constraints can be added to enforce minimum AFSC objective values. The function adds\n    constraints to ensure that the weighted sum of AFSC objective values meets the specified minimum value for each AFSC.\n\n    Cadet Value Constraints:\n    Optional decision-maker constraints can be added to enforce minimum cadet utility values. The function adds\n    constraints to ensure that the weighted sum of cadet utility values meets the specified minimum value for each cadet.\n\n    AFSCs Overall Min Value Constraint:\n    If a minimum overall value for AFSCs is specified, the function adds a constraint to ensure that the weighted sum of\n    AFSC objective values meets the specified minimum value for all AFSCs.\n\n    Note: The function assumes the availability of additional helper functions, such as 'add_objective_measure_constraint',\n    which are used to add specific types of constraints to the model.\n\n    \"\"\"\n\n    if printing:\n        print('Building VFT Model...')\n\n    # Build Model\n    m = ConcreteModel()\n\n    # Shorthand\n    p, vp, mdl_p = instance.parameters, instance.value_parameters, instance.mdl_p\n\n    # _________________________________PARAMETER ADJUSTMENTS_________________________________\n    def adjust_parameters():\n        \"\"\"\n        Function defined here to adjust certain parameters. The parameters adjusted here are the value function\n        breakpoint parameters (r, a, f^hat) and set (L) as well as the AFSC objective constraint min, max values since\n        they've been stored as strings (3, 6, for example) up until this point. These parameters are saved into a new\n        dictionary \"q\" for use in the model. This is done because the value function breakpoints need to be adjusted\n        due to the approximate model's capability of exceeding the normal domain, and I don't want it saved to \"vp\"\n        \"\"\"\n        # Written here, so I can reference it below (Keys \"r\" and \"L\" both use this)\n        r = [[len(vp['a'][j][k]) for k in vp['K']] for j in p['J']]\n\n        # New dictionary of parameters used in this main function (\"vft_model_build\") and in \"vft_model_solve\"\n        q = {\"r\": r,  # Number of breakpoints (bps) for objective k's function for AFSC j\n             \"L\": [[list(range(r[j][k])) for k in vp['K']] for j in p['J']],  # Set of breakpoints\n             \"a\": [[[vp['a'][j][k][l] for l in vp['L'][j][k]] for k in vp['K']] for j in p['J']],  # Measures of bps\n             \"f^hat\": [[[vp['f^hat'][j][k][l] for l in vp['L'][j][k]] for k in vp['K']] for j in\n                       p['J']]}  # Values of bps\n\n        # Loop through each AFSC\n        for j in p['J']:\n\n            # Loop through each objective for each AFSC\n            for k in vp['K^A'][j]:\n\n                # We need to add an extra breakpoint to effectively extend the domain\n                if instance.mdl_p[\"add_breakpoints\"]:\n                    # We add an extra breakpoint far along the x-axis with the same y value as the previous one\n                    last_a = q[\"a\"][j][k][q['r'][j][k] - 1]\n                    last_f = q[\"f^hat\"][j][k][q['r'][j][k] - 1]\n                    q[\"a\"][j][k].append(last_a * 2000)  # arbitrarily large number in the domain (x-space)\n                    q[\"f^hat\"][j][k].append(last_f)  # same AFSC objective \"y-value\" as previous one\n                    q[\"L\"][j][k].append(q['r'][j][k])  # add the new breakpoint index\n                    q['r'][j][k] += 1  # increase number of breakpoints by 1\n\n        # Convert to numpy arrays of lists\n        for key in [\"L\", \"r\", \"a\", \"f^hat\"]:\n            q[key] = np.array(q[key])\n\n        return q  # Return the new dictionary\n\n    q = adjust_parameters()  # Call the function\n\n    # _________________________________VARIABLE DEFINITIONS_________________________________\n    m = common_optimization_handling(m, p, vp, mdl_p)  # Define x along with additional functional constraints\n    m.f_value = Var(((j, k) for j in p['J'] for k in vp['K^A'][j]), within=NonNegativeReals)  # AFSC objective value\n    m.lam = Var(((j, k, l) for j in p['J'] for k in vp['K^A'][j] for l in q['L'][j, k]),\n                within=NonNegativeReals, bounds=(0, 1))  # Lambda and y variables for value functions\n    m.y = Var(((j, k, l) for j in p['J'] for k in vp['K^A'][j] for l in range(q['r'][j, k] - 1)), within=Binary)\n\n    def variable_adjustments(m):\n        \"\"\"\n        This function initializes the 4 variables defined above if applicable (warm start has been determined) and also\n        fixes certain x variables if necessary/applicable as well.\n        \"\"\"\n\n        # If we initialize variables\n        if instance.mdl_p[\"warm_start\"] is not None:\n\n            # For each cadet, for each AFSC that the cadet is eligible\n            for i in p['I']:\n                for j in p['J^E'][i]:\n                    # x: 1 if we assign cadet i to AFSC j; 0 otherwise\n                    m.x[i, j] = round(instance.mdl_p[\"warm_start\"]['x'][i, j])\n\n            # Loop through each AFSC objective for each AFSC\n            for j in p['J']:\n                for k in vp['K^A'][j]:\n\n                    # Value for AFSC j objective k  (Used in Constraint 20b in VFT thesis)\n                    m.f_value[j, k] = instance.mdl_p[\"warm_start\"]['f(measure)'][j, k]\n\n                    # Loop through each breakpoint for this AFSC objective value function\n                    for l in q['L'][j, k]:\n\n                        # % between breakpoint l and l + 1 that the measure for AFSC j objective k \"has yet to travel\"\n                        m.lam[j, k, l] = instance.mdl_p[\"warm_start\"]['lambda'][j, k, l]\n\n                        # There is one less \"y\" variable than lambda because this is for the line segments between bps\n                        if l &lt; q['r'][j, k] - 1:\n                            # 1 if AFSC j objective measure k is on line segment between breakpoints l and l + 1; 0 o/w\n                            m.y[j, k, l] = instance.mdl_p[\"warm_start\"]['y'][j, k, l]\n\n        # Return model (m)\n        return m\n\n    m = variable_adjustments(m)  # Call the function\n\n    # _________________________________OBJECTIVE FUNCTION_________________________________\n    if mdl_p['solve_extra_components']:\n\n        # Base/Training model extra components\n        m = base_training_model_handling(m, p, mdl_p)\n\n        def objective_function(m):  # Z^VFT (w/base/training revision on cadet_value)\n            \"\"\"\n            The objective function is to maximize \"Z\", the overall weighted sum of all VFT objectives\n            \"\"\"\n            return vp['afscs_overall_weight'] * np.sum(vp['afsc_weight'][j] * np.sum(\n                vp['objective_weight'][j, k] * m.f_value[j, k] for k in vp['K^A'][j]) for j in p['J']) + \\\n                   vp['cadets_overall_weight'] * np.sum(vp['cadet_weight'][i] * m.cadet_value[i] for i in p['I'])\n\n    else:\n\n        # AFSC-only objective function\n        def objective_function(m):  # Z^VFT (Definition of variable in written formulation)\n            \"\"\"\n            The objective function is to maximize \"Z\", the overall weighted sum of all VFT objectives\n            \"\"\"\n            return vp['afscs_overall_weight'] * np.sum(vp['afsc_weight'][j] * np.sum(\n                vp['objective_weight'][j, k] * m.f_value[j, k] for k in vp['K^A'][j]) for j in p['J']) + \\\n                   vp['cadets_overall_weight'] * np.sum(vp['cadet_weight'][i] * np.sum(\n                p['cadet_utility'][i, j] * m.x[i, j] for j in p['J^E'][i]) for i in p['I'])\n\n    m.objective = Objective(rule=objective_function, sense=maximize)\n\n    # ____________________________________CONSTRAINTS_____________________________________\n    pass  # Here so pycharm doesn't yell at me for the constraint line above\n\n    # Value Function Constraints: Linking main methodology with value function methodology...\n    m = initialize_value_function_constraint_lists(m)  # ...and then enforcing that methodology\n\n    # AFSC Value Constraints (Optional decision-maker constraints)\n    m.min_afsc_value_constraints = ConstraintList()\n\n    # AFSC Objective Measure Constraints (Optional decision-maker constraints)\n    m.measure_constraints = ConstraintList()\n\n    # Loop through all AFSCs to add AFSC objective measure constraints\n    for j in p['J']:\n\n        # Loop through all AFSC objectives\n        for k, objective in enumerate(vp['objectives']):\n\n            # Add AFSC objective measure value function \"functional\" constraints\n            if k in vp['K^A'][j]:\n\n                # Calculate AFSC objective measure components\n                measure, numerator = afccp.solutions.handling.calculate_objective_measure_matrix(\n                    m.x, j, objective, p, vp, approximate=instance.mdl_p['approximate'])\n\n                # Add Value Function constraints (for functionality)\n                m = add_objective_value_function_constraints(m, j, k, measure, q=q)\n\n                # Add AFSC objective measure constraint\n                if k in vp['K^C'][j]:\n                    m = add_objective_measure_constraint(m, j, k, measure, numerator, p, vp)\n\n        # AFSC value constraint\n        if vp['afsc_value_min'][j] != 0:\n            m.min_afsc_value_constraints.add(expr=np.sum(\n                vp['objective_weight'][j, k] * m.f_value[j, k] for k in vp['K^A'][j]) &gt;= vp['afsc_value_min'][j])\n\n    # AFSCs Overall Min Value\n    def afsc_min_value_constraint(m):\n        return vp['afscs_overall_value_min'] &lt;= np.sum(vp['afsc_weight'][j] * np.sum(\n            vp['objective_weight'][j, k] * m.f_value[j, k] for k in vp['K^A'][j]) for j in p['J'])\n\n    if vp['afscs_overall_value_min'] != 0:\n        m.afsc_min_value_constraint = Constraint(rule=afsc_min_value_constraint)\n\n    # Cadets Overall Min Value\n    def cadet_min_value_constraint(m):\n        return vp['cadets_overall_value_min'] &lt;= np.sum(vp['cadet_weight'][i] * np.sum(\n            p['cadet_utility'][i, j] * m.x[i, j] for j in p['J^E'][i]) for i in p['I'])\n\n    if vp['cadets_overall_value_min'] != 0:\n        m.cadet_min_value_constraint = Constraint(rule=cadet_min_value_constraint)\n\n    return m, q  # Return model and additional component dictionary\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.gp_model_build","title":"<code>gp_model_build(instance, printing=False)</code>","text":"<p>Builds Rebecca's goal programming (GP) model using the provided problem instance.</p> <p>Args:     instance (object): The problem instance to solve.     printing (bool, optional): Specifies whether to print status updates during model building. Default is False.</p> <p>Returns:     pyomo.core.base.PyomoModel.ConcreteModel: The constructed Pyomo model.</p> <p>Raises:     None</p> <p>Detailed Description:     This function builds the GP model according to Rebecca's goal programming formulation using the provided problem instance.     The model incorporates Rebecca's parameters and constructs the necessary variables, objective function, and constraints.</p> <pre><code>The function iterates over each constraint and AFSC to create the decision variables, penalty variables, and reward variables.\nIt defines the main objective function that represents the overall goal programming problem.\nAdditionally, it defines penalty and reward specific objective functions to obtain raw penalties and rewards.\n\nThe function also constructs various constraints related to AFSC assignments, penalty terms, and reward terms.\n</code></pre> <p>Parameter Details:     - instance (object): The problem instance to solve. It should contain the following attributes:         - gp_parameters (dict): The GP parameters, including the constraint terms, utility values, and sets.         - mdl_p (dict): Additional model parameters, including the current constraint term and the reward/penalty flag.     - printing (bool, optional): Specifies whether to print status updates during model building. Default is False.</p> <p>Returns:     - model (pyomo.core.base.PyomoModel.ConcreteModel): The constructed Pyomo model representing the GP problem.</p> <p>Note:     The function assumes that the necessary libraries and packages (such as NumPy) are imported.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def gp_model_build(instance, printing=False):\n    \"\"\"\n    Builds Rebecca's goal programming (GP) model using the provided problem instance.\n\n    Args:\n        instance (object): The problem instance to solve.\n        printing (bool, optional): Specifies whether to print status updates during model building. Default is False.\n\n    Returns:\n        pyomo.core.base.PyomoModel.ConcreteModel: The constructed Pyomo model.\n\n    Raises:\n        None\n\n    Detailed Description:\n        This function builds the GP model according to Rebecca's goal programming formulation using the provided problem instance.\n        The model incorporates Rebecca's parameters and constructs the necessary variables, objective function, and constraints.\n\n        The function iterates over each constraint and AFSC to create the decision variables, penalty variables, and reward variables.\n        It defines the main objective function that represents the overall goal programming problem.\n        Additionally, it defines penalty and reward specific objective functions to obtain raw penalties and rewards.\n\n        The function also constructs various constraints related to AFSC assignments, penalty terms, and reward terms.\n\n    Parameter Details:\n        - instance (object): The problem instance to solve. It should contain the following attributes:\n            - gp_parameters (dict): The GP parameters, including the constraint terms, utility values, and sets.\n            - mdl_p (dict): Additional model parameters, including the current constraint term and the reward/penalty flag.\n        - printing (bool, optional): Specifies whether to print status updates during model building. Default is False.\n\n    Returns:\n        - model (pyomo.core.base.PyomoModel.ConcreteModel): The constructed Pyomo model representing the GP problem.\n\n    Note:\n        The function assumes that the necessary libraries and packages (such as NumPy) are imported.\n    \"\"\"\n\n    if printing:\n        print('Building GP Model...')\n\n    # Shorthand\n    gp = instance.gp_parameters\n    mdl_p = instance.mdl_p\n\n    # Create model\n    m = ConcreteModel()\n\n    # ___________________________________VARIABLE DEFINITIONS_________________________________\n    m.x = Var(((c, a) for c in gp['C'] for a in gp['A^']['E'][c]), within=Binary)\n\n    # Amount by which the constraint is not met\n    m.Y = Var(((con, a) for con in gp['con'] for a in gp['A^'][con]), within=NonNegativeReals)\n\n    # Amount by which the constraint is exceeded\n    m.Z = Var(((con, a) for con in gp['con'] for a in gp['A^'][con]), within=NonNegativeReals)\n\n    # Binary variable indicating if Y is used (1) or if Z is used (0)\n    m.alpha = Var(((con, a) for con in gp['con'] for a in gp['A^'][con]), within=Binary)\n\n    # ___________________________________OBJECTIVE FUNCTION___________________________________\n    def main_objective_function(m):\n        return np.sum(  # Sum across each constraint\n            np.sum(  # Sum across each AFSC with that constraint\n\n                # Calculate penalties and rewards for each necessary AFSC\n                gp['lam^'][con] * m.Z[con, a] - gp['mu^'][con] * m.Y[con, a] for a in gp['A^'][con]) for con in\n            gp['con']) + gp['lam^']['S'] * np.sum(  # Sum across every cadet\n            np.sum(  # Sum across each AFSC that the cadet is both eligible for and has placed a preference on\n\n                # Calculate utility that the cadet received  (for each preferred AFSC for each constraint)\n                gp['utility'][c, a] * m.x[c, a] for a in gp['A^']['W^E'][c]) for c in gp['C'])\n\n    def penalty_objective_function(m):\n        return np.sum(m.Y[mdl_p[\"con_term\"], a] for a in gp['A^'][mdl_p[\"con_term\"]])\n\n    def reward_objective_function(m):\n        if mdl_p[\"con_term\"] == 'S':\n            return np.sum(np.sum(gp['utility'][c, a] * m.x[c, a] for a in gp['A^']['W^E'][c]) for c in gp['C'])\n        else:\n            return np.sum(m.Z[mdl_p[\"con_term\"], a] for a in gp['A^'][mdl_p[\"con_term\"]])\n\n    # Define model objective function\n    if mdl_p[\"con_term\"] is not None:  # Reward/Penalty specific objective function to get raw rewards/penalties\n        if mdl_p[\"get_reward\"]:\n            m.objective = Objective(rule=reward_objective_function, sense=maximize)\n        else:\n            m.objective = Objective(rule=penalty_objective_function, sense=maximize)\n    else:  # Regular objective function\n        m.objective = Objective(rule=main_objective_function, sense=maximize)\n\n    # ___________________________________CONSTRAINTS______________________________________\n    pass\n\n    # Each Cadet gets one AFSC for which they're eligible\n    m.one_afsc_constraints = ConstraintList()\n    for c in gp['C']:\n        m.one_afsc_constraints.add(expr=np.sum(m.x[c, a] for a in gp['A^']['E'][c]) == 1)\n\n    m.con_constraints = ConstraintList()  # List of goal constraints (Each goal constraint for each AFSC)\n    m.Y_constraints = ConstraintList()  # List of Y/alpha constraints\n    m.Z_constraints = ConstraintList()  # List of Z/alpha constraints\n\n    # Loop through each \"goal\" constraint\n    for con in gp['con']:\n\n        # Loop through all AFSCs for this constraint\n        for a in gp['A^'][con]:\n\n            # Number of cadets assigned to this AFSC\n            count = np.sum(m.x[c, a] for c in gp['C^']['E'][a])\n\n            if con in ['R_under', 'R_over']:\n\n                # Sum of percentiles of cadets assigned to this AFSC\n                con_count = np.sum(gp['merit'][c] * m.x[c, a] for c in gp['C^'][con][a])\n            else:\n\n                # Number of cadets assigned to this AFSC that pertain to this constraint\n                con_count = np.sum(m.x[c, a] for c in gp['C^'][con][a])\n\n            # Parameter for this constraint for this AFSC\n            parameter = gp['param'][con][a]\n\n            if con == 'T':\n                m.con_constraints.add(expr=count == parameter - m.Y[con, a] + m.Z[con, a])\n            elif con == 'F':\n                m.con_constraints.add(expr=count == parameter + m.Y[con, a] - m.Z[con, a])\n            elif con in ['M', 'D_under', 'W', 'U_under', 'R_under']:\n                m.con_constraints.add(expr=con_count == parameter * count - m.Y[con, a] + m.Z[con, a])\n            else:  # ('D_over', 'P', 'U_over', 'R_over')\n                m.con_constraints.add(expr=con_count == parameter * count + m.Y[con, a] - m.Z[con, a])\n\n            # Y/alpha constraint\n            m.Y_constraints.add(expr=m.Y[con, a] &lt;= gp['Big_M'] * m.alpha[con, a])\n\n            # Z/alpha constraint\n            m.Z_constraints.add(expr=m.Z[con, a] &lt;= gp['Big_M'] * (1 - m.alpha[con, a]))\n\n    # If we have AFSCs that have specified a limit on the number of USAFA cadets\n    if len(gp['A^']['U_lim']) &gt; 0:\n        # Number of USAFA cadets assigned to AFSCs that have an upper limit on USAFA cadets\n        usafa_cadet_lim_afsc_count = np.sum(np.sum(m.x[c, a] for c in gp['C^']['U'][a]) for a in gp['A^']['U_lim'])\n\n        # Overall number of cadets assigned to AFSCs that have an upper limit on USAFA cadets\n        cadet_lim_afsc_count = np.sum(np.sum(m.x[c, a] for c in gp['C^']['E'][a]) for a in gp['A^']['U_lim'])\n\n        # USAFA upper limit constraint\n        def USAFA_Limit(model):\n            return usafa_cadet_lim_afsc_count &lt;= gp['u_limit'] * cadet_lim_afsc_count\n\n        m.usafa_limit_constraint = Constraint(rule=USAFA_Limit)\n\n    if printing:\n        print('Model built.')\n    return m\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.solve_pyomo_model","title":"<code>solve_pyomo_model(instance, model, model_name, q=None, printing=False)</code>","text":"<p>Solve a Pyomo model using a specified solver.</p> <p>This function takes an instance, a Pyomo model, the model name, optional parameters (q), and a flag for printing intermediate information. It adjusts the solver settings based on the provided instance parameters, solves the model, and returns the solution.</p> <p>Args:     instance: The Pyomo instance.     model: The Pyomo model to solve.     model_name (str): The name of the model.     q (dict, optional): Optional parameters.     printing (bool, optional): Flag for printing intermediate information.</p> <p>Returns:     solution (int or tuple): The solution of the model.         - If the model name is \"GP\", returns a tuple (solution, x) where solution is an array of integers representing           the AFSCs assigned to cadets, and x is a 2D array representing the assignment matrix.         - Otherwise, returns a tuple (solution, x, warm_start), where solution is an array of integers representing           the AFSCs assigned to cadets, x is a 2D array representing the assignment matrix, and warm_start is a           dictionary containing warm start variables used for initializing the VFT Pyomo model.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def solve_pyomo_model(instance, model, model_name, q=None, printing=False):\n    \"\"\"\n    Solve a Pyomo model using a specified solver.\n\n    This function takes an instance, a Pyomo model, the model name, optional parameters (q), and a flag for printing\n    intermediate information. It adjusts the solver settings based on the provided instance parameters, solves the\n    model, and returns the solution.\n\n    Args:\n        instance: The Pyomo instance.\n        model: The Pyomo model to solve.\n        model_name (str): The name of the model.\n        q (dict, optional): Optional parameters.\n        printing (bool, optional): Flag for printing intermediate information.\n\n    Returns:\n        solution (int or tuple): The solution of the model.\n            - If the model name is \"GP\", returns a tuple (solution, x) where solution is an array of integers representing\n              the AFSCs assigned to cadets, and x is a 2D array representing the assignment matrix.\n            - Otherwise, returns a tuple (solution, x, warm_start), where solution is an array of integers representing\n              the AFSCs assigned to cadets, x is a 2D array representing the assignment matrix, and warm_start is a\n              dictionary containing warm start variables used for initializing the VFT Pyomo model.\n    \"\"\"\n\n    # Different parameters are needed based on the model\n    if model_name == 'CadetBoard':\n        b, mdl_p = instance.b, instance.b  # It's weird, I know, but this works\n        mdl_p[\"solver_name\"] = b['b_solver_name']  # Change the solver\n        mdl_p[\"pyomo_max_time\"] = b['b_pyomo_max_time']  # Set the max time\n    else:\n        p, vp, gp, mdl_p = instance.parameters, instance.value_parameters, instance.gp_parameters, instance.mdl_p\n\n        # Adjust solver if necessary\n        if not mdl_p[\"approximate\"] and model_name == \"VFT\":\n            if mdl_p[\"solver_name\"] == 'cbc':\n                mdl_p[\"solver_name\"] = 'ipopt'\n\n    # Determine how the solver is called here\n    if mdl_p[\"executable\"] is None:\n        if mdl_p[\"provide_executable\"]:\n            if mdl_p[\"exe_extension\"]:\n                mdl_p[\"executable\"] = afccp.globals.paths['solvers'] + mdl_p[\"solver_name\"] + '.exe'\n            else:\n                mdl_p[\"executable\"] = afccp.globals.paths['solvers'] + mdl_p[\"solver_name\"]\n    else:\n        mdl_p[\"provide_executable\"] = True\n\n    # Get correct solver\n    if mdl_p[\"provide_executable\"]:\n        if mdl_p[\"solver_name\"] == 'gurobi':\n            solver = SolverFactory(mdl_p[\"solver_name\"], solver_io='python', executable=mdl_p[\"executable\"])\n        else:\n            solver = SolverFactory(mdl_p[\"solver_name\"], executable=mdl_p[\"executable\"])\n    else:\n        if mdl_p[\"solver_name\"] == 'gurobi':\n            solver = SolverFactory(mdl_p[\"solver_name\"], solver_io='python')\n        else:\n            solver = SolverFactory(mdl_p[\"solver_name\"])\n\n    # Print Statement\n    if printing:\n        if model_name == \"VFT\":\n            if mdl_p[\"approximate\"]:\n                specific_model_name = \"Approximate VFT Model\"\n            else:\n                specific_model_name = \"Exact VFT Model\"\n        else:\n            specific_model_name = model_name + \" Model\"\n\n        if mdl_p['solve_extra_components']:\n            specific_model_name += \" (w/base &amp; training components)\"\n        if mdl_p['solve_castle_guo']:\n            specific_model_name += \" (w/CASTLE value curve modifications)\"\n\n        print('Solving ' + specific_model_name + ' instance with solver ' + mdl_p[\"solver_name\"] + '...')\n\n    # Solve Model\n    start_time = time.perf_counter()\n    if mdl_p[\"pyomo_max_time\"] is not None:\n        if mdl_p[\"solver_name\"] == 'mindtpy':\n            solver.solve(model, time_limit=mdl_p[\"pyomo_max_time\"]),\n            # mip_solver='cplex_persistent', nlp_solver='ipopt')\n        elif mdl_p[\"solver_name\"] == 'gurobi':\n            solver.solve(model, options={'TimeLimit': mdl_p[\"pyomo_max_time\"], 'IntFeasTol': 0.05})\n        elif mdl_p[\"solver_name\"] == 'ipopt':\n            solver.options['max_cpu_time'] = mdl_p[\"pyomo_max_time\"]\n            solver.solve(model)\n        elif mdl_p[\"solver_name\"] == 'cbc':\n            solver.options['seconds'] = mdl_p[\"pyomo_max_time\"]\n            solver.solve(model)\n        elif mdl_p[\"solver_name\"] == 'baron':\n            solver.solve(model, options={'MaxTime': mdl_p[\"pyomo_max_time\"]})\n        else:\n            solver.solve(model)\n    else:\n        if mdl_p[\"solver_name\"] == 'mindtpy':\n            model.pprint()\n            solver.solve(model, mip_solver='cplex_persistent', nlp_solver='ipopt')\n        else:\n            solver.solve(model)  # , tee=True)\n\n    # Get solve time\n    solve_time = round(time.perf_counter() - start_time, 2)\n\n    # Goal Programming Model specific actions\n    if model_name == \"GP\":\n\n        # We're \"pre-process\" solving the model for a specific GP constraint\n        if mdl_p[\"con_term\"] is not None:\n            return model.objective()\n\n        # We're actually solving the model for a solution\n        else:\n\n            # Get solution\n            solution = {\"method\": \"GP\", \"j_array\": np.zeros(gp['N']).astype(int), \"x\": np.zeros((gp['N'], gp['M']))}\n            for c in gp['C']:\n                for a in gp['A^']['E'][c]:\n                    solution['x'][c, a] = model.x[c, a].value\n                    if round(solution['x'][c, a]):\n                        solution['j_array'][c] = int(a)\n\n            if printing:\n                print('Model solved.')\n\n            return solution\n\n    # \"Cadet Board Figure\" optimization model\n    elif model_name == 'CadetBoard':\n\n        # Get the values from the model and return them\n        x, y, s = {}, {}, model.s.value\n\n        for j in b['J^translated']:\n            idx = b['J^translated'][j]\n            x[j], y[j] = model.x[idx].value, model.y[idx].value\n        return s, x, y\n\n    # VFT/Assignment Model specific actions\n    else:\n\n        # Obtain solution from the model\n        def obtain_solution():\n            \"\"\"\n            This nested function obtains the X matrix and the solution vector from the pyomo model\n            \"\"\"\n\n            # Get solution\n            solution = {\"method\": model_name, \"j_array\": np.zeros(p['N']).astype(int), \"x\": np.zeros((p['N'], p['M'])),\n                        'solve_time': solve_time, 'x_integer': True}\n\n            # Loop through each cadet to determine what AFSC they're assigned\n            for i in p['I']:\n                found = False\n                for j in p['J^E'][i]:\n                    solution['x'][i, j] = model.x[i, j].value\n                    try:\n                        if round(solution['x'][i, j]):\n                            solution['j_array'][i] = int(j)\n                            found = True\n\n                        if 0.01 &lt; solution['x'][i, j] &lt; 0.99:\n                            solution['x_integer'] = False\n                    except:\n                        raise ValueError(\"Solution didn't come out right, likely model is infeasible.\")\n\n                # For some reason we may not have assigned a cadet to an AFSC in which case we just give them to one\n                # they're eligible for and want (happens usually to only 1-3 people through VFT model)\n                if not found:\n\n                    # OTS candidates may go unmatched\n                    if 'I^OTS' in p:\n                        if i in p['I^OTS']:\n                            solution['j_array'][i] = p['M']  # Cadet assigned to \"unmatched\" AFSC!\n                            continue\n\n                    # Try to give the cadet their top choice AFSC for which they're eligible\n                    if len(p[\"J^P\"][i]) != 0:\n                        max_util = 0\n                        max_j = 0\n                        for j in p[\"J^P\"][i]:\n                            if p['cadet_utility'][i, j] &gt;= max_util:\n                                max_j = j\n                                max_util = max_util\n                        solution['j_array'][i] = int(max_j)\n\n                    # If we don't have any eligible preferences from the cadet, they get Needs of the Air Force\n                    else:\n\n                        if len(p[\"J^E\"][i]) &gt;= 2:\n                            solution['j_array'][i] = int(p[\"J^E\"][i][1])\n                        else:\n                            solution['j_array'][i] = int(p[\"J^E\"][i][0])\n\n                    afsc = p[\"afscs\"][int(solution['j_array'][i])]\n\n                    if printing:\n                        print(\"Cadet \" + str(i) + \" was not assigned by the model for some reason. \"\n                                                  \"We assigned them to\", afsc)\n\n            # Get objective value\n            solution['pyomo_obj_value'] = round(model.objective(), 4)\n            return solution\n\n        # Obtain base/training solution components from the model\n        def obtain_extra_solution_components(solution):\n            \"\"\"\n            This nested function obtains the base/training variable components from the pyomo model\n            \"\"\"\n\n            solution['b_array'] = np.zeros(p['N']).astype(int)\n            solution['c_array'] = np.array([(0, 0) for _ in p['I']])\n            solution['base_array'] = np.array([\" \" * 100 for _ in p['I']])\n            solution['course_array'] = np.array([\" \" * 100 for _ in p['I']])\n            solution['v'] = np.zeros((p['N'], p['S'])).astype(int)\n            solution['q'] = np.zeros((p['N'], p['M'], max(p['T']))).astype(int)\n            solution['cadet_value (Pyomo)'] = np.zeros(p['N'])\n            solution['v_integer'], solution['q_integer'] = True, True\n\n            # Loop through each cadet to determine what base they're assigned to\n            for i in p['I']:\n                found = False\n                for b in p['B^E'][i]:\n                    solution['v'][i, b] = model.v[i, b].value\n                    try:\n                        if round(solution['v'][i, b]):\n                            solution['b_array'][i] = int(b)\n                            found = True\n\n                        if 0.01 &lt; solution['v'][i, b] &lt; 0.99:\n                            warm_start['v_integer'] = False\n                    except:\n                        raise ValueError(\"Solution didn't come out right, likely model is infeasible.\")\n\n                if found:\n                    solution['base_array'][i] = p['bases'][solution['b_array'][i]]\n                else:  # Not matched to a base\n                    solution['base_array'][i] = \"\"\n                    solution['b_array'][i] = p['S']\n\n            # Loop through each cadet to determine what course they're assigned to\n            for i in p['I']:\n                found = False\n                for j in p['J^E'][i]:\n                    for c in p['C^E'][i][j]:\n                        solution['q'][i, j, c] = model.q[i, j, c].value\n                        try:\n                            if round(solution['q'][i, j, c]):\n                                solution['c_array'][i] = (j, c)\n                                found = True\n\n                            if 0.01 &lt; solution['q'][i, j, c] &lt; 0.99:\n                                warm_start['q_integer'] = False\n                        except:\n                            raise ValueError(\"Solution didn't come out right, likely model is infeasible.\")\n\n                if found:\n                    solution['course_array'][i] = p['courses'][solution['c_array'][i][0]][solution['c_array'][i][1]]\n                else:  # Not matched to a course\n                    print('Cadet', i, 'not matched to a course for some reason. Something went wrong.')\n\n            # Loop through each cadet to get their value from pyomo\n            for i in p['I']:\n                solution['cadet_value (Pyomo)'][i] = model.cadet_value[i].value\n\n            return solution\n\n        solution = obtain_solution()\n\n        # Base/Training Model components\n        if mdl_p['solve_extra_components']:\n            solution = obtain_extra_solution_components(solution)\n\n        # Obtain \"warm start\" variables used to initialize the VFT pyomo model\n        def obtain_warm_start_variables():\n            \"\"\"\n            This nested function obtains the variables used for the warm start (variable initialization) of the pyomo model\n            \"\"\"\n\n            # Determine maximum number of breakpoints for any particular AFSC\n            max_r = 0\n            for j in p[\"J\"]:\n                for k in vp[\"K^A\"][j]:\n                    if q[\"r\"][j][k] &gt; max_r:\n                        max_r = q[\"r\"][j][k]\n\n            # Initialize dictionary\n            warm_start = {'f(measure)': np.zeros([p['M'], vp['O']]), 'r^max': max_r + 1,\n                          'lambda': np.zeros([p['M'], vp['O'], max_r + 1]),\n                          'y': np.zeros([p['M'], vp['O'], max_r + 1]).astype(int), 'obj': model.objective(),\n                          'y_original': np.zeros([p['M'], vp['O'], max_r + 1]), 'y_integer': True}\n\n            # Load warm start variables\n            for j in p['J']:\n                for k in vp['K^A'][j]:\n                    warm_start['f(measure)'][j, k] = model.f_value[j, k].value\n                    for l in range(q['r'][j, k]):\n                        warm_start['lambda'][j, k, l] = model.lam[j, k, l].value\n                        if l &lt; q['r'][j, k] - 1:\n                            warm_start['y'][j, k, l] = round(model.y[j, k, l].value)\n                            warm_start['y_original'][j, k, l] = model.y[j, k, l].value\n                            if 0.01 &lt; warm_start['y_original'][j, k, l] &lt; 0.99:\n                                warm_start['y_integer'] = False\n\n            # Return the \"warm start\" dictionary\n            return warm_start\n\n        # Add additional components to solution dictionary\n        if mdl_p[\"obtain_warm_start_variables\"] and 'VFT' in model_name:\n            warm_start = obtain_warm_start_variables()\n            for key in warm_start:\n                solution[key] = warm_start[key]\n\n        if printing:\n            print(\"Model solved in\", solve_time, \"seconds. Pyomo reported objective value:\",\n                  solution['pyomo_obj_value'])\n\n        # Return solution dictionary\n        return solution\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.calculate_rewards_penalties","title":"<code>calculate_rewards_penalties(instance, printing=True)</code>","text":"<p>This function calculates the normalized penalties and rewards specific to an instance of Rebecca's goal programming (GP) model.</p> <p>Args:     instance (object): The problem instance to solve, which contains the GP parameters.     printing (bool, optional): Specifies whether to print status updates during the calculation. Default is True.</p> <p>Returns:     tuple: A tuple containing the normalized penalties and rewards as NumPy arrays.</p> <p>Detailed Description:     This function takes a set of Rebecca's goal programming parameters and returns the normalized penalties and     rewards specific to the given instance. The function iterates over each constraint in the GP parameters and     calculates the penalties and rewards using a GP model.</p> <pre><code>The GP model is built by initializing the necessary parameters and solving the model for each constraint.\nThe rewards are calculated by maximizing the objective function that represents the reward term, while the\npenalties are calculated by maximizing the objective function that represents the penalty term.\n\nThe function also calculates the reward term for the special constraint 'S' separately.\n</code></pre> <p>Parameter Details:     - instance (object): The problem instance to solve. It should contain the following attributes:         - gp_parameters (dict): The GP parameters, including the constraint terms, utility values, and sets.     - printing (bool, optional): Specifies whether to print status updates during the calculation. Default is True.</p> <p>Returns:     - rewards (numpy.ndarray): An array containing the normalized rewards for each constraint, including the reward     for constraint 'S'.     - penalties (numpy.ndarray): An array containing the normalized penalties for each constraint.</p> <p>Note:     The function assumes that the necessary functions 'gp_model_build' and 'solve_pyomo_model'     are defined and accessible.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def calculate_rewards_penalties(instance, printing=True):\n    \"\"\"\n    This function calculates the normalized penalties and rewards specific to an instance of\n    Rebecca's goal programming (GP) model.\n\n    Args:\n        instance (object): The problem instance to solve, which contains the GP parameters.\n        printing (bool, optional): Specifies whether to print status updates during the calculation. Default is True.\n\n    Returns:\n        tuple: A tuple containing the normalized penalties and rewards as NumPy arrays.\n\n    Detailed Description:\n        This function takes a set of Rebecca's goal programming parameters and returns the normalized penalties and\n        rewards specific to the given instance. The function iterates over each constraint in the GP parameters and\n        calculates the penalties and rewards using a GP model.\n\n        The GP model is built by initializing the necessary parameters and solving the model for each constraint.\n        The rewards are calculated by maximizing the objective function that represents the reward term, while the\n        penalties are calculated by maximizing the objective function that represents the penalty term.\n\n        The function also calculates the reward term for the special constraint 'S' separately.\n\n    Parameter Details:\n        - instance (object): The problem instance to solve. It should contain the following attributes:\n            - gp_parameters (dict): The GP parameters, including the constraint terms, utility values, and sets.\n        - printing (bool, optional): Specifies whether to print status updates during the calculation. Default is True.\n\n    Returns:\n        - rewards (numpy.ndarray): An array containing the normalized rewards for each constraint, including the reward\n        for constraint 'S'.\n        - penalties (numpy.ndarray): An array containing the normalized penalties for each constraint.\n\n    Note:\n        The function assumes that the necessary functions 'gp_model_build' and 'solve_pyomo_model'\n        are defined and accessible.\n    \"\"\"\n\n    # Shorthand\n    gp = instance.gp_parameters\n\n    # Initialize gp arrays\n    num_constraints = len(gp['con']) + 1\n    rewards = np.zeros(num_constraints)\n    penalties = np.zeros(num_constraints)\n\n    # Initialize model\n    instance.mdl_p[\"con_term\"] = gp['con'][0]  # Initialize constraint term\n    instance.mdl_p[\"get_reward\"] = True  # We want the reward term\n    instance.mdl_p[\"solve_time\"] = 60 * 4  # Don't want to be solving this thing for too long\n    model = gp_model_build(instance, printing=False)  # Build model\n\n    # Loop through each constraint\n    for c, con in enumerate(gp['con']):\n\n        # Set the constraint term\n        instance.mdl_p[\"con_term\"] = con\n\n        # Get reward term\n        def objective_function(m):\n            return np.sum(m.Z[con, a] for a in gp['A^'][con])\n\n        if printing:\n            print('')\n            print('Obtaining reward for constraint ' + con + '...')\n        model.objective = Objective(rule=objective_function, sense=maximize)\n        rewards[c] = solve_pyomo_model(instance, model, \"GP\")\n        if printing:\n            print('Reward:', rewards[c])\n\n        # Get penalty term\n        def objective_function(m):\n            return np.sum(m.Y[con, a] for a in gp['A^'][con])\n\n        if printing:\n            print('')\n            print('Obtaining penalty for constraint ' + con + '...')\n        model.objective = Objective(rule=objective_function, sense=maximize)\n        penalties[c] = solve_pyomo_model(instance, model, \"GP\")\n        if printing:\n            print('Penalty:', penalties[c])\n\n    # S reward term\n    def objective_function(m):\n        return np.sum(np.sum(gp['utility'][c, a] * m.x[c, a] for a in gp['A^']['W^E'][c]) for c in gp['C'])\n\n    if printing:\n        print('')\n        print('Obtaining reward for constraint S...')\n    model.objective = Objective(rule=objective_function, sense=maximize)\n    rewards[num_constraints - 1] = solve_pyomo_model(instance, model, \"GP\")\n    if printing:\n        print('Reward:', rewards[num_constraints - 1])\n\n    return rewards, penalties\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.initialize_value_function_constraint_lists","title":"<code>initialize_value_function_constraint_lists(m)</code>","text":"<p>Initialize constraint lists for the value function methodology.</p> <p>This function sets up empty constraint lists in the Pyomo model to enforce the relationships between the primary methodology and the value function methodology. These constraints are used later when defining the value function constraints.</p> <p>The constraint lists initialized correspond to the following formulations:</p> <ul> <li><code>measure_vf_constraints</code> (20a): Ensures the measure is computed using a weighted sum.</li> <li><code>value_vf_constraints</code> (20b): Computes the value function as a weighted sum.</li> <li><code>lambda_y_constraint1</code> (20c): Ensures the first lambda variable is bounded by y.</li> <li><code>lambda_y_constraint2</code> (20d): Ensures intermediate lambda variables are bounded by y variables.</li> <li><code>lambda_y_constraint3</code> (20e): Ensures the last lambda variable is bounded by y.</li> <li><code>y_sum_constraint</code> (20f): Ensures the y variables sum to 1.</li> <li><code>lambda_sum_constraint</code> (20g): Ensures the lambda variables sum to 1.</li> <li><code>lambda_positive</code> (20h): Enforces non-negativity on lambda variables.</li> <li><code>f_value_positive</code>: Enforces non-negativity on the AFSC objective value.</li> </ul> <p>Args:     m (ConcreteModel): The Pyomo model to which the constraint lists will be added.</p> <p>Returns:     ConcreteModel: The updated Pyomo model with initialized constraint lists.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def initialize_value_function_constraint_lists(m):\n    \"\"\"\n    Initialize constraint lists for the value function methodology.\n\n    This function sets up empty constraint lists in the Pyomo model to enforce the relationships\n    between the primary methodology and the value function methodology. These constraints\n    are used later when defining the value function constraints.\n\n    The constraint lists initialized correspond to the following formulations:\n\n    - `measure_vf_constraints` (20a): Ensures the measure is computed using a weighted sum.\n    - `value_vf_constraints` (20b): Computes the value function as a weighted sum.\n    - `lambda_y_constraint1` (20c): Ensures the first lambda variable is bounded by y.\n    - `lambda_y_constraint2` (20d): Ensures intermediate lambda variables are bounded by y variables.\n    - `lambda_y_constraint3` (20e): Ensures the last lambda variable is bounded by y.\n    - `y_sum_constraint` (20f): Ensures the y variables sum to 1.\n    - `lambda_sum_constraint` (20g): Ensures the lambda variables sum to 1.\n    - `lambda_positive` (20h): Enforces non-negativity on lambda variables.\n    - `f_value_positive`: Enforces non-negativity on the AFSC objective value.\n\n    Args:\n        m (ConcreteModel): The Pyomo model to which the constraint lists will be added.\n\n    Returns:\n        ConcreteModel: The updated Pyomo model with initialized constraint lists.\n    \"\"\"\n\n    # Value Function Constraints: Linking main methodology with value function methodology\n    m.measure_vf_constraints = ConstraintList()  # 20a in Thesis\n    m.value_vf_constraints = ConstraintList()  # 20b in Thesis\n\n    # Value Function Constraints: Functional constraints enforcing the relationship above\n    m.lambda_y_constraint1 = ConstraintList()  # 20c in Thesis\n    m.lambda_y_constraint2 = ConstraintList()  # 20d in Thesis\n    m.lambda_y_constraint3 = ConstraintList()  # 20e in Thesis\n    m.y_sum_constraint = ConstraintList()  # 20f in Thesis\n    m.lambda_sum_constraint = ConstraintList()  # 20g in Thesis\n    m.lambda_positive = ConstraintList()  # Lambda domain (20h)\n    m.f_value_positive = ConstraintList()  # AFSC objective value domain\n\n    # Return updated model\n    return m\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.add_objective_measure_constraint","title":"<code>add_objective_measure_constraint(m, j, k, measure, numerator, p, vp)</code>","text":"<p>Add an objective measure constraint to the model.</p> <p>This function takes the model (m), AFSC index (j), objective, objective measure, numerator of the function, problem parameters (p), and value parameters (vp) as inputs. It adds a constraint to the constraint list of the model based on the given objective measure.</p> <p>For objectives related to the number of cadets (such as Combined Quota, USAFA Quota, ROTC Quota), the minimum and maximum values of the measure are directly enforced.</p> <p>For objectives with constrained approximate measures, the function checks whether the constrained minimum number of cadets is lower than the Program Guidance Letter (PGL). If the constrained minimum is below the PGL, the objective constraint is based on that minimum value, otherwise, it is based on the PGL target.</p> <p>For objectives with constrained exact measures, the constraint is directly based on the minimum and maximum values multiplied by the count of cadets for the AFSC. (Numerator / Count) -&gt; Objective Measure</p> <p>Args:     m (ConcreteModel): The Pyomo model to which the constraint will be added.     j (int): The index of the AFSC.     k (int): The index of the objective.     measure (Expression): The objective measure.     numerator (Expression): The numerator of the objective measure function.     p (dict): The problem parameters.     vp (dict): The value parameters.</p> <p>Returns:     ConcreteModel: The updated Pyomo model with the objective measure constraint added.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def add_objective_measure_constraint(m, j, k, measure, numerator, p, vp):\n    \"\"\"\n    Add an objective measure constraint to the model.\n\n    This function takes the model (m), AFSC index (j), objective, objective measure, numerator of the function,\n    problem parameters (p), and value parameters (vp) as inputs. It adds a constraint to the constraint list of the model\n    based on the given objective measure.\n\n    For objectives related to the number of cadets (such as Combined Quota, USAFA Quota, ROTC Quota), the minimum and\n    maximum values of the measure are directly enforced.\n\n    For objectives with constrained approximate measures, the function checks whether the constrained minimum number\n    of cadets is lower than the Program Guidance Letter (PGL). If the constrained minimum is below the PGL, the\n    objective constraint is based on that minimum value, otherwise, it is based on the PGL target.\n\n    For objectives with constrained exact measures, the constraint is directly based on the minimum and maximum values\n    multiplied by the count of cadets for the AFSC. (Numerator / Count) -&gt; Objective Measure\n\n    Args:\n        m (ConcreteModel): The Pyomo model to which the constraint will be added.\n        j (int): The index of the AFSC.\n        k (int): The index of the objective.\n        measure (Expression): The objective measure.\n        numerator (Expression): The numerator of the objective measure function.\n        p (dict): The problem parameters.\n        vp (dict): The value parameters.\n\n    Returns:\n        ConcreteModel: The updated Pyomo model with the objective measure constraint added.\n    \"\"\"\n\n    # Get count variables for this AFSC\n    count = np.sum(m.x[i, j] for i in p['I^E'][j])\n\n    try:\n        # \"Number of Cadets\" objectives handled separately\n        if vp['objectives'][k] in ['Combined Quota', 'USAFA Quota', 'ROTC Quota', 'OTS Quota']:\n            m.measure_constraints.add(expr=measure &gt;= vp[\"objective_min\"][j, k])\n            m.measure_constraints.add(expr=measure &lt;= vp[\"objective_max\"][j, k])\n\n        else:\n            # Constrained Approximate Measure\n            if vp['constraint_type'][j, k] == 1:\n\n                # Take the smallest value between the PGL and constrained minimum number for this constraint\n                m.measure_constraints.add(\n                    expr=numerator - vp[\"objective_min\"][j, k] * min(p[\"pgl\"][j], p['quota_min'][j]) &gt;= 0)\n                m.measure_constraints.add(\n                    expr=numerator - vp[\"objective_max\"][j, k] * min(p[\"pgl\"][j], p['quota_min'][j]) &lt;= 0)\n\n            # Constrained Exact Measure\n            elif vp['constraint_type'][j, k] == 2:\n                m.measure_constraints.add(expr=numerator - vp[\"objective_min\"][j, k] * count &gt;= 0)\n                m.measure_constraints.add(expr=numerator - vp[\"objective_max\"][j, k] * count &lt;= 0)\n\n    except Exception as error:\n\n        print(\"AFSC '\" + p['afscs'][j] + \"' Objective '\" + vp['objectives'][k] + \" constraint failed to add.\")\n        print(\"Exception:\", error)\n\n    # Return updated model\n    return m\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.add_objective_value_function_constraints","title":"<code>add_objective_value_function_constraints(m, j, k, measure, q)</code>","text":"<p>Add linear value function constraints to the Pyomo model.</p> <p>This function incorporates constraints related to the value function into the Pyomo optimization model. These constraints ensure that the measure and value function constraints are properly enforced, the lambda variables are bounded by y variables, and that summation and positivity constraints hold.</p> <p>The constraints implemented correspond to the following formulations:</p> <ul> <li>Measure Constraint (20a): Ensures the measure is computed as a weighted sum of coefficients.</li> <li>Value Function Constraint (20b): Computes the value function as a weighted sum of given parameters.</li> <li>Lambda-Y Constraints (20c, 20d, 20e): Enforce relationships between lambda and y variables.</li> <li>Y Summation Constraint (20f): Ensures the sum of y values equals 1.</li> <li>Lambda Summation Constraint (20g): Ensures the sum of lambda values equals 1.</li> <li>Lambda and Value Function Positivity Constraints (20h): Enforces non-negativity of lambda and the value function.</li> </ul> <p>Args:     m (ConcreteModel): The Pyomo model to which the constraints will be added.     j (int): The index representing the AFSC.     k (int): The index representing the objective.     measure (Expression): The measure variable in the value function.     q (dict): A dictionary containing problem parameters, including:         - 'a': Coefficients for the measure function.         - 'f^hat': Coefficients for the value function.         - 'L': Set of lambda indices.         - 'r': The range parameter defining the number of lambda variables.</p> <p>Returns:     ConcreteModel: The updated Pyomo model with the value function constraints added.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def add_objective_value_function_constraints(m, j, k, measure, q):\n    \"\"\"\n    Add linear value function constraints to the Pyomo model.\n\n    This function incorporates constraints related to the value function into the Pyomo optimization model.\n    These constraints ensure that the measure and value function constraints are properly enforced, the lambda\n    variables are bounded by y variables, and that summation and positivity constraints hold.\n\n    The constraints implemented correspond to the following formulations:\n\n    - Measure Constraint (20a): Ensures the measure is computed as a weighted sum of coefficients.\n    - Value Function Constraint (20b): Computes the value function as a weighted sum of given parameters.\n    - Lambda-Y Constraints (20c, 20d, 20e): Enforce relationships between lambda and y variables.\n    - Y Summation Constraint (20f): Ensures the sum of y values equals 1.\n    - Lambda Summation Constraint (20g): Ensures the sum of lambda values equals 1.\n    - Lambda and Value Function Positivity Constraints (20h): Enforces non-negativity of lambda and the value function.\n\n    Args:\n        m (ConcreteModel): The Pyomo model to which the constraints will be added.\n        j (int): The index representing the AFSC.\n        k (int): The index representing the objective.\n        measure (Expression): The measure variable in the value function.\n        q (dict): A dictionary containing problem parameters, including:\n            - 'a': Coefficients for the measure function.\n            - 'f^hat': Coefficients for the value function.\n            - 'L': Set of lambda indices.\n            - 'r': The range parameter defining the number of lambda variables.\n\n    Returns:\n        ConcreteModel: The updated Pyomo model with the value function constraints added.\n    \"\"\"\n\n    # Add Linear Value Function Constraints\n    m.measure_vf_constraints.add(expr=measure == np.sum(  # Measure Constraint for Value Function (20a)\n        q['a'][j, k][l] * m.lam[j, k, l] for l in q['L'][j, k]))\n    m.value_vf_constraints.add(expr=m.f_value[j, k] == np.sum(  # Value Constraint for Value Function (20b)\n        q['f^hat'][j, k][l] * m.lam[j, k, l] for l in q['L'][j, k]))\n\n    # Lambda .. y constraints (20c, 20d, 20e)\n    m.lambda_y_constraint1.add(expr=m.lam[j, k, 0] &lt;= m.y[j, k, 0])  # (20c)\n    if q['r'][j, k] &gt; 2:\n        for l in range(1, q['r'][j, k] - 1):\n            m.lambda_y_constraint2.add(expr=m.lam[j, k, l] &lt;= m.y[j, k, l - 1] + m.y[j, k, l])  # (20d)\n    m.lambda_y_constraint3.add(expr=m.lam[j, k, q['r'][j, k] - 1] &lt;= m.y[j, k, q['r'][j, k] - 2])  # (20e)\n\n    # Y sum to 1 constraint (20f)\n    m.y_sum_constraint.add(expr=np.sum(m.y[j, k, l] for l in range(0, q['r'][j, k] - 1)) == 1)\n\n    # Lambda sum to 1 constraint (20g)\n    m.lambda_sum_constraint.add(expr=np.sum(m.lam[j, k, l] for l in q['L'][j, k]) == 1)\n\n    # Lambda .. value positive constraint (20h) although the \"f_value\" constraint is implied in the thesis\n    for l in q['L'][j, k]:\n        m.lambda_positive.add(expr=m.lam[j, k, l] &gt;= 0)\n    m.f_value_positive.add(expr=m.f_value[j, k] &gt;= 0)\n\n    # Return updated model\n    return m\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.common_optimization_handling","title":"<code>common_optimization_handling(m, p, vp, mdl_p)</code>","text":"<p>Adds optimization model components common to main optimization models like VFT and the generalized assignment problem models.</p> <p>Parameters: m (ConcreteModel): The Pyomo ConcreteModel instance to which the optimization model components will be added. p (dict): A dictionary containing problem-specific data, including cadet, AFSC, base, course, utility, and weight          information. vp (dict): A dictionary containing value-specific parameters and information. mdl_p (dict): A dictionary containing model-specific parameters and configurations.</p> <p>Returns: ConcreteModel: The modified Pyomo ConcreteModel instance with added optimization model components.</p> <p>Notes: - This function extends the given Pyomo ConcreteModel (m) by adding optimization model components common to   various main optimization models. - The parameters include:     - m: The Pyomo ConcreteModel instance to be extended.     - p: A dictionary containing various problem-specific data, such as cadet information, AFSCs, bases, courses,          utility values, and weights.     - vp: A dictionary containing value-specific parameters and information.     - mdl_p: A dictionary containing model-specific parameters and configurations. - The added optimization model components include binary variables (x), constraints for cadet AFSC assignment,   cadet value constraints, constraints for fixed variables, reserved AFSC constraints, and constraints for   AFSC cadet percentages, among others. - Additional constraints handle special cases like alternate list rated addition, 5% cap on total percentage of   USAFA cadets allowed in certain AFSCs, USSF SOC PGL constraint, and USSF OM constraint. - The given ConcreteModel (m) is modified in-place and returned for further use.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def common_optimization_handling(m, p, vp, mdl_p):\n    \"\"\"\n    Adds optimization model components common to *main* optimization models like VFT and the generalized assignment\n    problem models.\n\n    Parameters:\n    m (ConcreteModel): The Pyomo ConcreteModel instance to which the optimization model components will be added.\n    p (dict): A dictionary containing problem-specific data, including cadet, AFSC, base, course, utility, and weight\n             information.\n    vp (dict): A dictionary containing value-specific parameters and information.\n    mdl_p (dict): A dictionary containing model-specific parameters and configurations.\n\n    Returns:\n    ConcreteModel: The modified Pyomo ConcreteModel instance with added optimization model components.\n\n    Notes:\n    - This function extends the given Pyomo ConcreteModel (m) by adding optimization model components common to\n      various main optimization models.\n    - The parameters include:\n        - m: The Pyomo ConcreteModel instance to be extended.\n        - p: A dictionary containing various problem-specific data, such as cadet information, AFSCs, bases, courses,\n             utility values, and weights.\n        - vp: A dictionary containing value-specific parameters and information.\n        - mdl_p: A dictionary containing model-specific parameters and configurations.\n    - The added optimization model components include binary variables (x), constraints for cadet AFSC assignment,\n      cadet value constraints, constraints for fixed variables, reserved AFSC constraints, and constraints for\n      AFSC cadet percentages, among others.\n    - Additional constraints handle special cases like alternate list rated addition, 5% cap on total percentage of\n      USAFA cadets allowed in certain AFSCs, USSF SOC PGL constraint, and USSF OM constraint.\n    - The given ConcreteModel (m) is modified in-place and returned for further use.\n    \"\"\"\n\n    # Define the x-variable\n    m.x = Var(((i, j) for i in p['I'] for j in p['J^E'][i]), within=Binary)\n\n    # Cadets receive one and only one AFSC (Ineligibility constraint is always met as a result of the indexed sets)\n    m.one_afsc_constraints = ConstraintList()  # ...except for OTS candidates!\n    for i in p['I']:\n\n        # OTS candidates can go unmatched\n        if 'I^OTS' in p:\n            if i in p['I^OTS']:\n\n                # If this candidate does not have any preferences, they will go unmatched\n                if len(p['cadet_preferences'][i]) == 0:\n                    continue  # No need to assign a variable constraint (doesn't exist)\n                else:  # The candidate DOES have preferences, but they still COULD go unmatched\n                    m.one_afsc_constraints.add(expr=np.sum(m.x[i, j] for j in p['J^E'][i]) &lt;= 1)\n                continue  # Next!\n\n        # This cadet must receive one and only one AFSC\n        m.one_afsc_constraints.add(expr=np.sum(m.x[i, j] for j in p['J^E'][i]) == 1)\n\n    # Cadets may sometimes be constrained to be part of one \"Accessions Group\" (probably just USSF)\n    m.acc_grp_constraints = ConstraintList()\n    if 'acc_grp_constraint' in p:\n        for acc_grp in p['afscs_acc_grp']:\n            for i in p['I^' + acc_grp]:\n                m.acc_grp_constraints.add(\n                    expr=np.sum(m.x[i, j] for j in p['J^' + acc_grp] if j in p['J^E'][i]) == 1)\n\n    # Cadet value constraint (Could work on any optimization model)\n    m.min_cadet_value_constraints = ConstraintList()\n    for i in vp['I^C']:  # \"J^Top_Choice is set of AFSCs at or above designated utility value (typically top 3)\n        m.min_cadet_value_constraints.add(expr=np.sum(m.x[i, j] for j in vp['J^Top_Choice'][i]) == 1)\n\n    # \"AlTERNATE LIST\" Rated Addition\n    if mdl_p['rated_alternates'] and 'J^Preferred [usafa]' in p:  # If [usafa] version is here, [rotc] will be too\n\n        # Initialize list of blocking pairs constraints for alternate lists\n        m.blocking_pairs_alternates = ConstraintList()\n\n        # Subset of Rated AFSCs that have alternate constraints\n        rated_afscs_with_constraints = []\n        if mdl_p['rated_alternate_afscs'] is None:\n            rated_afscs_with_constraints = p['J^Rated']\n        else:\n            for afsc in mdl_p['rated_alternate_afscs']:\n                if afsc not in p['afscs']:\n                    raise ValueError(\"AFSC '\" + afsc + \"' not valid.\")\n\n                # Add the index of the AFSC\n                rated_afscs_with_constraints.append(np.where(p['afscs'] == afsc)[0][0])\n\n        # Do we want to allow ROTC to fill USAFA pilot slots? This is the VERY rare situation like in FY26 where\n        if mdl_p['usafa_soc_pilot_cross_in']:  # USAFA targets were high but people didn't want to fill em\n\n            # Remove pilot AFSC from standard alternate list blocking pair constraints (handle them in special case)\n            j_pilot_u = np.where(p['afscs'] == '11XX_U')[0][0]\n            j_pilot_r = np.where(p['afscs'] == '11XX_R')[0][0]\n            rated_afscs_with_constraints.remove(j_pilot_u)\n            rated_afscs_with_constraints.remove(j_pilot_r)\n\n            # For USAFA, loop through every pilot qualified USAFA cadet and make sure their right to a...\n            for i in p['I^E'][j_pilot_u]:  # ...pilot slot is protected from ROTC (they get something better)\n\n                # Where did this USAFA cadet rank pilot?\n                choice = np.where(p['cadet_preferences'][i] == j_pilot_u)[0][0]\n\n                # Have we already reserved an AFSC for them?\n                if i not in p['J^Reserved']:\n\n                    # If they're already fixed to something, skip them\n                    if i in p['J^Fixed']:\n                        continue\n                    else:  # Reserve a pilot slot for them!\n                        p['J^Reserved'][i] = p['cadet_preferences'][i][:choice + 1]\n\n                else:  # If they're already reserved for something, honor their best interest scenario\n                    num_reserved_already = len(p['J^Reserved'][i])\n                    num_to_reserve = min(choice + 1, num_reserved_already)\n                    p['J^Reserved'][i] = p['cadet_preferences'][i][:num_to_reserve]\n\n            # For ROTC, we introduce blocking pair constraints but include the deficit between USAFA pilot target and..\n            # for i in p['I^Alternate [rotc]'][j_pilot_r]:  # ...USAFA pilot assigned\n            for i in p['I^E'][j_pilot_r]:  # TODO: Figure out why alternate list isn't working\n\n                # Are they already fixed to something?\n                if i in p['J^Fixed']:\n\n                    # If we've already matched them to pilot, skip them\n                    if p['J^Fixed'][i] == j_pilot_r:\n                        continue\n\n                    # If we fixed them to something undesirable, don't do that  TODO: Change this in the algorithm\n                    if p['c_pref_matrix'][i, j_pilot_r] &lt; p['c_pref_matrix'][i, p['J^Fixed'][i]]:\n                        p['J^Fixed'].pop(i)\n\n                # Calculate number of USAFA pilot slots up for grabs\n                num_extra = p['usafa_quota'][j_pilot_u] - np.sum(m.x[i, j_pilot_u] for i in p['I^E'][j_pilot_u])\n\n                # Add the blocking pair constraint for the rated AFSC/cadet pair\n                m.blocking_pairs_alternates.add(  # \"j_p\"/\"i_p\" indicate j/i \"prime\" or (')\n                    expr=p['rotc_quota'][j_pilot_r] *\n                         (1 - np.sum(m.x[i, j_p] for j_p in p['J^Preferred [rotc]'][j_pilot_r][i])) &lt;=\n                         np.sum(m.x[i_p, j_pilot_r] for i_p in p['I^Preferred [rotc]'][j_pilot_r][i]) - num_extra)\n\n            # USAFA-ROTC pilot totals constraint\n            def usafa_rotc_pilot_totals(m):\n                \"\"\"\n                Make sure we meet the collective pilot quota\n                \"\"\"\n                usafa_pilot_totals = np.sum(m.x[i, j_pilot_u] for i in p['I^E'][j_pilot_u])\n                rotc_pilot_totals = np.sum(m.x[i, j_pilot_r] for i in p['I^E'][j_pilot_r])\n                return usafa_pilot_totals + rotc_pilot_totals == p['rotc_quota'][j_pilot_r] + \\\n                       p['usafa_quota'][j_pilot_u]\n\n            m.usafa_rotc_pilot_totals_constraint = Constraint(rule=usafa_rotc_pilot_totals)\n\n        # Loop through each SOC and rated AFSC\n        for soc in p['SOCs']:\n            for j in rated_afscs_with_constraints:\n\n                # Loop through each cadet on this rated AFSC's alternate list for this SOC\n                for i in p['I^Alternate [' + soc + ']'][j]:\n                    # Add the blocking pair constraint for the rated AFSC/cadet pair\n                    m.blocking_pairs_alternates.add(  # \"j_p\"/\"i_p\" indicate j/i \"prime\" or (')\n                        expr=p[soc + '_quota'][j] *\n                             (1 - np.sum(m.x[i, j_p] for j_p in p['J^Preferred [' + soc + ']'][j][i])) &lt;=\n                             np.sum(m.x[i_p, j] for i_p in p['I^Preferred [' + soc + ']'][j][i]))\n\n    # Fixing variables if necessary\n    for i in p['J^Fixed']:\n        m.x[i, p['J^Fixed'][i]].fix(1)\n\n    # Cadets with reserved AFSC slots get constrained so that the \"worst\" choice they can get is their reserved AFSC\n    m.reserved_afsc_constraints = ConstraintList()\n    for i in p['J^Reserved']:\n        m.reserved_afsc_constraints.add(expr=np.sum(m.x[i, j] for j in p['J^Reserved'][i]) == 1)\n\n    # 5% cap on total percentage of USAFA cadets allowed into certain AFSCs\n    if mdl_p[\"USAFA-Constrained AFSCs\"] is not None:\n        cap = 0.05 * instance.mdl_p[\"real_usafa_n\"]  # Total number of graduating USAFA cadets\n\n        # Convert list of AFSC names to list of AFSC indices\n        constrained_afscs = [np.where(p['afscs'] == afsc)[0][0] for afsc in mdl_p[\"USAFA-Constrained AFSCs\"]]\n\n        # USAFA 5% Cap Constraint\n        def usafa_afscs_rule(m):\n            \"\"\"\n            This is the 5% USAFA graduating class cap constraint for certain AFSCs (support AFSCs). I will note that\n            as of Mar '23 this constraint is effectively null and void! Still here for documentation however and for any\n            potential future experiment\n            \"\"\"\n            return np.sum(np.sum(m.x[i, j] for i in p['usafa_cadets']) for j in constrained_afscs) &lt;= cap\n\n        m.usafa_afscs_constraint = Constraint(rule=usafa_afscs_rule)\n\n    # Space Force PGL Constraint (Honor USSF SOC split)\n    if mdl_p['ussf_soc_pgl_constraint'] and \"USSF\" in p['afscs_acc_grp']:\n        # Necessary variables to calculate\n        ussf_usafa_sum = np.sum(np.sum(m.x[i, j] for i in p['usafa_cadets'] if i in p['I^E'][j]) for j in p['J^USSF'])\n        ussf_rotc_sum = np.sum(np.sum(m.x[i, j] for i in p['rotc_cadets'] if i in p['I^E'][j]) for j in p['J^USSF'])\n\n        # SOC/USSF PGL Constraints\n        m.soc_ussf_pgl_constraints = ConstraintList()\n        m.soc_ussf_pgl_constraints.add(expr=ussf_usafa_sum &gt;= p['ussf_usafa_pgl'] -\n                                            mdl_p['ussf_soc_pgl_constraint_bound'] * p['ussf_usafa_pgl'])\n        m.soc_ussf_pgl_constraints.add(expr=ussf_usafa_sum &lt;= p['ussf_usafa_pgl'] +\n                                            mdl_p['ussf_soc_pgl_constraint_bound'] * p['ussf_usafa_pgl'])\n        m.soc_ussf_pgl_constraints.add(expr=ussf_rotc_sum &gt;= p['ussf_rotc_pgl'] -\n                                            mdl_p['ussf_soc_pgl_constraint_bound'] * p['ussf_rotc_pgl'])\n        m.soc_ussf_pgl_constraints.add(expr=ussf_rotc_sum &lt;= p['ussf_rotc_pgl'] +\n                                            mdl_p['ussf_soc_pgl_constraint_bound'] * p['ussf_rotc_pgl'])\n\n    # Space Force OM Constraint\n    if mdl_p['USSF OM'] and \"USSF\" in p['afscs_acc_grp']:\n        # Necessary variables to calculate\n        ussf_merit_sum = np.sum(np.sum(p['merit'][i] * m.x[i, j] for i in p['I^E'][j]) for j in p['J^USSF'])\n        ussf_sum = np.sum(np.sum(m.x[i, j] for i in p['I^E'][j]) for j in p['J^USSF'])\n\n        # Define constraint functions\n        def ussf_om_upper_rule(m):\n            \"\"\"\n            This is the 50% OM split constraint between the USAF and USSF (upper bound)\n            \"\"\"\n\n            return ussf_merit_sum &lt;= ussf_sum * (0.5 + mdl_p['ussf_merit_bound'])\n\n        def ussf_om_lower_rule(m):\n            \"\"\"\n            This is the 50% OM split constraint between the USAF and USSF (lower bound)\n            \"\"\"\n\n            return ussf_merit_sum &gt;= ussf_sum * (0.5 - mdl_p['ussf_merit_bound'])\n\n        # Apply constraints\n        m.ussf_om_constraint_upper = Constraint(rule=ussf_om_upper_rule)\n        m.ussf_om_constraint_lower = Constraint(rule=ussf_om_lower_rule)\n\n    # OTS accessions cap\n    if 'ots' in p['SOCs']:\n        # Determine the cap on OTS accessions\n        print(f\"OTS accessions capacity constraint: {p['ots_accessions']}\")\n\n        # Define and apply the constraint\n        def ots_accessions_constraint_rule(m):\n            \"\"\"\n            Constraint to ensure we stay under OTS accessions cap\n            \"\"\"\n            return np.sum(np.sum(m.x[i, j] for j in p['J^E'][i]) for i in p['I^OTS']) &lt;= p['ots_accessions']\n\n        m.ots_accessions_constraint = Constraint(rule=ots_accessions_constraint_rule)\n\n    # Return updated model\n    return m\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.base_training_model_handling","title":"<code>base_training_model_handling(m, p, mdl_p)</code>","text":"<p>Adds optimization model components to handle base and training (IST) assignments.</p> <p>Parameters: m (ConcreteModel): The Pyomo ConcreteModel instance to which the optimization model components will be added. p (dict): A dictionary containing problem data, including cadet, base, course, utility, and weight information. mdl_p (dict): A dictionary containing model-specific parameters and configurations.</p> <p>Returns: ConcreteModel: The modified Pyomo ConcreteModel instance with added optimization model components.</p> <p>Notes: - This function extends the given Pyomo ConcreteModel (m) by adding optimization model components to handle base and   training (IST) assignments for cadets. - The parameters are as follows:     - m: The Pyomo ConcreteModel instance to be extended.     - p: A dictionary containing various problem data, such as cadet information, base information, course       information, utility values, and weight information.     - mdl_p: A dictionary containing model-specific parameters and configurations. - The added optimization model components include variables and constraints to handle cadet assignments to bases,   courses, and values based on utility outcomes and constraints to ensure that assigned bases and courses do not   exceed their capacities. - Cadet assignments are modeled using binary variables (v and q), which represent assignments to bases and courses,   respectively. - Constraints are formulated to ensure cadet value calculations based on cadet states, base assignments, course   assignments, and utility values. - Additionally, constraints ensure that cadet assignments to bases and courses do not exceed base and course   capacities.</p> <p>Note: The given ConcreteModel (m) is modified in-place and returned for further use.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def base_training_model_handling(m, p, mdl_p):\n    \"\"\"\n    Adds optimization model components to handle base and training (IST) assignments.\n\n    Parameters:\n    m (ConcreteModel): The Pyomo ConcreteModel instance to which the optimization model components will be added.\n    p (dict): A dictionary containing problem data, including cadet, base, course, utility, and weight information.\n    mdl_p (dict): A dictionary containing model-specific parameters and configurations.\n\n    Returns:\n    ConcreteModel: The modified Pyomo ConcreteModel instance with added optimization model components.\n\n    Notes:\n    - This function extends the given Pyomo ConcreteModel (m) by adding optimization model components to handle base and\n      training (IST) assignments for cadets.\n    - The parameters are as follows:\n        - m: The Pyomo ConcreteModel instance to be extended.\n        - p: A dictionary containing various problem data, such as cadet information, base information, course\n          information, utility values, and weight information.\n        - mdl_p: A dictionary containing model-specific parameters and configurations.\n    - The added optimization model components include variables and constraints to handle cadet assignments to bases,\n      courses, and values based on utility outcomes and constraints to ensure that assigned bases and courses do not\n      exceed their capacities.\n    - Cadet assignments are modeled using binary variables (v and q), which represent assignments to bases and courses,\n      respectively.\n    - Constraints are formulated to ensure cadet value calculations based on cadet states, base assignments, course\n      assignments, and utility values.\n    - Additionally, constraints ensure that cadet assignments to bases and courses do not exceed base and course\n      capacities.\n\n    Note: The given ConcreteModel (m) is modified in-place and returned for further use.\n    \"\"\"\n\n    # Define the v and q-variables\n    m.v = Var(((i, b) for i in p['I'] for b in p['B^E'][i]), within=Binary)\n    m.q = Var(((i, j, c) for i in p['I'] for j in p['J^E'][i] for c in p['C^E'][i][j]), within=Binary)\n\n    # Define the new cadet value variable\n    m.cadet_value = Var((i for i in p['I']), within=NonNegativeReals, bounds=(0, 1))\n\n    # Cadet Value Constraints. Define what the \"cadet_value\" variable should be based on which \"state\" the cadet is in.\n    m.bc_cadet_value_constraints = ConstraintList()\n    for i in p['I']:\n        for d in p['D'][i]:\n\n            # Calculate auxiliary variables for AFSC, base, course utility outcomes\n            u = {\n                'A': (1 / p['u^S'][i][d]) * np.sum(p['cadet_utility'][i, j] * m.x[i, j] for j in p['J^State'][i][d]),\n                'C': np.sum(np.sum(\n                    p['course_utility'][i][j][c] * m.q[i, j, c] for c in p['C^E'][i][j]) for j in p['J^State'][i][d])\n            }\n\n            # Weighted sum of cadet utilities in each area depends on if bases are involved\n            if len(p['B^State'][i][d]) &gt; 0:\n                u['B'] = np.sum(p['base_utility'][i, b] * m.v[i, b] for b in p['B^State'][i][d])\n                weighted_sum = p['w^A'][i][d] * u['A'] + p['w^B'][i][d] * u['B'] + p['w^C'][i][d] * u['C']\n            else:\n                weighted_sum = p['w^A'][i][d] * u['A'] + p['w^C'][i][d] * u['C']\n\n            # This is the base/course state cadet value constraint. It ensures cadet_value will be the right value\n            m.bc_cadet_value_constraints.add(expr=m.cadet_value[i] &lt;= p['u^S'][i][d] * weighted_sum +\n                                                  mdl_p['BIG M'] * (1 - np.sum(m.x[i, j] for j in p['J^State'][i][d])))\n\n    # Cadet Base Constraints. If a cadet is assigned to a base, it has to be one that the AFSC is located at\n    m.bc_cadet_base_constraints = ConstraintList()\n    for i in p['I']:\n        m.bc_cadet_base_constraints.add(expr=np.sum(m.v[i, b] for b in p['B^E'][i]) ==\n                                             np.sum(m.x[i, j] for j in np.intersect1d(p['J^E'][i], p['J^B'])))\n        for j in np.intersect1d(p['J^B'], p['J^E'][i]):\n            m.bc_cadet_base_constraints.add(expr=m.x[i, j] &lt;= np.sum(m.v[i, b] for b in p['B^A'][j]))\n\n    # Cadet Course Constraints. Cadets have to be assigned to a course for their designated AFSC\n    m.bc_cadet_course_constraints = ConstraintList()\n    for i in p['I']:\n        for j in p['J^E'][i]:\n            m.bc_cadet_course_constraints.add(expr=m.x[i, j] == np.sum(m.q[i, j, c] for c in p['C^E'][i][j]))\n\n    # Base Capacity Constraints. A base/AFSC pair cannot exceed its capacity\n    m.bc_base_capacity_constraints = ConstraintList()\n    for j in p['J^B']:\n        for b in p['B^A'][j]:\n            m.bc_base_capacity_constraints.add(expr=np.sum(m.v[i, b] for i in p['I^E'][j]) &lt;= p['hi^B'][j][b])\n            m.bc_base_capacity_constraints.add(expr=np.sum(m.v[i, b] for i in p['I^E'][j]) &gt;= p['lo^B'][j][b])\n\n    # Course Capacity Constraints. A course/AFSC pair cannot exceed its capacity\n    m.bc_course_capacity_constraints = ConstraintList()\n    for j in p['J']:\n        for c in p['C'][j]:\n            m.bc_course_capacity_constraints.add(expr=np.sum(m.q[i, j, c] for i in p['I^A'][j][c]) &lt;= p['hi^C'][j][c])\n            m.bc_course_capacity_constraints.add(expr=np.sum(m.q[i, j, c] for i in p['I^A'][j][c]) &gt;= p['lo^C'][j][c])\n\n    return m\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.assignment_model_objective_function_definition","title":"<code>assignment_model_objective_function_definition(m, p, vp, mdl_p, c)</code>","text":"<p>Define the objective function for the assignment model.</p> <p>This function constructs the objective function for an assignment optimization model. The objective function varies depending on whether the model includes additional components (<code>solve_extra_components</code>) or only considers AFSC-based assignments.</p> <p>If <code>solve_extra_components</code> is enabled, the objective function consists of two weighted components: - A cadet-specific value function weighted by <code>cadets_overall_weight</code> and individual   cadet weights. - An AFSC-specific utility function weighted by <code>afscs_overall_weight</code> and normalized by <code>1/N</code>.</p> <p>If <code>solve_extra_components</code> is disabled, the function simplifies to maximizing the AFSC-only utility values.</p> <p>Args:     m (ConcreteModel): The Pyomo model to which the objective function will be added.     p (dict): A dictionary containing problem parameters, including:         - 'I': Set of cadets.         - 'J^E': Set of available AFSCs for each cadet.         - 'afsc_utility': Utility values for cadet-to-AFSC assignments.         - 'N': Normalization factor for AFSC weight.     vp (dict): A dictionary containing value parameters, including:         - 'cadets_overall_weight': Overall weight for cadet value.         - 'cadet_weight': Individual weights for cadets.         - 'afscs_overall_weight': Overall weight for AFSC utility.     mdl_p (dict): Model parameters containing:         - 'solve_extra_components' (bool): Determines whether additional components           (cadet-based value) are included in the objective.     c (dict): A dictionary of AFSC-only utility values used when <code>solve_extra_components</code>         is disabled.</p> <p>Returns:     Objective: The Pyomo Objective function, maximizing either the full weighted sum     of cadet and AFSC utility (if <code>solve_extra_components</code> is True) or just AFSC utility     (if False).</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def assignment_model_objective_function_definition(m, p, vp, mdl_p, c):\n    \"\"\"\n    Define the objective function for the assignment model.\n\n    This function constructs the objective function for an assignment optimization model.\n    The objective function varies depending on whether the model includes additional components\n    (`solve_extra_components`) or only considers AFSC-based assignments.\n\n    If `solve_extra_components` is enabled, the objective function consists of two weighted\n    components:\n    - A cadet-specific value function weighted by `cadets_overall_weight` and individual\n      cadet weights.\n    - An AFSC-specific utility function weighted by `afscs_overall_weight` and normalized by `1/N`.\n\n    If `solve_extra_components` is disabled, the function simplifies to maximizing\n    the AFSC-only utility values.\n\n    Args:\n        m (ConcreteModel): The Pyomo model to which the objective function will be added.\n        p (dict): A dictionary containing problem parameters, including:\n            - 'I': Set of cadets.\n            - 'J^E': Set of available AFSCs for each cadet.\n            - 'afsc_utility': Utility values for cadet-to-AFSC assignments.\n            - 'N': Normalization factor for AFSC weight.\n        vp (dict): A dictionary containing value parameters, including:\n            - 'cadets_overall_weight': Overall weight for cadet value.\n            - 'cadet_weight': Individual weights for cadets.\n            - 'afscs_overall_weight': Overall weight for AFSC utility.\n        mdl_p (dict): Model parameters containing:\n            - 'solve_extra_components' (bool): Determines whether additional components\n              (cadet-based value) are included in the objective.\n        c (dict): A dictionary of AFSC-only utility values used when `solve_extra_components`\n            is disabled.\n\n    Returns:\n        Objective: The Pyomo Objective function, maximizing either the full weighted sum\n        of cadet and AFSC utility (if `solve_extra_components` is True) or just AFSC utility\n        (if False).\n    \"\"\"\n\n    # Do we incorporate base/training decision components to the model?\n    if mdl_p['solve_extra_components']:\n\n        # Base/Training model objective function\n        def objective_function(m):\n            return vp['cadets_overall_weight'] * np.sum(vp['cadet_weight'][i] * m.cadet_value[i] for i in p['I']) + \\\n                   1 / p['N'] * vp['afscs_overall_weight'] * np.sum(\n                np.sum(p['afsc_utility'][i, j] * m.x[i, j] for j in p['J^E'][i]) for i in p['I'])\n\n    else:  # If not, we solve the \"AFSC-only\" assignment problem model\n\n        # AFSC-only objective function (GUO) i.e. (not base/training component considerations)\n        z_guo = np.sum(np.sum(c[i, j] * m.x[i, j] for j in p[\"J^E\"][i]) for i in p[\"I\"]) / p['N^Match']\n        def objective_function(m):  # Standard \"GUO\" function value \"z^GUO\"\n            return z_guo\n\n        # Determine whether we want to add \"CASTLE\" modeling components or not\n        if mdl_p['solve_castle_guo']:\n            if 'castle_q' not in p:  # If we don't have castle parameters, we can't solve the model\n                print(\"CASTLE Parameters not found. We cannot solve model w/CASTLE modifications.\")\n                return Objective(rule=objective_function, sense=maximize)  # Return normal GUO function\n            afscs = [afsc for afsc, _ in p['castle_afscs'].items()]\n\n            # Define the Castle-informed objective function!\n            z_castle_values = np.sum(m.f_value[afsc] for afsc in afscs)\n            if mdl_p['w^G'] == 1:  # Weight on Castle solution is zero so we don't need to include it!\n                def objective_function(m):  # Standard \"GUO\" function value \"z^GUO\"\n                    return z_guo\n            elif mdl_p['w^G'] == 0:  # Weight on GUO solution is zero so just use Castle information\n                def objective_function(m):  # Castle-values portion of objective function\n                    return z_castle_values\n            else:\n                def objective_function(m):  # Full weighted function of GUO and Castle\n                    return mdl_p['w^G'] * z_guo + (1 - mdl_p['w^G']) * z_castle_values\n\n    # Objective function has been defined\n    return Objective(rule=objective_function, sense=maximize)\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.cadet_board_preprocess_model","title":"<code>cadet_board_preprocess_model(b)</code>","text":"<p>Builds a Pyomo optimization model to determine the x and y coordinates of AFSC squares on a chart.</p>"},{"location":"reference/solutions/optimization/#solutions.optimization.cadet_board_preprocess_model--parameters","title":"Parameters:","text":"<p>b : dict     A dictionary containing configuration parameters for the model.     The dictionary should include the following key-value pairs:     - 'n^sorted' : numpy array         Sorted values of the AFSC sizes (cadet box sizes).     - 'M' : int         The number of AFSCs (cadet boxes).     - 'add_legend' : bool         Whether to include a legend box in the chart.     - 'simplified_model' : bool         Whether to use a simplified model without positional constraints.     - 'row_constraint' : bool         Whether to incorporate a row constraint for AFSCs.     - Additional bounds and constants used in the model.</p>"},{"location":"reference/solutions/optimization/#solutions.optimization.cadet_board_preprocess_model--returns","title":"Returns:","text":"<p>m : ConcreteModel     The constructed Pyomo ConcreteModel instance representing the optimization model.</p>"},{"location":"reference/solutions/optimization/#solutions.optimization.cadet_board_preprocess_model--notes","title":"Notes:","text":"<p>This function creates an optimization model to determine the x and y coordinates of AFSC squares (cadet boxes) on a chart. The objective is to maximize the size of the cadet boxes, which are represented by the variable 'm.s'. The model seeks to find an optimal placement of the AFSC squares while satisfying various constraints. The specific constraints and objective function formulation depend on the configuration parameters provided in the 'b' dictionary.</p> <p>The function defines decision variables for the AFSC sizes ('m.s') and the x and y coordinates of each AFSC square ('m.x' and 'm.y'). Depending on the configuration parameters, additional variables for the legend box and positional relationships between AFSCs may be included.</p> <p>Constraints are added to ensure that the AFSC squares stay within the chart borders, avoid overlapping with the legend box (if present), and meet any specified row constraints. The constraints vary based on whether the simplified model or the full model with positional relationships between AFSCs is used.</p> <p>The objective function aims to maximize the size of the cadet boxes ('m.s'), representing the objective of maximizing the visual prominence of each AFSC on the chart.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def cadet_board_preprocess_model(b):\n    \"\"\"\n    Builds a Pyomo optimization model to determine the x and y coordinates of AFSC squares on a chart.\n\n    Parameters:\n    -----------\n    b : dict\n        A dictionary containing configuration parameters for the model.\n        The dictionary should include the following key-value pairs:\n        - 'n^sorted' : numpy array\n            Sorted values of the AFSC sizes (cadet box sizes).\n        - 'M' : int\n            The number of AFSCs (cadet boxes).\n        - 'add_legend' : bool\n            Whether to include a legend box in the chart.\n        - 'simplified_model' : bool\n            Whether to use a simplified model without positional constraints.\n        - 'row_constraint' : bool\n            Whether to incorporate a row constraint for AFSCs.\n        - Additional bounds and constants used in the model.\n\n    Returns:\n    --------\n    m : ConcreteModel\n        The constructed Pyomo ConcreteModel instance representing the optimization model.\n\n    Notes:\n    ------\n    This function creates an optimization model to determine the x and y coordinates of AFSC squares (cadet boxes)\n    on a chart. The objective is to maximize the size of the cadet boxes, which are represented by the variable 'm.s'.\n    The model seeks to find an optimal placement of the AFSC squares while satisfying various constraints.\n    The specific constraints and objective function formulation depend on the configuration parameters provided in the 'b' dictionary.\n\n    The function defines decision variables for the AFSC sizes ('m.s') and the x and y coordinates of each AFSC square ('m.x' and 'm.y').\n    Depending on the configuration parameters, additional variables for the legend box and positional relationships between AFSCs may be included.\n\n    Constraints are added to ensure that the AFSC squares stay within the chart borders, avoid overlapping with the legend box (if present),\n    and meet any specified row constraints. The constraints vary based on whether the simplified model or the full model with positional\n    relationships between AFSCs is used.\n\n    The objective function aims to maximize the size of the cadet boxes ('m.s'), representing the objective of maximizing the visual prominence\n    of each AFSC on the chart.\n    \"\"\"\n\n    # Build Model\n    m = ConcreteModel()\n\n    # Use the \"Sorted\" values for J and n\n    n = b['n^sorted']\n    J = np.arange(b['M'])\n    M = len(J)\n\n    # Get desired tuples of AFSCs\n    tuples = []\n    for i in J:\n        for j in J:\n            if i != j and (j, i) not in tuples:\n                tuples.append((i, j))\n\n    # ______________________________VARIABLE DEFINITIONS______________________________\n    m.s = Var(within=NonNegativeReals)  # Size of the cadet boxes (AFSC objective value)\n\n    # Coordinates of bottom left corner of AFSC j box\n    m.x = Var((j for j in J), within=NonNegativeReals)\n    m.y = Var((j for j in J), within=NonNegativeReals)\n\n    # ______________________________DUMMY VARIABLE DEFINITIONS______________________________\n    pass  # Here so pycharm doesn't yell at me for the constraint line above\n\n    if b['add_legend']:\n        # 1 if AFSC j is to the right of the left edge of the legend box, 0 otherwise\n        m.lga_r = Var((j for j in J), within=Binary)\n\n        # 1 if AFSC j is above the bottom edge of the legend box, 0 otherwise\n        m.lga_u = Var((j for j in J), within=Binary)\n\n    if b['simplified_model']:\n\n        # 1 if AFSC j is below AFSC j - 1, 0 otherwise\n        m.q = Var((j for j in np.arange(1, M)), within=Binary)\n\n    else:\n\n        # 1 if AFSC i is to the left of AFSC j\n        m.a_l = Var(((i, j) for i, j in tuples), within=Binary)\n\n        # 1 if AFSC i is to the right of AFSC j\n        m.a_r = Var(((i, j) for i, j in tuples), within=Binary)\n\n        # 1 if AFSC i is above AFSC j\n        m.a_u = Var(((i, j) for i, j in tuples), within=Binary)\n\n        # 1 if AFSC i is below AFSC j\n        m.a_d = Var(((i, j) for i, j in tuples), within=Binary)\n\n        # Toggle for if we want to incorporate the \"row constraint\"\n        if b['row_constraint']:\n            # 1 if AFSC j is on row k, 0 otherwise\n            m.lam = Var(((j, k) for j in J for k in range(b['n^rows'])), within=Binary)\n            m.y_row = Var((k for k in range(b['n^rows'])), within=NonNegativeReals)\n\n    # ______________________________OBJECTIVE FUNCTION______________________________\n    def objective_function(m):\n        return m.s\n\n    m.objective = Objective(rule=objective_function, sense=maximize)\n\n    # ____________________________________CONSTRAINTS_____________________________________\n    pass  # Here so pycharm doesn't yell at me for the constraint line above\n\n    # List of constraints that enforce AFSCs to stay within the borders\n    m.border_constraints = ConstraintList()\n\n    # List of constraints that enforce AFSCs to stay outside the legend box\n    m.legend_constraints = ConstraintList()\n\n    # More constraints\n    if b['simplified_model']:\n\n        # List of constraints that line up AFSCs in a nice grid\n        m.grid_constraints = ConstraintList()\n    else:\n\n        # List of constraints that keep AFSCs from overlapping\n        m.afsc_constraints = ConstraintList()\n\n        if b['row_constraint']:\n            # List of constraints that enforce the y row constraints\n            m.y_row_constraints = ConstraintList()\n            m.lam_constraints = ConstraintList()\n\n    # Loop through each AFSC\n    for j in J:\n\n        # Border\n        m.border_constraints.add(expr=m.x[j] &gt;= b['bw^l'])  # Left Border\n        m.border_constraints.add(expr=m.x[j] + m.s * n[j] &lt;= b['fw'] - b['bw^r'])  # Right Border\n        m.border_constraints.add(expr=m.y[j] &gt;= b['bw^b'])  # Bottom Border\n        m.border_constraints.add(expr=m.y[j] + m.s * n[j] &lt;= b['fh'] - b['bw^t'])  # Top Border\n\n        # Legend Dummy Definitions\n        if b['add_legend']:\n            m.legend_constraints.add(expr=m.x[j] + m.s * n[j] &gt;= (b['fw'] - b['bw^r'] - b['lw']) * m.lga_r[j])\n            m.legend_constraints.add(expr=m.x[j] + m.s * n[j] &lt;= (b['fw'] - b['bw^r'] - b['lw']) * (1 - m.lga_r[j]))\n            m.legend_constraints.add(expr=m.y[j] + m.s * n[j] &gt;= (b['fh'] - b['bw^t'] - b['lh']) * m.lga_u[j])\n            m.legend_constraints.add(expr=m.y[j] + m.s * n[j] &lt;= (b['fw'] - b['bw^t'] - b['lh']) * (1 - m.lga_u[j]))\n\n            # Enforce Legend Constraint\n            m.legend_constraints.add(expr=m.y[j] + m.s * n[j] &lt;= b['fh'] - b['bw^t'] - b['lh'] * m.lga_r[j])\n            m.legend_constraints.add(expr=m.x[j] + m.s * n[j] &lt;= b['fw'] - b['bw^r'] - b['lw'] * m.lga_u[j])\n\n        # Toggle for if we want to incorporate the \"row constraint\"\n        if b['row_constraint'] and not b['simplified_model']:\n            # y row constraints\n            m.y_row_constraints.add(\n                expr=m.y[j] == np.sum(m.lam[j, k] * (m.y_row[k] - n[j] * m.s) for k in range(b['n^rows'])))\n            m.lam_constraints.add(expr=np.sum(m.lam[j, k] for k in range(b['n^rows'])) == 1)\n\n    if b['simplified_model']:\n\n        # Pin the first AFSC to the left\n        m.grid_constraints.add(expr=m.x[0] &lt;= b['bw^l'])\n\n        # Loop through each AFSC (after the first one)\n        for j in np.arange(1, M):\n            # Add the constraints to enforce the grid\n            m.grid_constraints.add(expr=m.y[j] &lt;= m.y[j - 1] - (m.s * n[j] + b['abw^ud']) * m.q[j])\n            m.grid_constraints.add(expr=m.y[j] &gt;= m.y[j - 1] * (1 - m.q[j]))\n            m.grid_constraints.add(expr=m.x[j] &gt;= (m.x[j - 1] + m.s * n[j - 1] + b['abw^lr']) * (1 - m.q[j]))\n            m.grid_constraints.add(expr=m.x[j] &lt;= b['bw^l'] * m.q[j] +\n                                        (m.x[j - 1] + m.s * n[j - 1] + b['abw^lr']) * (1 - m.q[j]))\n\n    else:\n\n        # Loop through all AFSC \"tuples\"\n        for i, j in tuples:\n            # AFSC i is to the left of AFSC j (1) or not (0)\n            m.afsc_constraints.add(expr=m.x[j] &gt;= (m.x[i] + m.s * n[i] + b['abw^lr']) * m.a_l[i, j])\n\n            # AFSC i is to the right of AFSC j (1) or not (0)\n            m.afsc_constraints.add(expr=m.x[i] &gt;= (m.x[j] + m.s * n[j] + b['abw^lr']) * m.a_r[i, j])\n\n            # AFSC i is above AFSC j (1) or not (0)\n            m.afsc_constraints.add(expr=m.y[i] &gt;= (m.y[j] + m.s * n[j] + b['abw^ud']) * m.a_u[i, j])\n\n            # AFSC i is below AFSC j (1) or not (0)\n            m.afsc_constraints.add(expr=m.y[j] &gt;= (m.y[i] + m.s * n[i] + b['abw^ud']) * m.a_d[i, j])\n\n            # The positional relationship between AFSC i and AFSC j has to meet one of the above conditions\n            m.afsc_constraints.add(expr=m.a_l[i, j] + m.a_r[i, j] + m.a_u[i, j] + m.a_d[i, j] &gt;= 1)\n\n    return m\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.cadet_board_preprocess_model_simple","title":"<code>cadet_board_preprocess_model_simple(b)</code>","text":"<p>Builds a Pyomo optimization model to determine the x and y coordinates of AFSC squares on a chart.</p>"},{"location":"reference/solutions/optimization/#solutions.optimization.cadet_board_preprocess_model_simple--parameters","title":"Parameters:","text":"<p>b : dict     A dictionary containing configuration parameters for the model.     The dictionary should include the following key-value pairs:     - 'n^sorted' : numpy array         Sorted values of the AFSC sizes (cadet box sizes).     - 'M' : int         The number of AFSCs (cadet boxes).     - 'add_legend' : bool         Whether to include a legend box in the chart.     - 'simplified_model' : bool         Whether to use a simplified model without positional constraints.     - 'row_constraint' : bool         Whether to incorporate a row constraint for AFSCs.     - Additional bounds and constants used in the model.</p>"},{"location":"reference/solutions/optimization/#solutions.optimization.cadet_board_preprocess_model_simple--returns","title":"Returns:","text":"<p>m : ConcreteModel     The constructed Pyomo ConcreteModel instance representing the optimization model.</p>"},{"location":"reference/solutions/optimization/#solutions.optimization.cadet_board_preprocess_model_simple--notes","title":"Notes:","text":"<p>This function creates an optimization model to determine the x and y coordinates of AFSC squares (cadet boxes) on a chart. The objective is to maximize the size of the cadet boxes, which are represented by the variable 'm.s'. The model seeks to find an optimal placement of the AFSC squares while satisfying various constraints. The specific constraints and objective function formulation depend on the configuration parameters provided in the 'b' dictionary.</p> <p>The function defines decision variables for the AFSC sizes ('m.s') and the x and y coordinates of each AFSC square ('m.x' and 'm.y'). Depending on the configuration parameters, additional variables for the legend box and positional relationships between AFSCs may be included.</p> <p>Constraints are added to ensure that the AFSC squares stay within the chart borders, avoid overlapping with the legend box (if present), and meet any specified row constraints. The constraints vary based on whether the simplified model or the full model with positional relationships between AFSCs is used.</p> <p>The objective function aims to maximize the size of the cadet boxes ('m.s'), representing the objective of maximizing the visual prominence of each AFSC on the chart.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def cadet_board_preprocess_model_simple(b):\n    \"\"\"\n    Builds a Pyomo optimization model to determine the x and y coordinates of AFSC squares on a chart.\n\n    Parameters:\n    -----------\n    b : dict\n        A dictionary containing configuration parameters for the model.\n        The dictionary should include the following key-value pairs:\n        - 'n^sorted' : numpy array\n            Sorted values of the AFSC sizes (cadet box sizes).\n        - 'M' : int\n            The number of AFSCs (cadet boxes).\n        - 'add_legend' : bool\n            Whether to include a legend box in the chart.\n        - 'simplified_model' : bool\n            Whether to use a simplified model without positional constraints.\n        - 'row_constraint' : bool\n            Whether to incorporate a row constraint for AFSCs.\n        - Additional bounds and constants used in the model.\n\n    Returns:\n    --------\n    m : ConcreteModel\n        The constructed Pyomo ConcreteModel instance representing the optimization model.\n\n    Notes:\n    ------\n    This function creates an optimization model to determine the x and y coordinates of AFSC squares (cadet boxes)\n    on a chart. The objective is to maximize the size of the cadet boxes, which are represented by the variable 'm.s'.\n    The model seeks to find an optimal placement of the AFSC squares while satisfying various constraints.\n    The specific constraints and objective function formulation depend on the configuration parameters provided in the 'b' dictionary.\n\n    The function defines decision variables for the AFSC sizes ('m.s') and the x and y coordinates of each AFSC square ('m.x' and 'm.y').\n    Depending on the configuration parameters, additional variables for the legend box and positional relationships between AFSCs may be included.\n\n    Constraints are added to ensure that the AFSC squares stay within the chart borders, avoid overlapping with the legend box (if present),\n    and meet any specified row constraints. The constraints vary based on whether the simplified model or the full model with positional\n    relationships between AFSCs is used.\n\n    The objective function aims to maximize the size of the cadet boxes ('m.s'), representing the objective of maximizing the visual prominence\n    of each AFSC on the chart.\n    \"\"\"\n\n    # Initialize Model\n    m = ConcreteModel()  # Concrete model allows native numpy/python objects\n    n = b['n^sorted']  # Number of squares on edge of AFSC box (use sorted AFSCs)\n    J = np.arange(b['M'])  # Use sorted AFSCs!\n    M = len(J)\n\n    # ______________________________VARIABLE DEFINITIONS________________________________________________________\n    m.s = Var(within=NonNegativeReals)  # Size of the cadet boxes (AFSC objective value)\n    m.x = Var((j for j in J), within=NonNegativeReals)  # X coordinate of bottom left corner of AFSC j box\n    m.y = Var((j for j in J), within=NonNegativeReals)  # Y coordinate of bottom left corner of AFSC j box\n    m.q = Var((j for j in np.arange(1, M)), within=Binary)  # 1 if AFSC j is below AFSC j - 1, 0 otherwise\n\n    # ______________________________OBJECTIVE FUNCTION__________________________________________________________\n    def objective_function(m):\n        return m.s  # Objective is to maximize the size of the cadet boxes!\n\n    m.objective = Objective(rule=objective_function, sense=maximize)\n\n    # ____________________________________CONSTRAINTS___________________________________________________________\n    # Loop through each AFSC to add the border constraints\n    m.border_constraints = ConstraintList()  # List of constraints that enforce AFSCs to stay within the borders\n    m.border_constraints.add(expr=m.x[0] &lt;= b['bw^l'])  # Pin the first AFSC to the left\n    for j in J:\n        m.border_constraints.add(expr=m.x[j] &gt;= b['bw^l'])  # Left Border\n        m.border_constraints.add(expr=m.x[j] + m.s * n[j] &lt;= b['fw'] - b['bw^r'])  # Right Border\n        m.border_constraints.add(expr=m.y[j] &gt;= b['bw^b'])  # Bottom Border\n        m.border_constraints.add(expr=m.y[j] + m.s * n[j] &lt;= b['fh'] - b['bw^t'])  # Top Border\n\n    # Loop through each AFSC (after the first one) to add the grid constraints\n    m.grid_constraints = ConstraintList()  # List of constraints that line up AFSCs in a nice grid\n    for j in np.arange(1, M):\n        m.grid_constraints.add(expr=m.y[j] &lt;= m.y[j - 1] - (m.s * n[j] + b['abw^ud']) * m.q[j])\n        m.grid_constraints.add(expr=m.y[j] &gt;= m.y[j - 1] * (1 - m.q[j]))\n        m.grid_constraints.add(expr=m.x[j] &gt;= (m.x[j - 1] + m.s * n[j - 1] + b['abw^lr']) * (1 - m.q[j]))\n        m.grid_constraints.add(expr=m.x[j] &lt;= b['bw^l'] * m.q[j] +\n                                    (m.x[j - 1] + m.s * n[j - 1] + b['abw^lr']) * (1 - m.q[j]))\n    return m\n</code></pre>"},{"location":"reference/solutions/optimization/#solutions.optimization.solve_cadet_board_model_direct_from_board_parameters","title":"<code>solve_cadet_board_model_direct_from_board_parameters(instance, filepath)</code>","text":"<p>Solve the cadet board animation model using the provided instance parameters and save the results to a CSV file.</p>"},{"location":"reference/solutions/optimization/#solutions.optimization.solve_cadet_board_model_direct_from_board_parameters--parameters","title":"Parameters:","text":"<p>instance : object     An instance of the cadet board animation model.     The instance should contain the necessary model parameters in the 'mdl_p' attribute.     These parameters include board configuration details, such as size ratios, border widths, legend dimensions, etc.</p> <p>filepath : str     The file path where the results will be saved as a CSV file.     The file should have write permissions.</p>"},{"location":"reference/solutions/optimization/#solutions.optimization.solve_cadet_board_model_direct_from_board_parameters--returns","title":"Returns:","text":"<p>None</p>"},{"location":"reference/solutions/optimization/#solutions.optimization.solve_cadet_board_model_direct_from_board_parameters--notes","title":"Notes:","text":"<p>This function solves the cadet board animation model using the provided instance parameters. The instance parameters should include the necessary configuration details for the model, such as board dimensions, size ratios, solver information, etc.</p> <p>The function first initializes the board parameters ('b') by extracting them from the instance object. It calculates additional parameters, such as the figure height, border widths, AFSC border/buffer widths, and legend dimensions.</p> <p>The function then loads the AFSC data from a CSV file specified by the 'filepath' parameter. It assumes that the data is already sorted by the 'n' column.</p> <p>Next, the function creates the Pyomo optimization model using the 'cadet_board_preprocess_model' function, passing the board parameters ('b') as arguments.</p> <p>The solver executable path is set based on the 'b_solver_name' parameter from the board parameters ('b').</p> <p>The model is solved using the specified solver, and the solution time is printed.</p> <p>Finally, the x, y, and s (size) values from the solved model are extracted and stored in the AFSC dataframe. The updated dataframe is then saved to the specified CSV file.</p> Source code in <code>afccp/solutions/optimization.py</code> <pre><code>def solve_cadet_board_model_direct_from_board_parameters(instance, filepath):\n    \"\"\"\n    Solve the cadet board animation model using the provided instance parameters and save the results to a CSV file.\n\n    Parameters:\n    -----------\n    instance : object\n        An instance of the cadet board animation model.\n        The instance should contain the necessary model parameters in the 'mdl_p' attribute.\n        These parameters include board configuration details, such as size ratios, border widths, legend dimensions, etc.\n\n    filepath : str\n        The file path where the results will be saved as a CSV file.\n        The file should have write permissions.\n\n    Returns:\n    --------\n    None\n\n    Notes:\n    ------\n    This function solves the cadet board animation model using the provided instance parameters.\n    The instance parameters should include the necessary configuration details for the model, such as board dimensions, size ratios, solver information, etc.\n\n    The function first initializes the board parameters ('b') by extracting them from the instance object.\n    It calculates additional parameters, such as the figure height, border widths, AFSC border/buffer widths, and legend dimensions.\n\n    The function then loads the AFSC data from a CSV file specified by the 'filepath' parameter.\n    It assumes that the data is already sorted by the 'n' column.\n\n    Next, the function creates the Pyomo optimization model using the 'cadet_board_preprocess_model' function,\n    passing the board parameters ('b') as arguments.\n\n    The solver executable path is set based on the 'b_solver_name' parameter from the board parameters ('b').\n\n    The model is solved using the specified solver, and the solution time is printed.\n\n    Finally, the x, y, and s (size) values from the solved model are extracted and stored in the AFSC dataframe.\n    The updated dataframe is then saved to the specified CSV file.\n    \"\"\"\n\n    # Initialize b\n    b = instance.mdl_p\n\n    # Figure Height\n    b['fh'] = b['fw'] * b['fh_ratio']\n\n    # Border Widths\n    for i in ['t', 'l', 'r', 'b', 'u']:\n        b['bw^' + i] = b['fw'] * b['bw^' + i + '_ratio']\n\n    # AFSC border/buffer widths\n    b['abw^lr'] = b['fw'] * b['abw^lr_ratio']\n    b['abw^ud'] = b['fw'] * b['abw^ud_ratio']\n\n    # Legend width/height\n    if b['add_legend']:\n        b['lw'] = b['fw'] * b['lw_ratio']\n        b['lh'] = b['fw'] * b['lh_ratio']\n    else:\n        b['lw'], b['lh'] = 0, 0\n\n    # Load in \"b_df\"\n    b_df = afccp.globals.import_csv_data(filepath)\n\n    # We assume this dataframe is already sorted by 'n'\n    b['n^sorted'] = np.array(b_df['n'])\n    b['M'] = len(b['n^sorted'])\n\n    # Create model\n    model = cadet_board_preprocess_model(b)\n\n    # Get executable\n    b[\"executable\"] = afccp.globals.paths['solvers'] + b[\"b_solver_name\"]\n\n    # Solve Model\n    print('Solving CadetBoard Model instance with solver ' + b[\"b_solver_name\"] + '...')\n    start_time = time.perf_counter()\n    solver = SolverFactory(b[\"b_solver_name\"], executable=b[\"executable\"])\n    solver.solve(model)\n    print(\"Model solved in\", round(time.perf_counter() - start_time, 2), \"seconds.\")\n\n    # Get the values from the model and return them\n    x, y, s = [], [], model.s.value\n    for j in range(b['M']):\n        x.append(model.x[j].value)\n        y.append(model.y[j].value)\n\n    # Load values back into dataframe\n    b_df['x'], b_df['y'], b_df['s'] = x, y, s\n\n    # Export to csv\n    b_df.to_csv(filepath, index=False)\n</code></pre>"},{"location":"reference/solutions/sensitivity/","title":"Sensitivity","text":""},{"location":"reference/solutions/sensitivity/#solutions.sensitivity","title":"<code>solutions.sensitivity</code>","text":""},{"location":"reference/solutions/sensitivity/#solutions.sensitivity.determine_model_constraints","title":"<code>determine_model_constraints(instance)</code>","text":"<p>Iteratively evaluate the VFT (Value Focussed Thinking) model by adding constraints until a feasible solution is obtained, in order of importance.</p> <p>This function takes a problem instance containing parameters and value parameters as input. It starts with no constraints activated and gradually adds constraints in order of their importance. The function builds and solves the VFT model at each constraint iteration, evaluating the feasibility and objective value of the solution. The process continues until all constraints have been considered.</p> <p>Args:     instance (ProblemInstance): An instance of the problem containing the problem parameters and value parameters.</p> <p>Returns:     A tuple containing:         - constraint_type (ndarray): The adjusted constraint type matrix, indicating the active constraints.         - solutions_df (DataFrame): A DataFrame with the solutions for different constraint iterations.         - report_df (DataFrame): A DataFrame containing the report of each constraint iteration, including information                                  about the solution, the new constraint applied, the objective value, and if the solution                                  failed or not.</p> Source code in <code>afccp/solutions/sensitivity.py</code> <pre><code>def determine_model_constraints(instance):\n    \"\"\"\n    Iteratively evaluate the VFT (Value Focussed Thinking) model by adding constraints until a feasible solution is obtained,\n    in order of importance.\n\n    This function takes a problem instance containing parameters and value parameters as input. It starts with no constraints\n    activated and gradually adds constraints in order of their importance. The function builds and solves the VFT model at each\n    constraint iteration, evaluating the feasibility and objective value of the solution. The process continues until all\n    constraints have been considered.\n\n    Args:\n        instance (ProblemInstance): An instance of the problem containing the problem parameters and value parameters.\n\n    Returns:\n        A tuple containing:\n            - constraint_type (ndarray): The adjusted constraint type matrix, indicating the active constraints.\n            - solutions_df (DataFrame): A DataFrame with the solutions for different constraint iterations.\n            - report_df (DataFrame): A DataFrame containing the report of each constraint iteration, including information\n                                     about the solution, the new constraint applied, the objective value, and if the solution\n                                     failed or not.\n    \"\"\"\n\n    # Shorthand\n    p, vp, ip = instance.parameters, copy.deepcopy(instance.value_parameters), instance.mdl_p\n\n    # Create a copy of the problem instance\n    adj_instance = copy.deepcopy(instance)  # \"Adjusted Instance\"\n    real_constraint_type = copy.deepcopy(vp[\"constraint_type\"])  # All constraints (Not 0s)\n\n    # Initially, we'll start with no constraints turned on\n    vp[\"constraint_type\"] = np.zeros([p[\"M\"], vp[\"O\"]])\n    vp['K^C'] = {j: np.array([]) for j in p['J']}\n    adj_instance.value_parameters = vp  # Set to instance\n\n    # Initialize Report\n    report_columns = [\"Solution\", \"New Constraint\", \"Objective Value\", \"Failed\"]\n    report = {col: [] for col in report_columns}\n\n    # Determine which model we're going to solve (either VFT or Assignment model)\n    if ip['constraint_model_to_use'] == 'VFT':\n        print(\"Initializing VFT Model Constraint Algorithm...\")\n\n        # Build the model\n        model, q = afccp.solutions.optimization.vft_model_build(adj_instance)\n        model_name, obj_metric = 'VFT', 'z'\n\n    else:  # Assignment model\n        print(\"Initializing Assignment Model Constraint Algorithm...\")\n\n        # Build the model\n        adj_instance.mdl_p['assignment_model_obj'] = 'Global Utility'  # Force the correct objective function\n        model, q = afccp.solutions.optimization.assignment_model_build(adj_instance), None\n        model_name, obj_metric = 'Assignment', 'z^gu'\n    print(\"Done. Solving model with no constraints active...\")\n\n    # Dictionary of solutions with different constraints!\n    current_solution = afccp.solutions.optimization.solve_pyomo_model(\n        adj_instance, model, model_name, q=q, printing=False)\n    solutions = {0: current_solution}\n    current_solution = afccp.solutions.handling.evaluate_solution(current_solution, p, vp)\n    afsc_solutions = {0: current_solution['afsc_array']}\n\n    # Add first solution to the report\n    report[\"Solution\"].append(0)\n    report[\"Objective Value\"].append(round(current_solution[obj_metric], 4))\n    report[\"New Constraint\"].append(\"None\")\n    report[\"Failed\"].append(0)\n    print(\"Done. New solution objective value:\", str(report[\"Objective Value\"][0]))\n\n    # Get importance \"list\" based on multiplied weight\n    afsc_weight = np.atleast_2d(vp[\"afsc_weight\"]).T  # Turns 1d array into 2d column\n    scaled_weights = afsc_weight * vp[\"objective_weight\"]\n    flat = np.ndarray.flatten(scaled_weights)  # flatten them\n    tuples = [(j, k) for j in range(p['M']) for k in range(vp['O'])]  # get a list of tuples (0, 0), (0, 1) etc.\n    tuples = np.array(tuples)\n    sort_flat = np.argsort(flat)[::-1]\n    importance_list = [(j, k) for (j, k) in tuples[sort_flat] if real_constraint_type[j, k] != 0]\n    num_constraints = len(importance_list)\n\n    # Begin the algorithm!\n    cons = 0\n    print(\"Running through \" + str(num_constraints) + \" total constraint iterations...\")\n    for (j, k) in importance_list:\n        afsc = p[\"afscs\"][j]\n        objective = vp[\"objectives\"][k]\n\n        # Make a copy of the model (In case we have to remove a constraint)\n        new_model = copy.deepcopy(model)\n\n        # Calculate AFSC objective measure components\n        measure, numerator = afccp.solutions.handling.calculate_objective_measure_matrix(\n            new_model.x, j, objective, p, vp, approximate=True)\n\n        # Add AFSC objective measure constraint\n        vp['constraint_type'][j, k] = copy.deepcopy(real_constraint_type[j, k])\n        new_model = afccp.solutions.optimization.add_objective_measure_constraint(\n            new_model, j, k, measure, numerator, p, vp)\n        num_measure_constraints = len(new_model.measure_constraints)\n\n        # Update constraint type within the problem instance\n        adj_instance.value_parameters['constraint_type'][j, k] = copy.deepcopy(real_constraint_type[j, k])\n\n        # Print message\n        cons += 1\n        print_str = \"\\n------[\" + str(cons) + \"] AFSC \" + afsc + \" Objective \" + objective\n        print_str += \"-\" * (55 - len(print_str))\n        print(print_str)\n\n        # Loop through each of the constraints to validate how many are on\n        num_activated = 0\n        for i in list(new_model.measure_constraints):\n            if new_model.measure_constraints[i].active:\n                num_activated += 1\n        print(\"Constraint\", cons, \"Active Constraints:\", int(num_measure_constraints / 2),\n                               \"Validated:\", int(num_activated / 2))\n\n        # Variable to determine the outcome of this iteration\n        feasible = True  # Assume model is feasible until proven otherwise\n\n        # We can skip the quota constraint (leave it on without solving)\n        if objective == \"Combined Quota\" and ip[\"skip_quota_constraint\"]:\n            print(\"Result: SKIPPED [Combined Quota]\")\n            solutions[cons] = copy.deepcopy(current_solution)\n            skipped_obj = True\n\n        # If our most current solution is already meeting this constraint, then we can skip this constraint\n        elif vp['objective_min'][j, k] &lt;= current_solution[\"objective_measure\"][j, k] &lt;= vp['objective_max'][j, k]:\n            print(\"Result: SKIPPED [Measure:\", str(round(current_solution[\"objective_measure\"][j, k], 2)) + \"], \",\n                  \"Range: (\" + str(vp['objective_min'][j, k]) +\",\", str(vp['objective_max'][j, k]) + \")\")\n            solutions[cons] = copy.deepcopy(current_solution)\n            skipped_obj = True\n\n        # We can't skip the constraint, so we solve it\n        else:\n            skipped_obj = False\n\n            # Solution Solved!\n            try:\n                solutions[cons] = copy.deepcopy(afccp.solutions.optimization.solve_pyomo_model(\n                    adj_instance, new_model, model_name, q=q, printing=False))\n\n            # Solution Failed :(\n            except:\n                solutions[cons] = copy.deepcopy(current_solution)\n                feasible = False\n\n        # Get solution information\n        current_solution = copy.deepcopy(solutions[cons])\n        current_solution = copy.deepcopy(afccp.solutions.handling.evaluate_solution(current_solution, p, vp))\n        afsc_solutions[cons] = copy.deepcopy(current_solution['afsc_array'])\n\n        # Add this solution to report\n        report[\"Solution\"].append(cons)\n        report[\"New Constraint\"].append(afsc + \" \" + objective)\n\n        if feasible:\n            report[\"Objective Value\"].append(round(current_solution[obj_metric], 4))\n            if not skipped_obj:\n                print(\"Result: SOLVED [Z = \" + str(report[\"Objective Value\"][cons]) + \"]\")\n            report[\"Failed\"].append(0)\n            model = copy.deepcopy(new_model)  # Save this model!\n\n        else:\n            print(\"Result: INFEASIBLE. Proceeding with next constraint.\")\n            report[\"Objective Value\"].append(0)\n            report[\"Failed\"].append(1)\n\n            # Update constraint type within the problem instance (Remove this constraint)\n            vp[\"constraint_type\"][j, k] = 0\n\n        # Measure it again\n        current_solution = copy.deepcopy(afccp.solutions.handling.evaluate_solution(current_solution, p, vp))\n\n        # Validate solution meets the constraints:\n        num_constraint_check = np.sum(vp[\"constraint_type\"] != 0)\n        print(\"Active Objective Measure Constraints:\", num_constraint_check)\n        print(\"Total Failed Constraints:\", int(current_solution[\"total_failed_constraints\"]))\n        print(\"Current Objective Measure:\", round(current_solution[\"objective_measure\"][j, k], 2), \"Range:\",\n              vp[\"objective_value_min\"][j, k])\n\n        for con_fail_str in current_solution[\"failed_constraints\"]:\n            print(\"Failed:\", con_fail_str)\n\n        # Check all other AFSC objectives to see if we're suddenly failing them now for some reason\n        c = 0\n        measure_fails = 0\n        while c &lt; cons:\n            j_1, k_1 = importance_list[c]\n            afsc_1, objective_1 = p[\"afscs\"][j_1], vp[\"objectives\"][k_1]\n            if current_solution[\"objective_measure\"][j_1, k_1] &gt; (vp['objective_max'][j_1, k_1] * 1.05) or \\\n                    current_solution[\"objective_measure\"][j_1, k_1] &lt; (vp['objective_min'][j_1, k_1] * 0.95):\n                print(\"Measure Fail:\", afsc_1, objective_1, \"Measure:\",\n                      round(current_solution[\"objective_measure\"][j_1, k_1], 2), \"Range:\",\n                      vp[\"objective_value_min\"][j_1, k_1])\n                measure_fails += 1\n            c += 1\n        print_str = \"-\" * 10 + \" Objective Measure Fails:\" + str(measure_fails)\n        print(print_str + \"-\" * (55 - len(print_str)))\n\n    # Build Report\n    solutions_df = pd.DataFrame(afsc_solutions)\n    report_df = pd.DataFrame(report)\n    return vp[\"constraint_type\"], solutions_df, report_df\n</code></pre>"},{"location":"reference/solutions/sensitivity/#solutions.sensitivity.populate_initial_ga_solutions_from_vft_model","title":"<code>populate_initial_ga_solutions_from_vft_model(instance, printing=True)</code>","text":"<p>This function takes a problem instance and creates several initial solutions for the genetic algorithm to evolve from</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <p>problem instance</p> required <code>printing</code> <p>whether to print something or not</p> <code>True</code> <p>Returns:</p> Type Description <p>initial population</p> Source code in <code>afccp/solutions/sensitivity.py</code> <pre><code>def populate_initial_ga_solutions_from_vft_model(instance, printing=True):\n    \"\"\"\n    This function takes a problem instance and creates several initial solutions for the genetic algorithm to evolve\n    from\n    :param instance: problem instance\n    :param printing: whether to print something or not\n    :return: initial population\n    \"\"\"\n\n    if printing:\n        print(\"Generating initial population of solutions for the genetic algorithm from the approximate VFT model...\")\n\n    # Load parameters/variables\n    p, vp = instance.parameters, copy.deepcopy(instance.value_parameters)\n    previous_estimate = p[\"quota_e\"]\n    initial_solutions = []\n\n    # We get our first round of solutions by iterating on the estimated number of cadets\n    if instance.mdl_p[\"iterate_from_quota\"]:\n\n        # Initialize variables\n        deviations = np.ones(p[\"M\"])\n        quota_k = np.where(vp[\"objectives\"] == 'Combined Quota')[0][0]\n        i = 1\n        while sum(deviations) &gt; 0:\n\n            if printing:\n                print(\"\\nSolving VFT model... (\" + str(i) + \")\")\n\n            # Set the current estimated number of cadets\n            current_estimate = p[\"quota_e\"]\n\n            try:\n\n                # Build &amp; solve the VFT model\n                model, q = vft_model_build(instance)\n                solution = solve_pyomo_model(instance, model, \"VFT\", q=q, printing=False)\n                solution = afccp.solutions.handling.evaluate_solution(solution, p, vp)\n                initial_solutions.append(solution['j_array'])\n\n                # Save this estimate for quota\n                previous_estimate = current_estimate\n\n                # Update new quota information (based on the number of cadets assigned from this solution)\n                instance.parameters[\"quota_e\"] = solution[\"objective_measure\"][:, quota_k].astype(int)\n\n                # Validate the estimated number is within the appropriate range\n                for j in p[\"J\"]:\n\n                    # Reset the parameter if necessary\n                    if instance.parameters[\"quota_e\"][j] &lt; p[\"quota_min\"][j]:\n                        instance.parameters[\"quota_e\"][j] = p[\"quota_min\"][j]\n                    elif instance.parameters[\"quota_e\"][j] &gt; p[\"quota_max\"][j]:\n                        instance.parameters[\"quota_e\"][j] = p[\"quota_max\"][j]\n\n                # Calculate deviations and proceed with next iteration\n                p = instance.parameters\n                deviations = [abs(p[\"quota_e\"][j] - current_estimate[j]) for j in p[\"J\"]]\n                i += 1\n\n                if printing:\n                    print(\"Current Number of Quota Differences:\", sum(deviations), \"with objective value of\",\n                          round(solution[\"z\"], 4))\n\n                # Don't solve this thing too many times (other stopping conditions)\n                if i &gt; instance.mdl_p[\"max_quota_iterations\"]:\n                    break\n\n            except:\n\n                if printing:\n                    print(\"Something went wrong with this iteration, proceeding with overall weight technique...\")\n\n                # Revert to the previous quota estimate\n                instance.parameters[\"quota_e\"] = previous_estimate\n                break\n\n    # Solve for different overall weights on cadets/AFSCs\n    weights = np.arange(instance.mdl_p[\"population_additions\"])\n    weights = weights / np.max(weights)\n    for w in weights:\n\n        if printing:\n            print(\"\\nSolving VFT model with 'w' of \", str(round(w, 2)) + \"...\")\n\n        # Update overall weights\n        instance.value_parameters[\"cadets_overall_weight\"] = w\n        instance.value_parameters[\"afscs_overall_weight\"] = 1 - w\n\n        # Solve model\n        try:\n\n            # Build &amp; solve the model\n            model, q = vft_model_build(instance)\n            solution = solve_pyomo_model(instance, model, \"VFT\", q=q, printing=False)\n            solution = afccp.solutions.handling.evaluate_solution(solution, p, vp)\n            initial_solutions.append(solution['j_array'])\n\n            if printing:\n                print(\"Objective value of\", round(solution[\"z\"], 4), \"obtained\")\n        except:\n\n            if printing:\n                print(\"Failed to solve. Going to next iteration...\")\n\n    instance.value_parameters = vp\n    return np.array(initial_solutions)\n</code></pre>"},{"location":"reference/solutions/sensitivity/#solutions.sensitivity.populate_initial_ga_solutions_from_assignment_model","title":"<code>populate_initial_ga_solutions_from_assignment_model(instance, printing=True)</code>","text":"<p>This function generates several initial solutions for the genetic algorithm to evolve from using the new and improved Assignment Problem Model as a heuristic</p> Source code in <code>afccp/solutions/sensitivity.py</code> <pre><code>def populate_initial_ga_solutions_from_assignment_model(instance, printing=True):\n    \"\"\"\n    This function generates several initial solutions for the genetic algorithm to evolve from using the\n    *new and improved* Assignment Problem Model as a heuristic\n    \"\"\"\n\n    if printing:\n        print(\"Generating initial population of solutions for the genetic algorithm from the approximate VFT model...\")\n\n    # Force the correct objective function\n    instance.mdl_p['assignment_model_obj'] = 'Global Utility'\n\n    # Load parameters/variables\n    p, vp = instance.parameters, copy.deepcopy(instance.value_parameters)\n    initial_solutions = []\n\n    # Solve using different \"global utility\" matrices calculated from different overall weights on cadets/AFSCs\n    weights = np.arange(instance.mdl_p[\"population_additions\"])\n    weights = weights / np.max(weights)\n    for w in weights:\n\n        if printing:\n            print(\"\\nSolving assignment model with 'w' of \", str(round(w, 2)) + \"...\")\n\n        # Update global utility matrix\n        instance.value_parameters['global_utility'] = np.zeros([p['N'], p['M'] + 1])\n        for j in p['J']:\n            instance.value_parameters['global_utility'][:, j] = w * p['cadet_utility'][:, j] + \\\n                                                                (1 - w) * p['afsc_utility'][:, j]\n\n        # Solve model\n        try:\n\n            # Build &amp; solve the model\n            model = assignment_model_build(instance)\n            solution = solve_pyomo_model(instance, model, \"Assignment\", printing=False)\n            solution = afccp.solutions.handling.evaluate_solution(solution, p, vp)\n            initial_solutions.append(solution['j_array'])\n\n            if printing:\n                print(\"Objective value of\", round(solution[\"z\"], 4), \"obtained\")\n        except:\n\n            if printing:\n                print(\"Failed to solve. Going to next iteration...\")\n\n    instance.value_parameters = vp\n    return np.array(initial_solutions)\n</code></pre>"},{"location":"reference/solutions/sensitivity/#solutions.sensitivity.optimization_what_if_analysis","title":"<code>optimization_what_if_analysis(instance, printing=True)</code>","text":"<p>This function takes in an AFSC/cadet problem instance and performs some \"What If\" analysis based on the items listed in \"What If List.csv\". We manipulate the \"value parameters\" to meet these pre-defined conditions and then evaluate the model with the new constraints. We can then create a pareto frontier by modifying the weights on cadets/AFSCs. These results are all exported to a sub-folder called \"What If\" in the Analysis &amp; Results folder.</p> Source code in <code>afccp/solutions/sensitivity.py</code> <pre><code>def optimization_what_if_analysis(instance, printing=True):\n    \"\"\"\n    This function takes in an AFSC/cadet problem instance and performs some \"What If\" analysis based on the items listed\n    in \"What If List.csv\". We manipulate the \"value parameters\" to meet these pre-defined conditions and then evaluate\n    the model with the new constraints. We can then create a pareto frontier by modifying the weights on cadets/AFSCs.\n    These results are all exported to a sub-folder called \"What If\" in the Analysis &amp; Results folder.\n    \"\"\"\n\n    # Shorthand\n    p, vp, mdl_p = instance.parameters, instance.value_parameters, instance.mdl_p\n\n    # Import dataframe\n    df = afccp.globals.import_csv_data(instance.export_paths['Analysis &amp; Results'] + \"What If List.csv\")\n\n    # Make sure the first name is in the solutions dictionary\n    if df.loc[0, 'Name'] not in instance.solutions:\n        raise ValueError(\"Error. Constraint name '\" + df.loc[0, 'Name'] + \"' is the baseline solution and is currently\"\n                                                                          \" not in the solutions dictionary.\")\n\n    # Get baseline solution and evaluate it\n    baseline = instance.solutions[df.loc[0, 'Name']]\n    baseline = afccp.solutions.handling.evaluate_solution(baseline, p, vp)\n\n    # Dictionary of metric column names and their associated variable name in the solution dictionary\n    metrics_dictionary = {'Effect on Global Utility': 'z^gu', 'Effect on Cadet Utility': 'cadet_utility_overall',\n                          'Effect on AFSC Utility': 'afsc_utility_overall',\n                          'Effect on USAFA Cadet Utility': 'usafa_cadet_utility',\n                          'Effect on ROTC Cadet Utility': 'rotc_cadet_utility',\n                          'Effect on USSF Cadet Utility': 'ussf_cadet_utility',\n                          'Effect on USAF Cadet Utility': 'usaf_cadet_utility',\n                          'Effect on USSF AFSC Utility': 'ussf_afsc_utility',\n                          'Effect on USAF AFSC Utility': 'usaf_afsc_utility',\n                          'Effect on USSF AFSC Norm Score': 'weighted_average_ussf_afsc_score',\n                          'Effect on USAF AFSC Norm Score': 'weighted_average_usaf_afsc_score'}\n\n    # Dictionary of AFSC solutions\n    afsc_solutions = {}\n\n    # Loop through each constraint type\n    names, con = np.array(df['Name']), 0\n    for name in names[1:]:  # Skip the baseline\n        con += 1  # Next constraint iteration (skips baseline too)\n        c_vp = copy.deepcopy(vp)  # set of value parameters for this constraint iteration\n\n        # Print statement\n        if printing:\n            print('Iteration', con, name)\n\n        # If we don't want to re-calculate something we can skip it\n        if not df.loc[con, 'Calculate']:\n            print(\"Skipped\")\n            continue\n\n        # Set the appropriate value parameters for this iteration\n        if name == 'Unconstrained':  # Turn off all the AFSC objective constraints\n            c_vp['constraint_type'] = np.zeros([p['M'], vp['O']])\n\n            # Turn off cadet constraints\n            c_vp['cadet_value_min'] = np.zeros(p['N'])\n\n        elif name == 'PGL Only':  # Turn of all the AFSC objective constraints except PGL\n            c_vp['constraint_type'] = np.zeros([p['M'], vp['O']])\n\n            # Turn on PGL constraints\n            k = np.where(vp['objectives'] == 'Combined Quota')[0][0]\n            c_vp['constraint_type'][:, k] = np.ones(p['M']) * 2\n\n            # Turn off cadet constraints\n            c_vp['cadet_value_min'] = np.zeros(p['N'])\n\n        elif 'Top 10 First Choice' in name:  # Cadets from the top 10% of the class need to get first choice\n\n            if \"Replace\" in name:  # Do we add these constraints on top of current cadet value constraints?\n\n                # Turn off current cadet constraints\n                c_vp['cadet_value_min'] = np.zeros(p['N'])\n\n            # Constrained slots\n            constrained_slots = np.zeros(p['M'])\n\n            # Need an algorithm to see which constraints are possible based on GOM\n            sorted_cadets = np.argsort(p['merit'])[::-1]\n            for i in sorted_cadets:\n\n                # Once we're passed the top 10% we're done\n                if p['merit'][i] &lt; 0.9:\n                    break\n\n                # Loop through choices until we find one under capacity\n                for choice in [0, 1, 2, 3]:\n                    j = p['cadet_preferences'][i][choice]\n\n                    # Only constrain this preference if we're under constrained capacity\n                    if constrained_slots[j] &lt; p['pgl'][j]:\n\n                        # Constrain the utility of this preference\n                        utility = p['cadet_utility'][i, j]\n                        c_vp['cadet_value_min'][i] = utility\n\n                        # Increment constrained slots by one\n                        constrained_slots[j] += 1\n\n                        # Break out of this choice\n                        break\n\n        elif name == \"USSF OM\":  # Turn on USSF OM constraint\n            c_vp[\"USSF OM\"] = True\n\n        elif name == \"Strict AFOCD M Tier\":  # Turn on mandatory AFOCD constraints\n\n            # Loop through each degree tier to find AFSCs that have mandatory degree tier requirements\n            for t in [0, 1, 2, 3]:\n                j_indices = np.where(p[\"t_mandatory\"][:, t])[0]\n                vp['constraint_type'][j_indices] = 1  # Turn on these constraints\n\n        else:  # Skip the rest of this loop\n            print(\"Skipped\")\n            df.loc[con, \"Result\"] = \"Skipped\"\n            continue\n\n        # Set of constrained objectives for each AFSC\n        c_vp['K^C'] = {}  # constrained objectives\n        for j in p[\"J\"]:\n            c_vp['K^C'][j] = np.where(c_vp['constraint_type'][j, :] &gt; 0)[0].astype(int)\n\n        # Create a duplicate instance and set its value parameters\n        c_instance = copy.deepcopy(instance)\n        c_instance.value_parameters = copy.deepcopy(c_vp)\n\n        # Solve the model\n        model = afccp.solutions.optimization.assignment_model_build(c_instance)\n\n        # Check for feasibility\n        try:\n\n            # Solve model and get solution\n            solution = afccp.solutions.optimization.solve_pyomo_model(c_instance, model, 'Assignment',\n                                                                      printing=printing)\n            solution = afccp.solutions.handling.evaluate_solution(solution, p, c_vp)\n            afsc_solutions[name] = copy.deepcopy(solution['afsc_array'])\n\n            # Calculate metrics\n            for key, value in metrics_dictionary.items():\n                df.loc[con, key] = solution[value] - baseline[value]\n\n            # It was feasible!\n            df.loc[con, \"Result\"] = \"Feasible\"\n\n            if printing:\n                print(\"Feasible :)\")\n\n        except:\n\n            # Empty solution\n            afsc_solutions[name] = np.array([\"*\" for _ in p['I']])\n\n            # It was infeasible!\n            df.loc[con, \"Result\"] = \"Infeasible\"\n\n            if printing:\n                print(\"Infeasible :(\")\n\n    # Export main dataframe\n    df.to_csv(instance.export_paths['Analysis &amp; Results'] + \"What If List.csv\", index=False)\n\n    # Create and export solutions dataframe\n    solution_df = pd.DataFrame(afsc_solutions)\n    solution_df.to_csv(instance.export_paths['Analysis &amp; Results'] + \"What If Solutions.csv\", index=False)\n</code></pre>"},{"location":"reference/solutions/sensitivity/#solutions.sensitivity.solve_pgl_capacity_sensitivity","title":"<code>solve_pgl_capacity_sensitivity(instance, p_dict={}, printing=True)</code>","text":"<p>Doc string here</p> Source code in <code>afccp/solutions/sensitivity.py</code> <pre><code>def solve_pgl_capacity_sensitivity(instance, p_dict={}, printing=True):\n    \"\"\"\n    Doc string here\n    \"\"\"\n\n    def alter_quota_max(done_iterating):\n        \"\"\"\n\n        :return:\n        \"\"\"\n\n        # Determine which AFSCs were most over quota\n        count = instance.solution['count']\n        surplus = count - p['pgl']\n        percentage = count / p['pgl']\n\n        # Determine which AFSC to alter\n        sorted_afscs = np.argsort(percentage)[::-1]\n        for j in sorted_afscs:\n\n            # If we're already at our \"true max\", pick the next AFSC in the list\n            if count[j] &lt;= true_max[j]:\n                continue\n\n            # Calculate what the new max should be\n            new_max_val = np.floor(p['pgl'][j] + surplus[j] / 2)\n\n            # If the difference is small enough, skip straight to true max\n            difference = count[j] - new_max_val\n            if difference &lt;= 5:\n                new_max_val = true_max[j]\n\n            # If this would put the maximum under the \"true maximum\", force it to be the true maximum\n            if new_max_val &lt; true_max[j]:\n                new_max_val = true_max[j]\n\n            # Set the new maximum value for this AFSC\n            if p['quota_max'][j] == new_max_val:\n                print(\"Iterations complete.\")\n                done_iterating = True\n            else:\n                p['quota_max'][j] = new_max_val\n\n            # Break out of the loop\n            break\n\n        return done_iterating\n\n    # Shorthand\n    p, vp, mdl_p = instance.parameters, instance.value_parameters, instance.mdl_p\n\n    # Make the main directory if needed\n    folder_path = instance.export_paths['Analysis &amp; Results']\n    if \"PGL Sensitivity Analysis\" not in os.listdir(folder_path):\n        os.mkdir(folder_path + '/' + 'PGL Sensitivity Analysis')\n    folder_path += '/' + 'PGL Sensitivity Analysis/'\n\n    # Adjust the chart settings\n    p_dict[\"objective\"] = \"Combined Quota\"\n    p_dict[\"version\"] = \"quantity_bar\"\n    p_dict['macro_chart_kind'] = 'AFSC Chart'\n    p_dict['save'] = False\n\n    # Get contents of folder to determine sub-folder this analysis will be in\n    folder = os.listdir(folder_path)\n\n    # Settings for max quotas\n    true_max = copy.deepcopy(p['quota_max'])\n\n    # If we are starting where we left off and have provided a valid Analysis folder, we import there\n    if mdl_p['import_pgl_analysis_folder'] in folder:\n        sub_folder_name = mdl_p['import_pgl_analysis_folder']\n        folder_path += sub_folder_name + \"/\"\n\n        # Print statement\n        if printing:\n            print(\"Conducting PGL sensitivity analysis on this problem instance \"\n                  \"from imported '\" + sub_folder_name + \"'...\")\n\n        # Import dataframes\n        capacities_df = pd.read_csv(folder_path + \"Capacities.csv\")\n        solutions_df = pd.read_csv(folder_path + \"Solutions.csv\")\n\n        # Load dictionaries\n        capacities_dict = {int(col): np.array(capacities_df[col]) for col in capacities_df}\n        solutions_dict = {int(col): np.array(solutions_df[col]) for col in solutions_df}\n\n        # Determine what our last iteration was\n        iteration = len(capacities_df.columns) - 1\n\n        # Set initial quota_max\n        p['quota_max'] = capacities_dict[iteration]\n\n        # Add the current solution to the instance\n        instance.add_solution(solutions_dict[iteration])\n\n        # Process that solution to get new quota max\n        alter_quota_max(done_iterating=False)\n\n        # Set the iterations\n        iteration += 1\n        iterations = np.arange(iteration, iteration + mdl_p['num_pgl_analysis_iterations'])\n\n    # If we are starting from scratch, create the new analysis folder and start that way\n    else:\n\n        # Crate the new folder\n        name_determined, i = False, 1\n        while not name_determined:\n            sub_folder_name = \"Analysis \" + str(i)\n            if sub_folder_name not in folder:\n                folder_path += sub_folder_name + \"/\"\n                os.mkdir(folder_path)  # Make the folder\n                name_determined = True\n            else:\n                i += 1\n\n        # Print statement\n        if printing:\n            print(\"Conducting PGL sensitivity analysis on this problem instance \"\n                  \"using new '\" + sub_folder_name + \"'...\")\n\n        # Set essentially no maximum value for each AFSC at the beginning\n        p['quota_max'] = np.array([1000 if j in p['J^NRL'] else p['quota_max'][j] for j in p['J']])\n\n        # Create dictionaries of solution/capacity arrays\n        solutions_dict, capacities_dict = {},{}\n\n        # Set the iterations\n        iterations = np.arange(mdl_p['num_pgl_analysis_iterations'])\n\n    # Loop through each iteration\n    done_iterating = False\n    for iteration in iterations:\n\n        # Update the value parameters with the new quota max\n        instance.update_value_parameters()\n\n        # Run the model\n        if printing:\n            print(\"\\n\\nSolving iteration\", iteration, \"with capacities\", p['quota_max'])\n        instance.solve_guo_pyomo_model(p_dict, printing=True)\n\n        # Save solution and capacities information\n        capacities_dict[iteration] = copy.deepcopy(p['quota_max'])\n        solutions_dict[iteration] = instance.solution['afsc_array']\n\n        # Process the solution\n        done_iterating = alter_quota_max(done_iterating)\n\n        # If we're done iterating, stop. Otherwise, build the chart\n        if done_iterating:\n            break\n        else:\n\n            # Save dataframes at each step\n            print(\"Saving dataframes..\")\n            capacities_df = pd.DataFrame(capacities_dict)\n            capacities_df.to_csv(folder_path + \"Capacities.csv\", index=False)\n            solutions_df = pd.DataFrame(solutions_dict)\n            solutions_df.to_csv(folder_path + \"Solutions.csv\", index=False)\n            print(\"Done.\")\n</code></pre>"},{"location":"reference/visualizations/__init__/","title":"init","text":""},{"location":"reference/visualizations/__init__/#visualizations","title":"<code>visualizations</code>","text":""},{"location":"reference/visualizations/bubbles/","title":"Bubbles","text":""},{"location":"reference/visualizations/bubbles/#visualizations.bubbles","title":"<code>visualizations.bubbles</code>","text":""},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart","title":"<code>BubbleChart(instance, printing=None)</code>","text":"<p>Initialize an \"AFSC/Cadet Bubble\" chart and animation object.</p> <p>This class is designed to construct a graphical representation of the \"AFSC/Cadet Bubble,\" showing the placement of cadets in a solution and their movement through various algorithms. The problem instance is the only required parameter.</p> <p>Args:     instance: A CadetCareerProblem instance, containing various attributes and parameters necessary for constructing         the bubble chart.     printing (bool, None): A flag to control whether to print information during chart creation and animation. If set         to True, the class will print progress and debugging information. If set to False, it will suppress printing.         If None, the class will use the default printing setting from the instance.</p> <p>Notes: - This constructor extracts various attributes from the <code>CadetCareerProblem</code> instance provided as <code>instance</code>. - The <code>solution_iterations</code> attribute of the problem instance is expected to be a dictionary of a particular set of   solutions used in the figure. - The 'b' dictionary contains hyperparameters for the animation/plot, as defined in <code>afccp.core.data.ccp_helping_functions.py</code>.</p> <p>Attributes: - p: A dictionary containing parameters extracted from the <code>instance</code>. - vp: A dictionary containing value parameters extracted from the <code>instance</code>. - b: A dictionary containing hyperparameters for the bubble chart, populated from the <code>instance</code>. - data_name: The name of the data used for the chart. - data_version: The version of the data used for the chart. - solution: The solution data extracted from the <code>instance</code>. - mdl_p: Model parameters extracted from the <code>instance</code>. - paths: Export paths from the <code>instance</code>. - printing: A boolean flag for controlling printing behavior during chart creation and animation. - v_hex_dict: A dictionary mapping value parameter values to their corresponding hexadecimal colors. - ...</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def __init__(self, instance, printing=None):\n    \"\"\"\n    Initialize an \"AFSC/Cadet Bubble\" chart and animation object.\n\n    This class is designed to construct a graphical representation of the \"AFSC/Cadet Bubble,\" showing the placement\n    of cadets in a solution and their movement through various algorithms. The problem instance is the only required\n    parameter.\n\n    Args:\n        instance: A CadetCareerProblem instance, containing various attributes and parameters necessary for constructing\n            the bubble chart.\n        printing (bool, None): A flag to control whether to print information during chart creation and animation. If set\n            to True, the class will print progress and debugging information. If set to False, it will suppress printing.\n            If None, the class will use the default printing setting from the instance.\n\n    Notes:\n    - This constructor extracts various attributes from the `CadetCareerProblem` instance provided as `instance`.\n    - The `solution_iterations` attribute of the problem instance is expected to be a dictionary of a particular set of\n      solutions used in the figure.\n    - The 'b' dictionary contains hyperparameters for the animation/plot, as defined in `afccp.core.data.ccp_helping_functions.py`.\n\n    Attributes:\n    - p: A dictionary containing parameters extracted from the `instance`.\n    - vp: A dictionary containing value parameters extracted from the `instance`.\n    - b: A dictionary containing hyperparameters for the bubble chart, populated from the `instance`.\n    - data_name: The name of the data used for the chart.\n    - data_version: The version of the data used for the chart.\n    - solution: The solution data extracted from the `instance`.\n    - mdl_p: Model parameters extracted from the `instance`.\n    - paths: Export paths from the `instance`.\n    - printing: A boolean flag for controlling printing behavior during chart creation and animation.\n    - v_hex_dict: A dictionary mapping value parameter values to their corresponding hexadecimal colors.\n    - ...\n    \"\"\"\n\n    # Initialize attributes that we take directly from the CadetCareerProblem instance\n    self.p, self.vp = instance.parameters, instance.value_parameters\n    self.b, self.data_name, self.data_version = instance.mdl_p, instance.data_name, instance.data_version\n    self.solution, self.mdl_p = instance.solution, instance.mdl_p\n    self.paths = instance.export_paths\n    self.printing = printing\n\n    # Load in hex values/colors\n    filepath = afccp.globals.paths['files'] + 'value_hex_translation.xlsx'\n    if self.mdl_p['use_rainbow_hex']:\n        hex_df = afccp.globals.import_data(filepath, sheet_name='Rainbow')\n    else:\n        hex_df = afccp.globals.import_data(filepath)\n    self.v_hex_dict = {hex_df.loc[i, 'Value']: hex_df.loc[i, 'Hex'] for i in range(len(hex_df))}\n\n    # Figure Height\n    self.b['fh'] = self.b['fw'] * self.b['fh_ratio']\n\n    # Border Widths\n    for i in ['t', 'l', 'r', 'b', 'u']:\n        self.b['bw^' + i] = self.b['fw'] * self.b['bw^' + i + '_ratio']\n\n    # AFSC border/buffer widths\n    self.b['abw^lr'] = self.b['fw'] * self.b['abw^lr_ratio']\n    self.b['abw^ud'] = self.b['fw'] * self.b['abw^ud_ratio']\n\n    # Legend width/height\n    if self.b['add_legend']:\n        self.b['lw'] = self.b['fw'] * self.b['lw_ratio']\n        self.b['lh'] = self.b['fw'] * self.b['lh_ratio']\n    else:\n        self.b['lw'], self.b['lh'] = 0, 0\n\n    # Set up \"solutions\" properly\n    if 'iterations' in self.solution:\n        self.b['solutions'] = copy.deepcopy(self.solution['iterations']['matches'])\n        self.b['last_s'] = self.solution['iterations']['last_s']\n    else:\n        self.b['solutions'] = {0: self.solution['j_array']}\n        self.b['last_s'] = 0\n\n    # Basic information about this sequence for the animation\n    self.b['afscs'] = self.mdl_p['afscs']\n\n    # Determine which cadets were solved for in this solution\n    if self.b['cadets_solved_for'] is None:\n        self.b['cadets_solved_for'] = self.solution['cadets_solved_for']\n\n    # Rated cadets only\n    if 'Rated' in self.b['cadets_solved_for']:\n        for soc in self.p['SOCs']:\n            if soc.upper() in self.b['cadets_solved_for']:\n                self.b['cadets'] = self.p['Rated Cadets'][soc]\n                self.b['max_afsc'] = self.p[f'{soc}_quota']\n                self.b['min_afsc'] = self.p[f'{soc}_quota']\n                self.b['afscs'] = determine_soc_rated_afscs(soc, all_rated_afscs=self.p['afscs_acc_grp'][\"Rated\"])\n                self.soc = soc\n                break\n\n    # All the cadets!\n    else:\n        self.b['cadets'] = self.p['I']\n        self.b['max_afsc'] = self.p['quota_max']\n        self.b['min_afsc'] = self.p['pgl']\n        self.soc = 'both'\n\n    # Correct cadet parameters\n    self.b['N'] = len(self.b['cadets'])\n\n    # Correct AFSC parameters\n    self.b['M'] = len(self.b['afscs'])\n    self.b['J'] = np.array([np.where(afsc == self.p['afscs'])[0][0] for afsc in self.b['afscs']])\n\n    # These are attributes to use in the title of each iteration\n    self.num_unmatched = self.b['N']\n    self.average_afsc_choice = None\n    self.average_cadet_choice = None\n\n    # Initialize Figure\n    self.fig, self.ax = plt.subplots(figsize=self.b['b_figsize'], dpi=self.b['dpi'],\n                                     facecolor=self.b['figure_color'], tight_layout=True)\n    self.ax.set_facecolor(self.b['figure_color'])\n    self.ax.set_aspect('equal', adjustable='box')\n    self.ax.set(xlim=(-self.b['x_ext_left'], self.b['fw'] + self.b['x_ext_right']))\n    self.ax.set(ylim=(-self.b['y_ext_left'], self.b['fh'] + self.b['y_ext_right']))\n\n    # Remove tick marks\n    self.ax.tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.main","title":"<code>main()</code>","text":"<p>Main method to call all other methods based on what parameters the user provides</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def main(self):\n    \"\"\"\n    Main method to call all other methods based on what parameters the user provides\n    \"\"\"\n\n    # Run through some initial preprocessing (calculating 'n' for example)\n    self.preprocessing()\n    x_y_initialized = self.import_board_parameters()  # Potentially import x and y\n\n    # If we weren't able to initialize x and y coordinates for the board, determine that here\n    if not x_y_initialized:\n\n        # Determine x and y coordinates (and potentially 's')\n        if self.b['use_pyomo_model']:\n            self.calculate_afsc_x_y_s_through_pyomo()\n        else:\n            self.calculate_afsc_x_y_through_algorithm()\n\n    # Redistribute the AFSCs along each row by spacing out the x coordinates\n    if self.b['redistribute_x']:\n        self.redistribute_x_along_row()\n\n    # Only saving one image for a single solution\n    if 'iterations' not in self.solution:\n        self.b['save_iteration_frames'] = False\n        self.b['build_orientation_slides'] = False\n        self.b['save_board_default'] = False\n\n    # Create the rest of the main figure\n    self.calculate_cadet_box_x_y()\n\n    # Save the board parameters\n    self.export_board_parameters()\n\n    # Build out the orientation slides\n    if self.b['build_orientation_slides']:\n\n        # Orientation slides first\n        self.orientation_slides()\n    else:\n\n        # Initialize the board!\n        self.initialize_board()\n\n    # Just making one picture\n    if 'iterations' not in self.solution:\n        self.solution_iteration_frame(0, cadets_to_show='cadets_matched', kind='Final Solution')\n\n        # Save frame to solution sub-folder with solution name\n        filepath = self.paths['Analysis &amp; Results'] + self.solution['name'] + '/' + self.solution['name'] + ' ' +\\\n                   self.b['chart_filename'] + '.png'\n        self.fig.savefig(filepath)\n\n        if self.printing:\n            print('Done.')\n\n    # Create all the iteration frames\n    if self.b['save_iteration_frames']:\n\n        # Make the \"focus\" directory if needed\n        folder_path = self.paths['Analysis &amp; Results'] + 'Cadet Board/' + self.solution['iterations']['sequence']\n        if self.b['focus'] not in os.listdir(folder_path):\n            os.mkdir(folder_path + '/' + self.b['focus'])\n\n        # ROTC Rated Board\n        if self.solution['iterations']['type'] in ['ROTC Rated Board']:\n\n            if self.printing:\n                print(\"Creating \" + str(len(self.solution['iterations']['matches'])) + \" animation images...\")\n\n            # Loop through each solution\n            for s in self.b['solutions']:\n                self.solution_iteration_frame(s, cadets_to_show='cadets_matched')\n\n        # Matching Algorithm Proposals &amp; Rejections\n        elif self.solution['iterations']['type'] in ['HR', 'Rated SOC HR']:\n\n            if self.printing:  # \"Plus 2\" to account for orientation and final solution frames\n                print(\"Creating \" + str(len(self.b['solutions']) + 2) + \" animation images...\")\n\n            # Save the orientation slide\n            filepath = folder_path + '/' + self.b['focus'] + '/0 (Orientation).png'\n            self.fig.savefig(filepath)\n\n            # Loop through each iteration\n            for s in self.b['solutions']:\n                self.solution_iteration_frame(s, cadets_to_show='cadets_proposing', kind='Proposals')\n                self.rejections_iteration_frame(s, kind='Rejections')\n\n            # Final Solution\n            self.solution_iteration_frame(s, cadets_to_show='cadets_matched', kind='Final Solution')\n            if self.printing:\n                print('Done.')\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.preprocessing","title":"<code>preprocessing()</code>","text":"<p>This method preprocesses the different specs for this particular figure instance</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def preprocessing(self):\n    \"\"\"\n    This method preprocesses the different specs for this particular figure instance\n    \"\"\"\n\n    # Default AFSC fontsize and whether they're on two lines or not (likely overwritten later)\n    self.b['afsc_fontsize'] = {j: self.b['afsc_title_size'] for j in self.b['J']}\n    self.b['afsc_title_two_lines'] = {j: False for j in self.b['J']}\n\n    # Maximum number of cadets assigned to each AFSC across solutions\n    self.b['max_assigned'] = {j: 0 for j in self.b[\"J\"]}\n\n    # Subset of cadets assigned to the AFSC in each solution\n    self.b['cadets_matched'], self.b['counts'] = {}, {}\n\n    # Proposal iterations\n    if 'iterations' in self.solution:\n        if 'proposals' in self.solution['iterations']:\n            self.b['cadets_proposing'] = {}\n\n    # Loop through each solution (iteration)\n    for s in self.b['solutions']:\n        self.b['cadets_matched'][s], self.b['counts'][s] = {}, {}\n\n        # Proposal iterations\n        if 'iterations' in self.solution:\n            if 'proposals' in self.solution['iterations']:\n                self.b['cadets_proposing'][s] = {}\n\n        # Loop through each AFSC\n        for j in self.b['J']:\n            self.b['cadets_matched'][s][j] = np.where(self.b['solutions'][s] == j)[0]  # cadets assigned to this AFSC\n            self.b['counts'][s][j] = len(self.b['cadets_matched'][s][j])  # number of cadets assigned to this AFSC\n            max_count = self.b['counts'][s][j]\n\n            # Proposal iterations\n            if 'iterations' in self.solution:\n                if 'proposals' in self.solution['iterations']:\n                    self.b['cadets_proposing'][s][j] = np.where(self.solution['iterations']['proposals'][s] == j)[0]\n                    proposal_counts = len(self.b['cadets_proposing'][s][j])  # number of proposing cadets\n                    max_count = max(self.b['counts'][s][j], proposal_counts)\n\n            # Update maximum number of cadets assigned if necessary\n            if max_count &gt; self.b['max_assigned'][j]:\n                self.b['max_assigned'][j] = max_count\n\n        # Get number of unassigned cadets at the end of the iterations\n        if s == self.b['last_s']:\n            self.b['unassigned_cadets'] = np.where(self.b['solutions'][s] == self.p['M'])[0]  # cadets left unmatched\n            self.b['N^u'] = len(self.b['unassigned_cadets'])  # number of cadets left unmatched\n\n    # Determine number of cadet boxes for AFSCs based on nearest square\n    squares_required = [max(self.b['max_assigned'][j], self.b['max_afsc'][j]) for j in self.b['J']]\n    n = np.ceil(np.sqrt(squares_required)).astype(int)\n    n2 = (np.ceil(np.sqrt(squares_required)) ** 2).astype(int)\n    self.b['n'] = {j: n[idx] for idx, j in enumerate(self.b['J'])}\n    self.b['n^2'] = {j: n2[idx] for idx, j in enumerate(self.b['J'])}\n\n    # Number of boxes in row of unmatched box\n    self.b['n^u'] = int((self.b['fw'] - self.b['bw^r'] - self.b['bw^l']) / self.b['s'])\n\n    # Number of rows in unmatched box\n    self.b['n^urow'] = int(self.b['N^u'] / self.b['n^u'])\n\n    # Sort the AFSCs by 'n'\n    n = np.array([self.b['n'][j] for j in self.b['J']])  # Convert dictionary to numpy array\n    indices = np.argsort(n)[::-1]  # Get list of indices that would sort n\n    sorted_J = self.b['J'][indices]  # J Array sorted by n\n    sorted_n = n[indices]  # n Array sorted by n\n    self.b['J^sorted'] = {index: sorted_J[index] for index in range(self.b['M'])}  # Translate 'new j' to 'real j'\n    self.b['n^sorted'] = {index: sorted_n[index] for index in range(self.b['M'])}  # Translate 'new n' to 'real n'\n    self.b['J^translated'] = {sorted_J[index]: index for index in range(self.b['M'])}  # Translate 'real j' to 'new j'\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.orientation_slides","title":"<code>orientation_slides()</code>","text":"<p>Build out the orientation slides for a particular sequence (intended to be used on ONE AFSC)</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def orientation_slides(self):\n    \"\"\"\n    Build out the orientation slides for a particular sequence (intended to be used on ONE AFSC)\n    \"\"\"\n\n    # Make the \"orientation\" directory if needed\n    folder_path = self.paths['Analysis &amp; Results'] + 'Cadet Board/' + self.solution['iterations']['sequence']\n    if 'Orientation' not in os.listdir(folder_path):\n        os.mkdir(folder_path + '/Orientation')\n\n    # Save the \"zero\" slide (just black screen)\n    filepath = folder_path + '/Orientation/0.png'\n    self.fig.savefig(filepath)\n\n    # Create first frame\n    self.initialize_board(include_surplus=False)\n\n    # Save the real first frame\n    filepath = folder_path + '/Orientation/1.png'\n    self.fig.savefig(filepath)\n\n    # Reset Figure\n    self.fig, self.ax = plt.subplots(figsize=self.b['b_figsize'], dpi=self.b['dpi'],\n                                     facecolor=self.b['figure_color'], tight_layout=True)\n    self.ax.set_facecolor(self.b['figure_color'])\n    self.ax.set_aspect('equal', adjustable='box')\n    self.ax.set(xlim=(-self.b['x_ext_left'], self.b['fw'] + self.b['x_ext_right']))\n    self.ax.set(ylim=(-self.b['y_ext_left'], self.b['fh'] + self.b['y_ext_right']))\n\n    # Create second frame\n    self.initialize_board(include_surplus=True)\n\n    # Save the second frame\n    filepath = folder_path + '/Orientation/2.png'\n    self.fig.savefig(filepath)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.calculate_afsc_x_y_through_algorithm","title":"<code>calculate_afsc_x_y_through_algorithm()</code>","text":"<p>This method calculates the x and y locations of the AFSC boxes using a very simple algorithm.</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def calculate_afsc_x_y_through_algorithm(self):\n    \"\"\"\n    This method calculates the x and y locations of the AFSC boxes using a very simple algorithm.\n    \"\"\"\n\n    # Determine x and y coordinates of bottom left corner of AFSC squares algorithmically\n    self.b['x'], self.b['y'] = {j: 0 for j in self.b['J']}, {j: 0 for j in self.b['J']}\n    n = np.array([self.b['n'][j] for j in self.b['J']])  # Convert dictionary to numpy array\n\n    # Start at top left corner of main container (This is the algorithm)\n    x, y = self.b['bw^l'], self.b['fh'] - self.b['bw^t']\n    current_max_n = np.max(n)\n    for j in self.b['J']:\n        check_x = x + self.b['s'] * self.b['n'][j]\n\n        if check_x &gt; self.b['fw'] - self.b['bw^r'] - self.b['lw']:\n            x = self.b['bw^l']  # move back to left-most column\n            y = y - self.b['s'] * current_max_n - self.b['abw^ud']  # drop to next row\n            current_max_n = self.b['n'][j]\n\n        self.b['x'][j], self.b['y'][j] = x, y - self.b['s'] * self.b['n'][j]  # bottom left corner of box\n        x += self.b['s'] * self.b['n'][j] + self.b['abw^lr']  # move over to next column\n\n    if self.printing:\n        print(\"Board parameters 'x' and 'y' determined through simple algorithm.\")\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.calculate_afsc_x_y_s_through_pyomo","title":"<code>calculate_afsc_x_y_s_through_pyomo()</code>","text":"<p>This method calculates the x and y locations of the AFSC boxes, as well as the size (s) of the cadet boxes, using the pyomo optimization model to determine the optimal placement of all these objects</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def calculate_afsc_x_y_s_through_pyomo(self):\n    \"\"\"\n    This method calculates the x and y locations of the AFSC boxes, as well as the size (s) of the cadet boxes,\n    using the pyomo optimization model to determine the optimal placement of all these objects\n    \"\"\"\n\n    if not afccp.globals.use_pyomo:\n        raise ValueError(\"Pyomo not installed.\")\n\n    # Build the model\n    model = afccp.solutions.optimization.cadet_board_preprocess_model_simple(self.b)\n\n    # Get coordinates and size of boxes by solving the model\n    self.b['s'], self.b['x'], self.b['y'] = afccp.solutions.optimization.solve_pyomo_model(\n        self, model, \"CadetBoard\", q=None, printing=self.printing)\n\n    if self.printing:\n        print(\"Board parameters 'x' and 'y' determined through pyomo model.\")\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.redistribute_x_along_row","title":"<code>redistribute_x_along_row()</code>","text":"<p>This method re-calculates the x coordinates by spacing out the AFSCs along each row</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def redistribute_x_along_row(self):\n    \"\"\"\n    This method re-calculates the x coordinates by spacing out the AFSCs along each row\n    \"\"\"\n\n    # Unique y coordinates\n    y_unique = np.unique(np.array([round(self.b['y'][j], 4) for j in self.b['J']]))[::-1]\n\n    # Need to get ordered list of AFSCs in each row\n    sorted_J = np.array([j for j in self.b['J^translated']])\n    rows = {row: [] for row in range(len(y_unique))}\n    for j in sorted_J:\n        y = round(self.b['y'][j], 4)\n        row = np.where(y_unique == y)[0][0]\n        rows[row].append(j)\n\n    # Loop through each row to determine optimal spacing\n    for row in rows:\n\n        # Only adjust spacing for rows with more than one AFSC\n        if len(rows[row]) &gt; 1:\n\n            # Calculate total spacing to play around with\n            total_spacing = self.b['fw'] - self.b['bw^l'] - self.b['bw^r']\n            for j in rows[row]:\n                total_spacing -= (self.b['s'] * self.b['n'][j])\n\n            # Spacing used to fill in the gaps\n            new_spacing = total_spacing / (len(rows[row]) - 1)\n\n            # Loop through each AFSC in this row to calculate the new x position\n            for num, j in enumerate(rows[row]):\n\n                # Calculate the appropriate x coordinate\n                if num == 0:\n                    x = self.b['x'][j] + (self.b['n'][j] * self.b['s']) + new_spacing\n                else:\n                    self.b['x'][j] = x\n                    x += (self.b['n'][j] * self.b['s']) + new_spacing\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.calculate_cadet_box_x_y","title":"<code>calculate_cadet_box_x_y()</code>","text":"<p>This method uses the x and y coordinates of the AFSC boxes, along with the size of the cadet boxes, to calculate the x and y coordinates of all the individual cadet boxes.</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def calculate_cadet_box_x_y(self):\n    \"\"\"\n    This method uses the x and y coordinates of the AFSC boxes, along with the size of the cadet boxes, to calculate\n    the x and y coordinates of all the individual cadet boxes.\n    \"\"\"\n\n    # Get coordinates of all cadet boxes\n    self.b['cb_coords'] = {}\n    for j in self.b['J']:\n        self.b['cb_coords'][j] = {}\n\n        # Bottom left corner of top left cadet square\n        x, y = self.b['x'][j], self.b['y'][j] + self.b['s'] * (self.b['n'][j] - 1)\n\n        # Loop through all cadet boxes to get individual coordinates of bottom left corner of each cadet box\n        i = 0\n        for r in range(self.b['n'][j]):\n            for c in range(self.b['n'][j]):\n                x_i = x + c * self.b['s']\n                y_i = y - r * self.b['s']\n                self.b['cb_coords'][j][i] = (x_i, y_i)\n                i += 1\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.initialize_board","title":"<code>initialize_board(include_surplus=True)</code>","text":"<p>This method takes all the necessary board parameters and constructs the board to then be manipulated in other algorithms based on what the user wants to do.</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def initialize_board(self, include_surplus=True):\n    \"\"\"\n    This method takes all the necessary board parameters and constructs the board to then be manipulated in other\n    algorithms based on what the user wants to do.\n    \"\"\"\n\n    # Loop through each AFSC to add certain elements\n    self.b['afsc_name_text'] = {}\n    self.b['c_boxes'] = {}\n    self.b['c_circles'] = {}\n    self.b['c_rank_text'] = {}\n    for j in self.b['J']:\n\n        # AFSC names\n        if self.b['afsc_names_sized_box']:\n\n            # Calculate fontsize and put AFSC name in middle of box\n            x = self.b['x'][j] + (self.b['n'][j] / 2) * self.b['s']\n            y = self.b['y'][j] + (self.b['n'][j] / 2) * self.b['s']\n            w, h = self.b['n'][j] * self.b['s'], self.b['n'][j] * self.b['s']\n            self.b['afsc_fontsize'][j] = get_fontsize_for_text_in_box(self.ax, self.p['afscs'][j], (x, y), w, h,\n                                                                   va='center')\n            va = 'center'\n            ha = 'center'\n        else:\n\n            # AFSC fontsize is given and put AFSC name above box\n            x = self.b['x'][j] + (self.b['n'][j] / 2) * self.b['s']\n            y = self.b['y'][j] + self.b['n'][j] * self.b['s'] + 0.02\n            va = 'bottom'\n            ha = 'center'\n\n            self.b['x'] = {key: round(val, 4) for key, val in self.b['x'].items()}\n            self.b['y'] = {key: round(val, 4) for key, val in self.b['y'].items()}\n\n            # Are we on a bottom edge?\n            row = np.array([j_p for j_p, val in self.b['y'].items() if val == self.b['y'][j]])\n            x_coords = np.array([self.b['x'][j_p] for j_p in row])\n            if self.b['x'][j] == np.max(x_coords) and self.b['y'][j] &lt;= 0.03:  # We're at the right edge\n                x = self.b['x'][j] + (self.b['n'][j]) * self.b['s']\n                ha = 'right'\n            elif self.b['x'][j] == np.min(x_coords) and self.b['y'][j] &lt;= 0.03:  # We're at the left edge\n                x = self.b['x'][j]\n                ha = 'left'\n\n        # AFSC text\n        self.b['afsc_name_text'][j] = self.ax.text(x, y, self.p['afscs'][j], fontsize=self.b['afsc_fontsize'][j],\n                                                   horizontalalignment=ha, verticalalignment=va,\n                                                   color=self.b['text_color'])\n\n        # Cadet box text size\n        cb_s = get_fontsize_for_text_in_box(self.ax, \"0\", (0, 0), self.b['s'], self.b['s'], va='center')\n\n        # Loop through each cadet to add the cadet boxes and circles\n        self.b['c_boxes'][j] = {}\n        self.b['c_circles'][j] = {}\n        self.b['c_rank_text'][j] = {}\n        for i in range(self.b['n^2'][j]):  # All cadet boxes\n\n            # If we are under the maximum number of cadets allowed\n            if i + 1 &lt;= self.b['max_afsc'][j]:\n\n                # Boxes based on SOC PGL Breakouts\n                if 'SOC PGL' in self.b['focus']:\n\n                    # If we are under the USAFA PGL\n                    if i + 1 &lt;= self.p['usafa_quota'][j]:\n                        linestyle = self.b['pgl_linestyle']\n                        color = self.b['usafa_pgl_color']\n                        alpha = self.b['pgl_alpha']\n\n                    # We're in the ROTC range\n                    elif i + 1 &lt;= self.p['usafa_quota'][j] + self.p['rotc_quota'][j]:\n                        linestyle = self.b['pgl_linestyle']\n                        color = self.b['rotc_pgl_color']\n                        alpha = self.b['pgl_alpha']\n\n                    # 'Surplus' Range\n                    else:\n                        linestyle = self.b['surplus_linestyle']\n                        color = self.b['surplus_color']\n                        alpha = self.b['surplus_alpha']\n\n                else:\n\n                    # If we are under the PGL\n                    if i + 1 &lt;= self.b['min_afsc'][j]:\n                        linestyle = self.b['pgl_linestyle']\n                        color = self.b['pgl_color']\n                        alpha = self.b['pgl_alpha']\n\n                    # 'Surplus' Range\n                    else:\n                        linestyle = self.b['surplus_linestyle']\n                        color = self.b['surplus_color']\n                        alpha = self.b['surplus_alpha']\n\n                # Make the rectangle patch (cadet box)\n                self.b['c_boxes'][j][i] = patches.Rectangle(self.b['cb_coords'][j][i], self.b['s'], self.b['s'],\n                                                            linestyle=linestyle, linewidth=1, facecolor=color,\n                                                            alpha=alpha, edgecolor=self.b['cb_edgecolor'])\n\n                # Add the patch to the figure\n                if include_surplus or linestyle == self.b['pgl_linestyle']:\n                    self.ax.add_patch(self.b['c_boxes'][j][i])\n\n            # If we are under the maximum number of cadets assigned to this AFSC across the solutions\n            if i + 1 &lt;= self.b['max_assigned'][j]:\n\n                # Make the circle patch (cadet)\n                x, y = self.b['cb_coords'][j][i][0] + (self.b['s'] / 2), \\\n                       self.b['cb_coords'][j][i][1] + (self.b['s'] / 2)\n                self.b['c_circles'][j][i] = patches.Circle(\n                    (x, y), radius = (self.b['s'] / 2) * self.b['circle_radius_percent'], linestyle='-', linewidth=1,\n                    facecolor='black', alpha=1, edgecolor='black')\n\n                # Add the patch to the figure\n                self.ax.add_patch(self.b['c_circles'][j][i])\n\n                # Hide the circle\n                self.b['c_circles'][j][i].set_visible(False)\n\n                # We may want to include rank text on the cadets\n                if self.b['show_rank_text']:\n                    self.b['c_rank_text'][j][i] = self.ax.text(x, y, '0', fontsize=cb_s, horizontalalignment='center',\n                                                               verticalalignment='center',\n                                                               color=self.b['rank_text_color'])\n                    self.b['c_rank_text'][j][i].set_visible(False)\n\n\n    # Remove tick marks\n    self.ax.tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)\n\n    # Add the title\n    if self.b['b_title'] is None:\n        title = \"Round 0 (Orientation)\"\n    else:\n        title = self.b['b_title']\n    self.fig.suptitle(title, fontsize=self.b['b_title_size'], color=self.b['text_color'])\n\n    # Add the legend if necessary\n    if self.b['b_legend']:\n        self.create_legend()\n\n    # Save the figure\n    if self.b['save_board_default']:\n        folder_path = self.paths['Analysis &amp; Results'] + 'Cadet Board/'\n        if self.solution['iterations']['sequence'] not in os.listdir(folder_path):\n            os.mkdir(folder_path + self.b['sequence'])\n\n        # Get the filepath and save the \"default\" graph\n        filepath = folder_path + self.solution['iterations']['sequence'] + '/Default Board'\n        if type(self.mdl_p['afscs_to_show']) == str:\n            filepath += ' (' + self.mdl_p['afscs_to_show'] + ' Cadets).png'\n        else:\n            filepath += ' (M = ' + str(self.b['M']) + ').png'\n        self.fig.savefig(filepath)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.solution_iteration_frame","title":"<code>solution_iteration_frame(s, cadets_to_show='cadets_matched', kind=None)</code>","text":"<p>This method reconstructs the figure to reflect the cadet/afsc state in this iteration</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def solution_iteration_frame(self, s, cadets_to_show='cadets_matched', kind=None):\n    \"\"\"\n    This method reconstructs the figure to reflect the cadet/afsc state in this iteration\n    \"\"\"\n\n    # AFSC Normalized scores\n    self.b['scores'] = {j: 0 for j in self.b['J']}\n\n    # Loop through each AFSC\n    for j in self.b['J']:\n\n        # Sort the cadets based on whatever method we choose\n        unsorted_cadets = self.b[cadets_to_show][s][j]\n        cadets = self.sort_cadets(j, unsorted_cadets)\n\n        # Make sure we have cadets assigned to this AFSC in this frame\n        if len(cadets) &gt; 0:\n\n            # Change the colors of the circles based on the desired method\n            self.change_circle_features(s, j, cadets)\n\n            # Hide the circles/text that aren't in the solution\n            for i in range(len(cadets), self.b['max_assigned'][j]):\n\n                # Hide the circle\n                self.b['c_circles'][j][i].set_visible(False)\n\n                # If rank text is included\n                if self.b['show_rank_text']:\n                    self.b['c_rank_text'][j][i].set_visible(False)\n\n            # Update the text above the AFSC square\n            self.update_afsc_text(s, j)\n\n        else:  # There aren't any assigned cadets yet!\n            self.b['afsc_name_text'][j].set_color('white')\n            self.b['afsc_name_text'][j].set_text(self.p['afscs'][j] + \": 0\")\n\n    # Update the title of the figure\n    self.update_title_text(s, kind=kind)\n\n    # Save the figure\n    if self.b['save_iteration_frames']:\n        self.save_iteration_frame(s, kind=kind)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.rejections_iteration_frame","title":"<code>rejections_iteration_frame(s, kind='Rejections')</code>","text":"<p>This method reconstructs the figure to reflect the cadet/afsc state in this iteration</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def rejections_iteration_frame(self, s, kind='Rejections'):\n    \"\"\"\n    This method reconstructs the figure to reflect the cadet/afsc state in this iteration\n    \"\"\"\n\n    # Rejection 'Xs' lines\n    line_1, line_2 = {}, {}\n\n    # Loop through each AFSC\n    for j in self.b['J']:\n\n        # Sort the cadets based on whatever method we choose\n        unsorted_cadets = self.b['cadets_proposing'][s][j]\n        cadets_proposing = self.sort_cadets(j, unsorted_cadets)\n\n        # Rejection lines\n        line_1[j], line_2[j] = {}, {}\n        for i, cadet in enumerate(cadets_proposing):\n            if cadet not in self.b['cadets_matched'][s][j]:\n\n                # Get line coordinates\n                x_values_1 = [self.b['cb_coords'][j][i][0], self.b['cb_coords'][j][i][0] + self.b['s']]\n                y_values_1 = [self.b['cb_coords'][j][i][1], self.b['cb_coords'][j][i][1] + self.b['s']]\n                x_values_2 = [self.b['cb_coords'][j][i][0], self.b['cb_coords'][j][i][0] + self.b['s']]\n                y_values_2 = [self.b['cb_coords'][j][i][1] + self.b['s'], self.b['cb_coords'][j][i][1]]\n\n                # Plot the 'Big Red X' lines\n                line_1[j][i] = self.ax.plot(x_values_1, y_values_1, linestyle='-', c='red')\n                line_2[j][i] = self.ax.plot(x_values_2, y_values_2, linestyle='-', c='red')\n\n    # Update the title of the figure\n    self.update_title_text(s, kind=kind)\n\n    # Save the figure\n    if self.b['save_iteration_frames']:\n        self.save_iteration_frame(s, kind)\n\n    # Remove the \"Big Red X\" lines\n    for j in self.b['J']:\n        for i in line_1[j]:\n            line = line_1[j][i].pop(0)\n            line.remove()\n            line = line_2[j][i].pop(0)\n            line.remove()\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.sort_cadets","title":"<code>sort_cadets(j, cadets_unsorted)</code>","text":"<p>This method sorts the cadets in this frame through some means</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def sort_cadets(self, j, cadets_unsorted):\n    \"\"\"\n    This method sorts the cadets in this frame through some means\n    \"\"\"\n\n    # Sort the cadets by SOC\n    if self.b['focus'] == 'SOC PGL':\n        indices = np.argsort(self.p['usafa'][cadets_unsorted])[::-1]\n\n    # Sort the cadets by AFSC preferences\n    elif self.mdl_p['sort_cadets_by'] == 'AFSC Preferences':\n        indices = np.argsort(self.p['a_pref_matrix'][cadets_unsorted, j])\n\n    # Return the sorted cadets\n    return cadets_unsorted[indices]\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.change_circle_features","title":"<code>change_circle_features(s, j, cadets)</code>","text":"<p>This method determines the color and edgecolor of the circles to show</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def change_circle_features(self, s, j, cadets):\n    \"\"\"\n    This method determines the color and edgecolor of the circles to show\n    \"\"\"\n\n    # Colors based on cadet utility\n    if self.b['focus'] == 'Cadet Utility':\n        utility = self.p['cadet_utility'][cadets, j]\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n\n            # Change circle color\n            color = self.v_hex_dict[round(utility[i], 2)]\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif self.b['focus'] == 'Cadet Choice':\n        choice = self.p['c_pref_matrix'][cadets, j]\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n\n            # Change circle color\n            if choice[i] in self.mdl_p['choice_colors']:\n                color = self.mdl_p['choice_colors'][choice[i]]\n            else:\n                color = self.mdl_p['all_other_choice_colors']\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif self.b['focus'] == 'Cadet Choice Categories':\n        choice = self.p['c_pref_matrix'][cadets, j]\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n\n            # If the AFSC was a top 6 choice, we use that color\n            if choice[i] in [1, 2, 3, 4, 5, 6]:\n                color = self.mdl_p['choice_colors'][choice[i]]\n\n            # If the AFSC was at least selected, we make it that color\n            elif j in self.p['J^Selected'][cadet]:\n\n                # Use the color for the 8th choice\n                color = self.mdl_p['choice_colors'][8]\n\n            # If the AFSC was not in the bottom 3 choices, we make it that color\n            elif j not in self.p['J^Bottom 2 Choices'][cadet] and j != self.p['J^Last Choice'][cadet]:\n\n                # Use the color for the 9th choice\n                color = self.mdl_p['choice_colors'][9]\n\n            # Otherwise, it's a bottom 3 choice\n            else:\n                color = self.mdl_p['all_other_choice_colors']\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif self.b['focus'] == 'AFSC Choice':\n        choice = self.p['a_pref_matrix'][cadets, j]\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n\n            value = round(1 - (choice[i] / self.p['num_eligible'][j]), 2)\n\n            # Change circle color\n            color = self.v_hex_dict[value]\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif self.b['focus'] == 'ROTC Rated Interest':\n        afsc_index = np.where(self.b['J'] == j)[0][0]\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n            idx = self.p['Rated Cadet Index Dict']['rotc'][cadet]\n            interest = self.p['rr_interest_matrix'][idx, afsc_index]\n\n            # Change circle color\n            color = self.mdl_p['interest_colors'][interest]\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif self.b['focus'] == 'Reserves':\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n            if cadet in self.solution['iterations']['matched'][s]:\n                color = self.b['matched_slot_color']\n            elif cadet in self.solution['iterations']['reserves'][s]:\n                color = self.b['reserved_slot_color']\n            else:\n                color = self.b['unmatched_color']\n\n            # Change circle color\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif self.b['focus'] == 'SOC PGL':\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n            if cadet in self.p['usafa_cadets']:\n                color = self.b['usafa_bubble']\n            else:\n                color = self.b['rotc_bubble']\n\n            # Change circle color\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif self.b['focus'] == 'Rated Choice':\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n            rated_choices = self.p['Rated Choices'][self.soc][cadet]\n\n            # Get color of this choice\n            if j in rated_choices:\n                choice = np.where(rated_choices == j)[0][0] + 1\n            else:\n                choice = 100  # Arbitrary big number\n\n            # Change circle color\n            if choice in self.mdl_p['choice_colors']:\n                color = self.mdl_p['choice_colors'][choice]\n            else:\n                color = self.mdl_p['all_other_choice_colors']\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif 'Specific Choice' in self.b['focus']:\n\n        # Get the AFSC we're highlighting\n        j_focus = np.where(self.p['afscs'] == self.mdl_p['afsc'])[0][0]\n        choice = self.p['c_pref_matrix'][cadets, j_focus]\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n\n            # Change circle color\n            if choice[i] in self.mdl_p['choice_colors']:\n                color = self.mdl_p['choice_colors'][choice[i]]\n            elif choice[i] == 0:  # Ineligible\n                color = self.mdl_p['unfocused_color']\n            else:  # All other choices\n                color = self.mdl_p['all_other_choice_colors']\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    elif 'Tier 1' in self.b['focus']:\n        choice = self.p['c_pref_matrix'][cadets, j]\n\n        # Get the AFSC we're highlighting\n        j_focus = np.where(self.p['afscs'] == self.mdl_p['afsc'])[0][0]\n\n        # Change the cadet circles to reflect the appropriate colors\n        for i, cadet in enumerate(cadets):\n\n            # Change circle color\n            if '1' in self.p['qual'][cadet, j_focus]:\n                if choice[i] in self.mdl_p['choice_colors']:\n                    color = self.mdl_p['choice_colors'][choice[i]]\n                else:\n                    color = self.mdl_p['all_other_choice_colors']\n            else:\n                color = self.mdl_p['unfocused_color']\n            self.b['c_circles'][j][i].set_facecolor(color)\n\n            # Edgecolor (Don't worry about exception anymore)\n            if 'E' in self.p['qual'][cadet, j_focus]:# and j == j_focus:\n                self.b['c_circles'][j][i].set_edgecolor(self.mdl_p['exception_edge'])\n            else:\n                self.b['c_circles'][j][i].set_edgecolor(self.mdl_p['base_edge'])\n\n            # Show the circle\n            self.b['c_circles'][j][i].set_visible(True)\n\n    # Cadet rank text\n    if self.b['show_rank_text']:\n        choice = self.p['a_pref_matrix'][cadets, j]\n        for i, cadet in enumerate(cadets):\n            txt = str(choice[i])\n            x, y = self.b['cb_coords'][j][i][0] + (self.b['s'] / 2), \\\n                   self.b['cb_coords'][j][i][1] + (self.b['s'] / 2)\n            w, h = self.b['s'] * self.b['circle_radius_percent'], self.b['s'] * self.b['circle_radius_percent']\n            fontsize = get_fontsize_for_text_in_box(self.ax, txt, (x, y), w, h, va='center')\n\n            # Adjust fontsize for single digit ranks\n            if int(txt) &lt; 10:\n                fontsize = int(fontsize * self.b['fontsize_single_digit_adj'])\n            self.b['c_rank_text'][j][i].set_text(txt)\n            self.b['c_rank_text'][j][i].set_fontsize(fontsize)\n            self.b['c_rank_text'][j][i].set_visible(True)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.update_afsc_text","title":"<code>update_afsc_text(s, j)</code>","text":"<p>This method updates the text above the AFSC squares</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def update_afsc_text(self, s, j):\n    \"\"\"\n    This method updates the text above the AFSC squares\n    \"\"\"\n\n    # Set of ranks for all the cadets \"considered\" in this solution for this AFSC\n    cadets_considered = np.intersect1d(self.b['cadets'], self.p['I^E'][j])\n    ranks = self.p['a_pref_matrix'][cadets_considered, j]\n    achieved_ranks = self.p['a_pref_matrix'][self.b['cadets_matched'][s][j], j]\n\n    # Calculate AFSC Norm Score and use it in the new text\n    self.b['scores'][j] = round(afccp.solutions.handling.calculate_afsc_norm_score_general(\n        ranks, achieved_ranks), 2)\n\n    # If we want to put this AFSC title on two lines or not\n    if self.b['afsc_title_two_lines'][j]:\n        afsc_text = self.p['afscs'][j] + \":\\n\"\n    else:\n        afsc_text = self.p['afscs'][j] + \": \"\n\n    # Change the text for the AFSCs\n    if self.b['focus'] == 'SOC PGL':\n        more = 'neither'\n        for soc, other_soc in {'usafa': 'rotc', 'rotc': 'usafa'}.items():\n            soc_cadets = len(np.intersect1d(self.b['cadets_matched'][s][j], self.p[soc + '_cadets']))\n            soc_pgl = self.p[soc + '_quota'][j]\n            diff = soc_cadets - soc_pgl\n            if diff &gt; 0:\n                more = soc\n                afsc_text += '+' + str(diff)\n\n        if more == 'neither':\n            color = 'white'\n            afsc_text += '+0'\n        else:\n            color = self.b[more + '_bubble']\n        self.b['afsc_name_text'][j].set_color(color)\n\n\n    elif self.b['afsc_text_to_show'] == 'Norm Score':\n        color = self.v_hex_dict[self.b['scores'][j]]  # New AFSC color\n        afsc_text += str(self.b['scores'][j])\n        self.b['afsc_name_text'][j].set_color(color)\n\n    # Determine average cadet choice and use it in the new text\n    elif self.b['afsc_text_to_show'] == 'Cadet Choice':\n        average_choice = round(np.mean(self.p['c_pref_matrix'][self.b['cadets_matched'][s][j], j]), 2)\n        color = 'white'\n        afsc_text += str(average_choice)\n        self.b['afsc_name_text'][j].set_color(color)\n\n    # Text shows number of cadets matched/proposing\n    else:\n        afsc_text += str(len(self.b['cadets_matched'][s][j]))\n\n    # Update the text\n    self.b['afsc_name_text'][j].set_text(afsc_text)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.update_title_text","title":"<code>update_title_text(s, kind=None)</code>","text":"<p>This method purely updates the text in the title of the figure</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def update_title_text(self, s, kind=None):\n    \"\"\"\n    This method purely updates the text in the title of the figure\n    \"\"\"\n\n    # Change the text and color of the title\n    if kind == 'Proposals':\n        title_text = 'Round ' + str(s + 1) + ' (Proposals)'\n\n        # Get the color of the title\n        if s + 1 in self.b['choice_colors']:\n            title_color = self.b['choice_colors'][s + 1]\n        else:\n            title_color = self.b['all_other_choice_colors']\n    else:\n        title_color = self.b['text_color']\n\n        # Update the title text in a specific way\n        if kind == 'Final Solution':\n            title_text = 'Solution'\n        elif kind == 'Rejections':\n            title_text = 'Round ' + str(s + 1) + ' (Rejections)'\n\n            # Get the color of the title\n            if s + 1 in self.b['choice_colors']:\n                title_color = self.b['choice_colors'][s + 1]\n            else:\n                title_color = self.b['all_other_choice_colors']\n        else:\n            title_text = self.b['iteration_names'][s]\n\n    # All unmatched cadets in the solution (even the ones we're not considering)\n    unmatched_cadets_all = np.where(self.b['solutions'][s] == self.p['M'])[0]\n\n    # Unmatched cadets that we're concerned about in this solution (This really just applies to Rated)\n    unmatched_cadets = np.intersect1d(unmatched_cadets_all, self.b['cadets'])\n    self.num_unmatched = len(unmatched_cadets)\n    matched_cadets = np.array([i for i in self.b['cadets'] if i not in unmatched_cadets])\n\n    # Calculate average cadet choice based on matched cadets\n    choices = np.zeros(len(matched_cadets))\n    for idx, i in enumerate(matched_cadets):\n        j = self.b['solutions'][s][i]\n        choices[idx] = self.p['c_pref_matrix'][i, j]\n    self.average_cadet_choice = round(np.mean(choices), 2)\n\n    # Calculate AFSC weighted average score (and add number of unmatched cadets)\n    counts = np.array([len(np.where(self.b['solutions'][s] == j)[0]) for j in self.b['J']])\n    weights = counts / np.sum(counts)\n    scores = np.array([self.b['scores'][j] for j in self.b['J']])\n    self.average_afsc_choice = round(np.dot(weights, scores), 2)\n\n    # Add title text\n    if self.b['focus'] in ['Specific Choice', 'Tier 1']:\n        title_text += ' Highlighting Results for ' + self.mdl_p['afsc']\n    else:\n        percent_text = str(np.around(self.solution['top_3_choice_percent'] * 100, 3)) + \"%\"\n        title_text += ' Results: Cadet Top3: ' + percent_text\n        title_text += ', AFSC Score: ' + str(np.around(self.average_afsc_choice, 2))\n\n    # Update the title\n    if self.b['b_title'] is not None:  # We specified a title directly\n        title_text = self.b['b_title']\n    self.fig.suptitle(title_text, fontsize=self.b['b_title_size'], color=title_color)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.save_iteration_frame","title":"<code>save_iteration_frame(s, kind=None)</code>","text":"<p>Saves the iteration frame to the appropriate folder</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def save_iteration_frame(self, s, kind=None):\n    \"\"\"\n    Saves the iteration frame to the appropriate folder\n    \"\"\"\n\n    # Save the figure\n    if self.b['save_iteration_frames']:\n\n        # 'Sequence' Folder\n        folder_path = self.paths['Analysis &amp; Results'] + 'Cadet Board/'\n        if self.solution['iterations']['sequence'] not in os.listdir(folder_path):\n            os.mkdir(folder_path + self.solution['iterations']['sequence'])\n\n        # 'Sequence Focus' Sub-folder\n        sub_folder_name = self.b['focus']\n        if sub_folder_name not in os.listdir(folder_path + self.solution['iterations']['sequence'] + '/'):\n            os.mkdir(folder_path + self.solution['iterations']['sequence'] + '/' + sub_folder_name)\n        sub_folder_path = folder_path + self.solution['iterations']['sequence']  + '/' + sub_folder_name + '/'\n        if kind is None:\n            filepath = sub_folder_path + str(s + 1) + '.png'\n        elif kind == \"Final Solution\":\n            filepath = sub_folder_path + str(s + 2) + ' (' + kind + ').png'\n        else:\n            filepath = sub_folder_path + str(s + 1) + ' (' + kind + ').png'\n\n        # Save frame\n        self.fig.savefig(filepath)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.export_board_parameters","title":"<code>export_board_parameters()</code>","text":"<p>This function exports the board parameters back to excel</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def export_board_parameters(self):\n    \"\"\"\n    This function exports the board parameters back to excel\n    \"\"\"\n\n    if 'iterations' not in self.solution:\n\n        # Solutions Folder\n        filepath = self.paths['Analysis &amp; Results'] + self.solution['name'] + '/Board Parameters.csv'\n        if self.solution['name'] not in os.listdir(self.paths['Analysis &amp; Results']):\n            os.mkdir(self.paths['Analysis &amp; Results'] + self.solution['name'] + '/')\n    else:\n\n        # 'Sequence' Folder\n        folder_path = self.paths['Analysis &amp; Results'] + 'Cadet Board/'\n        filepath = folder_path + self.solution['iterations']['sequence'] + '/Board Parameters.csv'\n        if self.solution['iterations']['sequence'] not in os.listdir(folder_path):\n            os.mkdir(folder_path + self.solution['iterations']['sequence'])\n\n    # Create dataframe\n    df = pd.DataFrame({'J': [j for j in self.b['J']],\n                       'AFSC': [self.p['afscs'][j] for j in self.b['J']],\n                       'x': [self.b['x'][j] for j in self.b['J']],\n                       'y': [self.b['y'][j] for j in self.b['J']],\n                       'n': [self.b['n'][j] for j in self.b['J']],\n                       's': [self.b['s'] for _ in self.b['J']],\n                       'afsc_fontsize': [self.b['afsc_fontsize'][j] for j in self.b['J']],\n                       'afsc_title_two_lines': [self.b['afsc_title_two_lines'][j] for j in self.b['J']]})\n\n    # Export file\n    df.to_csv(filepath, index=False)\n\n    if self.printing:\n        print(\"Sequence parameters (J, x, y, n, s) exported to\", filepath)\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.BubbleChart.import_board_parameters","title":"<code>import_board_parameters()</code>","text":"<p>This method imports the board parameters from excel if applicable</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def import_board_parameters(self):\n    \"\"\"\n    This method imports the board parameters from excel if applicable\n    \"\"\"\n\n    # 'Solutions' Folder\n    if 'iterations' not in self.solution:\n        folder_path = self.paths['Analysis &amp; Results'] + self.solution['name']\n\n        # Import the file if we have it\n        if 'Board Parameters.csv' in os.listdir(folder_path):\n            filepath = folder_path + '/Board Parameters.csv'\n            df = afccp.globals.import_csv_data(filepath)\n\n            # Load parameters\n            self.b['J'] = np.array(df['J'])\n            self.b['afscs'] = np.array(df['AFSC'])\n            self.b['s'] = float(df.loc[0, 's'])\n            for key in ['x', 'y', 'n', 'afsc_fontsize', 'afsc_title_two_lines']:\n                self.b[key] = {j: df.loc[idx, key] for idx, j in enumerate(self.b['J'])}\n\n            if self.printing:\n                print(\"Sequence parameters (J, x, y, n, s) imported from\", filepath)\n            return True\n\n        else:\n\n            if self.printing:\n                print(\"No Sequence parameters found in solution analysis sub-folder '\" +\n                      self.solution['name'] + \"'.\")\n            return False\n\n\n    # 'Sequence' Folder\n    folder_path = self.paths['Analysis &amp; Results'] + 'Cadet Board/'\n    if self.solution['iterations']['sequence'] in os.listdir(folder_path):\n\n        # Import the file if we have it\n        if 'Board Parameters.csv' in os.listdir(folder_path + self.solution['iterations']['sequence']):\n            filepath = folder_path + self.solution['iterations']['sequence'] + '/Board Parameters.csv'\n            df = afccp.globals.import_csv_data(filepath)\n\n            # Load parameters\n            self.b['J'] = np.array(df['J'])\n            self.b['afscs'] = np.array(df['AFSC'])\n            self.b['s'] = float(df.loc[0, 's'])\n            for key in ['x', 'y', 'n', 'afsc_fontsize', 'afsc_title_two_lines']:\n                self.b[key] = {j: df.loc[idx, key] for idx, j in enumerate(self.b['J'])}\n\n            if self.printing:\n                print(\"Sequence parameters (J, x, y, n, s) imported from\", filepath)\n            return True\n\n        else:\n\n            if self.printing:\n                print(\"Sequence folder '\" + self.solution['iterations']['sequence'] + \"' in 'Cadet Board' analysis sub-folder, but no \"\n                                                                 \"board parameter file found within sequence folder.\")\n            return False\n\n    else:\n        if self.printing:\n            print(\"No sequence folder '\" + self.solution['iterations']['sequence'] + \"' in 'Cadet Board' analysis sub-folder.\")\n        return False\n</code></pre>"},{"location":"reference/visualizations/bubbles/#visualizations.bubbles.get_fontsize_for_text_in_box","title":"<code>get_fontsize_for_text_in_box(self, txt, xy, width, height, *, transform=None, ha='center', va='center', **kwargs)</code>","text":"<p>Determines fontsize of the text that needs to be inside a specific box</p> Source code in <code>afccp/visualizations/bubbles.py</code> <pre><code>def get_fontsize_for_text_in_box(self, txt, xy, width, height, *, transform=None,\n                                 ha='center', va='center', **kwargs):\n    \"\"\"\n    Determines fontsize of the text that needs to be inside a specific box\n    \"\"\"\n\n    # Transformation\n    if transform is None:\n        if isinstance(self, plt.Axes):\n            transform = self.transData\n        if isinstance(self, plt.Figure):\n            transform = self.transFigure\n\n    # Align the x and y\n    x_data = {'center': (xy[0] - width / 2, xy[0] + width / 2),\n              'left': (xy[0], xy[0] + width),\n              'right': (xy[0] - width, xy[0])}\n    y_data = {'center': (xy[1] - height / 2, xy[1] + height / 2),\n              'bottom': (xy[1], xy[1] + height),\n              'top': (xy[1] - height, xy[1])}\n\n    (x0, y0) = transform.transform((x_data[ha][0], y_data[va][0]))\n    (x1, y1) = transform.transform((x_data[ha][1], y_data[va][1]))\n\n    # Rectangle region size to constrain the text\n    rect_width = x1 - x0\n    rect_height = y1 - y0\n\n    # Doing stuff\n    fig = self.get_figure() if isinstance(self, plt.Axes) else self\n    dpi = fig.dpi\n    rect_height_inch = rect_height / dpi\n    fontsize = rect_height_inch * 72\n\n    # Put on the text\n    if isinstance(self, plt.Axes):\n        text = self.annotate(txt, xy, ha=ha, va=va, xycoords=transform,\n                             **kwargs)\n\n    # Adjust the fontsize according to the box size.\n    text.set_fontsize(fontsize)\n    bbox: Bbox = text.get_window_extent(fig.canvas.get_renderer())\n    adjusted_size = fontsize * rect_width / bbox.width\n    text.set_fontsize(adjusted_size)\n\n    # Remove the text but return the font size\n    text.remove()\n    return text.get_fontsize()\n</code></pre>"},{"location":"reference/visualizations/charts/","title":"Charts","text":""},{"location":"reference/visualizations/charts/#visualizations.charts","title":"<code>visualizations.charts</code>","text":""},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart","title":"<code>AFSCsChart(instance)</code>","text":"<p>This is a class dedicated to creating \"AFSCs Charts\" which are all charts that include AFSCs on the x-axis. This is meant to condense the amount of code and increase read-ability of the various kinds of charts.</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def __init__(self, instance):\n    \"\"\"\n    This is a class dedicated to creating \"AFSCs Charts\" which are all charts\n    that include AFSCs on the x-axis. This is meant to condense the amount of code and increase\n    read-ability of the various kinds of charts.\n    \"\"\"\n\n    # Load attributes\n    self.parameters = instance.parameters\n    self.value_parameters, self.vp_name = instance.value_parameters, instance.vp_name\n    self.ip = instance.mdl_p  # \"instance plot parameters\"\n    self.solution, self.solution_name = instance.solution, instance.solution_name\n    self.data_name, self.data_version = instance.data_name, instance.data_version\n\n    # Dictionaries of instance components (sets of value parameters, solutions)\n    self.vp_dict, self.solutions = instance.vp_dict, instance.solutions\n\n    # Initialize the matplotlib figure/axes\n    self.fig, self.ax = plt.subplots(figsize=self.ip['figsize'], facecolor=self.ip['facecolor'], tight_layout=True,\n                                     dpi=self.ip['dpi'])\n\n    # Label dictionary for AFSC objectives\n    self.label_dict = copy.deepcopy(afccp.globals.obj_label_dict)\n\n    # This is going to be a dictionary of all the various chart-specific components we need\n    self.c = {\"J\": self.ip['J'], 'afscs': self.ip['afscs'], 'M': self.ip['M'], 'k': 0,  # Default k\n              'y_max': self.ip['y_max'], 'legend_elements': None, 'use_calculated_y_max': False,\n              'legend_title': None}\n\n    # If we skip AFSCs\n    if self.ip[\"skip_afscs\"]:\n        self.c[\"tick_indices\"] = np.arange(1, self.c[\"M\"], 2).astype(int)\n    else:\n        self.c[\"tick_indices\"] = np.arange(self.c[\"M\"]).astype(int)\n\n    # Where to save the chart\n    self.paths = {\"Data\": instance.export_paths[\"Analysis &amp; Results\"] + \"Data Charts/\",\n                  \"Solution\": instance.export_paths[\"Analysis &amp; Results\"] + self.solution_name + \"/\",\n                  \"Comparison\": instance.export_paths[\"Analysis &amp; Results\"] + \"Comparison Charts/\"}\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.build","title":"<code>build(chart_type='Data', printing=True)</code>","text":"<p>Builds the specific chart based on what the user passes within the \"instance plot parameters\" (ip)</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def build(self, chart_type=\"Data\", printing=True):\n    \"\"\"\n    Builds the specific chart based on what the user passes within the \"instance plot parameters\" (ip)\n    \"\"\"\n\n    # If we don't have that data, just fill this in so this chart still works\n    if 'race_categories' not in self.parameters.keys():\n        self.parameters['race_categories'] = ['Blank']\n    if 'ethnicity_categories' not in self.parameters.keys():\n        self.parameters['ethnicity_categories'] = ['Blank']\n\n    # Determine which chart to build\n    if chart_type == \"Data\":\n        if self.ip['data_graph'] in ['Average Merit', 'USAFA Proportion', 'Average Utility']:\n            self.data_average_chart()\n        elif self.ip[\"data_graph\"] == \"AFOCD Data\":\n            self.data_afocd_chart()\n        elif self.ip[\"data_graph\"] == \"Cadet Preference Analysis\":\n            self.data_preference_chart()\n        elif self.ip[\"data_graph\"] == \"Eligible Quota\":\n            self.data_quota_chart()\n\n        # Get filename\n        if self.ip[\"filename\"] is None:\n            self.ip[\"filename\"] = \\\n                self.data_name + \" (\" + self.data_version + \") \" + self.ip[\"data_graph\"] + \" (Data).png\"\n\n    elif chart_type in [\"Solution\", \"Comparison\"]:\n\n        # Only perform the following steps if it's for a \"real\" VP objective\n        if self.ip['objective'] != 'Extra':\n\n            # AFSC objective index and condense the AFSCs if this is an AFOCD objective\n            self.c['k'] = np.where(self.value_parameters['objectives'] == self.ip['objective'])[0][0]\n            self.condense_afscs_based_on_objective()\n\n        # Need to know number of cadets assigned\n        self.c['total_count'] = self.solution[\"count\"][self.c['J']]\n\n        # Determine if we sort the AFSCs by PGL or not\n        if self.ip['sort_by_pgl'] and \"STEM\" not in self.ip['version']:\n            quota = np.array([self.parameters['pgl'][j] for j in self.c['J']])\n\n            # Sort the AFSCs by the PGL\n            indices = np.argsort(quota)[::-1]\n            self.c['afscs'] = self.c['afscs'][indices]\n            self.c['total_count'] = self.c['total_count'][indices]\n            self.c['J'] = self.c['J'][indices]\n\n        # Sort by STEM AFSCs\n        if \"STEM\" in self.ip['version']:\n\n            # Sort all the AFSCs by the PGL\n            sorted_indices = np.argsort(self.parameters['pgl'])[::-1]\n\n            # Sort the AFSCs by \"Not STEM\", \"Hybrid\", \"STEM\" and then by PGL\n            sorted_j = []\n            for cat in [\"Not STEM\", \"Hybrid\", \"STEM\"]:\n                for j in sorted_indices:\n                    if j in p['J^' + cat] and j in self.c['J']:\n                        sorted_j.append(j)\n\n            # Sort the specific elements of this chart\n            indices = np.array(sorted_j)\n            self.c['afscs'] = self.c['afscs'][indices]\n            self.c['total_count'] = self.c['total_count'][indices]\n            self.c['J'] = self.c['J'][indices]\n\n        if self.ip['results_graph'] == 'Solution Comparison':\n            self.results_solution_comparison_chart()\n        else:\n\n            if self.ip['objective'] != 'Extra':\n\n                # Default y-label\n                self.c['y_label'] = self.label_dict[self.ip['objective']]\n\n                # Shared elements\n                self.c['measure'] = self.solution['objective_measure'][self.c['J'], self.c['k']]\n\n                # Build the Merit Chart\n                if self.ip['objective'] == 'Merit':\n                    self.results_merit_chart()\n\n                # Demographic Chart\n                elif self.ip['objective'] in ['USAFA Proportion', 'Male', 'Minority']:\n                    self.results_demographic_chart()\n\n                # AFOCD Degree Tier Chart\n                elif self.ip['objective'] in ['Mandatory', 'Desired', 'Permitted', 'Tier 1', 'Tier 2',\n                                              'Tier 3', 'Tier 4']:\n                    self.results_degree_tier_chart()\n\n                # Combined Quota Chart\n                elif self.ip['objective'] == 'Combined Quota':\n                    self.results_quota_chart()\n\n                # Cadet/AFSC Preference Chart\n                elif self.ip['objective'] == 'Utility':\n                    self.results_preference_chart()\n                elif self.ip['objective'] == 'Norm Score':\n                    if self.ip['version'] == 'bar':\n                        self.results_norm_score_chart()\n                    else:\n                        self.results_preference_chart()\n\n            else:\n\n                # Demographic Charts\n                if self.ip['version'] in ['Race Chart', 'Gender Chart', 'Ethnicity Chart', 'SOC Chart',\n                                          'Race Chart_proportion', 'Gender Chart_proportion',\n                                          'Ethnicity Chart_proportion', 'SOC Chart_proportion']:\n\n                    # if 'race_categories' not in self.parameters:\n                    #     return None  # We're not doing this\n\n                    self.results_demographic_proportion_chart()\n\n        # Get filename\n        if self.ip[\"filename\"] is None:\n            self.ip[\"filename\"] = self.data_name + \" (\" + self.data_version + \") \" + self.solution_name + \" \" + \\\n                                  self.ip['objective'] + ' ' + self.ip[\"results_graph\"] + \" [\" + \\\n                                  self.ip['version'] + \"] (Results).png\"\n    else:\n        raise ValueError(\"Error. Invalid AFSC 'main' chart type value of '\" +\n                         chart_type + \"'. Valid inputs are 'Data' or 'Results'.\")\n\n    # Put the solution name in the title\n    if self.ip[\"solution_in_title\"]:\n        self.ip['title'] = self.solution_name + \": \" + self.ip['title']\n\n    # Display title\n    if self.ip['display_title']:\n        self.fig.suptitle(self.ip['title'], fontsize=self.ip['title_size'])\n\n    # Labels\n    self.ax.set_ylabel(self.c[\"y_label\"])\n    self.ax.yaxis.label.set_size(self.ip['label_size'])\n    self.ax.set_xlabel('AFSCs')\n    self.ax.xaxis.label.set_size(self.ip['label_size'])\n\n    if self.ip[\"color_afsc_text_by_grp\"]:\n        afsc_colors = [self.ip['bar_colors'][self.parameters['acc_grp'][j]] for j in self.c['J']]\n    else:\n        afsc_colors = [\"black\" for _ in self.c['afscs']]\n\n    # X axis\n    self.ax.tick_params(axis='x', labelsize=self.ip['afsc_tick_size'])\n    self.ax.set_xticklabels(self.c[\"afscs\"][self.c[\"tick_indices\"]], rotation=self.ip['afsc_rotation'])\n    self.ax.set_xticks(self.c[\"tick_indices\"])\n    self.ax.set(xlim=(-0.8, self.c[\"M\"]))\n\n    # Unique AFSC colors potentially based on accessions group\n    for index, xtick in enumerate(self.ax.get_xticklabels()):\n        xtick.set_color(afsc_colors[index])\n\n    # Y axis\n    self.ax.tick_params(axis='y', labelsize=self.ip['yaxis_tick_size'])\n    self.ax.set(ylim=(0, self.c[\"y_max\"]))\n    if \"y_ticks\" in self.c:\n        self.ax.set_yticklabels(self.c['y_ticks'])\n        self.ax.set_yticks(self.c['y_ticks'])\n\n    # Legend\n    if self.ip[\"add_legend_afsc_chart\"] and self.c['legend_elements'] is not None:\n\n        if self.c['legend_title']:\n            self.ax.legend(handles=self.c[\"legend_elements\"], edgecolor='black', loc=self.ip['legend_loc'],\n                           fontsize=self.ip['legend_size'], ncol=self.ip['ncol'], labelspacing=1, handlelength=0.8,\n                           handletextpad=0.2, borderpad=0.2, handleheight=2, title=self.c['legend_title'],\n                           title_fontsize=self.ip['legend_fontsize'])\n        else:\n            self.ax.legend(handles=self.c[\"legend_elements\"], edgecolor='black', loc=self.ip['legend_loc'],\n                           fontsize=self.ip['legend_size'], ncol=self.ip['ncol'], labelspacing=1, handlelength=0.8,\n                           handletextpad=0.2, borderpad=0.2, handleheight=2)\n\n    # Save the chart\n    if self.ip['save']:\n        self.fig.savefig(self.paths[chart_type] + self.ip[\"filename\"])\n\n        if printing:\n            print(\"Saved\", self.ip[\"filename\"], \"Chart to \" + self.paths[chart_type] + \".\")\n    else:\n        if printing:\n            print(\"Created\", self.ip[\"filename\"], \"Chart.\")\n\n    # Return the full chart object\n    return self\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.condense_afscs_based_on_objective","title":"<code>condense_afscs_based_on_objective()</code>","text":"<p>This method reduces the AFSCs we're looking at based on the AFSCs that have a non-zero objective weight for AFOCD objectives</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def condense_afscs_based_on_objective(self):\n    \"\"\"\n    This method reduces the AFSCs we're looking at based on the AFSCs that have a non-zero objective weight\n    for AFOCD objectives\n    \"\"\"\n\n    # If it's an AFOCD objective, we only take the AFSCs that have that objective\n    if self.ip['objective'] in ['Mandatory', 'Desired', 'Permitted', 'Tier 1', 'Tier 2', 'Tier 3', 'Tier 4']:\n        self.c['J'] = np.array([j for j in self.c['J'] if self.c['k'] in self.value_parameters['K^A'][j]]).astype(int)\n        self.c['afscs'] = self.parameters['afscs'][self.c['J']]\n        self.c['M'] = len(self.c['afscs'])\n\n        # Make sure we're not skipping AFSCs at this point\n        self.c[\"tick_indices\"] = np.arange(self.c[\"M\"]).astype(int)\n\n    # Make sure at least one AFSC has this objective selected\n    if self.c['M'] == 0:\n        raise ValueError(\"Error. No AFSCs have objective '\" + self.ip[\"objective\"] + \"'.\")\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.determine_y_max_and_y_ticks","title":"<code>determine_y_max_and_y_ticks()</code>","text":"<p>This method calculates the correct y_max and y_ticks for this chart in place</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def determine_y_max_and_y_ticks(self):\n    \"\"\"\n    This method calculates the correct y_max and y_ticks for this chart in place\n    \"\"\"\n    # Y max\n    if self.ip['y_exact_max'] is None:\n        self.c['y_max'] = self.ip['y_max'] * max(self.c['total_count'])\n    else:\n        self.c['y_max'] = self.ip['y_max'] * self.ip['y_exact_max']\n\n    if 100 &lt;= self.c['y_max'] &lt; 150:\n        self.c['y_ticks'] = [50, 100, 150]\n    elif 150 &lt;= self.c['y_max'] &lt; 200:\n        self.c['y_ticks'] = [50, 100, 150, 200]\n    elif 200 &lt;= self.c['y_max'] &lt; 250:\n        self.c['y_ticks'] = [50, 100, 150, 200, 250]\n    elif 250 &lt;= self.c['y_max'] &lt; 300:\n        self.c['y_ticks'] = [50, 100, 150, 200, 250, 300]\n    elif 250 &lt;= self.c['y_max'] &lt; 300:\n        self.c['y_ticks'] = [50, 100, 150, 200, 250, 300, 350]\n    elif self.c['y_max'] &gt;= 500:\n        self.c['y_ticks'] = [100, 200, 300, 400, 500, 600]\n    else:\n        self.c['y_ticks'] = [50]\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.construct_gradient_chart","title":"<code>construct_gradient_chart(parameter_to_use='cadet_utility')</code>","text":"<p>Constructs the gradient chart with \"DIY color bar\"</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def construct_gradient_chart(self, parameter_to_use='cadet_utility'):\n    \"\"\"\n    Constructs the gradient chart with \"DIY color bar\"\n    \"\"\"\n\n    # Shorthand\n    p = self.parameters\n\n    for index, j in enumerate(self.c['J']):\n        cadets = np.where(self.solution['j_array'] == j)[0]\n\n        # What are we plotting\n        if 'parameter_to_use' == 'cadet_utility':\n            measure = p[\"utility\"][cadets, j]\n        else:\n            measure = p[\"merit\"][cadets]\n\n        # Plot the bar\n        uq = np.unique(measure)\n        count_sum = 0\n        for val in uq:\n            count = len(np.where(measure == val)[0])\n\n            if parameter_to_use == 'cadet_utility':\n                c = (1 - val, 0, val)  # Blue to Red\n            else:\n                c = str(val)  # Grayscale\n            self.ax.bar([index], count, bottom=count_sum, color=c)\n            count_sum += count\n\n        # Add the text\n        self.ax.text(index, self.c['total_count'][index] + 2, int(self.c['total_count'][index]),\n                     fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n\n    # DIY Colorbar\n    h = (100 / 245) * self.c['y_max']\n    w1 = 0.8\n    w2 = 0.74\n    vals = np.arange(101) / 100\n    current_height = (150 / 245) * self.c['y_max']\n    self.ax.add_patch(Rectangle((self.c['M'] - 2, current_height), w1, h, edgecolor='black', facecolor='black',\n                                fill=True, lw=2))\n    self.ax.text(self.c['M'] - 3.3, (245 / 245) * self.c['y_max'], '100%', fontsize=self.ip[\"xaxis_tick_size\"])\n    self.ax.text(self.c['M'] - 2.8, current_height, '0%', fontsize=self.ip[\"xaxis_tick_size\"])\n    self.ax.text((self.c['M'] - 0.95), (166 / 245) * self.c['y_max'], 'Cadet Satisfaction',\n                fontsize=self.ip[\"xaxis_tick_size\"], rotation=270)\n    for val in vals:\n        if parameter_to_use == 'cadet_utility':\n            c = (1 - val, 0, val)  # Blue to Red\n        else:\n            c = str(val)  # Grayscale\n        self.ax.add_patch(Rectangle((self.c['M'] - 1.95, current_height), w2, h / 101, facecolor=c, fill=True))\n        current_height += h / 101\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.data_average_chart","title":"<code>data_average_chart()</code>","text":"<p>This method builds the \"Average Merit\", \"USAFA Proportion\", and \"Average Utility\" data graph charts. They are all in a very similar format and are therefore combined</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def data_average_chart(self):\n    \"\"\"\n    This method builds the \"Average Merit\", \"USAFA Proportion\", and \"Average Utility\" data graph charts. They are\n    all in a very similar format and are therefore combined\n    \"\"\"\n\n    # Shorthand\n    p = self.parameters\n\n    # Get correct solution and targets\n    if self.ip['data_graph'] == \"Average Merit\":\n        metric = np.array([np.mean(p['merit'][p['I^E'][j]]) for j in self.c[\"J\"]])\n        target = 0.5\n    elif self.ip['data_graph'] == 'USAFA Proportion':\n        metric = np.array([len(p['I^D']['USAFA Proportion'][j]) / len(p['I^E'][j]) for j in self.c[\"J\"]])\n        target = p['usafa_proportion']\n    else:\n        if self.ip[\"eligibility\"]:\n            metric = np.array([np.mean(p['utility'][p['I^E'][j], j]) for j in self.c[\"J\"]])\n        else:\n            metric = np.array([np.mean(p['utility'][:, j]) for j in self.c[\"J\"]])\n        target = None\n\n    # Axis Adjustments\n    self.ax.set(ylim=(0, 1))\n\n    # Bar Chart\n    self.ax.bar(self.c['afscs'], metric, color=self.ip[\"bar_color\"], alpha=self.ip[\"alpha\"], edgecolor='black')\n\n    # Add a \"target\" line\n    if target is not None:\n        self.ax.axhline(y=target, color='black', linestyle='--', alpha=self.ip[\"alpha\"])\n\n    # Get correct label, title\n    self.c['y_label'] = self.ip['data_graph']\n    if self.ip['title'] is None:\n        self.ip['title'] = self.ip['data_graph'] + ' Across '\n        if self.ip['data_graph'] == 'Average Utility' and not self.ip['eligibility']:\n            self.ip['title'] += 'All Cadets'\n        else:\n            self.ip['title'] += 'Eligible Cadets'\n        if self.ip['eligibility_limit'] != p['N']:\n            self.ip['title'] += ' for AFSCs with &lt;= ' + \\\n                                str(self.ip['eligibility_limit']) + ' Eligible Cadets'\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.data_afocd_chart","title":"<code>data_afocd_chart()</code>","text":"<p>This method builds the \"AFOCD Data\" data graph chart.</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def data_afocd_chart(self):\n    \"\"\"\n    This method builds the \"AFOCD Data\" data graph chart.\n    \"\"\"\n\n    # Shorthand\n    p = self.parameters\n\n    # Legend\n    self.c[\"legend_elements\"] = [\n        Patch(facecolor=self.ip[\"bar_colors\"][\"Permitted\"], label='Permitted', edgecolor='black'),\n        Patch(facecolor=self.ip[\"bar_colors\"][\"Desired\"], label='Desired', edgecolor='black'),\n        Patch(facecolor=self.ip[\"bar_colors\"][\"Mandatory\"], label='Mandatory', edgecolor='black')]\n\n    # Get solution\n    mandatory_count = np.array([np.sum(p['mandatory'][:, j]) for j in self.c[\"J\"]])\n    desired_count = np.array([np.sum(p['desired'][:, j]) for j in self.c[\"J\"]])\n    permitted_count = np.array([np.sum(p['permitted'][:, j]) for j in self.c[\"J\"]])\n\n    # Bar Chart\n    self.ax.bar(self.c[\"afscs\"], mandatory_count, color=self.ip[\"bar_colors\"][\"Mandatory\"], edgecolor='black')\n    self.ax.bar(self.c[\"afscs\"], desired_count, bottom=mandatory_count,\n                color=self.ip[\"bar_colors\"][\"Desired\"], edgecolor='black')\n    self.ax.bar(self.c[\"afscs\"], permitted_count, bottom=mandatory_count + desired_count,\n                color=self.ip[\"bar_colors\"][\"Permitted\"], edgecolor='black')\n\n    # Axis Adjustments\n    self.ax.set(ylim=(0, self.ip['eligibility_limit'] + self.ip['eligibility_limit'] / 100))\n\n    # Get correct text\n    self.c[\"y_label\"] = \"Number of Cadets\"\n    if self.ip['title'] is None:\n        self.ip['title'] = 'AFOCD Degree Tier Breakdown'\n        if self.ip['eligibility_limit'] != p['N']:\n            self.ip['title'] += ' for AFSCs with &lt;= ' + \\\n                                str(self.ip['eligibility_limit']) + ' Eligible Cadets'\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.data_preference_chart","title":"<code>data_preference_chart()</code>","text":"<p>This method generates the \"Cadet Preference\" charts based on the version specified</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def data_preference_chart(self):\n    \"\"\"\n    This method generates the \"Cadet Preference\" charts based on the version\n    specified\n    \"\"\"\n\n    # Shorthand\n    p = self.parameters\n\n    # Choice Counts\n    top_3_count = np.array([sum(p[\"Choice Count\"][choice][j] for choice in [0, 1, 2]) for j in p[\"J\"]])\n    next_3_count = np.array([sum(p[\"Choice Count\"][choice][j] for choice in [3, 4, 5]) for j in p[\"J\"]])\n\n    # Sets of cadets that have the AFSC in their top 3 choices and are eligible for the AFSC\n    top_3_cadets = {}\n    top_3_eligible_cadets = {}\n    for j in p[\"J\"]:\n        top_3_cadets[j] = []\n        top_3_eligible_cadets[j] = []\n        for i in p[\"I\"]:\n            for choice in [0, 1, 2]:\n                if i in p[\"I^Choice\"][choice][j]:\n                    top_3_cadets[j].append(i)\n                    if i in p[\"I^E\"][j]:\n                        top_3_eligible_cadets[j].append(i)\n        top_3_cadets[j] = np.array(top_3_cadets[j])\n        top_3_eligible_cadets[j] = np.array(top_3_eligible_cadets[j])\n\n    # AFOCD solution\n    mandatory_count = np.array([np.sum(p['mandatory'][top_3_cadets[j], j]) for j in p[\"J\"]])\n    desired_count = np.array([np.sum(p['desired'][top_3_cadets[j], j]) for j in p[\"J\"]])\n    permitted_count = np.array([np.sum(p['permitted'][top_3_cadets[j], j]) for j in p[\"J\"]])\n    ineligible_count = np.array([np.sum(p['ineligible'][top_3_cadets[j], j]) for j in p[\"J\"]])\n\n    # Version 1\n    if self.ip[\"version\"] == \"1\":\n        self.c[\"legend_elements\"] = [\n            Patch(facecolor=self.ip['bar_colors'][\"top_choices\"], label='Top 3 Choices', edgecolor='black'),\n            Patch(facecolor=self.ip['bar_colors'][\"mid_choices\"], label='Next 3 Choices', edgecolor='black')]\n\n        # Bar Chart\n        self.ax.bar(self.c[\"afscs\"], next_3_count, color=self.ip['bar_colors'][\"mid_choices\"], edgecolor='black')\n        self.ax.bar(self.c[\"afscs\"], top_3_count, bottom=next_3_count, color=self.ip['bar_colors'][\"top_choices\"],\n                    edgecolor='black')\n\n        # Y max used for axis adjustments\n        self.c[\"y_max\"] = np.max(top_3_count + next_3_count)\n\n        if self.ip['title'] is None:\n            self.ip['title'] = \"Cadet Preferences Placed on Each AFSC (Before Match)\"\n\n    # Version 2\n    elif self.ip[\"version\"] == \"2\":\n        self.c[\"legend_elements\"] = [\n            Patch(facecolor=self.ip['bar_colors'][\"top_choices\"], label='Top 3 Choices', edgecolor='black')]\n\n        # Bar Chart\n        self.ax.bar(self.c[\"afscs\"], top_3_count, color=self.ip['bar_colors'][\"top_choices\"], edgecolor='black')\n\n        # Y max used for axis adjustments\n        self.c[\"y_max\"] = np.max(top_3_count)\n\n        if self.ip['title'] is None:\n            self.ip['title'] = \"Cadet Top 3 Preferences Placed on Each AFSC (Before Match)\"\n\n    # Version 3\n    elif self.ip[\"version\"] == \"3\":\n        self.c[\"legend_elements\"] = [Patch(facecolor=self.ip['bar_colors'][objective], label=objective) for\n                                     objective in [\"Ineligible\", \"Permitted\", \"Desired\", \"Mandatory\"]]\n\n        # Bar Chart\n        self.ax.bar(self.c[\"afscs\"], mandatory_count, color=self.ip['bar_colors'][\"Mandatory\"], edgecolor='black')\n        self.ax.bar(self.c[\"afscs\"], desired_count, bottom=mandatory_count, color=self.ip['bar_colors'][\"Desired\"],\n               edgecolor='black')\n        self.ax.bar(self.c[\"afscs\"], permitted_count, bottom=desired_count + mandatory_count,\n                    color=self.ip['bar_colors'][\"Permitted\"], edgecolor='black')\n        self.ax.bar(self.c[\"afscs\"], ineligible_count, bottom=permitted_count + desired_count + mandatory_count,\n               color=self.ip['bar_colors'][\"Ineligible\"], edgecolor='black')\n\n        # Y max used for axis adjustments\n        self.c[\"y_max\"] = np.max(top_3_count)\n\n        if self.ip['title'] is None:\n            self.ip['title'] = \"Cadet Degree Eligibility of Preferred Cadets on Each AFSC (Before Match)\"\n\n    # Version 4\n    elif self.ip[\"version\"] == \"4\":\n        self.c[\"legend_elements\"] = [Patch(facecolor=self.ip['bar_colors'][objective], label=objective) for\n                                     objective in [\"Permitted\", \"Desired\", \"Mandatory\"]]\n\n        # Bar Chart\n        self.ax.bar(self.c[\"afscs\"], mandatory_count, color=self.ip['bar_colors'][\"Mandatory\"],\n                    edgecolor='black')\n        self.ax.bar(self.c[\"afscs\"], desired_count, bottom=mandatory_count,\n                    color=self.ip['bar_colors'][\"Desired\"],\n                    edgecolor='black')\n        self.ax.bar(self.c[\"afscs\"], permitted_count, bottom=desired_count + mandatory_count,\n                    color=self.ip['bar_colors'][\"Permitted\"], edgecolor='black')\n\n        # Y max used for axis adjustments\n        self.c[\"y_max\"] = np.max(top_3_count)\n\n        if self.ip['title'] is None:\n            self.ip['title'] = \"Cadet Degree Eligibility of Preferred Cadets on Each AFSC (Before Match)\"\n\n    # Version 5\n    elif self.ip[\"version\"] == \"5\":\n\n        # Build a gradient\n        for j in p[\"J\"]:\n            merit = p[\"merit\"][top_3_eligible_cadets[j]]\n            uq = np.unique(merit)\n            count_sum = 0\n            for val in uq:\n                count = len(np.where(merit == val)[0])\n                c = str(val)  # Grayscale\n                self.ax.bar([j], count, bottom=count_sum, color=c, zorder=2)\n                count_sum += count\n\n            # Add the text and an outline\n            self.ax.text(j, len(top_3_eligible_cadets[j]) + 4, round(np.mean(merit), 2),\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n            self.ax.bar([j], len(top_3_eligible_cadets[j]), color=\"black\", zorder=1, edgecolor=\"black\")\n\n        # Y max used for axis adjustments\n        self.c[\"y_max\"] = np.max(top_3_count)\n\n        # DIY Colorbar\n        h = (100 / 245) * self.c[\"y_max\"]\n        w1 = 0.8\n        w2 = 0.74\n        current_height = (150 / 245) * self.c[\"y_max\"]\n        self.ax.add_patch(Rectangle((self.c[\"M\"] - 2, current_height), w1, h, edgecolor='black', facecolor='black',\n                                    fill=True, lw=2))\n        self.ax.text(self.c[\"M\"] - 3.3, (245 / 245) * self.c[\"y_max\"], '100%', fontsize=self.ip[\"text_size\"])\n        self.ax.text(self.c[\"M\"] - 2.8, current_height, '0%', fontsize=self.ip[\"text_size\"])\n        self.ax.text((self.c[\"M\"] - 0.95), (166 / 245) * self.c[\"y_max\"], 'Cadet Percentile',\n                     fontsize=self.ip[\"text_size\"], rotation=270)\n        vals = np.arange(101) / 100\n        for val in vals:\n            c = str(val)  # Grayscale\n            self.ax.add_patch(Rectangle((self.c[\"M\"] - 1.95, current_height), w2, h / 101, color=c, fill=True))\n            current_height += h / 101\n\n        # Y max used for axis adjustments\n        self.c[\"y_max\"] = np.max(top_3_count)\n\n        if self.ip['title'] is None:\n            self.ip['title'] = \"Merit of Preferred Cadets on Each AFSC (Before Match)\"\n\n    # Version 6\n    elif self.ip[\"version\"] == \"6\":\n        self.c[\"legend_elements\"] = [\n            Patch(facecolor=self.ip['bar_colors'][\"usafa\"], label='USAFA'),\n            Patch(facecolor=self.ip['bar_colors'][\"rotc\"], label='ROTC'),\n            mlines.Line2D([], [], color=\"red\", linestyle='-', linewidth=3, label=\"Baseline\")]\n\n        # USAFA/ROTC Numbers\n        rotc_baseline = np.array([len(top_3_eligible_cadets[j]) - (\n                len(top_3_eligible_cadets[j]) * p[\"usafa_proportion\"]) for j in p[\"J\"]])\n        usafa_count = np.array([np.sum(p['usafa'][top_3_eligible_cadets[j]]) for j in p[\"J\"]])\n        rotc_count = np.array([len(top_3_eligible_cadets[j]) - usafa_count[j] for j in p[\"J\"]])\n\n        # Bar Chart\n        self.ax.bar(self.c[\"afscs\"], rotc_count, color=self.ip['bar_colors'][\"rotc\"], edgecolor='black')\n        self.ax.bar(self.c[\"afscs\"], usafa_count, bottom=rotc_count, color=self.ip['bar_colors'][\"usafa\"],\n                    edgecolor='black')\n\n        # Add the baseline marks\n        for j in p[\"J\"]:\n            self.ax.plot((j - 0.4, j + 0.4), (rotc_baseline[j], rotc_baseline[j]),\n                    color=\"red\", linestyle=\"-\", zorder=2, linewidth=3)\n\n        # Y max used for axis adjustments\n        self.c[\"y_max\"] = np.max(top_3_count)\n\n        if self.ip['title'] is None:\n            self.ip['title'] = \"USAFA/ROTC Breakdown of Preferred Cadets on Each AFSC (Before Match)\"\n\n    # Version 7\n    elif self.ip[\"version\"] == \"7\":\n        self.c[\"legend_elements\"] = [\n            Patch(facecolor=self.ip['bar_colors'][\"male\"], label='Male'),\n            Patch(facecolor=self.ip['bar_colors'][\"female\"], label='Female'),\n            mlines.Line2D([], [], color=\"red\", linestyle='-', linewidth=3, label=\"Baseline\")]\n\n        # USAFA/ROTC Numbers\n        female_baseline = np.array([len(top_3_eligible_cadets[j]) - (\n                len(top_3_eligible_cadets[j]) * p[\"male_proportion\"]) for j in p[\"J\"]])\n        male_count = np.array([np.sum(p['male'][top_3_eligible_cadets[j]]) for j in p[\"J\"]])\n        female_count = np.array([len(top_3_eligible_cadets[j]) - male_count[j] for j in p[\"J\"]])\n\n        # Bar Chart\n        self.ax.bar(self.c[\"afscs\"], female_count, color=self.ip['bar_colors'][\"female\"], edgecolor='black')\n        self.ax.bar(self.c[\"afscs\"], male_count, bottom=female_count, color=self.ip['bar_colors'][\"male\"],\n                    edgecolor='black')\n\n        # Add the baseline marks\n        for j in p[\"J\"]:\n            self.ax.plot((j - 0.4, j + 0.4), (female_baseline[j], female_baseline[j]),\n                         color=\"red\", linestyle=\"-\", zorder=2, linewidth=3)\n\n        # Y max used for axis adjustments\n        self.c[\"y_max\"] = np.max(top_3_count)\n\n        if self.ip['title'] is None:\n            self.ip['title'] = \"Male/Female Breakdown of Preferred Cadets on Each AFSC (Before Match)\"\n\n    else:\n        raise ValueError(\"Version '\" + str(\n            self.ip[\"version\"]) + \"' is not valid for the Cadet Preference Analysis data graph.\")\n\n    # Axis Adjustments\n    self.ax.set(ylim=(0, self.c[\"y_max\"] * self.ip[\"y_max\"]))\n\n    # Get correct y-label\n    self.c[\"y_label\"] = \"Number of Cadets\"\n\n    # Get filename\n    if self.ip[\"filename\"] is None:\n        self.ip[\"filename\"] = self.data_name + \" (\" + self.data_version + \\\n                              \") Cadet Preference Analysis Version \" + self.ip[\"version\"] + \" (Data).png\"\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.data_quota_chart","title":"<code>data_quota_chart()</code>","text":"<p>This method builds the \"Eligible Quota\" data graph chart.</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def data_quota_chart(self):\n    \"\"\"\n    This method builds the \"Eligible Quota\" data graph chart.\n    \"\"\"\n\n    # Shorthand\n    p = self.parameters\n\n    # Legend\n    self.c[\"legend_elements\"] = [Patch(facecolor='blue', label='Eligible Cadets', edgecolor='black'),\n                                 Patch(facecolor='black', alpha=0.5, label='AFSC Quota', edgecolor='black')]\n\n    # Get solution\n    eligible_count = p[\"num_eligible\"][self.c[\"J\"]]\n    quota = p['pgl'][self.c[\"J\"]]\n\n    # Bar Chart\n    self.ax.bar(self.c[\"afscs\"], eligible_count, color='blue', edgecolor='black')\n    self.ax.bar(self.c[\"afscs\"], quota, color='black', edgecolor='black', alpha=0.5)\n\n    # Axis Adjustments\n    self.ax.set(ylim=(0, self.ip['eligibility_limit'] + self.ip['eligibility_limit'] / 100))\n\n    # Get correct text\n    self.c[\"y_label\"] = \"Number of Cadets\"\n    if self.ip['title'] is None:\n        self.ip['title'] = 'Eligible Cadets and Quotas'\n        if self.ip['eligibility_limit'] != p['N']:\n            self.ip['title'] += ' for AFSCs with &lt;= ' + \\\n                           str(self.ip['eligibility_limit']) + ' Eligible Cadets'\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.results_solution_comparison_chart","title":"<code>results_solution_comparison_chart()</code>","text":"<p>This method plots the solution comparison chart for the chosen objective specified</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_solution_comparison_chart(self):\n    \"\"\"\n    This method plots the solution comparison chart for the chosen objective specified\n    \"\"\"\n\n    # Shorthand\n    p, vp = self.parameters, self.value_parameters\n    k = self.c['k']\n\n    # Make sure at least one AFSC has this objective selected\n    if self.c['M'] == 0:\n        raise ValueError(\"Error. No AFSCs have objective '\" + ip[\"objective\"] + \"'.\")\n\n    # Keep track of useful variables\n    x_under, x_over = [], []\n    quota_percent_filled, max_quota_percent = np.zeros(self.c['M']), np.zeros(self.c['M'])\n    self.c['legend_elements'] = []\n    max_measure = np.zeros(self.c['M'])\n    y_top = 0\n\n    if self.ip['ncol'] != 1:\n        self.ip['ncol'] = len(self.ip['solution_names'])\n\n    # Loop through each solution\n    for s, solution in enumerate(self.ip[\"solution_names\"]):\n\n        # Calculate objective measure\n        if self.ip['version'] == 'median_preference':\n            cadets = [np.where(self.solutions[solution]['j_array'] == j)[0] for j in p['J']]\n            measure = np.array([np.median(p['c_pref_matrix'][cadets[j], j]) for j in self.c['J']])\n            self.label_dict[self.ip['objective']] = 'Median Cadet Choice'\n        elif self.ip['version'] == 'mean_preference':\n            cadets = [np.where(self.solutions[solution]['j_array'] == j)[0] for j in p['J']]\n            measure = np.array([np.mean(p['c_pref_matrix'][cadets[j], j]) for j in self.c['J']])\n            self.label_dict[self.ip['objective']] = 'Average Cadet Choice'\n        elif self.ip['version'] == 'Race Chart':\n            measure = np.array([self.solutions[solution]['simpson_index'][j] for j in self.c['J']])\n            self.label_dict[self.ip['objective']] = 'Simpson Diversity Index'\n        else:\n            measure = self.solutions[solution][\"objective_measure\"][self.c['J'], k]\n        if self.ip[\"objective\"] == \"Combined Quota\":\n            self.label_dict[self.ip[\"objective\"]] = 'Proportion of PGL Target Met'  # Adjust Label\n\n            # Assign the right color to the AFSCs\n            for idx, j in enumerate(self.c['J']):\n\n                # Get bounds\n                value_list = vp['objective_value_min'][j, k].split(\",\")\n                ub = float(value_list[1].strip())  # upper bound\n                quota = p[\"pgl\"][j]\n\n                # Constraint violations\n                if quota &gt; measure[idx]:\n                    x_under.append(idx)\n                elif measure[idx] &gt; ub:\n                    x_over.append(idx)\n\n                quota_percent_filled[idx] = measure[idx] / quota\n                max_quota_percent[idx] = ub / quota\n\n            # Top dot location\n            y_top = max(y_top, max(quota_percent_filled))\n\n            # Plot the points\n            self.ax.scatter(self.c['afscs'], quota_percent_filled, color=self.ip[\"colors\"][solution],\n                            marker=self.ip[\"markers\"][solution], alpha=self.ip[\"alpha\"], edgecolor='black',\n                            s=self.ip[\"dot_size\"], zorder=self.ip[\"zorder\"][solution])\n\n        else:\n\n            # Plot the points\n            self.ax.scatter(self.c['afscs'], measure, color=self.ip[\"colors\"][solution],\n                            marker=self.ip[\"markers\"][solution], alpha=self.ip[\"alpha\"], edgecolor='black',\n                            s=self.ip[\"dot_size\"], zorder=self.ip[\"zorder\"][solution])\n\n        max_measure = np.array([max(max_measure[idx], measure[idx]) for idx in range(self.c['M'])])\n        element = mlines.Line2D([], [], color=self.ip[\"colors\"][solution], marker=self.ip[\"markers\"][solution],\n                                linestyle='None', markeredgecolor='black', markersize=self.ip['legend_dot_size'],\n                                label=solution, alpha=self.ip[\"alpha\"])\n        self.c['legend_elements'].append(element)\n\n    # Lines to the top solution's dot\n    if self.ip[\"objective\"] not in [\"Combined Quota\", \"Mandatory\", \"Desired\", \"Permitted\", 'Tier 1', 'Tier 2',\n                                    'Tier 3', 'Tier 4']:\n        for idx in range(self.c['M']):\n            self.ax.plot((idx, idx), (0, max_measure[idx]), color='black', linestyle='--', zorder=1, alpha=0.5,\n                          linewidth=2)\n\n    # Objective Specific elements\n    if self.ip[\"objective\"] == \"Merit\":\n\n        # Tick marks and extra lines\n        self.c['y_ticks'] = [0, 0.35, 0.50, 0.65, 0.80, 1]\n        self.ax.plot((-1, 50), (0.65, 0.65), color='blue', linestyle='-', zorder=1, alpha=0.5, linewidth=1.5)\n        self.ax.plot((-1, 50), (0.5, 0.5), color='black', linestyle='--', zorder=1, alpha=0.5, linewidth=1.5)\n        self.ax.plot((-1, 50), (0.35, 0.35), color='blue', linestyle='-', zorder=1, alpha=0.5, linewidth=1.5)\n\n        # Set the max for the y-axis\n        self.c['y_max'] = self.ip['y_max'] * np.max(max_measure)\n\n    elif self.ip['version'] == 'Race Chart':\n        baseline = self.parameters['baseline_simpson_index']\n        self.c['y_ticks'] = [0, baseline, 1]\n        self.ax.plot((-1, 50), (baseline, baseline), color='black', linestyle='--', zorder=1, alpha=0.5,\n                     linewidth=1.5)\n\n        # Set the max for the y-axis\n        self.c['y_max'] = self.ip['y_max'] * np.max(max_measure)\n\n    elif self.ip[\"objective\"] in [\"USAFA Proportion\", \"Male\", \"Minority\"]:\n\n        # Demographic Proportion elements\n        prop_dict = {\"USAFA Proportion\": \"usafa_proportion\", \"Male\": \"male_proportion\",\n                     \"Minority\": \"minority_proportion\"}\n        up_lb = round(p[prop_dict[self.ip[\"objective\"]]] - 0.15, 2)\n        up_ub = round(p[prop_dict[self.ip[\"objective\"]]] + 0.15, 2)\n        up = round(p[prop_dict[self.ip[\"objective\"]]], 2)\n        self.c['y_ticks'] = [0, up_lb, up, up_ub, 1]\n\n        # Add lines for the ranges\n        self.ax.axhline(y=up, color='black', linestyle='--', alpha=0.5)\n        self.ax.axhline(y=up_lb, color='blue', linestyle='-', alpha=0.5)\n        self.ax.axhline(y=up_ub, color='blue', linestyle='-', alpha=0.5)\n\n        # Set the max for the y-axis\n        self.c['y_max'] = self.ip['y_max'] * np.max(max_measure)\n\n    elif self.ip[\"objective\"] in [\"Mandatory\", \"Desired\", \"Permitted\", \"Tier 1\", \"Tier 2\", 'Tier 3', \"Tier 4\"]:\n\n        # Degree Tier elements\n        self.c['y_ticks'] = [0, 0.2, 0.4, 0.6, 0.8, 1]\n        minimums = np.zeros(self.c['M'])\n        maximums = np.zeros(self.c['M'])\n\n        # Assign the right color to the AFSCs\n        for idx, j in enumerate(self.c['J']):\n            if \"Increasing\" in vp[\"value_functions\"][j, k]:\n                minimums[idx] = vp['objective_target'][j, k]\n                maximums[idx] = 1\n            else:\n                minimums[idx] = 0\n                maximums[idx] = vp['objective_target'][j, k]\n\n        # Calculate ranges\n        y = [(minimums[idx], maximums[idx]) for idx in range(self.c['M'])]\n        y_lines = [(0, minimums[idx]) for idx in range(self.c['M'])]\n\n        # Plot bounds\n        self.ax.scatter(range(self.c['M']), minimums, c=\"black\", marker=\"_\", linewidth=2, zorder=1)\n        self.ax.scatter(range(self.c['M']), maximums, c=\"black\", marker=\"_\", linewidth=2, zorder=1)\n\n        # Constraint Range\n        self.ax.plot((range(self.c['M']), range(self.c['M'])), ([i for (i, j) in y], [j for (i, j) in y]),\n                      c=\"black\", zorder=1)\n\n        # Line from x-axis to constraint range\n        self.ax.plot((range(self.c['M']), range(self.c['M'])), ([i for (i, j) in y_lines], [j for (i, j) in y_lines]),\n                      c=\"black\", zorder=1, alpha=0.5, linestyle='--', linewidth=2)\n\n    elif self.ip[\"objective\"] == \"Combined Quota\":\n\n        # Y axis adjustments\n        self.c['y_ticks'] = [0, 0.5, 1, 1.5, 2]\n        self.c['y_max'] = self.ip['y_max'] * y_top\n\n        # Lines\n        y_mins = np.repeat(1, self.c['M'])\n        y_maxs = max_quota_percent\n        y = [(y_mins[idx], y_maxs[idx]) for idx in range(self.c['M'])]\n        y_under = [(quota_percent_filled[idx], 1) for idx in x_under]\n        y_over = [(max_quota_percent[idx], quota_percent_filled[idx]) for idx in x_over]\n\n        # Plot Bounds\n        self.ax.scatter(self.c['afscs'], y_mins, c=np.repeat('black', self.c['M']), marker=\"_\", linewidth=2, zorder=1)\n        self.ax.scatter(self.c['afscs'], y_maxs, c=np.repeat('black', self.c['M']), marker=\"_\", linewidth=2, zorder=1)\n\n        # Plot Range Lines\n        self.ax.plot((range(self.c['M']), range(self.c['M'])), ([i for (i, j) in y], [j for (i, j) in y]),\n                     c='black', zorder=1)\n        self.ax.plot((x_under, x_under), ([i for (i, j) in y_under], [j for (i, j) in y_under]), c='black',\n                     linestyle='--', zorder=1)\n        self.ax.plot((x_over, x_over), ([i for (i, j) in y_over], [j for (i, j) in y_over]), c='black',\n                      linestyle='--', zorder=1)\n        self.ax.plot((range(self.c['M']), range(self.c['M'])), (np.zeros(self.c['M']), np.ones(self.c['M'])),\n                     c='black', linestyle='--', alpha=0.3, zorder=1)\n\n        # Quota Line\n        self.ax.axhline(y=1, color='black', linestyle='-', alpha=0.5, zorder=1)\n\n    elif self.ip[\"objective\"] in [\"Utility\", \"Norm Score\"] and self.ip['version'] == 'dot':\n\n        # Fix some things for this chart (y_ticks and label)\n        self.c['y_ticks'] = [0, 0.2, 0.4, 0.6, 0.8, 1]\n        self.label_dict[self.ip['objective']] = afccp.globals.obj_label_dict[self.ip['objective']]\n\n    # Set the max for the y-axis\n    if self.ip['version'] in ['median_preference', 'mean_preference']:\n        self.c['y_max'] = self.ip['y_max'] * np.max(max_measure)\n\n    # Get y-label\n    self.c['y_label'] = self.label_dict[self.ip['objective']]\n\n    # Get names of Solutions\n    solution_names = ', '.join(self.ip[\"solution_names\"])\n\n    # Create the title!\n    if self.ip[\"title\"] is None:\n        self.ip['title'] = solution_names + ' ' + self.label_dict[self.ip[\"objective\"]] + \" Across Each AFSC\"\n\n    # Update the version of the data using the solution names\n    self.ip['version'] = solution_names + ' ' + self.ip['version']\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.results_merit_chart","title":"<code>results_merit_chart()</code>","text":"<p>This method constructs the different charts showing the \"Balance Merit\" objective</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_merit_chart(self):\n    \"\"\"\n    This method constructs the different charts showing the \"Balance Merit\" objective\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = self.parameters, self.value_parameters, self.solution\n    k, quota, measure = self.c['k'], p['pgl'][self.c['J']], self.c['measure']\n    colors, afscs = np.array([self.ip['bar_colors'][\"small_afscs\"] for _ in self.c['J']]), self.c['afscs']\n\n    if self.ip[\"version\"] == \"large_only_bar\":\n\n        # Get the title\n        self.ip[\"title\"] = \"Average Merit Across Each Large AFSC\"\n\n        # Y-axis\n        self.c['use_calculated_y_max'] = True\n        self.c['y_max'] = self.ip['y_max']  # * np.max(measure)\n\n        # Assign the right color to the AFSCs\n        for j in range(self.c['M']):\n            if 0.35 &lt;= measure[j] &lt;= 0.65:\n                colors[j] = self.ip['bar_colors'][\"merit_within\"]\n            elif measure[j] &gt; 0.65:\n                colors[j] = self.ip['bar_colors'][\"merit_above\"]\n            else:\n                colors[j] = self.ip['bar_colors'][\"merit_below\"]\n\n        # Add lines for the ranges\n        self.ax.axhline(y=0.5, color='black', linestyle='--', alpha=0.5)\n\n        # Bound lines\n        if self.ip['add_bound_lines']:\n            self.c['y_ticks'] = [0, 0.35, 0.50, 0.65, 0.80, 1]\n            self.ax.axhline(y=0.35, color='blue', linestyle='-', alpha=0.5)\n            self.ax.axhline(y=0.65, color='blue', linestyle='-', alpha=0.5)\n        else:\n            self.c['y_ticks'] = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n\n        # Bar Chart\n        self.ax.bar(afscs, measure, color=colors, edgecolor='black', alpha=self.ip[\"alpha\"])\n\n    elif self.ip[\"version\"] == \"bar\":\n\n        # Get the title\n        self.ip[\"title\"] = \"Average Merit Across Each AFSC\"\n\n        # Set the max for the y-axis\n        self.c['use_calculated_y_max'] = True\n        self.c['y_max'] = self.ip['y_max']  # * np.max(measure)\n\n        # Merit elements\n        if self.ip['large_afsc_distinction']:\n            self.c['legend_elements'] = [Patch(facecolor=self.ip['bar_colors'][\"small_afscs\"], label='Small AFSC'),\n                                         Patch(facecolor=self.ip['bar_colors'][\"large_afscs\"], label='Large AFSC')]\n\n        # Assign the right color to the AFSCs\n        for j in range(self.c['M']):\n\n            # Colors\n            if self.ip['large_afsc_distinction']:\n                if quota[j] &gt;= 40:\n                    colors[j] = self.ip['bar_colors'][\"large_afscs\"]\n                else:\n                    colors[j] = self.ip['bar_colors'][\"small_afscs\"]\n            else:\n                colors[j] = self.ip['bar_color']\n\n            # Add the text\n            self.ax.text(j, measure[j] + 0.013, round(measure[j], 2),\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n\n        # Add lines for the ranges\n        self.ax.axhline(y=0.5, color='black', linestyle='--', alpha=0.5)\n\n        # Bound lines\n        if self.ip['add_bound_lines']:\n            self.c['legend_elements'].append(mlines.Line2D([], [], color=\"blue\", linestyle='-', label=\"Bound\"))\n            self.c['y_ticks'] = [0, 0.35, 0.50, 0.65, 0.80, 1]\n            self.ax.axhline(y=0.35, color='blue', linestyle='-', alpha=0.5)\n            self.ax.axhline(y=0.65, color='blue', linestyle='-', alpha=0.5)\n        else:\n            self.c['y_ticks'] = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n\n        # Bar Chart\n        self.ax.bar(afscs, measure, color=colors, edgecolor='black', alpha=self.ip[\"alpha\"])\n\n    elif self.ip[\"version\"] == \"quantity_bar_gradient\":\n\n        # Get the title and label\n        self.ip[\"title\"] = \"Cadet Merit Breakdown Across Each AFSC\"\n        self.c['y_label'] = \"Number of Cadets\"\n\n        # Calculate y-axis attributes\n        self.determine_y_max_and_y_ticks()\n\n        # Build the gradient chart\n        self.construct_gradient_chart(parameter_to_use='merit')\n\n    else:  # quantity_bar_proportion  (Quartiles in this case)\n\n        # Update the title\n        self.ip[\"title\"] = \"Cadet Quartiles Across Each AFSC\"\n        self.c['y_label'] = \"Number of Cadets\"\n\n        # Legend\n        self.c['legend_elements'] = [Patch(facecolor=self.ip['bar_colors'][\"quartile_1\"], label='1st Quartile'),\n                                     Patch(facecolor=self.ip['bar_colors'][\"quartile_2\"], label='2nd Quartile'),\n                                     Patch(facecolor=self.ip['bar_colors'][\"quartile_3\"], label='3rd Quartile'),\n                                     Patch(facecolor=self.ip['bar_colors'][\"quartile_4\"], label='4th Quartile')]\n\n        # Calculate y-axis attributes\n        self.determine_y_max_and_y_ticks()\n\n        percentile_dict = {1: (0.75, 1), 2: (0.5, 0.75), 3: (0.25, 0.5), 4: (0, 0.25)}\n        for index, j in enumerate(self.c['J']):\n            cadets = np.where(self.solution['j_array'] == j)[0]\n            merit = p[\"merit\"][cadets]\n\n            # Loop through each quartile\n            count_sum = 0\n            for q in [4, 3, 2, 1]:\n                lb, ub = percentile_dict[q][0], percentile_dict[q][1]\n                count = len(np.where((merit &lt;= ub) &amp; (merit &gt; lb))[0])\n                self.ax.bar([index], count, bottom=count_sum,\n                            color=self.ip['bar_colors'][\"quartile_\" + str(q)], zorder=2)\n                count_sum += count\n\n                # Put a number on the bar\n                if count &gt;= 10:\n                    if q == 1:\n                        c = \"white\"\n                    else:\n                        c = \"black\"\n                    self.ax.text(index, (count_sum - count / 2 - 2), int(count), color=c,\n                                 zorder=3, fontsize=self.ip[\"bar_text_size\"], horizontalalignment='center')\n\n            # Add the text and an outline\n            self.ax.text(index, self.c['total_count'][index] + 2, int(self.c['total_count'][index]),\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n            self.ax.bar([index], self.c['total_count'][index], color=\"black\", zorder=1, edgecolor=\"black\")\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.results_demographic_chart","title":"<code>results_demographic_chart()</code>","text":"<p>Chart to visualize the demographics of the solution</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_demographic_chart(self):\n    \"\"\"\n    Chart to visualize the demographics of the solution\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = self.parameters, self.value_parameters, self.solution\n    k, quota, measure = self.c['k'], p['pgl'][self.c['J']], self.c['measure']\n    colors, afscs = np.array([self.ip['bar_colors'][\"small_afscs\"] for _ in self.c['J']]), self.c['afscs']\n\n    # Demographic Proportion elements\n    prop_dict = {\"USAFA Proportion\": \"usafa_proportion\", \"Male\": \"male_proportion\",\n                 \"Minority\": \"minority_proportion\"}\n    legend_dict = {\"USAFA Proportion\": \"USAFA Proportion\", \"Male\": \"Male Proportion\",\n                   \"Minority\": \"Minority Proportion\"}\n    up_lb = round(p[prop_dict[self.ip[\"objective\"]]] - 0.15, 2)\n    up_ub = round(p[prop_dict[self.ip[\"objective\"]]] + 0.15, 2)\n    up = round(p[prop_dict[self.ip[\"objective\"]]], 2)\n\n    if self.ip[\"version\"] == \"large_only_bar\":\n\n        # Get the title and filename\n        self.ip[\"title\"] = legend_dict[self.ip[\"objective\"]] + \" Across Large AFSCs\"\n\n        # Set the max for the y-axis\n        self.c['use_calculated_y_max'] = True\n        self.c['y_max'] = self.ip['y_max']  # * np.max(measure)\n        self.c['y_ticks'] = [0, up_lb, up, up_ub, 1]\n\n        # Legend elements\n        self.c['legend_elements'] = [\n            Patch(facecolor=self.ip['bar_colors'][\"large_within\"], label=str(up_lb) + ' &lt; ' + legend_dict[\n                self.ip[\"objective\"]] + ' &lt; ' + str(up_ub)), Patch(facecolor=self.ip['bar_colors'][\"large_else\"],\n                                                                   label='Otherwise')]\n\n        # Assign the right color to the AFSCs\n        for j in range(self.c['M']):\n            if up_lb &lt;= measure[j] &lt;= up_ub:\n                colors[j] = self.ip['bar_colors'][\"large_within\"]\n            else:\n                colors[j] = self.ip['bar_colors'][\"large_else\"]\n\n        # Add lines for the ranges\n        self.ax.axhline(y=up, color='black', linestyle='--', alpha=0.5)\n        self.ax.axhline(y=up_lb, color='blue', linestyle='-', alpha=0.5)\n        self.ax.axhline(y=up_ub, color='blue', linestyle='-', alpha=0.5)\n\n        # Bar Chart\n        self.ax.bar(afscs, measure, color=colors, edgecolor='black', alpha=self.ip[\"alpha\"])\n\n    elif self.ip[\"version\"] == \"bar\":\n\n        # Get the title and filename\n        self.ip[\"title\"] = legend_dict[self.ip[\"objective\"]] + \" Across Each AFSC\"\n\n        # Y-axis\n        self.c['use_calculated_y_max'] = True\n        self.c['y_max'] = self.ip['y_max']  # * np.max(measure)\n        self.c['y_ticks'] = [0, up_lb, up, up_ub, 1]\n\n        # Legend elements\n        self.c['legend_elements'] = [Patch(facecolor=self.ip['bar_colors'][\"small_afscs\"], label='Small AFSC'),\n                                     Patch(facecolor=self.ip['bar_colors'][\"large_afscs\"], label='Large AFSC'),\n                                     mlines.Line2D([], [], color=\"blue\", linestyle='-', label=\"Bound\")]\n\n        # Assign the right color to the AFSCs\n        for j in range(self.c['M']):\n            if quota[j] &gt;= 40:\n                colors[j] = self.ip['bar_colors'][\"large_afscs\"]\n            else:\n                colors[j] = self.ip['bar_colors'][\"small_afscs\"]\n\n            # Add the text\n            self.ax.text(j, measure[j] + 0.013, round(measure[j], 2),\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n\n        # Add lines for the ranges\n        self.ax.axhline(y=up, color='black', linestyle='--', alpha=0.5)\n        self.ax.axhline(y=up_lb, color='blue', linestyle='-', alpha=0.5)\n        self.ax.axhline(y=up_ub, color='blue', linestyle='-', alpha=0.5)\n\n        # Bar Chart\n        self.ax.bar(afscs, measure, color=colors, edgecolor='black', alpha=self.ip[\"alpha\"])\n\n    elif self.ip[\"version\"] == \"preference_chart\":\n        self.c['y_label'] = \"Number of Cadets\"\n\n        # Objective specific components\n        if self.ip[\"objective\"] == \"USAFA Proportion\":\n\n            # Get the title\n            self.ip[\"title\"] = \"USAFA/ROTC 7+ Choice Across Each AFSC\"\n            classes = [\"USAFA\", \"ROTC\"]\n\n        elif self.ip[\"objective\"] == \"Male\":\n\n            # Get the title\n            self.ip[\"title\"] = \"Male/Female 7+ Choice Across Each AFSC\"\n            classes = [\"Male\", \"Female\"]\n\n        else:  # Minority\n\n            # Get the title\n            self.ip[\"title\"] = \"Minority/Non-Minority 7+ Choice Across Each AFSC\"\n            classes = [\"Minority\", \"Non-Minority\"]\n\n        # Calculate y-axis attributes\n        self.determine_y_max_and_y_ticks()\n\n        # Categories! (Volunteers/Non-Volunteers)\n        categories = [\"Top 6 Choices\", \"7+ Choice\"]\n\n        # Get the counts for each category and class\n        counts = {cls: {cat: np.zeros(self.c['M']) for cat in categories} for cls in classes}\n        dem = classes[0].lower()  # reference demographic (male, usafa, minority, etc.)\n        for index, afsc in enumerate(afscs):\n            j = np.where(p[\"afscs\"] == afsc)[0][0]\n            cadets_assigned = np.where(self.solution['j_array'] == j)[0]\n            cadets_with_demographic = np.where(p[dem] == 1)[0]\n            cadets_class = {classes[0]: np.intersect1d(cadets_assigned, cadets_with_demographic),\n                            classes[1]: np.array([cadet for cadet in cadets_assigned if\n                                                  cadet not in cadets_with_demographic])}\n\n            # Determine volunteer status\n            if categories == [\"Top 6 Choices\", \"7+ Choice\"]:\n                cadets_with_category = np.where(p['c_pref_matrix'][:, j] &lt; 7)[0]\n                cadets_cat = {\"Top 6 Choices\": np.intersect1d(cadets_assigned, cadets_with_category),\n                              \"7+ Choice\": np.array(\n                                  [cadet for cadet in cadets_assigned if cadet not in cadets_with_category])}\n\n            # Loop through each demographic\n            for cls in classes:\n                for cat in categories:\n                    counts[cls][cat][index] = len(np.intersect1d(cadets_class[cls], cadets_cat[cat]))\n\n        # Legend\n        self.c['legend_elements'] = [Patch(facecolor=self.ip['bar_colors'][cls.lower()],\n                                           label=cls, edgecolor='black') for cls in classes]\n        self.c['legend_elements'].append(\n            Patch(facecolor=self.ip['bar_colors'][\"7+ Choice\"], label=\"7+ Choice\"))\n\n        # Loop through each AFSC to plot the bars\n        for index, afsc in enumerate(afscs):\n\n            # Plot the AFOCD bars\n            count_sum = 0\n            for cls in classes[::-1]:\n                for cat in categories[::-1]:\n\n                    if cat == \"Top 6 Choices\":\n                        color = self.ip[\"bar_colors\"][cls.lower()]\n                    else:\n                        color = self.ip['bar_colors'][cat]\n\n                    # Plot the bars\n                    count = counts[cls][cat][index]\n                    self.ax.bar([index], count, bottom=count_sum, edgecolor=\"black\", color=color)\n                    count_sum += count\n\n                    # Put a number on the bar\n                    if count &gt;= 10:\n\n                        if cls in [\"Male\", \"USAFA\", \"Minority\"]:\n                            color = \"white\"\n                        else:\n                            color = \"black\"\n                        self.ax.text(index, (count_sum - count / 2 - 2), int(count), color=color,\n                                     zorder=2, fontsize=self.ip[\"bar_text_size\"], horizontalalignment='center')\n\n            # Add the text\n            self.ax.text(index, self.c['total_count'][index] + 2, int(self.c['total_count'][index]),\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n\n    else:  # Sorted Sized Bar Chart\n        self.c['y_label'] = \"Number of Cadets\"\n\n        # Objective specific components\n        if self.ip[\"objective\"] == \"USAFA Proportion\":\n            self.ip[\"title\"] = \"Source of Commissioning Breakdown Across Each AFSC\"\n            class_1_color = self.ip['bar_colors'][\"usafa\"]\n            class_2_color = self.ip['bar_colors'][\"rotc\"]\n\n            # Legend\n            self.c['legend_elements'] = [Patch(facecolor=class_1_color, label='USAFA'),\n                                         Patch(facecolor=class_2_color, label='ROTC')]\n\n        elif self.ip[\"objective\"] == \"Minority\":\n            self.ip[\"title\"] = \"Minority/Non-Minority Breakdown Across Each AFSC\"\n            class_1_color = self.ip['bar_colors'][\"minority\"]\n            class_2_color = self.ip['bar_colors'][\"non-minority\"]\n\n            # Legend\n            self.c['legend_elements'] = [Patch(facecolor=class_1_color, label='Minority'),\n                                         Patch(facecolor=class_2_color, label='Non-Minority')]\n\n        else:\n            self.ip[\"title\"] = \"Gender Breakdown Across Each AFSC\"\n            class_1_color = self.ip['bar_colors'][\"male\"]\n            class_2_color = self.ip['bar_colors'][\"female\"]\n\n            # Legend\n            self.c['legend_elements'] = [Patch(facecolor=class_1_color, label='Male'),\n                                         Patch(facecolor=class_2_color, label='Female')]\n\n        # Calculate y-axis attributes\n        self.determine_y_max_and_y_ticks()\n\n        # Get \"class\" objective measures (number of cadets with demographic)\n        class_1 = measure * self.c['total_count']\n        class_2 = (1 - measure) * self.c['total_count']\n        self.ax.bar(afscs, class_2, color=class_2_color, zorder=2, edgecolor=\"black\")\n        self.ax.bar(afscs, class_1, bottom=class_2, color=class_1_color, zorder=2, edgecolor=\"black\")\n        for j, afsc in enumerate(afscs):\n            if class_2[j] &gt;= 10:\n                self.ax.text(j, class_2[j] / 2, int(class_2[j]), color=\"black\",\n                             zorder=3, fontsize=self.ip[\"bar_text_size\"], horizontalalignment='center')\n            if class_1[j] &gt;= 10:\n                self.ax.text(j, class_2[j] + class_1[j] / 2, int(class_1[j]), color=\"white\", zorder=3,\n                             fontsize=self.ip[\"bar_text_size\"], horizontalalignment='center')\n\n            # Add the text and an outline\n            self.ax.text(j, self.c['total_count'][j] + 2, round(measure[j], 2), fontsize=self.ip[\"text_size\"],\n                         horizontalalignment='center')\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.results_demographic_proportion_chart","title":"<code>results_demographic_proportion_chart()</code>","text":"<p>Chart to visualize the demographics of the solution across each AFSC</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_demographic_proportion_chart(self):\n    \"\"\"\n    Chart to visualize the demographics of the solution across each AFSC\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = self.parameters, self.value_parameters, self.solution\n\n    # Category Dictionary\n    category_dict = {\"Race Chart\": p['race_categories'], 'Ethnicity Chart': p['ethnicity_categories'],\n                     'Gender Chart': ['Male', 'Female'], 'SOC Chart': ['USAFA', 'ROTC']}\n    title_dict = {\"Race Chart\": 'Racial Demographics Across Each AFSC',\n                  'Ethnicity Chart': 'Ethnicity Demographics Across Each AFSC',\n                  'Gender Chart': 'Gender Breakdown Across Each AFSC',\n                  'SOC Chart': 'Source of Commissioning Breakdown Across Each AFSC'}\n    afsc_num_dict = {\"Race Chart\": \"simpson_index\", \"Ethnicity Chart\": \"simpson_index_eth\",\n                     \"Gender Chart\": \"male_proportion_afscs\", \"SOC Chart\": \"usafa_proportion_afscs\"}\n    baseline_dict = {\"Gender Chart\": \"male_proportion\", \"SOC Chart\": \"usafa_proportion\",\n                     \"Race Chart\": \"baseline_simpson_index\", \"Ethnicity Chart\": \"baseline_simpson_index_eth\"}\n\n    # Proportion Chart\n    if '_proportion' in self.ip['version']:\n        proportion_chart = True\n        version = self.ip['version'][:-11]\n    else:\n        proportion_chart = False\n        version = self.ip['version']\n\n    # Extract the specific information for this chart from the dictionaries above\n    self.ip['title'] = title_dict[version]\n    categories = category_dict[version]\n    afsc_num_dict_s = afsc_num_dict[version]\n    baseline_p = baseline_dict[version]\n\n    # Legend elements\n    self.c['legend_elements'] = []\n    for cat in categories[::-1]:  # Flip the legend\n        color = self.ip['bar_colors'][cat]\n        self.c['legend_elements'].append(Patch(facecolor=color, label=cat, edgecolor='black'))\n\n    # Calculate y-axis attributes\n    if proportion_chart:\n\n        # Get y axis characteristics\n        self.c['use_calculated_y_max'] = True\n        self.c['y_ticks'] = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n        self.c['y_label'] = \"Proportion of Cadets\"\n        self.c['y_max'] *= 1.03  # expand it a little\n        self.ip['legend_size'] = self.ip['proportion_legend_size']  # Change the size of the legend\n        self.ip['ncol'] = 20  # Adjust number of columns for legend (Arbitrarily large number for horizontal legend)\n        self.ip['text_bar_threshold'] = self.ip['proportion_text_bar_threshold']  # Adjust this threshold\n\n        # Baseline\n        if len(categories) == 2:\n            self.c['legend_elements'].append(mlines.Line2D([], [], color=\"black\", linestyle='--', label=\"Baseline\"))\n            self.ax.axhline(y=p[baseline_p], color='black', linestyle='--', alpha=1, zorder=4)\n            self.c['y_ticks'] = [0, round(p[baseline_p], 2), 1]\n    else:\n        self.determine_y_max_and_y_ticks()\n        self.c['y_label'] = \"Number of Cadets\"\n\n    # Loop through each category and AFSC pair\n    quantities, proportions = {}, {}\n    for cat in categories:\n        quantities[cat], proportions[cat] = np.zeros(self.c['M']), np.zeros(self.c['M'])\n        for idx, j in enumerate(self.c['J']):\n            cadets = np.intersect1d(p['I^' + cat], solution['cadets_assigned'][j])\n\n            # Load metrics\n            quantities[cat][idx] = int(len(cadets))\n            proportions[cat][idx] = len(cadets) / len(solution['cadets_assigned'][j])\n\n    # Loop through each AFSC to add the text above the bars\n    for idx, j in enumerate(self.c['J']):\n\n        # Get the text for the top of the bar\n        txt = str(solution[afsc_num_dict_s][j])\n        if txt[0] == '0' and txt != '0.0':\n            txt = txt[1:]\n        elif txt == 'nan':\n            txt = ''\n\n        # Add the text\n        if proportion_chart:\n            self.ax.text(idx, 1.005, txt, verticalalignment='bottom', fontsize=self.ip[\"text_size\"],\n                         horizontalalignment='center')\n        else:\n            self.ax.text(idx, solution['count'][j] + 2, txt, verticalalignment='bottom',\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n\n    # Plot the data\n    totals = np.zeros(self.c['M'])\n    for cat in quantities:\n        color = self.ip['bar_colors'][cat]\n\n        if proportion_chart:\n            self.ax.bar(range(self.c['M']), proportions[cat], bottom=totals, color=color, zorder=2,\n                        edgecolor='black')\n            totals += proportions[cat]\n        else:\n            self.ax.bar(range(self.c['M']), quantities[cat], bottom=totals, color=color, zorder=2,\n                        edgecolor='black')\n            totals += quantities[cat]\n\n        # If it's a dark color, change text color to white\n        if 'Black' in cat or \"Male\" in cat:\n            text_color = 'white'\n        else:\n            text_color = 'black'\n\n        # Put a number on the bar\n        for idx, j in enumerate(self.c['J']):\n            if proportion_chart:\n                if proportions[cat][idx] &gt;= self.ip['text_bar_threshold'] / max(solution['count']):\n\n                    # Rotate triple digit text\n                    if quantities[cat][idx] &gt;= 100:\n                        rotation = 90\n                    else:\n                        rotation = 0\n\n                    # Place the text\n                    self.ax.text(idx, (totals[idx] - proportions[cat][idx] / 2), int(quantities[cat][idx]),\n                                 color=text_color, zorder=2, fontsize=self.ip[\"text_size\"],\n                                 horizontalalignment='center', verticalalignment='center', rotation=rotation)\n            else:\n                if proportions[cat][idx] &gt;= self.ip['text_bar_threshold'] / max(solution['count']):\n\n                    # Place the text\n                    self.ax.text(idx, (totals[idx] - quantities[cat][idx] / 2), int(quantities[cat][idx]),\n                                 color=text_color, zorder=2, fontsize=self.ip[\"text_size\"],\n                                 horizontalalignment='center', verticalalignment='center')\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.results_degree_tier_chart","title":"<code>results_degree_tier_chart()</code>","text":"<p>Builds the degree tier results chart</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_degree_tier_chart(self):\n    \"\"\"\n    Builds the degree tier results chart\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = self.parameters, self.value_parameters, self.solution\n    k, quota, measure = self.c['k'], p['pgl'][self.c['J']], self.c['measure']\n    colors, afscs = np.array([self.ip['bar_colors'][\"small_afscs\"] for _ in self.c['J']]), self.c['afscs']\n\n    # Get the title\n    self.ip[\"title\"] = self.ip[\"objective\"] + \" Proportion Across Each AFSC\"\n\n    # Set the max for the y-axis\n    self.c['use_calculated_y_max'] = True\n    self.c['y_max'] = self.ip['y_max']  # * np.max(measure)\n\n    minimums = np.zeros(self.c['M'])\n    maximums = np.zeros(self.c['M'])\n    x_under = []\n    x_over = []\n    x_within = []\n\n    # Assign the right color to the AFSCs\n    for index, j in enumerate(self.c['J']):\n        if \"Increasing\" in vp[\"value_functions\"][j, k]:\n            minimums[index] = vp['objective_target'][j, k]\n            maximums[index] = 1\n        else:\n            minimums[index] = 0\n            maximums[index] = vp['objective_target'][j, k]\n\n        if minimums[index] &lt;= measure[index] &lt;= maximums[index]:\n            colors[index] = \"blue\"\n            x_within.append(index)\n        else:\n            colors[index] = \"red\"\n            if measure[index] &lt; minimums[index]:\n                x_under.append(index)\n            else:\n                x_over.append(index)\n\n    # Plot points\n    self.ax.scatter(afscs, measure, c=colors, linewidths=4, s=self.ip[\"dot_size\"], zorder=3)\n\n    # Calculate ranges\n    y_within = [(minimums[j], maximums[j]) for j in x_within]\n    y_under_ranges = [(minimums[j], maximums[j]) for j in x_under]\n    y_over_ranges = [(minimums[j], maximums[j]) for j in x_over]\n    y_under = [(measure[j], minimums[j]) for j in x_under]\n    y_over = [(maximums[j], measure[j]) for j in x_over]\n\n    # Plot bounds\n    self.ax.scatter(afscs, minimums, c=\"black\", marker=\"_\", linewidth=2)\n    self.ax.scatter(afscs, maximums, c=\"black\", marker=\"_\", linewidth=2)\n\n    # Plot Ranges\n    self.ax.plot((x_within, x_within), ([i for (i, j) in y_within], [j for (i, j) in y_within]),\n                 c=\"black\")\n    self.ax.plot((x_under, x_under), ([i for (i, j) in y_under_ranges], [j for (i, j) in y_under_ranges]),\n                 c=\"black\")\n    self.ax.plot((x_over, x_over),([i for (i, j) in y_over_ranges], [j for (i, j) in y_over_ranges]), c=\"black\")\n\n    # How far off\n    self.ax.plot((x_under, x_under), ([i for (i, j) in y_under], [j for (i, j) in y_under]), c='red', linestyle='--')\n    self.ax.plot((x_over, x_over), ([i for (i, j) in y_over], [j for (i, j) in y_over]), c='red', linestyle='--')\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.results_quota_chart","title":"<code>results_quota_chart()</code>","text":"<p>This method produces the \"Combined Quota\" chart for each AFSC</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_quota_chart(self):\n    \"\"\"\n    This method produces the \"Combined Quota\" chart for each AFSC\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = self.parameters, self.value_parameters, self.solution\n    k, quota, measure = self.c['k'], p['pgl'][self.c['J']], self.c['measure']\n    colors, afscs = np.array([self.ip['bar_colors'][\"small_afscs\"] for _ in self.c['J']]), self.c['afscs']\n\n    if self.ip[\"version\"] == \"dot\":\n\n        # Get the title and label\n        self.ip[\"title\"] = \"Percent of PGL Target Met Across Each AFSC\"\n        self.c['y_label'] = \"Percent of PGL Target Met\"  # Manual change from objective label dictionary\n\n        # Set the max for the y-axis\n        self.c['use_calculated_y_max'] = True\n        self.c['y_ticks'] = [0, 0.5, 1, 1.5, 2]\n\n        # Degree Tier elements\n        x_under = []\n        x_over = []\n        x_within = []\n        quota_percent_filled = np.zeros(self.c['M'])\n        max_quota_percent = np.zeros(self.c['M'])\n\n        # Assign the right color to the AFSCs\n        for index, j in enumerate(self.c['J']):\n\n            # Get bounds\n            value_list = vp['objective_value_min'][j, k].split(\",\")\n            max_measure = float(value_list[1].strip())\n            if quota[index] &gt; measure[index]:\n                colors[index] = \"red\"\n                x_under.append(index)\n            elif quota[index] &lt;= measure[index] &lt;= max_measure:\n                colors[index] = \"blue\"\n                x_within.append(index)\n            else:\n                colors[index] = \"orange\"\n                x_over.append(index)\n\n            quota_percent_filled[index] = measure[index] / quota[index]\n            max_quota_percent[index] = max_measure / quota[index]\n\n        # Plot points\n        self.ax.scatter(afscs, quota_percent_filled, c=colors, linewidths=4, s=self.ip[\"dot_size\"], zorder=3)\n\n        # Set the max for the y-axis\n        self.c['y_max'] = self.ip['y_max'] * np.max(quota_percent_filled)\n\n        # Lines\n        y_mins = np.repeat(1, self.c['M'])\n        y_maxs = max_quota_percent\n        y = [(y_mins[j], y_maxs[j]) for j in range(self.c['M'])]\n        y_under = [(quota_percent_filled[j], 1) for j in x_under]\n        y_over = [(max_quota_percent[j], quota_percent_filled[j]) for j in x_over]\n\n        # Plot Bounds\n        self.ax.scatter(afscs, y_mins, c=np.repeat('blue', self.c['M']), marker=\"_\", linewidth=2)\n        self.ax.scatter(afscs, y_maxs, c=np.repeat('blue', self.c['M']), marker=\"_\", linewidth=2)\n\n        # Plot Range Lines\n        self.ax.plot((np.arange(self.c['M']), np.arange(self.c['M'])), ([i for (i, j) in y], [j for (i, j) in y]),\n                     c='blue')\n        self.ax.plot((x_under, x_under), ([i for (i, j) in y_under], [j for (i, j) in y_under]), c='red',\n                linestyle='--')\n        self.ax.plot((x_over, x_over), ([i for (i, j) in y_over], [j for (i, j) in y_over]), c='orange',\n                linestyle='--')\n        self.ax.plot((np.arange(self.c['M']), np.arange(self.c['M'])), (np.zeros(self.c['M']), np.ones(self.c['M'])),\n                     c='black', linestyle='--', alpha=0.3)\n\n        # Quota Line\n        self.ax.axhline(y=1, color='black', linestyle='-', alpha=0.5)\n\n        # Put quota text\n        y_top = round(max(quota_percent_filled))\n        y_spacing = (y_top / 80)\n        for j in range(self.c['M']):\n            if int(measure[j]) &gt;= 100:\n                self.ax.text(j, quota_percent_filled[j] + 1.4 * y_spacing, int(measure[j]),\n                             fontsize=self.ip[\"xaxis_tick_size\"], multialignment='right',\n                             horizontalalignment='center')\n            elif int(measure[j]) &gt;= 10:\n                self.ax.text(j, quota_percent_filled[j] + y_spacing, int(measure[j]),\n                             fontsize=self.ip[\"xaxis_tick_size\"], multialignment='right',\n                             horizontalalignment='center')\n            else:\n                self.ax.text(j, quota_percent_filled[j] + y_spacing, int(measure[j]),\n                             fontsize=self.ip[\"xaxis_tick_size\"], multialignment='right',\n                             horizontalalignment='center')\n\n    else:  # quantity_bar\n\n        # Get the title and label\n        self.ip[\"title\"] = \"Number of Cadets Assigned to Each AFSC against PGL\"\n        self.c['y_label'] = self.label_dict[self.ip[\"objective\"]]\n\n        # Calculate y-axis attributes\n        self.determine_y_max_and_y_ticks()\n\n        # Legend\n        self.c['legend_elements'] = [Patch(facecolor=self.ip['bar_colors'][\"pgl\"], label='PGL Target',\n                                           edgecolor=\"black\"),\n                                     Patch(facecolor=self.ip['bar_colors'][\"surplus\"],\n                                           label='Cadets Exceeding PGL Target', edgecolor=\"black\"),\n                                     Patch(facecolor=self.ip['bar_colors'][\"failed_pgl\"], label='PGL Target Not Met',\n                                           edgecolor=\"black\")]\n\n        # Add the text and quota lines\n        for j in range(self.c['M']):\n\n            # Add the text\n            self.ax.text(j, measure[j] + 2, int(measure[j]),\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n\n            # Determine which category the AFSC falls into\n            line_color = \"black\"\n            if measure[j] &gt; quota[j]:\n                self.ax.bar([j], quota[j], color=self.ip['bar_colors'][\"pgl\"], edgecolor=\"black\")\n                self.ax.bar([j], measure[j] - quota[j], bottom=quota[j],\n                            color=self.ip['bar_colors'][\"surplus\"], edgecolor=\"black\")\n            elif measure[j] &lt; quota[j]:\n                self.ax.bar([j], measure[j], color=self.ip['bar_colors'][\"failed_pgl\"], edgecolor=\"black\")\n                self.ax.plot((j - 0.4, j - 0.4), (quota[j], measure[j]),\n                        color=self.ip['bar_colors'][\"failed_pgl\"], linestyle=\"--\", zorder=2)\n                self.ax.plot((j + 0.4, j + 0.4), (quota[j], measure[j]),\n                        color=self.ip['bar_colors'][\"failed_pgl\"], linestyle=\"--\", zorder=2)\n                line_color = self.ip['bar_colors'][\"failed_pgl\"]\n            else:\n                self.ax.bar([j], measure[j], color=self.ip['bar_colors'][\"pgl\"], edgecolor=\"black\")\n\n            # Add the PGL lines\n            self.ax.plot((j - 0.4, j + 0.4), (quota[j], quota[j]), color=line_color, linestyle=\"-\", zorder=2)\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.results_preference_chart","title":"<code>results_preference_chart()</code>","text":"<p>This method builds the charts for cadet/AFSC preferences</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_preference_chart(self):\n    \"\"\"\n    This method builds the charts for cadet/AFSC preferences\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = self.parameters, self.value_parameters, self.solution\n    k, quota, measure = self.c['k'], p['pgl'][self.c['J']], self.c['measure']\n    colors, afscs = np.array([self.ip['bar_colors'][\"small_afscs\"] for _ in self.c['J']]), self.c['afscs']\n\n    if self.ip[\"version\"] in [\"quantity_bar_proportion\", \"quantity_bar_choice\"]:\n\n        # Counts\n        counts = {\"bottom_choices\": np.zeros(self.c['M']), \"mid_choices\": np.zeros(self.c['M']),\n                  \"top_choices\": np.zeros(self.c['M'])}\n\n        # Colors\n        colors = self.ip['bar_colors']\n\n        if self.ip[\"objective\"] == \"Utility\":\n\n            # Get the title\n            self.ip[\"title\"] = \"Cadet Preference Breakdown Across Each AFSC\"\n\n            if self.ip[\"version\"] == 'quantity_bar_choice':\n\n                # Legend (and colors)\n                self.c['legend_elements'] = []\n                self.ip['legend_size'] = int(self.ip['legend_size'] * 0.7)\n                colors = {}\n                for choice in range(p['P'])[:10]:\n                    colors[str(choice + 1)] = self.ip['choice_colors'][choice + 1]\n                    self.c['legend_elements'].append(Patch(facecolor=colors[str(choice + 1)],\n                                                           label=str(choice + 1), edgecolor='black'))\n                colors['All Others'] = self.ip['all_other_choice_colors']\n                self.c['legend_elements'].append(Patch(facecolor=colors['All Others'],\n                                                       label='All Others', edgecolor='black'))\n\n                # Add the title of the legend\n                self.c['legend_title'] = 'Cadet Choice'\n\n                # Counts\n                counts = {\"All Others\": np.zeros(self.c['M'])}\n                for choice in range(p['P'])[:10][::-1]:\n                    counts[str(choice + 1)] = np.zeros(self.c['M'])\n                for index, j in enumerate(self.c['J']):\n                    afsc = p['afscs'][j]\n                    total = 0\n                    for choice in range(p['P'])[:10]:\n                        counts[str(choice + 1)][index] = solution[\"choice_counts\"][\"TOTAL\"][afsc][choice]\n                        total += counts[str(choice + 1)][index]\n                    counts['All Others'][index] = self.c['total_count'][index] - total\n\n            else:\n\n                # Legend\n                self.c['legend_elements'] = [Patch(facecolor=self.ip['bar_colors'][\"top_choices\"],\n                                                   label='Top 3 Choices', edgecolor='black'),\n                                             Patch(facecolor=self.ip['bar_colors'][\"mid_choices\"],\n                                                   label='Next 3 Choices', edgecolor='black'),\n                                             Patch(facecolor=self.ip['bar_colors'][\"bottom_choices\"],\n                                                   label='All Others', edgecolor='black')]\n\n                # Cadet Choice Counts\n                for index, j in enumerate(self.c['J']):\n                    counts['top_choices'][index] = solution['choice_counts']['TOTAL']['Top 3'][j]\n                    counts['mid_choices'][index] = solution['choice_counts']['TOTAL']['Next 3'][j]\n                    counts['bottom_choices'][index] = solution['choice_counts']['TOTAL']['All Others'][j]\n\n\n        else:\n\n            # Get the title\n            self.ip[\"title\"] = \"AFSC Preference Breakdown\"\n\n            if self.ip[\"version\"] == 'quantity_bar_choice':\n\n                # Legend (and colors)\n                self.c['legend_elements'] = []\n                self.ip['legend_size'] = int(self.ip['legend_size'] * 0.7)\n                colors = {}\n                cat_choice_dict = {'90-100%': 1, '80-89%': 2, '70-79%': 3, '60-69%': 4, '50-59%': 5,\n                                   '40-49%': 6, '30-39%': 7, '20-29%': 8, '10-19%': 9, '0-10%': 10}\n                for cat, choice in cat_choice_dict.items():\n                    colors[cat] = self.ip['choice_colors'][choice]\n                    self.c['legend_elements'].append(Patch(facecolor=colors[cat],\n                                                           label=cat, edgecolor='black'))\n\n                # Add the title of the legend\n                self.c['legend_title'] = 'AFSC Rank\\nPercentile'\n\n                # Counts\n                counts = {}\n                cat_dem_dict = {'90-100%': 0.9, '80-89%': 0.8, '70-79%': 0.7, '60-69%': 0.6, '50-59%': 0.5,\n                                '40-49%': 0.4, '30-39%': 0.3, '20-29%': 0.2, '10-19%': 0.1, '0-10%': 0}\n                categories = list(cat_dem_dict.keys())\n                for cat in categories[::-1]:\n                    counts[cat] = np.zeros(self.c['M'])\n                for index, j in enumerate(self.c['J']):\n                    afsc = p['afscs'][j]\n                    total = 0\n                    for cat, dem in cat_dem_dict.items():\n                        counts[cat][index] = solution[\"afsc_choice_counts\"][afsc][cat]\n                        total += counts[cat][index]\n\n            else:\n\n                # Legend\n                self.c['legend_elements'] = [Patch(facecolor=self.ip['bar_colors'][\"top_choices\"], label='Top Third',\n                                                   edgecolor='black'),\n                                             Patch(facecolor=self.ip['bar_colors'][\"mid_choices\"], label='Middle Third',\n                                                   edgecolor='black'),\n                                             Patch(facecolor=self.ip['bar_colors'][\"bottom_choices\"],\n                                                   label='Bottom Third', edgecolor='black')]\n\n                # AFSC Choice Counts\n                for i, j in enumerate(self.solution['j_array']):\n                    if j in self.c['J']:\n                        index = np.where(self.c['J'] == j)[0][0]\n                        if p[\"afsc_utility\"][i, j] &lt; 1 / 3:\n                            counts[\"bottom_choices\"][index] += 1\n                        elif p[\"afsc_utility\"][i, j] &lt; 2 / 3:\n                            counts[\"mid_choices\"][index] += 1\n                        else:\n                            counts[\"top_choices\"][index] += 1\n\n        # Set label\n        self.c['y_label'] = \"Number of Cadets\"\n\n        # Calculate y-axis attributes\n        self.determine_y_max_and_y_ticks()\n\n        # Loop through each AFSC to plot the bars\n        for index, j in enumerate(self.c[\"J\"]):\n\n            count_sum = 0\n            for cat in counts:\n                text_color = \"black\"\n\n                # Plot the bars\n                count = counts[cat][index]\n                self.ax.bar([index], count, bottom=count_sum, edgecolor=\"black\", color=colors[cat])\n                count_sum += count\n\n                # Put a number on the bar\n                if count &gt;= self.ip['text_bar_threshold']:\n                    self.ax.text(index, (count_sum - count / 2 - 2), int(count), color=text_color, zorder=2,\n                                 fontsize=self.ip[\"bar_text_size\"], horizontalalignment='center')\n\n            # Add the text\n            self.ax.text(index, self.c['total_count'][index] + 2, int(self.c['total_count'][index]),\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n\n    elif self.ip[\"version\"] in [\"dot\", \"bar\"]:\n\n        # Get the title\n        self.ip[\"title\"] = self.label_dict[self.ip[\"objective\"]] + \" Across Each AFSC\"\n\n        # Average Utility Chart (simple)\n        self.c['y_ticks'] = [0, 0.2, 0.4, 0.6, 0.8, 1]\n        self.c['use_calculated_y_max'] = True\n        self.ax.bar(afscs, measure, color=\"black\", edgecolor='black', alpha=self.ip[\"alpha\"])\n\n        for j in range(self.c['M']):\n\n            # Add the text\n            self.ax.text(j, measure[j] + 0.013, round(measure[j], 2), fontsize=self.ip[\"text_size\"],\n                         horizontalalignment='center')\n\n    elif self.ip[\"version\"] == \"quantity_bar_gradient\":\n\n        # Get the title and label\n        self.ip[\"title\"] = \"Cadet Satisfaction Breakdown Across Each AFSC\"\n        self.c['y_label'] = 'Number of Cadets'\n\n        # Calculate y-axis attributes\n        self.determine_y_max_and_y_ticks()\n\n        # Build the gradient chart\n        self.construct_gradient_chart(parameter_to_use='cadet_utility')\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AFSCsChart.results_norm_score_chart","title":"<code>results_norm_score_chart()</code>","text":"<p>This method constructs the different charts showing the \"Norm Score\" objective</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_norm_score_chart(self):\n    \"\"\"\n    This method constructs the different charts showing the \"Norm Score\" objective\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = self.parameters, self.value_parameters, self.solution\n    k, quota, measure = self.c['k'], p['pgl'][self.c['J']], self.c['measure']\n    colors, afscs = np.array([self.ip[\"bar_color\"] for _ in self.c['J']]), self.c['afscs']\n\n    if self.ip[\"version\"] == \"bar\":\n\n        # Get the title and label\n        self.ip[\"title\"] = \"Normalized Score Across Each AFSC\"\n\n        # Y-axis\n        self.c['use_calculated_y_max'] = True\n        self.c['y_max'] = self.ip['y_max']\n        self.c['y_ticks'] = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n\n        # Add the text\n        for j in range(self.c['M']):\n\n            # Add the text\n            self.ax.text(j, measure[j] + 0.013, round(measure[j], 2),\n                         fontsize=self.ip[\"text_size\"], horizontalalignment='center')\n\n        # Bar Chart\n        self.ax.bar(afscs, measure, color=colors, edgecolor='black', alpha=self.ip[\"alpha\"])\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.CadetUtilityGraph","title":"<code>CadetUtilityGraph(instance)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>instance</code> required Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def __init__(self, instance):\n    \"\"\"\n\n    :param instance:\n    \"\"\"\n\n    # Load attributes\n    self.parameters = instance.parameters\n    self.value_parameters, self.vp_name = instance.value_parameters, instance.vp_name\n    self.ip = instance.mdl_p  # \"instance plot parameters\"\n    self.data_name, self.data_version = instance.data_name, instance.data_version\n\n    # Initialize the matplotlib figure/axes\n    self.fig, self.ax = plt.subplots(figsize=self.ip['figsize'], facecolor=self.ip['facecolor'], tight_layout=True,\n                                     dpi=self.ip['dpi'])\n\n    # Where to save the chart\n    self.path = instance.export_paths[\"Analysis &amp; Results\"] + \"Data Charts/\"\n\n    # Shorthand\n    i, p = self.ip['cadet'], self.parameters\n    J = p['cadet_preferences'][i]\n    afscs, M = p['afscs'][J], len(J)\n\n    # Utility categories\n    categories = ['Utility Ascribed', 'Normalized Rank', 'Not Bottom 3', 'Not Last Choice']\n    legend_elements = []\n    for cat in categories:\n        legend_elements.append(Patch(facecolor=self.ip['bar_colors'][cat], label=cat,\n                                     edgecolor='black'))\n\n    # AFSCs the cadet is eligible for and selected (ordered appropriately)\n    intersection = np.intersect1d(p['J^Selected'][i], J)\n    intersection = np.array([j for j in p['cadet_preferences'][i] if j in intersection])\n    num_selected = len(intersection)\n\n    # 1, 2, 3, 4, ..., N  (Pure rankings)\n    rankings = np.arange(num_selected) + 1\n\n    # 1, 0.8, 0.6, 0.4, ..., 1 / N  (Scale rankings to range from 1 to 0)\n    normalized_rankings = 1 - (rankings / np.max(rankings)) + (1 / np.max(rankings))\n\n    # Create dictionary of normalized ordinal rankings\n    norm_ord_rankings_dict = {j: normalized_rankings[index] for index, j in enumerate(intersection)}\n\n    # A: AFSC is NOT the LAST choice\n    a = np.array([(j != p['J^Last Choice'][i]) * 1 for j in J])\n\n    # B: AFSC is NOT in the bottom 3 choices\n    b = np.array([((j not in p['J^Bottom 2 Choices'][i]) and (j != p['J^Last Choice'][i])) * 1 for j in J])\n\n    # C: AFSC was selected as a preference\n    c = np.array([(j in p['J^Selected'][i]) * 1 for j in J])\n\n    # D: AFSC was selected as a preference and has a utility assigned\n    d = np.array([(p['utility'][i, j] &gt; 0) * 1 for j in J])\n\n    # X: Normalized ordinal ranking of the AFSC\n    x = np.array([norm_ord_rankings_dict[j] if j in norm_ord_rankings_dict else 0 for j in J])\n\n    # Y: Utility value the cadet assigned to the AFSC\n    y = p['utility'][i, J]\n\n    # # Execute the formula and load it into the cadet utility matrix\n    # p['cadet_utility'][i, j] = 0.05 * a + 0.05 * b + 0.9 * (0.3 * c * x + 0.7 * d * y)\n\n    # Plot the bars\n    total = np.zeros(M)\n    self.ax.bar(np.arange(M), a * 0.05, color=self.ip['bar_colors'][\"Not Last Choice\"], edgecolor='black')\n    total += a * 0.05\n    self.ax.bar(np.arange(M), b * 0.05, bottom=total, color=self.ip['bar_colors'][\"Not Bottom 3\"], edgecolor='black')\n    total += b * 0.05\n    self.ax.bar(np.arange(M), c * x  * 0.3 * 0.9, bottom=total, color=self.ip['bar_colors'][\"Normalized Rank\"],\n                edgecolor='black')\n    total += c * x  * 0.3 * 0.9\n    self.ax.bar(np.arange(M), d * y * 0.7 * 0.9, bottom=total, color=self.ip['bar_colors'][\"Utility Ascribed\"],\n                edgecolor='black')\n\n    # Put text on the bars\n    for index, j in enumerate(J):\n\n        # Final utility above bar\n        self.ax.text(index, p['cadet_utility'][i, j] + 0.005,\n                     np.around(100 * p['cadet_utility'][i, j], 1).astype(str) + \"%\", fontsize=self.ip[\"bar_text_size\"],\n                     horizontalalignment='center')\n\n        # Reported utility in bar\n        val = y[index] * 0.7 * 0.9\n        if d[index] == 1 and val &gt; 0.02:\n            y_pt = 0.1 + x[index] * 0.3 * 0.9 + val / 2\n            self.ax.text(index, y_pt,\n                         np.around(p['utility'][i, j], 2), fontsize=self.ip[\"bar_text_size\"],\n                         horizontalalignment='center', verticalalignment='center')\n\n        # Normalized ranking val in bar\n        val = x[index] * 0.3 * 0.9\n        if c[index] == 1 and val &gt; 0.02:\n            y_pt = 0.1 + val / 2\n            self.ax.text(index, y_pt,\n                         np.around(norm_ord_rankings_dict[j], 2), fontsize=self.ip[\"bar_text_size\"],\n                         horizontalalignment='center', verticalalignment='center')\n\n    # # Put text above the bar\n    # self.ax.text(np.arange(M), p['cadet_utility'][i, J] + 0.02,\n    #              np.around(p['cadet_utility'][i, J], 3).astype(str), fontsize=self.ip[\"bar_text_size\"],\n    #              horizontalalignment='center')\n\n    # Display title\n    self.ip['title'] = 'Cadet \"' + str(i) + '\" Utility Chart'\n    if self.ip['display_title']:\n        self.fig.suptitle(self.ip['title'], fontsize=self.ip['title_size'])\n\n    # Labels\n    self.ax.set_ylabel(\"Utility\")\n    self.ax.yaxis.label.set_size(self.ip['label_size'])\n    self.ax.set_xlabel('AFSCs')\n    self.ax.xaxis.label.set_size(self.ip['label_size'])\n\n    # Color the AFSCs on the x axis\n    if self.ip[\"color_afsc_text_by_grp\"]:\n        afsc_colors = [self.ip['bar_colors'][p['acc_grp'][j]] for j in p['cadet_preferences'][i]]\n    else:\n        afsc_colors = [\"black\" for _ in afscs]\n\n    # X axis\n    self.ax.tick_params(axis='x', labelsize=self.ip['afsc_tick_size'])\n    self.ax.set_xticks(np.arange(M))\n    self.ax.set_xticklabels(afscs, rotation=self.ip['afsc_rotation'])\n    self.ax.set(xlim=(-0.8, M))\n\n    # Unique AFSC colors potentially based on accessions group\n    for index, xtick in enumerate(self.ax.get_xticklabels()):\n        xtick.set_color(afsc_colors[index])\n\n    # Y axis\n    self.ax.tick_params(axis='y', labelsize=self.ip['yaxis_tick_size'])\n    self.ax.set_yticks([0, 0.2, 0.4, 0.6, 0.8, 1])\n    self.ax.set_yticklabels(['0%', '20%', '40%', '60%', '80%', '100%'])\n\n    # Legend\n    if self.ip[\"add_legend_afsc_chart\"]:\n        self.ax.legend(handles=legend_elements, edgecolor='black', loc=self.ip['legend_loc'],\n                       fontsize=self.ip['legend_size'], ncol=self.ip['ncol'], labelspacing=1, handlelength=0.8,\n                       handletextpad=0.2, borderpad=0.2, handleheight=2)\n\n    # Save the chart\n    self.ip['filename'] = self.ip['title']\n    if self.ip['save']:\n        self.fig.savefig(self.path + self.ip[\"filename\"])\n        print(\"Saved\", self.ip[\"filename\"], \"Chart to \" + self.path + \".\")\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AccessionsGroupChart","title":"<code>AccessionsGroupChart(instance)</code>","text":"<p>This is a class dedicated to creating \"Accessions Group Charts\" which are all charts that include the \"accessions groups\" on the x-axis alongside the basline. This is meant to condense the amount of code and increase read-ability of the various kinds of charts.</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def __init__(self, instance):\n    \"\"\"\n    This is a class dedicated to creating \"Accessions Group Charts\" which are all charts\n    that include the \"accessions groups\" on the x-axis alongside the basline. This is meant to condense the amount\n    of code and increase read-ability of the various kinds of charts.\n    \"\"\"\n\n    # Load attributes\n    self.parameters = instance.parameters\n    self.value_parameters, self.vp_name = instance.value_parameters, instance.vp_name\n    self.ip = instance.mdl_p  # \"instance plot parameters\"\n    self.solution, self.solution_name = instance.solution, instance.solution_name\n    self.data_name, self.data_version = instance.data_name, instance.data_version\n\n    # Dictionaries of instance components (sets of value parameters, solutions)\n    self.vp_dict, self.solutions = instance.vp_dict, instance.solutions\n\n    # Initialize the matplotlib figure/axes\n    self.fig, self.ax = plt.subplots(figsize=self.ip['figsize'], facecolor=self.ip['facecolor'], tight_layout=True,\n                                     dpi=self.ip['dpi'])\n\n    # Label dictionary for AFSC objectives\n    self.label_dict = copy.deepcopy(afccp.globals.obj_label_dict)\n\n    # Where to save the chart\n    self.paths = {\"Data\": instance.export_paths[\"Analysis &amp; Results\"] + \"Data Charts/\",\n                  \"Solution\": instance.export_paths[\"Analysis &amp; Results\"] + self.solution_name + \"/\",\n                  \"Comparison\": instance.export_paths[\"Analysis &amp; Results\"] + \"Comparison Charts/\"}\n\n    # Initialize \"c\" dictionary (specific chart parameters)\n    self.c = {\"x_labels\": [\"All Cadets\"]}\n    for acc_grp in self.parameters['afscs_acc_grp']:\n        self.c['x_labels'].append(acc_grp)\n    self.c['g'] = len(self.c['x_labels'])\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AccessionsGroupChart.build","title":"<code>build(chart_type='Data', printing=True)</code>","text":"<p>Builds the specific chart based on what the user passes within the \"instance plot parameters\" (ip)</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def build(self, chart_type=\"Data\", printing=True):\n    \"\"\"\n    Builds the specific chart based on what the user passes within the \"instance plot parameters\" (ip)\n    \"\"\"\n\n    # Determine what kind of chart we're showing\n    if chart_type == \"Data\":  # \"Before Solution\" chart\n        pass\n\n    elif chart_type == \"Solution\":  # Solution chart\n\n        if 'race_categories' not in self.parameters:\n            return None  # We're not doing this\n\n        self.results_demographic_chart()\n\n    # Put the solution name in the title if specified\n    if self.ip[\"solution_in_title\"]:\n        self.ip['title'] = self.solution['name'] + \": \" + self.ip['title']\n\n    # Display title\n    if self.ip['display_title']:\n        self.fig.suptitle(self.ip['title'], fontsize=self.ip['title_size'])\n\n    # Labels\n    self.ax.set_ylabel(self.c[\"y_label\"])\n    self.ax.yaxis.label.set_size(self.ip['label_size_acc'])\n    self.ax.set_xlabel('Accessions Group')\n    self.ax.xaxis.label.set_size(self.ip['label_size_acc'])\n\n    # Color the x-axis labels\n    if self.ip[\"color_afsc_text_by_grp\"]:\n        label_colors = [self.ip['bar_colors'][grp] for grp in self.c['x_labels']]\n    else:\n        label_colors = [\"black\" for _ in self.c['x_labels']]\n\n    # X axis\n    self.ax.tick_params(axis='x', labelsize=self.ip['xaxis_tick_size'])\n    self.ax.set_xticklabels(self.c['x_labels'])\n\n    # Unique label colors potentially based on accessions group\n    for index, xtick in enumerate(self.ax.get_xticklabels()):\n        xtick.set_color(label_colors[index])\n\n    # Y axis\n    self.ax.tick_params(axis='y', labelsize=self.ip['yaxis_tick_size'])\n    self.ax.set(ylim=(0, self.ip[\"y_max\"] * 1.03))\n\n    # Legend\n    if self.c['legend_elements'] is not None:\n        self.ax.legend(handles=self.c[\"legend_elements\"], edgecolor='black', loc=self.ip['legend_loc'],\n                       fontsize=self.ip['acc_legend_size'], ncol=self.ip['ncol'], labelspacing=1, handlelength=0.8,\n                       handletextpad=0.2, borderpad=0.2, handleheight=2)\n\n    # Get the filename\n    if self.ip[\"filename\"] is None:\n        self.ip[\"filename\"] = self.data_name + \" (\" + self.data_version + \") \" + self.solution['name'] + \\\n                              \" Accessions Group [\" + self.ip['version'] + \"] (Results).png\"\n\n    # Save the chart\n    if self.ip['save']:\n        self.fig.savefig(self.paths[chart_type] + self.ip[\"filename\"])\n\n        if printing:\n            print(\"Saved\", self.ip[\"filename\"], \"Chart to \" + self.paths[chart_type] + \".\")\n    else:\n        if printing:\n            print(\"Created\", self.ip[\"filename\"], \"Chart.\")\n\n    # Return the chart\n    return self.fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.AccessionsGroupChart.results_demographic_chart","title":"<code>results_demographic_chart()</code>","text":"<p>Displays a demographic breakdown across accessions groups</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def results_demographic_chart(self):\n    \"\"\"\n    Displays a demographic breakdown across accessions groups\n    \"\"\"\n\n    # Shorthand\n    p, vp, solution = self.parameters, self.value_parameters, self.solution\n\n    # Update certain things that apply to all versions of this kind of chart\n    self.c['y_label'] = 'Proportion of Cadets'\n\n    # Category Dictionary\n    category_dict = {\"Race Chart\": p['race_categories'], 'Ethnicity Chart': p['ethnicity_categories'],\n                     'Gender Chart': ['Male', 'Female'], 'SOC Chart': ['USAFA', 'ROTC']}\n    title_dict = {\"Race Chart\": 'Racial Demographics Across Each Accessions Group',\n                  'Ethnicity Chart': 'Ethnicity Demographics Across Each Accessions Group',\n                  'Gender Chart': 'Gender Breakdown Across Each Accessions Group',\n                  'SOC Chart': 'Source of Commissioning Breakdown Across Each Accessions Group'}\n    baseline_num_dict = {\"Race Chart\": \"baseline_simpson_index\", \"Ethnicity Chart\": \"baseline_simpson_index_eth\",\n                         \"Gender Chart\": \"male_proportion\", \"SOC Chart\": \"usafa_proportion\"}\n    acc_grp_num_dict = {\"Race Chart\": \"simpson_index_\", \"Ethnicity Chart\": \"simpson_index_eth_\",\n                        \"Gender Chart\": \"male_proportion_\", \"SOC Chart\": \"usafa_proportion_\"}\n\n    # Extract the specific information for this chart from the dictionaries above\n    self.ip['title'] = title_dict[self.ip['version']]\n    categories = category_dict[self.ip['version']]\n    baseline_p = baseline_num_dict[self.ip['version']]\n    acc_grp_num_dict_s = acc_grp_num_dict[self.ip['version']]\n\n    # Legend elements\n    self.c['legend_elements'] = []\n    for cat in categories[::-1]:  # Flip the legend\n        color = self.ip['bar_colors'][cat]\n        self.c['legend_elements'].append(Patch(facecolor=color, label=cat, edgecolor='black'))\n\n    # Baseline\n    if len(categories) == 2:\n        self.c['legend_elements'].append(mlines.Line2D([], [], color=\"black\", linestyle='--', label=\"Baseline\"))\n        self.ax.axhline(y=p[baseline_p], color='black', linestyle='--', zorder=4)\n        self.c['y_ticks'] = [0, round(p[baseline_p], 2), 1]\n\n    self.ip['ncol'] = len(self.c['legend_elements'])  # Adjust number of columns for legend\n\n    # Loop through each category and accessions group pair\n    quantities, proportions = {}, {}\n    for cat in categories:\n        quantities[cat], proportions[cat] = np.zeros(self.c['g']), np.zeros(self.c['g'])\n        for idx, grp in enumerate(self.c['x_labels']):\n\n            # Get metrics from this category group in this accessions group\n            if grp == \"All Cadets\":\n                cadets = p['I^' + cat]\n\n                # Load metrics\n                quantities[cat][idx] = int(len(cadets))\n                proportions[cat][idx] = len(cadets) / p['N']\n            else:\n                cadets = np.intersect1d(p['I^' + cat], solution['I^' + grp])\n\n                # Load metrics\n                quantities[cat][idx] = int(len(cadets))\n                proportions[cat][idx] = len(cadets) / len(solution['I^' + grp])\n\n    # Loop through each accession group to add the text above the bars\n    for idx, grp in enumerate(self.c['x_labels']):\n        if grp == \"All Cadets\":\n            txt = str(round(p[baseline_p], 2))\n        else:\n            txt = str(solution[acc_grp_num_dict_s + grp])\n        self.ax.text(idx, 1.005, txt, verticalalignment='bottom', fontsize=self.ip[\"acc_text_size\"],\n                     horizontalalignment='center')\n\n    # Plot the data\n    totals = np.zeros(self.c['g'])\n    for cat in quantities:\n        color = self.ip['bar_colors'][cat]\n        self.ax.bar(self.c['x_labels'], proportions[cat], bottom=totals, color=color, zorder=2, edgecolor='black')\n        totals += proportions[cat]\n\n        # Put a number on the bar\n        for idx in range(self.c['g']):\n            if proportions[cat][idx] &gt;= self.ip['acc_text_bar_threshold'] / max(solution['count']):\n\n                # If it's a dark color, change text color to white\n                if 'Black' in cat or \"Male\" in cat:\n                    text_color = 'white'\n                else:\n                    text_color = 'black'\n\n                # Place the text\n                self.ax.text(idx, (totals[idx] - proportions[cat][idx] / 2), int(quantities[cat][idx]),\n                             color=text_color, zorder=2, fontsize=self.ip[\"acc_bar_text_size\"],\n                             horizontalalignment='center', verticalalignment='center')\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.individual_weight_graph","title":"<code>individual_weight_graph(instance)</code>","text":"<p>This function creates the chart for either the individual weight function for cadets or the actual individual weights on the AFSCs</p> <p>Returns:</p> Type Description <p>chart</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def individual_weight_graph(instance):\n    \"\"\"\n    This function creates the chart for either the individual weight function for cadets or the actual\n    individual weights on the AFSCs\n    :return: chart\n    \"\"\"\n\n    # Shorthand\n    p, vp, ip = instance.parameters, instance.value_parameters, instance.mdl_p\n\n    # Initialize figure and title\n    if ip[\"title\"] is None:\n        if ip[\"cadets_graph\"]:\n            title = 'Individual Weight on Cadets'\n        else:\n            title = 'Individual Weight on AFSCs'\n    else:\n        title = ip[\"title\"]\n\n    # Build figure\n    if ip[\"cadets_graph\"]:\n\n        # Cadets Graph\n        fig, ax = plt.subplots(figsize=ip[\"square_figsize\"], facecolor=ip[\"facecolor\"], dpi=ip[\"dpi\"],\n                               tight_layout=True)\n        # ax.set_aspect('equal', adjustable='box')\n\n        # Get x and y coordinates\n        if 'merit_all' in p:\n            x = p['merit_all']\n        else:\n            x = p['merit']\n        y = vp['cadet_weight'] / np.max(vp['cadet_weight'])\n\n        # Plot\n        ax.scatter(x, y, color=ip[\"bar_color\"], alpha=ip[\"alpha\"], linewidth=3)\n\n        # Labels\n        ax.set_ylabel('Cadet Weight', fontname='Times New Roman')\n        ax.yaxis.label.set_size(ip[\"label_size\"])\n        ax.set_xlabel('Percentile', fontname='Times New Roman')\n        ax.xaxis.label.set_size(ip[\"label_size\"])\n\n        # Ticks\n        # x_ticks = [0, 0.2, 0.4, 0.6, 0.8, 1]\n        # ax.set_xticklabels(x_ticks, fontname='Times New Roman')\n        ax.tick_params(axis='x', labelsize=ip[\"xaxis_tick_size\"])\n        ax.tick_params(axis='y', labelsize=ip[\"yaxis_tick_size\"])\n\n        # Margins\n        ax.set(xlim=(-0.02, 1.02))\n        # ax.margins(x=0)\n        # ax.margins(y=0)\n\n    else:  # AFSC Chart\n\n        # AFSCs Graph\n        fig, ax = plt.subplots(figsize=ip[\"figsize\"], facecolor=ip[\"facecolor\"], dpi=ip[\"dpi\"], tight_layout=True)\n\n        # Labels\n        ax.set_ylabel('AFSC Weight')\n        ax.yaxis.label.set_size(ip[\"label_size\"])\n        ax.set_xlabel('AFSCs')\n        ax.xaxis.label.set_size(ip[\"label_size\"])\n\n        # We can skip AFSCs\n        if ip[\"skip_afscs\"]:\n            tick_indices = np.arange(1, p[\"M\"], 2).astype(int)\n        else:\n            tick_indices = np.arange(p[\"M\"])\n\n        # Plot\n        afscs = p['afscs'][:p[\"M\"]]\n        ax.bar(afscs, vp['afsc_weight'], color=ip[\"bar_color\"], alpha=ip[\"alpha\"])\n\n        # Ticks\n        ax.set(xlim=(-0.8, p[\"M\"]))\n        ax.tick_params(axis='x', labelsize=ip[\"afsc_tick_size\"])\n        ax.set_yticks([])\n        ax.set_xticklabels(afscs[tick_indices], rotation=ip[\"afsc_rotation\"])\n        ax.set_xticks(tick_indices)\n\n    if ip[\"display_title\"]:\n        ax.set_title(title, fontsize=ip[\"label_size\"])\n\n    if ip[\"save\"]:\n        fig.savefig(instance.export_paths['Analysis &amp; Results'] + 'Value Parameters/' + title + '.png',\n                    bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.afsc_multi_criteria_graph","title":"<code>afsc_multi_criteria_graph(instance, max_num=None)</code>","text":"<p>This chart compares certain AFSCs in a solution according to multiple criteria</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def afsc_multi_criteria_graph(instance, max_num=None):\n    \"\"\"\n    This chart compares certain AFSCs in a solution according to multiple criteria\n    \"\"\"\n\n    # Shorthand\n    ip = instance.plt_p\n    p = instance.parameters\n    vp = instance.value_parameters\n\n    # Create figure\n    fig, ax = plt.subplots(figsize=ip['figsize'], facecolor=ip['facecolor'], tight_layout=True, dpi=ip['dpi'])\n\n    # Get list of AFSCs we're considering\n    afscs = np.array(ip[\"comparison_afscs\"])\n    used_indices = np.array([np.where(p[\"afscs\"] == afsc)[0][0] for afsc in afscs])\n    criteria = ip[\"comparison_criteria\"]\n    num_afscs = len(afscs)\n    num_criteria = len(criteria)\n\n    # Get quota\n    if \"pgl\" in p:\n        quota = p[\"pgl\"][used_indices]\n    else:\n        quota = p[\"quota\"][used_indices]\n\n    # Need to know number of cadets assigned\n    quota_k = np.where(vp[\"objectives\"] == \"Combined Quota\")[0][0]\n    total_count = instance.metrics[\"objective_measure\"][used_indices, quota_k]\n    full_count = instance.metrics[\"objective_measure\"][:, quota_k]\n\n    # Sort the AFSCs by the PGL\n    if ip[\"sort_by_pgl\"]:\n        indices = np.argsort(quota)[::-1]\n\n    # Sort the AFSCs by the number of cadets assigned\n    else:\n        indices = np.argsort(total_count)[::-1]\n\n    # Re-sort the AFSCs, quota, and total count\n    afscs = afscs[indices]\n    quota = quota[indices]\n    total_count = total_count[indices]\n    indices = used_indices[indices]\n\n    # Set the bar chart structure parameters\n    label_locations = np.arange(num_afscs)\n    bar_width = 0.8 / num_criteria\n\n    # Y max\n    if max_num is None:\n        y_max = ip[\"y_max\"] * max(instance.metrics[\"objective_measure\"][:, quota_k])\n    else:\n        y_max = ip[\"y_max\"] * max_num\n\n    # Y tick marks\n    if 100 &lt;= y_max &lt; 150:\n        y_ticks = [50, 100, 150]\n    elif 150 &lt;= y_max &lt; 200:\n        y_ticks = [50, 100, 150, 200]\n    elif 200 &lt;= y_max &lt; 250:\n        y_ticks = [50, 100, 150, 200, 250]\n    elif 250 &lt;= y_max &lt; 300:\n        y_ticks = [50, 100, 150, 200, 250, 300]\n    elif y_max &gt;= 300:\n        y_ticks = [50, 100, 150, 200, 250, 300, 350]\n    else:\n        y_ticks = [50]\n\n    # Convert utility matrix to utility columns\n    preferences, utilities_array = afccp.data.preferences.get_utility_preferences(p)\n\n    # AFOCD\n    afocd_objectives = [\"Mandatory\", \"Desired\", \"Permitted\"]\n    afocd_k = {objective: np.where(vp[\"objectives\"] == objective)[0][0] for objective in afocd_objectives}\n    afocd_count = {objective: full_count * instance.metrics[\"objective_measure\"][:, afocd_k[objective]]\n                   for objective in afocd_objectives}\n    afocd_count = {objective: afocd_count[objective][indices] for objective in afocd_objectives}  # Re-sort\n\n    # Counts\n    top_3_count = np.zeros(p[\"M\"])\n    next_3_count = np.zeros(p[\"M\"])\n    non_vol_count = np.zeros(p[\"M\"])\n    for i, j in enumerate(instance.solution):\n\n        # Preference Counts\n        afsc = p[\"afscs\"][j]\n        if afsc in preferences[i, 0:3]:\n            top_3_count[j] += 1\n        elif afsc in preferences[i, 3:6]:\n            next_3_count[j] += 1\n        else:\n            non_vol_count[j] += 1\n\n    # Re-sort preferences\n    top_3_count, next_3_count = top_3_count[indices], next_3_count[indices]\n    non_vol_count = non_vol_count[indices]\n\n    # Percentile\n    percentile_dict = {1: (0.75, 1), 2: (0.5, 0.75), 3: (0.25, 0.5), 4: (0, 0.25)}\n\n    # Loop through each solution/AFSC bar\n    M = len(indices)\n    for index, j in enumerate(indices):\n        cadets = np.where(instance.solution == j)[0]\n        merit = p[\"merit\"][cadets]\n        utility = p[\"utility\"][cadets, j]\n        for c, obj in enumerate(criteria):\n\n            if obj == \"Preference\":\n\n                # Plot preference bars\n                ax.bar(label_locations[index] + bar_width * c, non_vol_count[index], bar_width,\n                       edgecolor='black', color=ip['bar_colors'][\"bottom_choices\"])\n                ax.bar(label_locations[index] + bar_width * c, next_3_count[index], bar_width,\n                       bottom=non_vol_count[index], edgecolor='black',\n                       color=ip['bar_colors'][\"mid_choices\"])\n                ax.bar(label_locations[index] + bar_width * c, top_3_count[index], bar_width,\n                       bottom=non_vol_count[index] + next_3_count[index], edgecolor='black',\n                       color=ip['bar_colors'][\"top_choices\"])\n\n            elif obj == \"Merit\":\n\n                # Plot the merit gradient bars\n                uq = np.unique(merit)\n                count_sum = 0\n                for val in uq:\n                    count = len(np.where(merit == val)[0])\n                    color = str(val)  # Grayscale\n                    ax.bar(label_locations[index] + bar_width * c, count, bar_width, bottom=count_sum, color=color,\n                           zorder=2)\n                    count_sum += count\n\n                # Add the text\n                ax.text(label_locations[index] + bar_width * c, total_count[index] + 2, round(np.mean(merit), 2),\n                        fontsize=ip[\"text_size\"], horizontalalignment='center')\n\n            elif obj == \"Utility\":\n\n                # Plot the utility gradient bars\n                uq = np.unique(utility)\n                count_sum = 0\n                for val in uq:\n                    count = len(np.where(utility == val)[0])\n                    color = (1 - val, 0, val)  # Blue to Red\n                    ax.bar(label_locations[index] + bar_width * c, count, bar_width, bottom=count_sum, color=color,\n                           zorder=2)\n                    count_sum += count\n\n                # Add the text\n                ax.text(label_locations[index] + bar_width * c, total_count[index] + 2, round(np.mean(utility), 2),\n                        fontsize=ip[\"text_size\"], horizontalalignment='center')\n\n            elif obj == \"Quartile\":\n\n                # Loop through each quartile\n                count_sum = 0\n                for q in [4, 3, 2, 1]:\n                    lb, ub = percentile_dict[q][0], percentile_dict[q][1]\n                    count = len(np.where((merit &lt;= ub) &amp; (merit &gt; lb))[0])\n                    ax.bar(label_locations[index] + bar_width * c, count, bar_width, bottom=count_sum,\n                           edgecolor=\"black\",\n                           color=ip['bar_colors'][\"quartile_\" + str(q)], zorder=2)\n                    count_sum += count\n\n                    # Put a number on the bar\n                    if count &gt;= 10:\n                        if q == 1:\n                            color = \"white\"\n                        else:\n                            color = \"black\"\n                        ax.text(label_locations[index] + bar_width * c, (count_sum - count / 2 - 2), int(count),\n                                color=color, zorder=3, fontsize=ip[\"bar_text_size\"], horizontalalignment='center')\n\n            elif obj == \"AFOCD\":\n\n                # Plot the AFOCD bars\n                count_sum = 0\n                for objective in afocd_objectives:\n\n                    # Plot AFOCD bars\n                    count = afocd_count[objective][index]\n                    ax.bar(label_locations[index] + bar_width * c, count, bar_width,\n                           bottom=count_sum, edgecolor='black', color=ip['bar_colors'][objective])\n                    count_sum += count\n\n                    # Put a number on the bar\n                    if count &gt;= 10:\n\n                        prop = count / total_count[index]\n                        if objective == \"Permitted\":\n                            color = \"black\"\n                        else:\n                            color = \"white\"\n                        ax.text(label_locations[index] + bar_width * c, (count_sum - count / 2 - 2),\n                                round(prop, 2), color=color, zorder=3, fontsize=ip[\"bar_text_size\"],\n                                horizontalalignment='center')\n\n                # Add the text\n                ax.text(label_locations[index] + bar_width * c, total_count[index] + 2, int(total_count[index]),\n                        fontsize=ip[\"text_size\"], horizontalalignment='center')\n\n        # Add Lines to the bar chart\n        left = label_locations[index] - bar_width / 2\n        right = label_locations[index] + bar_width * (num_criteria - 1) + bar_width / 2\n        ax.plot((left, right), (total_count[index], total_count[index]), linestyle=\"-\", linewidth=1, zorder=2,\n                color=\"black\")\n\n        # PGL Line\n        ax.plot((right - 0.02, right + 0.02), (quota[index], quota[index]), linestyle=\"-\", zorder=2, linewidth=4,\n                color=\"black\")  # PGL tick mark\n\n        # Add the text\n        ax.text(right + 0.04, quota[index], int(quota[index]), fontsize=ip[\"bar_text_size\"], horizontalalignment='left',\n                verticalalignment=\"center\")\n    # Labels\n    ax.set_ylabel(\"Number of Cadets\")\n    ax.yaxis.label.set_size(ip[\"label_size\"])\n    ax.set_xlabel(\"AFSCs\")\n    ax.xaxis.label.set_size(ip[\"label_size\"])\n\n    # Y ticks\n    ax.set_yticks(y_ticks)\n    ax.tick_params(axis=\"y\", labelsize=ip[\"yaxis_tick_size\"])\n    ax.set_yticklabels(y_ticks)\n    ax.margins(y=0)\n    ax.set(ylim=(0, y_max))\n\n    # X ticks\n    ax.set_xticklabels(afscs, rotation=0)\n    ax.set_xticks(label_locations + (bar_width / 2) * (num_criteria - 1))\n    ax.tick_params(axis=\"x\", labelsize=ip[\"afsc_tick_size\"])\n    # ax.set(xlim=[2 * bar_width - 1, num_criteria])\n\n    # Title\n    if ip[\"display_title\"]:\n        ax.set_title(ip[\"title\"], fontsize=ip[\"title_size\"])\n\n    # Filename\n    if ip[\"filename\"] is None:\n        ip[\"filename\"] = ip[\"title\"]\n\n    # Save\n    if ip['save']:\n        fig.savefig(afccp.globals.paths['figures'] + instance.data_name + \"/results/\" + ip['filename'] + '.png',\n                    bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.cadet_utility_histogram","title":"<code>cadet_utility_histogram(instance, filepath=None)</code>","text":"<p>Builds the Cadet Utility histogram</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def cadet_utility_histogram(instance, filepath=None):\n    \"\"\"\n    Builds the Cadet Utility histogram\n    \"\"\"\n\n    # Shorthand\n    ip = instance.mdl_p\n\n    # Shared elements\n    fig, ax = plt.subplots(figsize=ip[\"figsize\"], facecolor=ip[\"facecolor\"], dpi=ip[\"dpi\"], tight_layout=True)\n    bins = np.arange(21) / 20\n\n    if ip[\"solution_names\"] is not None:  # Comparing two or more solutions\n        if ip[\"title\"] is None:\n\n            # Create the title!\n            if ip[\"num_solutions\"] == 1:\n                ip['title'] = ip[\"solution_names\"][0] + \" Cadet Utility Results Histogram\"\n            elif ip[\"num_solutions\"] == 2:\n                ip['title'] = ip[\"solution_names\"][0] + \" and \" + ip[\"solution_names\"][1] + \\\n                              \" Cadet Utility Results Histogram\"\n            elif ip[\"num_solutions\"] == 3:\n                ip['title'] = ip[\"solution_names\"][0] + \", \" + ip[\"solution_names\"][1] + \\\n                              \", and \" + ip[\"solution_names\"][2] + \" Cadet Utility Results Histogram\"\n            else:\n                ip['title'] = ip[\"solution_names\"][0] + \", \" + ip[\"solution_names\"][1] + \\\n                              \", \" + ip[\"solution_names\"][2] + \", and \" + ip[\"solution_names\"][3] + \\\n                              \" Cadet Utility Results Histogram\"\n\n        # Plot the results\n        legend_elements = []\n        for solution_name in ip[\"solution_names\"]:\n            value = instance.solutions[solution_name]['cadet_utility_achieved']\n            ax.hist(value, bins=bins, edgecolor='black', color=ip[\"colors\"][solution_name], alpha=0.5)\n            legend_elements.append(Patch(facecolor=ip[\"colors\"][solution_name], label=solution_name,\n                                         alpha=0.5, edgecolor='black'))\n\n        ax.legend(handles=legend_elements, edgecolor='black', fontsize=ip[\"legend_size\"], loc='upper left',\n                  ncol=ip[\"num_solutions\"], columnspacing=0.8, handletextpad=0.25, borderaxespad=0.5, borderpad=0.4)\n    else:\n\n        # Get the title and filename\n        ip[\"title\"] = \"Cadet Utility Results Histogram\"\n        ip[\"filename\"] = instance.solution_name + \" Cadet_Utility_Histogram\"\n        if ip[\"solution_in_title\"]:\n            ip['title'] = instance.solution_name + \": \" + ip['title']\n\n        value = instance.solution[\"cadet_utility_achieved\"]\n        ax.hist(value, bins=bins, edgecolor='white', color='black', alpha=1)\n\n    # Labels\n    ax.set_ylabel('Number of Cadets')\n    ax.yaxis.label.set_size(ip[\"label_size\"])\n    ax.set_xlabel('Utility Received')\n    ax.xaxis.label.set_size(ip[\"label_size\"])\n\n    # Axis\n    x_ticks = np.arange(11) / 10\n    ax.set_xticks(x_ticks)\n    ax.tick_params(axis='x', labelsize=ip[\"xaxis_tick_size\"])\n    ax.tick_params(axis='y', labelsize=ip[\"yaxis_tick_size\"])\n\n    # Title\n    if ip[\"display_title\"]:\n        ax.set_title(ip[\"title\"], fontsize=ip[\"title_size\"])\n\n    # Filename\n    if ip[\"filename\"] is None:\n        ip[\"filename\"] = ip[\"title\"] + '.png'\n\n    # Save the figure\n    if ip[\"save\"]:\n        if filepath is None:\n            filepath = instance.export_paths['Analysis &amp; Results'] + \"Results Charts/\"\n        fig.savefig(filepath + ip[\"filename\"], bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.cadet_utility_merit_scatter","title":"<code>cadet_utility_merit_scatter(instance)</code>","text":"<p>Scatter plot of cadet utility vs cadet merit</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def cadet_utility_merit_scatter(instance):\n    \"\"\"\n    Scatter plot of cadet utility vs cadet merit\n    \"\"\"\n\n    # Shorthand\n    ip = instance.plt_p\n\n    # Shared elements\n    fig, ax = plt.subplots(figsize=ip[\"figsize\"], facecolor=ip[\"facecolor\"], dpi=ip[\"dpi\"], tight_layout=True)\n\n    # Get the title and filename\n    ip[\"title\"] = \"Cadet Preference vs. Merit\"\n    ip[\"filename\"] = instance.solution_name + \" Cadet_Preference_Merit_Scatter\"\n    if ip[\"solution_in_title\"]:\n        ip['title'] = instance.solution_name + \": \" + ip['title']\n\n    y = instance.metrics[\"cadet_value\"]\n\n    if \"merit_all\" in instance.parameters:\n        x = instance.parameters[\"merit_all\"]\n    else:\n        x = instance.parameters[\"merit\"]\n\n    ax.scatter(x, y, s=ip[\"dot_size\"], color='black', alpha=1)\n\n    # Labels\n    ax.set_ylabel('Cadet Utility Value')\n    ax.yaxis.label.set_size(ip[\"label_size\"])\n    ax.set_xlabel('Cadet Merit')\n    ax.xaxis.label.set_size(ip[\"label_size\"])\n\n    # Axis\n    x_ticks = np.arange(11) / 10\n    ax.set_xticks(x_ticks)\n    ax.tick_params(axis='x', labelsize=ip[\"xaxis_tick_size\"])\n    ax.tick_params(axis='y', labelsize=ip[\"yaxis_tick_size\"])\n\n    # Title\n    if ip[\"display_title\"]:\n        ax.set_title(ip[\"title\"], fontsize=ip[\"title_size\"])\n\n    # Filename\n    if ip[\"filename\"] is None:\n        ip[\"filename\"] = ip[\"title\"]\n\n    if ip[\"save\"]:\n        fig.savefig(afccp.globals.paths['figures'] + instance.data_name + \"/results/\" + ip[\"filename\"] + '.png',\n                    bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.holistic_color_graph","title":"<code>holistic_color_graph(parameters, value_parameters, metrics, figsize=(11, 10), save=False, facecolor='white')</code>","text":"<p>Builds the Holistic Color Chart</p> <p>Parameters:</p> Name Type Description Default <code>facecolor</code> <p>color of the background of the graph</p> <code>'white'</code> <code>figsize</code> <p>size of the figure</p> <code>(11, 10)</code> <code>save</code> <p>Whether we should save the graph</p> <code>False</code> <code>parameters</code> <p>fixed cadet/AFSC data</p> required <code>value_parameters</code> <p>value parameters</p> required <code>metrics</code> <p>solution metrics</p> required <p>Returns:</p> Type Description <p>figure</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def holistic_color_graph(parameters, value_parameters, metrics, figsize=(11, 10), save=False, facecolor='white'):\n    \"\"\"\n    Builds the Holistic Color Chart\n    :param facecolor: color of the background of the graph\n    :param figsize: size of the figure\n    :param save: Whether we should save the graph\n    :param parameters: fixed cadet/AFSC data\n    :param value_parameters: value parameters\n    :param metrics: solution metrics\n    :return: figure\n    \"\"\"\n    fig, ax = plt.subplots(figsize=figsize, facecolor=facecolor, tight_layout=True)\n    ax.set_aspect('equal', adjustable='box')\n    N = parameters['N']\n    title = 'Attribute Weights and Values Color Chart. Z = ' + str(round(metrics['z'], 2))\n    ax.set_title(title)\n\n    # Cadets\n    length = value_parameters['cadets_overall_weight']\n    values = metrics['cadet_value']\n    weights = value_parameters['cadet_weight']\n    sorted_indices = values.argsort()[::-1]\n    sorted_values = values[sorted_indices]\n    sorted_weights = weights[sorted_indices]\n    y = 0\n    for i in range(N):\n        xy = (0, y)\n        height = sorted_weights[i]\n        objective_value = sorted_values[i]\n        c = (1 - objective_value, 0, objective_value)\n        rect = Rectangle(xy, length, height, edgecolor='none', color=c)\n        ax.add_patch(rect)\n        y += height\n\n    # AFSCs\n    full_length = value_parameters['afscs_overall_weight']\n    afsc_values = metrics['afsc_value']\n    afsc_weights = value_parameters['afsc_weight']\n    sorted_afsc_indices = afsc_values.argsort()[::-1]\n    sorted_afsc_weights = afsc_weights[sorted_afsc_indices]\n    y = 0\n    for j in sorted_afsc_indices:\n        weights = value_parameters['objective_weight'][j, :]\n        values = metrics['objective_value'][j, :]\n        zeros = np.where(weights == 0)[0]\n        weights = np.delete(weights, zeros)\n        values = np.delete(values, zeros)\n        sorted_indices = values.argsort()[::-1]\n        sorted_values = values[sorted_indices]\n        sorted_weights = weights[sorted_indices]\n        x = value_parameters['cadets_overall_weight']\n        height = sorted_afsc_weights[j]\n        for k in range(len(sorted_indices)):\n            xy = (x, y)\n            objective_value = sorted_values[k]\n            c = (1 - objective_value, 0, objective_value)\n            rect = Rectangle(xy, sorted_weights[k], height, edgecolor='none', color=c)\n            ax.add_patch(rect)\n            x += sorted_weights[k] * full_length\n        height = sorted_afsc_weights[j]\n        y += height\n\n    if save:\n        fig.savefig(afccp.globals.paths['figures'] + instance.data_name + \"/results/\" + title + '.png',\n                    bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.pareto_graph","title":"<code>pareto_graph(instance, pareto_df, solution_names=None, dimensions=None, save=True, title=None, figsize=(10, 8), facecolor='white', display_title=False, l_word='Value', filepath=None)</code>","text":"<p>Builds the Pareto Frontier Chart for adjusting the overall weight on cadets</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <p>path to the folder to save this chart in</p> <code>None</code> <code>solution_names</code> <p>other solutions to plot on the chart</p> <code>None</code> <code>instance</code> <p>problem instance</p> required <code>l_word</code> <p>\"Label word\" for whether we're referring to these as \"values\" or \"utilities\"</p> <code>'Value'</code> <code>display_title</code> <p>if we should display a title or not</p> <code>False</code> <code>save</code> <p>If we should save the figure</p> <code>True</code> <code>title</code> <p>If we should include a title or not</p> <code>None</code> <code>pareto_df</code> <p>data frame of pareto analysis</p> required <code>dimensions</code> <p>N and M</p> <code>None</code> <code>facecolor</code> <p>color of the background of the graph</p> <code>'white'</code> <code>figsize</code> <p>size of the figure</p> <code>(10, 8)</code> <p>Returns:</p> Type Description <p>figure</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def pareto_graph(instance, pareto_df, solution_names=None, dimensions=None, save=True, title=None, figsize=(10, 8),\n                 facecolor='white', display_title=False, l_word='Value', filepath=None):\n    \"\"\"\n    Builds the Pareto Frontier Chart for adjusting the overall weight on cadets\n    :param filepath: path to the folder to save this chart in\n    :param solution_names: other solutions to plot on the chart\n    :param instance: problem instance\n    :param l_word: \"Label word\" for whether we're referring to these as \"values\" or \"utilities\"\n    :param display_title: if we should display a title or not\n    :param save: If we should save the figure\n    :param title: If we should include a title or not\n    :param pareto_df: data frame of pareto analysis\n    :param dimensions: N and M\n    :param facecolor: color of the background of the graph\n    :param figsize: size of the figure\n    :return: figure\n    \"\"\"\n\n    # Shorthand\n    ip = instance.mdl_p\n\n    # Colors and Axis\n    cm = plt.cm.get_cmap('RdYlBu')\n    label_size = 20\n    xaxis_tick_size = 20\n    yaxis_tick_size = 20\n\n    # Chart\n    fig, ax = plt.subplots(figsize=figsize, facecolor=facecolor, tight_layout=True)\n    ax.set_aspect('equal', adjustable='box')\n\n    sc = ax.scatter(pareto_df[l_word + ' on AFSCs'], pareto_df[l_word + ' on Cadets'], c=pareto_df['Weight on Cadets'],\n                    s=100, cmap=cm, edgecolor='black', zorder=1)\n    c_bar = plt.colorbar(sc)\n    c_bar.set_label('Weight on Cadets', fontsize=label_size)\n    c_bar.ax.tick_params(labelsize=xaxis_tick_size)\n    if title is None:\n        if dimensions is not None:\n            N = dimensions[0]\n            M = dimensions[1]\n            title = 'Pareto Frontier for Weight on Cadets (N=' + str(N) + ', M=' + str(M) + ')'\n        else:\n            title = 'Pareto Frontier for Weight on Cadets'\n    if display_title:\n        ax.set_title(title)\n\n    # Plot solution point(s)\n    if solution_names is not None:\n        for solution_name in solution_names:\n            solution = instance.solutions[solution_name]\n            ax.scatter(solution['afsc_utility_overall'], solution['cadet_utility_overall'],\n                       c=ip[\"colors\"][solution_name],\n                       s=100, edgecolor='black', zorder=2, marker=ip[\"markers\"][solution_name])\n            plt.text(solution['afsc_utility_overall'],\n                     solution['cadet_utility_overall'] + 0.003, solution_name, fontsize=15,\n                     horizontalalignment='center')\n\n    # Labels\n    ax.set_ylabel(l_word + ' on Cadets')\n    ax.yaxis.label.set_size(label_size)\n    ax.set_xlabel(l_word + ' on AFSCs')\n    ax.xaxis.label.set_size(label_size)\n\n    # Axis\n    ax.tick_params(axis='y', labelsize=yaxis_tick_size)\n    ax.tick_params(axis='x', labelsize=xaxis_tick_size)\n\n    # Save the figure\n    if save:\n        if filepath is None:\n            filepath = instance.export_paths['Analysis &amp; Results'] + \"Results Charts/\"\n        if solution_names is None:\n            filename = instance.data_name + \" \" + title + '.png'\n        else:\n            string_names = ', '.join(solution_names)\n            filename = instance.data_name + \" \" + title + '(' + string_names + ').png'\n        fig.savefig(filepath + filename, bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.afsc_objective_weights_graph","title":"<code>afsc_objective_weights_graph(parameters, value_parameters_dict, afsc, colors=None, save=False, figsize=(19, 7), facecolor='white', title=None, display_title=True, label_size=25, bar_color=None, xaxis_tick_size=15, yaxis_tick_size=25, legend_size=25, title_size=25)</code>","text":"<p>This chart compares the weights under different value parameters for AFSC objectives for a particular AFSC</p> <p>Parameters:</p> Name Type Description Default <code>bar_color</code> <p>color of bars for figure (for certain kinds of graphs)</p> <code>None</code> <code>title_size</code> <p>font size of the title</p> <code>25</code> <code>legend_size</code> <p>font size of the legend</p> <code>25</code> <code>yaxis_tick_size</code> <p>y axis tick sizes</p> <code>25</code> <code>xaxis_tick_size</code> <p>x axis tick sizes</p> <code>15</code> <code>label_size</code> <p>size of labels</p> <code>25</code> <code>display_title</code> <p>if we should show the title</p> <code>True</code> <code>title</code> <p>title of chart</p> <code>None</code> <code>parameters</code> <p>fixed cadet/AFSC parameters</p> required <code>value_parameters_dict</code> <p>dictionary of value parameters</p> required <code>afsc</code> <p>which AFSC we should plot</p> required <code>colors</code> <p>colors for the kinds of weights</p> <code>None</code> <code>save</code> <p>Whether we should save the graph</p> <code>False</code> <code>facecolor</code> <p>color of the background of the graph</p> <code>'white'</code> <code>figsize</code> <p>size of the figure</p> <code>(19, 7)</code> <p>Returns:</p> Type Description <p>figure</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def afsc_objective_weights_graph(parameters, value_parameters_dict, afsc, colors=None, save=False, figsize=(19, 7),\n                                 facecolor=\"white\", title=None, display_title=True, label_size=25, bar_color=None,\n                                 xaxis_tick_size=15, yaxis_tick_size=25, legend_size=25, title_size=25):\n    \"\"\"\n    This chart compares the weights under different value parameters for AFSC objectives for a particular AFSC\n    :param bar_color: color of bars for figure (for certain kinds of graphs)\n    :param title_size: font size of the title\n    :param legend_size: font size of the legend\n    :param yaxis_tick_size: y axis tick sizes\n    :param xaxis_tick_size: x axis tick sizes\n    :param label_size: size of labels\n    :param display_title: if we should show the title\n    :param title: title of chart\n    :param parameters: fixed cadet/AFSC parameters\n    :param value_parameters_dict: dictionary of value parameters\n    :param afsc: which AFSC we should plot\n    :param colors: colors for the kinds of weights\n    :param save: Whether we should save the graph\n    :param facecolor: color of the background of the graph\n    :param figsize: size of the figure\n    :return: figure\n    \"\"\"\n    if colors is None:\n        colors = ['blue', 'black', 'orange', 'magenta']\n\n    if title is None:\n        title = afsc + ' Objective Weights For Different Value Parameters'\n\n    fig, ax = plt.subplots(figsize=figsize, facecolor=facecolor, tight_layout=True)\n\n    # Get chart specs\n    num_weights = len(value_parameters_dict)\n    j = np.where(parameters['afscs'] == afsc)[0][0]\n    first_key = list(value_parameters_dict.keys())[0]\n    K_A = value_parameters_dict[first_key]['K^A'][j].astype(int)\n    objectives = value_parameters_dict[first_key]['objectives'][K_A]\n    for k, objective in enumerate(objectives):\n        if objective == 'USAFA Proportion':\n            objectives[k] = 'USAFA\\nProportion'\n        elif objective == 'Combined Quota':\n            objectives[k] = 'Combined\\nQuota'\n\n    if colors is None:\n        colors = ['blue', 'lime', 'orange', 'magenta', 'yellow', 'cyan', 'green', 'deeppink', 'red']\n        colors = colors[:num_weights]\n\n    if bar_color is not None:\n        colors = [bar_color for _ in range(num_weights)]\n\n    # Set the bar chart structure parameters\n    label_locations = np.arange(len(K_A))\n    bar_width = 0.8 / num_weights\n\n    # Loop through each set of value parameters\n    max_weight = 0\n    for w_num, weight_name in enumerate(value_parameters_dict):\n        # Plot weights\n        weights = value_parameters_dict[weight_name]['objective_weight'][j, K_A]\n        max_weight = max(max_weight, max(weights))\n        ax.bar(label_locations + bar_width * w_num, weights, bar_width, edgecolor='black',\n               label=weight_name, color=colors[w_num], alpha=0.5)\n\n    # Labels\n    ax.set_ylabel('Objective Weight')\n    ax.yaxis.label.set_size(label_size)\n    if bar_color is not None:\n        ax.set_xlabel('Objectives')\n        ax.xaxis.label.set_size(label_size)\n\n    # X ticks\n    ax.set(xticks=label_locations + (bar_width / 2) * (num_weights - 1),\n           xticklabels=[value_parameters_dict[first_key]['objectives'][i] for i in K_A])\n    ax.tick_params(axis='x', labelsize=xaxis_tick_size)\n    ax.set_xticklabels(objectives)\n\n    # Y ticks\n    ax.tick_params(axis='y', labelsize=yaxis_tick_size)\n    ax.margins(y=0)\n    ax.set(ylim=(0, max_weight * 1.2))\n\n    if display_title:\n        ax.set_title(title, fontsize=title_size)\n\n    if bar_color is None:\n        ax.legend(edgecolor='black', fontsize=legend_size, loc='upper right',\n                  ncol=num_weights, columnspacing=0.8, handletextpad=0.25, borderaxespad=0.5, borderpad=0.4)\n\n    if save:\n        fig.savefig(afccp.globals.paths['figures'] + instance.data_name + \"/value parameters/\" + title + '.png',\n                    bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.solution_parameter_comparison_graph","title":"<code>solution_parameter_comparison_graph(z_dict, colors=None, save=False, figsize=(19, 7), facecolor='white')</code>","text":"<p>This chart compares the solutions' objective values under different value parameters</p> <p>Parameters:</p> Name Type Description Default <code>z_dict</code> <p>dictionary of solution objective values for each set of value parameters</p> required <code>value_parameters_dict</code> <p>dictionary of value parameters</p> required <code>colors</code> <p>colors for the kinds of weights</p> <code>None</code> <code>save</code> <p>Whether we should save the graph</p> <code>False</code> <code>facecolor</code> <p>color of the background of the graph</p> <code>'white'</code> <code>figsize</code> <p>size of the figure</p> <code>(19, 7)</code> <p>Returns:</p> Type Description <p>figure</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def solution_parameter_comparison_graph(z_dict, colors=None, save=False, figsize=(19, 7), facecolor=\"white\"):\n    \"\"\"\n        This chart compares the solutions' objective values under different value parameters\n        :param z_dict: dictionary of solution objective values for each set of value parameters\n        :param value_parameters_dict: dictionary of value parameters\n        :param colors: colors for the kinds of weights\n        :param save: Whether we should save the graph\n        :param facecolor: color of the background of the graph\n        :param figsize: size of the figure\n        :return: figure\n        \"\"\"\n    fig, ax = plt.subplots(figsize=figsize, facecolor=facecolor, tight_layout=True)\n\n    # Get chart specs\n    solution_names = list(z_dict.keys())\n    vp_names = list(z_dict[solution_names[0]].keys())\n    num_solutions = len(solution_names)\n    num_vps = len(vp_names)\n\n    if colors is None:\n        colors = ['blue', 'lime', 'orange', 'magenta', 'yellow', 'cyan', 'green', 'deeppink', 'red']\n        colors = colors[:num_solutions]\n\n    # Set the bar chart structure parameters\n    label_locations = np.arange(num_vps)\n    bar_width = 0.8 / num_solutions\n\n    # Loop through each set of solutions\n    legend_elements = []\n    for s_num, solution_name in enumerate(solution_names):\n        legend_elements.append(Patch(facecolor=colors[s_num], label=solution_name, alpha=0.5, edgecolor='black'))\n        for vp_num, vp_name in enumerate(vp_names):\n            # Plot solutions\n            ax.bar(label_locations[vp_num] + bar_width * s_num, z_dict[solution_name][vp_name], bar_width,\n                   edgecolor='black', color=colors[s_num])\n\n    # Text\n    ax.set_ylabel('Z')\n    ax.set(xticks=label_locations + bar_width / 2, xlim=[2 * bar_width - 1, num_vps],\n           xticklabels=vp_names)\n\n    title = 'Objective Values for Different Solutions and Value Parameters'\n    ax.set_title(title)\n    ax.legend(handles=legend_elements, edgecolor='black', loc='upper right', columnspacing=0.8, handletextpad=0.25,\n              borderaxespad=0.5, borderpad=0.4)\n    if save:\n        fig.savefig(afccp.globals.paths['figures'] + instance.data_name + \"/value parameters/\" + title + '.png',\n                    bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.solution_results_graph","title":"<code>solution_results_graph(parameters, value_parameters, solutions, vp_name, k, save=False, colors=None, figsize=(19, 7), facecolor='white')</code>","text":"<p>Builds the Graph to show how well we meet each of the objectives</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <p>colors of the solutions</p> <code>None</code> <code>vp_name</code> <p>value parameter name (to access from solutions)</p> required <code>k</code> <p>objective index</p> required <code>facecolor</code> <p>color of the background of the graph</p> <code>'white'</code> <code>figsize</code> <p>size of the figure</p> <code>(19, 7)</code> <code>save</code> <p>Whether we should save the graph</p> <code>False</code> <code>parameters</code> <p>fixed cadet/AFSC data</p> required <code>value_parameters</code> <p>value parameters</p> required <code>solutions</code> <p>solution metrics dictionary</p> required <p>Returns:</p> Type Description <p>figure</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def solution_results_graph(parameters, value_parameters, solutions, vp_name, k, save=False, colors=None,\n                           figsize=(19, 7), facecolor='white'):\n    \"\"\"\n    Builds the Graph to show how well we meet each of the objectives\n    :param colors: colors of the solutions\n    :param vp_name: value parameter name (to access from solutions)\n    :param k: objective index\n    :param facecolor: color of the background of the graph\n    :param figsize: size of the figure\n    :param save: Whether we should save the graph\n    :param parameters: fixed cadet/AFSC data\n    :param value_parameters: value parameters\n    :param solutions: solution metrics dictionary\n    :return: figure\n    \"\"\"\n\n    # Load the data\n    indices = value_parameters['J^E'][k]\n    afscs = parameters['afscs'][indices]\n    minimums = np.zeros(len(indices))\n    maximums = np.zeros(len(indices))\n    num_solutions = len(solutions.keys())\n    if colors is None:\n        colors = ['blue', 'lime', 'orange', 'magenta', 'yellow', 'cyan', 'green', 'deeppink', 'red']\n        colors = colors[:num_solutions]\n\n    fig, ax = plt.subplots(figsize=figsize, facecolor=facecolor, tight_layout=True)\n    for j, loc in enumerate(indices):\n        if k == 0:\n            minimums[j], maximums[j] = 0.35, 0.65\n        elif k == 1:\n            minimums[j], maximums[j] = 0.20, 0.40\n        elif k == 2:\n            minimums[j] = parameters['quota_min'][j] / parameters['quota'][j]\n            maximums[j] = parameters['quota_max'][j] / parameters['quota'][j]\n        elif k == 3:\n            if parameters['usafa_quota'][j] / parameters['quota'][j] == 0:\n                minimums[j], maximums[j] = 0, 0\n            elif parameters['usafa_quota'][j] / parameters['quota'][j] == 1:\n                minimums[j], maximums[j] = 1, 1\n            else:\n                minimums[j] = parameters['usafa_quota'][j] / parameters['quota'][j] - 0.1\n                maximums[j] = parameters['usafa_quota'][j] / parameters['quota'][j] + 0.1\n        elif k == 4:\n            if parameters['usafa_quota'][j] / parameters['quota'][j] == 0:\n                minimums[j], maximums[j] = 1, 1\n            elif parameters['usafa_quota'][j] / parameters['quota'][j] == 1:\n                minimums[j], maximums[j] = 0, 0\n            else:\n                minimums[j] = (parameters['quota'][j] - parameters['usafa_quota'][j]) / parameters['quota'][j] - 0.1\n                maximums[j] = (parameters['quota'][j] - parameters['usafa_quota'][j]) / parameters['quota'][j] + 0.1\n        elif k in [5, 6, 7]:\n            if k == 5 or (k == 6 and afscs[j] not in [\"14F\", \"15A\", \"17D\"]):\n                minimums[j] = value_parameters['objective_target'][loc, k]\n                maximums[j] = 1\n            else:\n                minimums[j] = 0\n                maximums[j] = value_parameters['objective_target'][loc, k]\n        elif k == 8:\n            minimums[j], maximums[j] = 0.8, 1\n        elif k == 9:\n            male_proportion = np.mean(parameters['male'])\n            minimums[j], maximums[j] = male_proportion - 0.1, male_proportion + 0.1\n        elif k == 10:\n            minority_proportion = np.mean(parameters['minority'])\n            minimums[j], maximums[j] = minority_proportion - 0.1, minority_proportion + 0.1\n\n    # ticks = list(np.arange(0, 1.1, 0.1))\n    # ax.set_yticks(ticks)\n    for s_num, solution_name in enumerate(solutions.keys()):\n        if k == 2:\n            measures = solutions[solution_name][vp_name]['objective_measure'][indices, k] / \\\n                       parameters['quota'][indices]\n        elif k == 3:\n            measures = solutions[solution_name][vp_name]['objective_measure'][indices, k] / \\\n                       parameters['usafa_quota'][indices]\n        elif k == 4:\n            measures = solutions[solution_name][vp_name]['objective_measure'][indices, k] / \\\n                       (parameters['quota'][indices] - parameters['usafa_quota'][indices])\n        else:\n            measures = solutions[solution_name][vp_name]['objective_measure'][indices, k]\n\n        ax.scatter(afscs, measures, c=colors[s_num], linewidths=4)\n\n    # Ranges\n    y = [(minimums[i], maximums[i]) for i in range(len(afscs))]\n    x = range(len(afscs))\n    for i in x:\n        plt.axvline(x=i, color='black', linestyle='--', alpha=0.2)\n    ax.plot((x, x), ([i for (i, j) in y], [j for (i, j) in y]), c='black')\n    ax.scatter(afscs, minimums, c='black', marker=\"_\", linewidth=2)\n    ax.scatter(afscs, maximums, c='black', marker=\"_\", linewidth=2)\n\n    # Titles and Labels\n    objective = value_parameters['objectives'][k]\n    ax.set_title(objective + ' Solution Comparison')\n    ax.set_ylabel(objective + ' Measure')\n\n    if save:\n        fig.savefig(afccp.globals.paths['figures'] + instance.data_name + \"/results/Solution Results Graph.png\",\n                    bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/charts/#visualizations.charts.solution_similarity_graph","title":"<code>solution_similarity_graph(instance, coords, solution_names, filepath=None)</code>","text":"<p>This is the chart that compares the approximate and exact models (with genetic algorithm) in solve time and objective value</p> Source code in <code>afccp/visualizations/charts.py</code> <pre><code>def solution_similarity_graph(instance, coords, solution_names, filepath=None):\n    \"\"\"\n    This is the chart that compares the approximate and exact models (with genetic algorithm) in solve time and\n    objective value\n    \"\"\"\n\n    # Load in plot parameters\n    ip = instance.mdl_p\n    ip[\"figsize\"] = (10, 10)\n\n    if ip[\"title\"] is None:\n        ip[\"title\"] = instance.data_name + \" Solution Similarity\"\n\n    # Create figure\n    fig, ax = plt.subplots(figsize=ip[\"figsize\"], facecolor=ip[\"facecolor\"], tight_layout=True)\n    ax.set_aspect('equal', adjustable='box')\n\n    # Plot the solution dot\n    legend_elements = []\n    special_solutions = []\n    for i, solution_name in enumerate(solution_names):\n        x, y = coords[i, 0], coords[i, 1]\n\n        # \"Special\" Solutions to show\n        if solution_name in ip['solution_names']:\n            special_solutions.append(solution_name)\n            ax.scatter(x, y, c=ip[\"colors\"][solution_name], marker=ip[\"markers\"][solution_name], edgecolor=\"black\",\n                       s=ip[\"sim_dot_size\"], zorder=2)\n\n            # Add legend element\n            legend_elements.append(mlines.Line2D([], [], color=ip[\"colors\"][solution_name],\n                                                 marker=ip[\"markers\"][solution_name], linestyle='None',\n                                                 markeredgecolor='black', markersize=20, label=solution_name))\n\n        # \"Basic\" solutions\n        else:\n\n            ax.scatter(x, y, c=ip['default_sim_color'], marker=ip[\"default_sim_marker\"], edgecolor=\"black\",\n                       s=ip[\"sim_dot_size\"], zorder=2)\n\n    ax.legend(handles=legend_elements, edgecolor='black', fontsize=ip[\"legend_size\"], loc='upper right',\n              ncol=len(legend_elements), columnspacing=0.4, handletextpad=0.1, borderaxespad=0.5, borderpad=0.2)\n\n    # Remove tick marks\n    ax.tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)\n\n    # Save the figure\n    if ip[\"save\"]:\n        if filepath is None:\n            filepath = instance.export_paths['Analysis &amp; Results'] + \"Results Charts/\"\n        if len(special_solutions) &gt; 0:\n            string_names = ', '.join(special_solutions)\n            filename = ip['title'] + '(' + string_names + ').png'\n        else:\n            filename = ip['title'] + '.png'\n        fig.savefig(filepath + filename, bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"reference/visualizations/slides/","title":"Slides","text":""},{"location":"reference/visualizations/slides/#visualizations.slides","title":"<code>visualizations.slides</code>","text":""},{"location":"reference/visualizations/slides/#visualizations.slides.generate_results_slides","title":"<code>generate_results_slides(instance)</code>","text":"<p>Function to generate the results slides for a particular problem instance with solution</p> Source code in <code>afccp/visualizations/slides.py</code> <pre><code>def generate_results_slides(instance):\n    \"\"\"\n    Function to generate the results slides for a particular problem instance with solution\n    \"\"\"\n\n    # Shorthand\n    mdl_p = instance.mdl_p\n\n    # Build the presentation object\n    prs = Presentation(afccp.globals.paths['files'] + 'results_slide_template.pptx')\n\n    # Delete the current slides in the template\n    for i in range(len(prs.slides) - 1, -1, -1):\n        rId = prs.slides._sldIdLst[i].rId\n        prs.part.drop_rel(rId)\n        del prs.slides._sldIdLst[i]\n\n    # Slide Layouts\n    title_slide_layout = prs.slide_layouts[0]\n    content_slide_layout = prs.slide_layouts[1]\n    chart_slide_layout = prs.slide_layouts[2]\n    bubble_slide_layout = prs.slide_layouts[3]\n    closing_slide_layout = prs.slide_layouts[4]\n\n    # Set width and height of presentation\n    prs.slide_width = Inches(mdl_p['b_figsize'][0])\n    prs.slide_height = Inches(mdl_p['b_figsize'][1])\n\n    # Add title slide\n    slide = prs.slides.add_slide(title_slide_layout)\n    title = slide.shapes.title\n    title.text = instance.data_name + \" Classification Results (\" + instance.solution['name'] + \")\"\n    # print(len(slide.placeholders))\n    # print(slide.placeholders)\n    # content = slide.placeholders[1]\n    # content.text = \"Rank, Name\\nAFPC/DSYA\\nTBD\"\n\n    # Initial content slide\n    slide = prs.slides.add_slide(content_slide_layout)\n    title = slide.shapes.title\n    title.text = \"Overview\"\n    content = slide.placeholders[1]\n    content.text = \"Here's where the overview goes\"\n\n    # Size of the chart\n    # top, left = Inches(instance.mdl_p['ch_top']), Inches(instance.mdl_p['ch_left'])\n    # height, width = Inches(instance.mdl_p['ch_height']), Inches(instance.mdl_p['ch_width'])\n\n    # # Size of the chart\n    # top, left = Inches(0), Inches(0)\n    # height, width = Inches(mdl_p['figsize'][1]), Inches(mdl_p['figsize'][0])\n\n    # Get the file paths to all the relevant images\n    folder_path = instance.export_paths['Analysis &amp; Results'] + instance.solution_name + \"/\"\n    folder = os.listdir(folder_path)\n    chart_paths = {}\n    for file in folder:\n        if instance.solution_name in file and '.png' in file:\n            chart_paths[file] = folder_path + file\n\n    # Loop through the pictures I want in the order I want\n    chart_text_order = {\"PGL\": [\"Combined Quota\", \"quantity_bar\"], \"BUBBLE CHART\": [\"Cadet Choice.png\"],\n                        \"SOC by Accessions Group\": [\"Accessions\", \"SOC Chart\"],\n                        \"Gender by Accessions Group\": [\"Accessions\", \"Gender Chart\"],\n                        \"Race by Accessions Group\": [\"Accessions\", \"Race Chart\"],\n                        \"Ethnicity by Accessions Group\": [\"Accessions\", \"Ethnicity Chart\"],\n                        \"SOC by AFSC\": [\"Extra Measure\", \"SOC Chart_proportion\"],\n                        \"Gender by AFSC\": [\"Extra Measure\", \"Gender Chart_proportion\"],\n                        \"Race by AFSC\": [\"Extra Measure\", \"Race Chart_proportion\"],\n                        \"Ethnicity by AFSC\": [\"Extra Measure\", \"Ethnicity Chart_proportion\"],\n                        \"Cadet Preference by AFSC\": [\"Utility\", \"quantity_bar_choice\"],\n                        \"AFSC Preference\": [\"Norm Score\", \"quantity_bar_choice\"],\n                        \"62EXE BUBBLE CHART\": [\"62EXE Specific Choice.png\"],}\n    for title_text in chart_text_order:\n\n        # Loop through each potential image\n        for file in chart_paths:\n\n            # Determine if this is the image I want here\n            found = True\n            for test_text in chart_text_order[title_text]:\n                if test_text not in file:\n                    found = False\n                    break\n\n            # If this is the file I want, we do things\n            if found:\n\n                # Determine the layout of the chart needed\n                if \"BUBBLE CHART\" in title_text:\n\n                    # Create the bubble chart slide\n                    slide = prs.slides.add_slide(bubble_slide_layout)\n\n                    # Add the image to the slide\n                    for shape in slide.placeholders:\n                        if \"Picture\" in shape.name:\n                            shape.insert_picture(chart_paths[file])\n                else:\n\n                    # Create the AFSC/Accessions Chart slide\n                    slide = prs.slides.add_slide(chart_slide_layout)\n                    title = slide.shapes.title\n                    title.text = title_text\n\n                    # # Add the picture to the slide\n                    # slide.shapes.add_picture(chart_paths[file], left, top, height=height, width=width)\n\n                    # Add the image to the slide\n                    for shape in slide.placeholders:\n                        if \"Picture\" in shape.name:\n                            shape.insert_picture(chart_paths[file])\n\n                # Break out of this loop since we found the image we want\n                break\n\n\n    # Add closing slide\n    prs.slides.add_slide(closing_slide_layout)\n\n    # Save the PowerPoint\n    filepath = instance.export_paths['Analysis &amp; Results'] + instance.solution_name + '/' + \\\n               instance.data_name + ' ' + instance.solution_name + '.pptx'\n    prs.save(filepath)\n</code></pre>"},{"location":"reference/visualizations/slides/#visualizations.slides.generate_comparison_slides","title":"<code>generate_comparison_slides(instance)</code>","text":"<p>Function to generate the results slides for a particular problem instance with solution</p> Source code in <code>afccp/visualizations/slides.py</code> <pre><code>def generate_comparison_slides(instance):\n    \"\"\"\n    Function to generate the results slides for a particular problem instance with solution\n    \"\"\"\n\n    # Shorthand\n    mdl_p = instance.mdl_p\n\n    # Build the presentation object\n    prs = Presentation()\n    blank_slide_layout = prs.slide_layouts[6]\n\n    # Set width and height of presentation\n    prs.slide_width = Inches(mdl_p['b_figsize'][0])\n    prs.slide_height = Inches(mdl_p['b_figsize'][1])\n\n    # Size of the chart\n    top, left = Inches(0), Inches(0)\n\n    # Get the file paths to all the relevant images\n    folder_path = instance.export_paths['Analysis &amp; Results'] + \"Comparison Charts/\"\n    folder = os.listdir(folder_path)\n\n    # Sort the files in the folder according to my preferred method\n    chart_paths = {}\n    keyword_order = [['Combined Quota'], ['Tier 1'], ['Male'], ['USAFA Proportion'], ['Merit'], ['Norm Score'],\n                     ['Utility', 'dot'], ['Utility', 'mean_preference'], ['Utility', 'median_preference'],\n                     ['Utility', 'Histogram'], ['Pareto', 'Cadets.png'], ['Pareto', ').png'], ['Similarity']]\n\n    # Loop through each set of \"keywords\"\n    for keywords in keyword_order:\n\n        # Loop through each file until we have a match\n        for file in folder:\n\n            # Loop through all keywords to see if we have a match\n            match = True\n            for keyword in keywords:\n                if keyword not in file:\n                    match = False\n                    break\n\n            # If we have a \"match\", add it!\n            if match:\n                chart_paths[file] = folder_path + file\n                folder.remove(file)  # Remove this file since we've accounted for it\n                break\n\n    # Add any remaining files\n    for file in folder:\n        if '.png' in file:\n            chart_paths[file] = folder_path + file\n\n    # Loop through each image file path to add the image to the presentation\n    for file in chart_paths:\n\n        # Add an empty slide\n        slide = prs.slides.add_slide(blank_slide_layout)\n\n        # Add the picture to the slide\n        slide.shapes.add_picture(chart_paths[file], left, top)  #, height=height, width=width)\n\n    # Save the PowerPoint\n    filepath = instance.export_paths['Analysis &amp; Results'] + instance.data_name + ' ' + 'Comparison.pptx'\n    prs.save(filepath)\n</code></pre>"},{"location":"reference/visualizations/slides/#visualizations.slides.create_animation_slides","title":"<code>create_animation_slides(instance)</code>","text":"<p>Function to generate the results slides for a particular problem instance with solution</p> Source code in <code>afccp/visualizations/slides.py</code> <pre><code>def create_animation_slides(instance):\n    \"\"\"\n    Function to generate the results slides for a particular problem instance with solution\n    \"\"\"\n\n    # Shorthand\n    mdl_p, sequence = instance.mdl_p, instance.solution['iterations']['sequence']\n\n    # Build the presentation object\n    prs = Presentation()\n    blank_slide_layout = prs.slide_layouts[6]\n\n    # Set width and height of presentation\n    prs.slide_width = Inches(mdl_p['b_figsize'][0])\n    prs.slide_height = Inches(mdl_p['b_figsize'][1])\n\n    # Size of the chart\n    top, left = Inches(0), Inches(0)\n    height, width = Inches(mdl_p['b_figsize'][1]), Inches(mdl_p['b_figsize'][0])\n\n    # Make sure we have the \"sequence\" folder\n    if sequence not in os.listdir(instance.export_paths['Analysis &amp; Results'] + \"Cadet Board/\"):\n        raise ValueError(\"Error. Sequence folder '\" + sequence + \"' not in 'Cadet Board' folder.\")\n\n    # Get the file path to the sequence folder\n    sequence_folder_path = instance.export_paths['Analysis &amp; Results'] + \"Cadet Board/\" + sequence + '/'\n\n    # Make sure we have the \"focus\" folder\n    if mdl_p['focus'] not in os.listdir(sequence_folder_path):\n        raise ValueError(\"Error. Focus folder '\" + mdl_p['focus'] + \"' not in '\" + sequence + \"' sequence folder.\")\n\n    # Files in the focus folder\n    focus_folder_path = sequence_folder_path + mdl_p['focus'] + '/'\n    folder = np.array(os.listdir(focus_folder_path))\n\n    # Regular solution iterations frames: 1.png for example\n    if \"1.png\" in folder:\n\n        # Sort the folder in order by the frames\n        int_vals = np.array([int(file[0]) for file in folder])\n        indices = np.argsort(int_vals)\n        img_paths = {file: focus_folder_path + file for file in folder[indices]}\n\n    # Matching Algorithm proposals/rejections frames: 1 (Proposals).png &amp; 1 (Rejections).png for example\n    else:\n\n        # The integer values at the beginning of each file\n        int_vals = np.array([int(file[:2]) for file in folder])\n        min, max = np.min(int_vals), np.max(int_vals)\n\n        # Loop through the files to get the ordered list of frames\n        img_paths = {}\n        for val in np.arange(min, max + 1):\n            indices = np.where(int_vals == val)[0]\n            files = folder[indices]\n            if len(files) &gt; 1:\n                if 'Proposals' in files[0]:\n                    img_paths[files[0]] = focus_folder_path + files[0]\n                    img_paths[files[1]] = focus_folder_path + files[1]\n                else:\n                    img_paths[files[1]] = focus_folder_path + files[1]\n                    img_paths[files[0]] = focus_folder_path + files[0]\n            else:\n                img_paths[files[0]] = focus_folder_path + files[0]\n\n    # Loop through each image file path to add the image to the presentation\n    for file in img_paths:\n\n        # Add an empty slide\n        slide = prs.slides.add_slide(blank_slide_layout)\n\n        # Add the picture to the slide\n        slide.shapes.add_picture(img_paths[file], left, top, height=height, width=width)\n\n    # Save the PowerPoint\n    filepath = sequence_folder_path + mdl_p['focus'] + '.pptx'\n    prs.save(filepath)\n</code></pre>"}]}